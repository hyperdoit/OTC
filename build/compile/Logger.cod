; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	c:\users\neonik\desktop\csgo cheat sources\otc-source\otc\cpp\runtime\logger.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	??_C@_0BK@MOPMIHII@?2Documents?2otc_latest?4txt@ ; `string'
PUBLIC	??_C@_0M@DPNKMMOG@USERPROFILE@			; `string'
PUBLIC	??_C@_0DF@OFKJIDHJ@GameInterfaces?5is?5null?4?5Can?8t?5i@ ; `string'
PUBLIC	??_C@_0DB@MJIOIOJA@showconsole?$DL?5log_color?5General?5@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp___get_stream_buffer_pointers:PROC
EXTRN	__imp__getenv:PROC
EXTRN	__imp___fseeki64:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fsetpos:PROC
EXTRN	__imp__ungetc:PROC
EXTRN	__imp__setvbuf:PROC
EXTRN	__imp__fgetpos:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp___lock_file:PROC
EXTRN	__imp___unlock_file:PROC
EXTRN	__imp__fgetc:PROC
EXTRN	_atexit:PROC
EXTRN	__imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC
EXTRN	__imp_?uncaught_exceptions@std@@YAHXZ:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fputc:PROC
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MJIOIOJA@showconsole?$DL?5log_color?5General?5@
CONST	SEGMENT
??_C@_0DB@MJIOIOJA@showconsole?$DL?5log_color?5General?5@ DB 'showconsole'
	DB	'; log_color General 0xFFFFFFFF; clear', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OFKJIDHJ@GameInterfaces?5is?5null?4?5Can?8t?5i@
CONST	SEGMENT
??_C@_0DF@OFKJIDHJ@GameInterfaces?5is?5null?4?5Can?8t?5i@ DB 'GameInterfa'
	DB	'ces is null. Can''t initialize the logger.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DPNKMMOG@USERPROFILE@
CONST	SEGMENT
??_C@_0M@DPNKMMOG@USERPROFILE@ DB 'USERPROFILE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MOPMIHII@?2Documents?2otc_latest?4txt@
CONST	SEGMENT
??_C@_0BK@MOPMIHII@?2Documents?2otc_latest?4txt@ DB '\Documents\otc_lates'
	DB	't.txt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
PUBLIC	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$exchange@PAV_Facet_base@std@@PAV12@@std@@YAPAV_Facet_base@0@AAPAV10@$$QAPAV10@@Z ; std::exchange<std::_Facet_base *,std::_Facet_base *>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
PUBLIC	??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
PUBLIC	??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHABD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?not_eof@?$_Narrow_char_traits@DH@std@@SAHABH@Z	; std::_Narrow_char_traits<char,int>::not_eof
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBEXQAD0I0I@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBEXQADI0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBEXQADQBDID@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?to_char_type@?$_Narrow_char_traits@DH@std@@SADABH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	?SwitchedInfo@Logger@@QAAXPBDZZ			; Logger::SwitchedInfo
PUBLIC	?Info@Logger@@QAAXPBDZZ				; Logger::Info
PUBLIC	?Space@Logger@@QAEXH@Z				; Logger::Space
PUBLIC	?Setup@Logger@@QAEXXZ				; Logger::Setup
PUBLIC	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	?AtConsoleInterface@GameFramework@@QAEP6EHPBXPBD@ZXZ ; GameFramework::AtConsoleInterface
PUBLIC	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z		; std::_Ungetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A DB 0b0H DUP (?) ; GLoggerFile
_BSS	ENDS
CRT$XCU	SEGMENT
?GLoggerFile$initializer$@@3P6AXXZA DD FLAT:??__EGLoggerFile@@YAXXZ ; GLoggerFile$initializer$
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??__EGLoggerFile@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??__EGLoggerFile@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??__EGLoggerFile@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__EGLoggerFile@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??__EGLoggerFile@@YAXXZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT
; __Len$ = ecx

; 987  :     // convert size_t to size_t, unchanged
; 988  :     return _Len;

  00000	8b c1		 mov	 eax, ecx

; 989  : }

  00002	c3		 ret	 0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2206 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlen_strin:
  0000b	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vcruntime_typeinfo.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vcruntime_exception.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 135  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 136  :     }

  00003	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vcruntime_exception.h

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast@
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vcruntime_typeinfo.h

; 135  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@

; 136  :     }

  00017	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00016	83 c4 04	 add	 esp, 4
  00019	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001d	74 0b		 je	 SHORT $LN9@scalar
  0001f	6a 0c		 push	 12			; 0000000cH
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN9@scalar:
  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00010	59		 pop	 ecx
  00011	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 64   : [[noreturn]] inline void _Throw_bad_cast() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 65   :     _THROW(bad_cast{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  0000e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  00013	8b c1		 mov	 eax, ecx
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001b	cc		 int	 3
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_copy
  00024	83 c4 08	 add	 esp, 8
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
  0002d	8b c6		 mov	 eax, esi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 352  :         if (_Ptr) {

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	85 c9		 test	 ecx, ecx
  00005	74 11		 je	 SHORT $LN4@locale

; 353  :             delete _Ptr->_Decref();

  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 08	 call	 DWORD PTR [eax+8]
  0000c	85 c0		 test	 eax, eax
  0000e	74 08		 je	 SHORT $LN4@locale
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	6a 01		 push	 1
  00016	ff 12		 call	 DWORD PTR [edx]
$LN4@locale:

; 354  :         }
; 355  :     }

  00018	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 374  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 375  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __Id$[ebp]
  0000a	3b 71 0c	 cmp	 esi, DWORD PTR [ecx+12]
  0000d	73 0c		 jae	 SHORT $LN6@Getfacet
  0000f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00012	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 376  :         if (_Facptr || !_Ptr->_Xparent) {

  00015	85 c0		 test	 eax, eax
  00017	75 22		 jne	 SHORT $LN1@Getfacet
  00019	eb 02		 jmp	 SHORT $LN8@Getfacet
$LN6@Getfacet:

; 375  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  0001b	33 c0		 xor	 eax, eax
$LN8@Getfacet:

; 376  :         if (_Facptr || !_Ptr->_Xparent) {

  0001d	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00021	74 18		 je	 SHORT $LN1@Getfacet

; 377  :             return _Facptr; // found facet or not transparent
; 378  :         }
; 379  : 
; 380  :         // look in current locale
; 381  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 382  :         if (_Id < _Ptr0->_Facetcount) {

  00029	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  0002c	73 0b		 jae	 SHORT $LN4@Getfacet

; 383  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  0002e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00031	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00034	5e		 pop	 esi

; 387  :     }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN4@Getfacet:

; 384  :         }
; 385  : 
; 386  :         return nullptr; // no entry in current locale

  00039	33 c0		 xor	 eax, eax
$LN1@Getfacet:
  0003b	5e		 pop	 esi

; 387  :     }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT
; __Byte$ = ecx
; __File$ = edx

; 65   : inline bool _Fgetc(char& _Byte, FILE* _File) { // get a char element from a C stream

  00000	56		 push	 esi

; 66   :     int _Meta;
; 67   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

  00001	52		 push	 edx
  00002	8b f1		 mov	 esi, ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  0000a	83 c4 04	 add	 esp, 4
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	75 04		 jne	 SHORT $LN2@Fgetc

; 68   :         return false;

  00012	32 c0		 xor	 al, al
  00014	5e		 pop	 esi

; 72   :     }
; 73   : }

  00015	c3		 ret	 0
$LN2@Fgetc:

; 69   :     } else { // got one, convert to char
; 70   :         _Byte = static_cast<char>(_Meta);

  00016	88 06		 mov	 BYTE PTR [esi], al

; 71   :         return true;

  00018	b0 01		 mov	 al, 1
  0001a	5e		 pop	 esi

; 72   :     }
; 73   : }

  0001b	c3		 ret	 0
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT
; __Byte$ = cl
; __File$ = edx

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

  00000	52		 push	 edx
  00001	0f be c1	 movsx	 eax, cl
  00004	50		 push	 eax
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputc
  0000b	83 c4 08	 add	 esp, 8
  0000e	83 f8 ff	 cmp	 eax, -1
  00011	0f 95 c0	 setne	 al

; 108  : }

  00014	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT
; __Byte$ = ecx
; __File$ = edx

; 130  :     return _CSTD ungetc(static_cast<unsigned char>(_Byte), _File) != EOF;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00003	52		 push	 edx
  00004	50		 push	 eax
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ungetc
  0000b	83 c4 08	 add	 esp, 8
  0000e	83 f8 ff	 cmp	 eax, -1
  00011	0f 95 c0	 setne	 al

; 131  : }

  00014	c3		 ret	 0
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\frameworks\GameFramework.h
;	COMDAT ?AtConsoleInterface@GameFramework@@QAEP6EHPBXPBD@ZXZ
_TEXT	SEGMENT
?AtConsoleInterface@GameFramework@@QAEP6EHPBXPBD@ZXZ PROC ; GameFramework::AtConsoleInterface, COMDAT
; _this$ = ecx

; 47   :         return m_ConsoleInterface;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 48   :     }

  00003	c3		 ret	 0
?AtConsoleInterface@GameFramework@@QAEP6EHPBXPBD@ZXZ ENDP ; GameFramework::AtConsoleInterface
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
;	COMDAT ??__EGLoggerFile@@YAXXZ
text$di	SEGMENT
$T13 = -64						; size = 24
$T2 = -40						; size = 24
$T12 = -16						; size = 1
__$EHRec$ = -12						; size = 12
??__EGLoggerFile@@YAXXZ PROC				; `dynamic initializer for 'GLoggerFile'', COMDAT

; 4    : std::ofstream GLoggerFile (std::string (getenv("USERPROFILE")) + "\\Documents\\otc_latest.txt");

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??__EGLoggerFile@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DPNKMMOG@USERPROFILE@
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getenv
  00031	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00033	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 322  :             return __builtin_strlen(_First);

  0003a	8b ca		 mov	 ecx, edx

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0003c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 4    : std::ofstream GLoggerFile (std::string (getenv("USERPROFILE")) + "\\Documents\\otc_latest.txt");

  00043	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00046	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0

; 322  :             return __builtin_strlen(_First);

  0004a	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0004d	0f 1f 00	 npad	 3
$LL115@dynamic:
  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL115@dynamic
  00057	2b ce		 sub	 ecx, esi

; 2992 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00059	51		 push	 ecx
  0005a	52		 push	 edx
  0005b	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0005e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 4    : std::ofstream GLoggerFile (std::string (getenv("USERPROFILE")) + "\\Documents\\otc_latest.txt");

  00063	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2867 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0006a	8b 55 ec	 mov	 edx, DWORD PTR $T2[ebp+20]
  0006d	8b c2		 mov	 eax, edx
  0006f	8b 4d e8	 mov	 ecx, DWORD PTR $T2[ebp+16]
  00072	2b c1		 sub	 eax, ecx

; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00074	6a 19		 push	 25			; 00000019H
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MOPMIHII@?2Documents?2otc_latest?4txt@
  0007b	83 f8 19	 cmp	 eax, 25			; 00000019H
  0007e	72 24		 jb	 SHORT $LN28@dynamic

; 2141 :         if (_Large_string_engaged()) {

  00080	83 fa 10	 cmp	 edx, 16			; 00000010H
  00083	8d 75 d8	 lea	 esi, DWORD PTR $T2[ebp]

; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00086	8d 41 19	 lea	 eax, DWORD PTR [ecx+25]

; 2141 :         if (_Large_string_engaged()) {

  00089	0f 43 75 d8	 cmovae	 esi, DWORD PTR $T2[ebp]

; 2871 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0008d	03 f1		 add	 esi, ecx
  0008f	89 45 e8	 mov	 DWORD PTR $T2[ebp+16], eax

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00092	56		 push	 esi
  00093	e8 00 00 00 00	 call	 _memmove
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2872 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0009b	c6 46 19 00	 mov	 BYTE PTR [esi+25], 0

; 2873 :             return *this;

  0009f	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  000a2	eb 0d		 jmp	 SHORT $LN27@dynamic
$LN28@dynamic:

; 2874 :         }
; 2875 : 
; 2876 :         return _Reallocate_grow_by(

  000a4	ff 75 f0	 push	 DWORD PTR $T12[ebp]
  000a7	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  000aa	6a 19		 push	 25			; 00000019H
  000ac	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
$LN27@dynamic:

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  000b1	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T13[ebp+16], 0
  000b8	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T13[ebp+20], 0

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000bf	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000c2	0f 11 45 c0	 movups	 XMMWORD PTR $T13[ebp], xmm0
  000c6	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  000cb	66 0f d6 45 d0	 movq	 QWORD PTR $T13[ebp+16], xmm0

; 4301 :         _Mypair._Myval2._Mysize = 0;

  000d0	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  000d7	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  000de	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 4    : std::ofstream GLoggerFile (std::string (getenv("USERPROFILE")) + "\\Documents\\otc_latest.txt");

  000e1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2149 :         const value_type* _Result = _Bx._Buf;

  000e5	8d 45 c0	 lea	 eax, DWORD PTR $T13[ebp]

; 2158 :         return _BUF_SIZE <= _Myres;

  000e8	83 7d d4 10	 cmp	 DWORD PTR $T13[ebp+20], 16 ; 00000010H

; 2150 :         if (_Large_string_engaged()) {

  000ec	0f 43 45 c0	 cmovae	 eax, DWORD PTR $T13[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 1014 :         : basic_ofstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

  000f0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
  000f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  000fe	8b 55 d4	 mov	 edx, DWORD PTR $T13[ebp+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 1014 :         : basic_ofstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A[eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A
  00113	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00116	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00119	89 81 fc ff ff
	ff		 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A[ecx-4], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  0011f	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00122	72 28		 jb	 SHORT $LN72@dynamic
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00124	8b 4d c0	 mov	 ecx, DWORD PTR $T13[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00127	42		 inc	 edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00128	8b c1		 mov	 eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0012a	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00130	72 10		 jb	 SHORT $LN82@dynamic

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00132	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00135	83 c2 23	 add	 edx, 35			; 00000023H
  00138	2b c1		 sub	 eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0013a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0013d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00140	77 42		 ja	 SHORT $LN107@dynamic
$LN82@dynamic:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00142	52		 push	 edx
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00149	83 c4 08	 add	 esp, 8
$LN72@dynamic:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  0014c	8b 55 ec	 mov	 edx, DWORD PTR $T2[ebp+20]

; 4317 :         _Mypair._Myval2._Mysize = 0;

  0014f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T13[ebp+16], 0

; 4318 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00156	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T13[ebp+20], 15 ; 0000000fH

; 4319 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4320 :         // write can alias this
; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0015d	c6 45 c0 00	 mov	 BYTE PTR $T13[ebp], 0

; 2158 :         return _BUF_SIZE <= _Myres;

  00161	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00164	72 2e		 jb	 SHORT $LN100@dynamic
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00166	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00169	42		 inc	 edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0016a	8b c1		 mov	 eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0016c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00172	72 16		 jb	 SHORT $LN110@dynamic

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00174	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00177	83 c2 23	 add	 edx, 35			; 00000023H
  0017a	2b c1		 sub	 eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0017c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0017f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00182	76 06		 jbe	 SHORT $LN110@dynamic
$LN107@dynamic:
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN110@dynamic:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0018a	52		 push	 edx
  0018b	51		 push	 ecx
  0018c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00191	83 c4 08	 add	 esp, 8
$LN100@dynamic:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 4    : std::ofstream GLoggerFile (std::string (getenv("USERPROFILE")) + "\\Documents\\otc_latest.txt");

  00194	68 00 00 00 00	 push	 OFFSET ??__FGLoggerFile@@YAXXZ ; `dynamic atexit destructor for 'GLoggerFile''
  00199	e8 00 00 00 00	 call	 _atexit
  0019e	83 c4 04	 add	 esp, 4
  001a1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001a4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ab	59		 pop	 ecx
  001ac	5e		 pop	 esi
  001ad	8b e5		 mov	 esp, ebp
  001af	5d		 pop	 ebp
  001b0	c3		 ret	 0
$LN117@dynamic:
text$di	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__EGLoggerFile@@YAXXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??__EGLoggerFile@@YAXXZ$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR $T13[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??__EGLoggerFile@@YAXXZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__EGLoggerFile@@YAXXZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__EGLoggerFile@@YAXXZ ENDP				; `dynamic initializer for 'GLoggerFile''
; Function compile flags: /Ogtp
;	COMDAT ??__FGLoggerFile@@YAXXZ
text$yd	SEGMENT
??__FGLoggerFile@@YAXXZ PROC				; `dynamic atexit destructor for 'GLoggerFile'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  00005	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
??__FGLoggerFile@@YAXXZ ENDP				; `dynamic atexit destructor for 'GLoggerFile''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
; _this$dead$ = ecx
  00000	68 b0 00 00 00	 push	 176			; 000000b0H
  00005	6a 00		 push	 0
  00007	68 00 00 00 00	 push	 OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  0000c	e8 00 00 00 00	 call	 _memset
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH
  00014	c2 04 00	 ret	 4
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1141 :     virtual __CLR_OR_THIS_CALL ~basic_ofstream() noexcept {}

  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	8d 79 68	 lea	 edi, DWORD PTR [ecx+104]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00035	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  0003e	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax

; 170  :     virtual __CLR_OR_THIS_CALL ~basic_filebuf() noexcept {

  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 171  :         if (_Myfile) {

  00049	83 7f e8 00	 cmp	 DWORD PTR [edi-24], 0
  0004d	c7 47 9c 00 00
	00 00		 mov	 DWORD PTR [edi-100], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00054	74 1e		 je	 SHORT $LN12@vbase
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00056	8b 5f a8	 mov	 ebx, DWORD PTR [edi-88]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

  00059	8d 47 d8	 lea	 eax, DWORD PTR [edi-40]
  0005c	39 03		 cmp	 DWORD PTR [ebx], eax
  0005e	75 14		 jne	 SHORT $LN12@vbase

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00060	8b 57 f0	 mov	 edx, DWORD PTR [edi-16]
  00063	8b 4f ec	 mov	 ecx, DWORD PTR [edi-20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00066	2b d1		 sub	 edx, ecx
  00068	89 0b		 mov	 DWORD PTR [ebx], ecx
  0006a	8b 47 b8	 mov	 eax, DWORD PTR [edi-72]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx
  0006f	8b 47 c8	 mov	 eax, DWORD PTR [edi-56]
  00072	89 10		 mov	 DWORD PTR [eax], edx
$LN12@vbase:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 175  :         if (_Closef) {

  00074	80 7f e4 00	 cmp	 BYTE PTR [edi-28], 0
  00078	74 08		 je	 SHORT $LN8@vbase

; 176  :             close();

  0007a	8d 4f 9c	 lea	 ecx, DWORD PTR [edi-100]
  0007d	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN8@vbase:

; 177  :         }
; 178  :     }

  00082	8d 4f 9c	 lea	 ecx, DWORD PTR [edi-100]
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ

; 1141 :     virtual __CLR_OR_THIS_CALL ~basic_ofstream() noexcept {}

  0008b	8d 4f a0	 lea	 ecx, DWORD PTR [edi-96]
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00094	8b cf		 mov	 ecx, edi
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0009c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a6	59		 pop	 ecx
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
  000ae	cc		 int	 3
  000af	cc		 int	 3
  000b0	cc		 int	 3
  000b1	cc		 int	 3
  000b2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
;	COMDAT ?Setup@Logger@@QAEXXZ
_TEXT	SEGMENT
?Setup@Logger@@QAEXXZ PROC				; Logger::Setup, COMDAT
; _this$ = ecx

; 6    : void Logger::Setup () {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 7    : 
; 8    : 	if (m_Type == CONSOLE) {

  00003	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  00007	75 1e		 jne	 SHORT $LN2@Setup

; 9    : 		if (!m_Game.m_IsInterfacesAvailable) PanicUtils::Release (PanicUtils::Layers::INIT, "GameInterfaces is null. Can't initialize the logger.");

  00009	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000d	75 0c		 jne	 SHORT $LN3@Setup
  0000f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DF@OFKJIDHJ@GameInterfaces?5is?5null?4?5Can?8t?5i@
  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN3@Setup:

; 10   : 		m_Game.AtConsoleInterface () (NULL, "showconsole; log_color General 0xFFFFFFFF; clear");

  0001b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001e	33 c9		 xor	 ecx, ecx
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@MJIOIOJA@showconsole?$DL?5log_color?5General?5@
  00025	ff d0		 call	 eax
$LN2@Setup:

; 11   : 	}
; 12   : 
; 13   : }

  00027	5e		 pop	 esi
  00028	c3		 ret	 0
?Setup@Logger@@QAEXXZ ENDP				; Logger::Setup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
;	COMDAT ?Space@Logger@@QAEXH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
?Space@Logger@@QAEXH@Z PROC				; Logger::Space, COMDAT
; _this$ = ecx

; 15   : void Logger::Space (int count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 16   : 
; 17   : 	switch (m_Type) {

  00006	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00009	83 e8 00	 sub	 eax, 0
  0000c	74 25		 je	 SHORT $LN4@Space
  0000e	83 e8 01	 sub	 eax, 1
  00011	75 3f		 jne	 SHORT $LN9@Space

; 18   : 
; 19   : 	    case CONSOLE:
; 20   : 		   m_Game.PrintNewLineToConsole (count);
; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  00013	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EEMJAFIK@?6@
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  0001d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00022	5f		 pop	 edi
  00023	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0002a	8b c8		 mov	 ecx, eax

; 29   : }

  0002c	5d		 pop	 ebp

; 18   : 
; 19   : 	    case CONSOLE:
; 20   : 		   m_Game.PrintNewLineToConsole (count);
; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  0002d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN4@Space:
  00033	56		 push	 esi
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  00034	8b 75 08	 mov	 esi, DWORD PTR _count$[ebp]
  00037	85 f6		 test	 esi, esi
  00039	7e 16		 jle	 SHORT $LN16@Space
  0003b	0f 1f 44 00 00	 npad	 5
$LL10@Space:
  00040	8b 07		 mov	 eax, DWORD PTR [edi]
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00047	ff d0		 call	 eax
  00049	83 c4 04	 add	 esp, 4
  0004c	83 ee 01	 sub	 esi, 1
  0004f	75 ef		 jne	 SHORT $LL10@Space
$LN16@Space:
  00051	5e		 pop	 esi
$LN9@Space:
  00052	5f		 pop	 edi
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 29   : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?Space@Logger@@QAEXH@Z ENDP				; Logger::Space
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
;	COMDAT ?Info@Logger@@QAAXPBDZZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
_message$ = 12						; size = 4
?Info@Logger@@QAAXPBDZZ PROC				; Logger::Info, COMDAT

; 31   : void Logger::Info (const char* message...) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 32   : 
; 33   : 	switch (m_Type) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0000a	83 e8 00	 sub	 eax, 0
  0000d	74 22		 je	 SHORT $LN4@Info
  0000f	83 e8 01	 sub	 eax, 1
  00012	75 3e		 jne	 SHORT $LN2@Info

; 37   : 		   break;
; 38   : 
; 39   : 		case FILE:
; 40   : 			GLoggerFile << message << std::endl;

  00014	8b 55 0c	 mov	 edx, DWORD PTR _message$[ebp]
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  0001c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00021	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00026	8b c8		 mov	 ecx, eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0002e	5e		 pop	 esi

; 41   : 		   break;
; 42   : 
; 43   : 	}
; 44   : 
; 45   : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN4@Info:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00038	ff d0		 call	 eax
  0003a	83 c4 04	 add	 esp, 4

; 11   :     Sleep (0x90);

  0003d	68 90 00 00 00	 push	 144			; 00000090H
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 36   : 		    m_Game.PrintToConsole () (message);

  00048	ff 75 0c	 push	 DWORD PTR _message$[ebp]
  0004b	8b 06		 mov	 eax, DWORD PTR [esi]
  0004d	ff d0		 call	 eax
  0004f	83 c4 04	 add	 esp, 4
$LN2@Info:
  00052	5e		 pop	 esi

; 41   : 		   break;
; 42   : 
; 43   : 	}
; 44   : 
; 45   : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?Info@Logger@@QAAXPBDZZ ENDP				; Logger::Info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
;	COMDAT ?SwitchedInfo@Logger@@QAAXPBDZZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
_message$ = 12						; size = 4
?SwitchedInfo@Logger@@QAAXPBDZZ PROC			; Logger::SwitchedInfo, COMDAT

; 47   : void Logger::SwitchedInfo (const char* message...) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 48   : 	
; 49   : 	switch (m_Type) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0000a	83 e8 00	 sub	 eax, 0
  0000d	74 29		 je	 SHORT $LN4@SwitchedIn
  0000f	83 e8 01	 sub	 eax, 1
  00012	75 3e		 jne	 SHORT $LN2@SwitchedIn
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  0001b	ff d0		 call	 eax
  0001d	83 c4 04	 add	 esp, 4

; 11   :     Sleep (0x90);

  00020	68 90 00 00 00	 push	 144			; 00000090H
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 56   : 		   m_Game.PrintToConsole () (message);

  0002b	ff 75 0c	 push	 DWORD PTR _message$[ebp]
  0002e	8b 06		 mov	 eax, DWORD PTR [esi]
  00030	ff d0		 call	 eax
  00032	83 c4 04	 add	 esp, 4
  00035	5e		 pop	 esi

; 57   : 		  break;
; 58   : 
; 59   : 	}
; 60   : 
; 61   : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN4@SwitchedIn:

; 50   : 
; 51   : 	   case CONSOLE:
; 52   : 		   GLoggerFile << message << std::endl;

  00038	8b 55 0c	 mov	 edx, DWORD PTR _message$[ebp]
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  00040	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00045	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0004a	8b c8		 mov	 ecx, eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN2@SwitchedIn:
  00052	5e		 pop	 esi

; 57   : 		  break;
; 58   : 
; 59   : 	}
; 60   : 
; 61   : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?SwitchedInfo@Logger@@QAAXPBDZZ ENDP			; Logger::SwitchedInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 692  :     virtual void __CLR_OR_THIS_CALL imbue(const locale& _Loc) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 693  :         // set locale to argument (capture nontrivial codecvt facet)
; 694  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00009	57		 push	 edi
  0000a	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  0000f	8b f8		 mov	 edi, eax

; 761  :         if (_Newcvt.always_noconv()) {

  00011	8b cf		 mov	 ecx, edi
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
  00019	84 c0		 test	 al, al
  0001b	74 0d		 je	 SHORT $LN4@imbue
  0001d	5f		 pop	 edi

; 762  :             _Pcvt = nullptr; // nothing to do

  0001e	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 695  :     }

  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN4@imbue:

; 765  :             _Mysb::_Init(); // reset any buffering

  0002a	8b ce		 mov	 ecx, esi
  0002c	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
  00035	5f		 pop	 edi

; 695  :     }

  00036	5e		 pop	 esi
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 684  :     virtual int __CLR_OR_THIS_CALL sync() override { // synchronize C stream with external file

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 685  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

  00003	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00007	74 21		 je	 SHORT $LN3@sync
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	6a ff		 push	 -1
  0000d	ff 50 0c	 call	 DWORD PTR [eax+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 397  :         return _Left == _Right;

  00010	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 685  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

  00013	74 15		 je	 SHORT $LN3@sync
  00015	ff 76 4c	 push	 DWORD PTR [esi+76]
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	79 05		 jns	 SHORT $LN3@sync

; 687  :         }
; 688  : 
; 689  :         return -1;

  00025	83 c8 ff	 or	 eax, -1
  00028	5e		 pop	 esi

; 690  :     }

  00029	c3		 ret	 0
$LN3@sync:

; 686  :             return 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	5e		 pop	 esi

; 690  :     }

  0002d	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
_TEXT	SEGMENT
__Nr$1 = -16						; size = 4
__Pn$2 = -12						; size = 4
__Pb$3 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 8
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 665  :     virtual _Mysb* __CLR_OR_THIS_CALL setbuf(_Elem* _Buffer, streamsize _Count) override { // offer _Buffer to C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR __Buffer$[ebp]
  00015	8b f1		 mov	 esi, ecx

; 666  :         int _Mode;
; 667  :         if (!_Buffer && _Count == 0) {

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0001a	85 ff		 test	 edi, edi
  0001c	75 0e		 jne	 SHORT $LN2@setbuf
  0001e	8b c1		 mov	 eax, ecx
  00020	0b 45 10	 or	 eax, DWORD PTR __Count$[ebp+4]
  00023	75 07		 jne	 SHORT $LN2@setbuf

; 668  :             _Mode = _IONBF;

  00025	b8 04 00 00 00	 mov	 eax, 4

; 669  :         } else {

  0002a	eb 02		 jmp	 SHORT $LN3@setbuf
$LN2@setbuf:

; 670  :             _Mode = _IOFBF;

  0002c	33 c0		 xor	 eax, eax
$LN3@setbuf:

; 671  :         }
; 672  : 
; 673  :         const size_t _Size = static_cast<size_t>(_Count) * sizeof(_Elem);
; 674  : 
; 675  :         if (!_Myfile || _CSTD setvbuf(_Myfile, reinterpret_cast<char*>(_Buffer), _Mode, _Size) != 0) {

  0002e	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  00031	85 d2		 test	 edx, edx
  00033	0f 84 a1 00 00
	00		 je	 $LN5@setbuf
  00039	51		 push	 ecx
  0003a	50		 push	 eax
  0003b	57		 push	 edi
  0003c	52		 push	 edx
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setvbuf
  00043	83 c4 10	 add	 esp, 16			; 00000010H
  00046	85 c0		 test	 eax, eax
  00048	0f 85 8c 00 00
	00		 jne	 $LN5@setbuf

; 676  :             return nullptr; // failed
; 677  :         }
; 678  : 
; 679  :         // new buffer, reinitialize pointers
; 680  :         _Init(_Myfile, _Openfl);

  0004e	8b 7e 4c	 mov	 edi, DWORD PTR [esi+76]

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

  00051	8b ce		 mov	 ecx, esi
  00053	c6 46 48 01	 mov	 BYTE PTR [esi+72], 1
  00057	88 46 3d	 mov	 BYTE PTR [esi+61], al
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

  00060	85 ff		 test	 edi, edi
  00062	74 46		 je	 SHORT $LN8@setbuf

; 712  :             ::_get_stream_buffer_pointers(

  00064	8d 45 f0	 lea	 eax, DWORD PTR __Nr$1[ebp]
  00067	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Pb$3[ebp], 0
  0006e	50		 push	 eax
  0006f	8d 45 f4	 lea	 eax, DWORD PTR __Pn$2[ebp]
  00072	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Pn$2[ebp], 0
  00079	50		 push	 eax
  0007a	8d 45 f8	 lea	 eax, DWORD PTR __Pb$3[ebp]
  0007d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Nr$1[ebp], 0
  00084	50		 push	 eax
  00085	57		 push	 edi
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___get_stream_buffer_pointers
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 276  :         _IGfirst = _Gf;

  0008c	8b 45 f8	 mov	 eax, DWORD PTR __Pb$3[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 712  :             ::_get_stream_buffer_pointers(

  0008f	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 280  :         _IGcount = _Gc;

  00092	8b 4d f0	 mov	 ecx, DWORD PTR __Nr$1[ebp]
  00095	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00098	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0009b	8b 45 f4	 mov	 eax, DWORD PTR __Pn$2[ebp]
  0009e	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  000a1	89 46 20	 mov	 DWORD PTR [esi+32], eax
  000a4	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx

; 281  :         _IPcount = _Pc;

  000a7	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
$LN8@setbuf:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 720  :         _State  = _Stinit;

  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 681  :         return this;

  000b0	8b c6		 mov	 eax, esi

; 719  :         _Myfile = _File;

  000b2	89 7e 4c	 mov	 DWORD PTR [esi+76], edi

; 720  :         _State  = _Stinit;

  000b5	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  000b8	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000be	5f		 pop	 edi
  000bf	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

  000c2	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 682  :     }

  000c9	5e		 pop	 esi
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cd	33 cd		 xor	 ecx, ebp
  000cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 0c 00	 ret	 12			; 0000000cH
$LN5@setbuf:
  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	33 c0		 xor	 eax, eax
  000df	5f		 pop	 edi
  000e0	33 cd		 xor	 ecx, ebp
  000e2	5e		 pop	 esi
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__Off$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 652  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 10	 mov	 DWORD PTR __$ArrayPad$[esp+20], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 70   :         return _Myoff + _Fpos;

  00014	8b 55 0c	 mov	 edx, DWORD PTR __Pos$[ebp]
  00017	03 55 14	 add	 edx, DWORD PTR __Pos$[ebp+8]
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Pos$[ebp+4]
  0001d	13 45 18	 adc	 eax, DWORD PTR __Pos$[ebp+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 652  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	8b f1		 mov	 esi, ecx

; 653  :         // change position to _Pos
; 654  :         off_type _Off = static_cast<off_type>(_Pos);

  00024	89 54 24 0c	 mov	 DWORD PTR __Off$[esp+28], edx
  00028	57		 push	 edi
  00029	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0002c	89 44 24 14	 mov	 DWORD PTR __Off$[esp+36], eax

; 655  : 
; 656  :         if (!_Myfile || !_Endwrite() || _CSTD fsetpos(_Myfile, &_Off) != 0) {

  00030	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00034	74 71		 je	 SHORT $LN3@seekpos
  00036	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0003b	84 c0		 test	 al, al
  0003d	74 68		 je	 SHORT $LN3@seekpos
  0003f	8d 44 24 10	 lea	 eax, DWORD PTR __Off$[esp+32]
  00043	50		 push	 eax
  00044	ff 76 4c	 push	 DWORD PTR [esi+76]
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fsetpos
  0004d	83 c4 08	 add	 esp, 8
  00050	85 c0		 test	 eax, eax
  00052	75 53		 jne	 SHORT $LN3@seekpos

; 660  :         _State = _Pos.state();

  00054	8b 45 1c	 mov	 eax, DWORD PTR __Pos$[ebp+16]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00057	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 660  :         _State = _Pos.state();

  0005a	89 46 40	 mov	 DWORD PTR [esi+64], eax
  0005d	8b 45 20	 mov	 eax, DWORD PTR __Pos$[ebp+20]
  00060	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 778  :         if (_Mysb::eback() == &_Mychar) {

  00063	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  00066	39 03		 cmp	 DWORD PTR [ebx], eax
  00068	75 14		 jne	 SHORT $LN12@seekpos

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0006a	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  0006d	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00070	2b d1		 sub	 edx, ecx
  00072	89 0b		 mov	 DWORD PTR [ebx], ecx
  00074	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00077	89 08		 mov	 DWORD PTR [eax], ecx
  00079	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0007c	89 10		 mov	 DWORD PTR [eax], edx
$LN12@seekpos:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 662  :         return pos_type(_State, _Off); // return new position

  0007e	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  00081	8b 76 44	 mov	 esi, DWORD PTR [esi+68]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  00084	8b 4c 24 10	 mov	 ecx, DWORD PTR __Off$[esp+32]
  00088	89 0f		 mov	 DWORD PTR [edi], ecx
  0008a	8b 4c 24 14	 mov	 ecx, DWORD PTR __Off$[esp+36]
  0008e	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00091	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00098	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  0009f	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000a2	89 77 14	 mov	 DWORD PTR [edi+20], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 662  :         return pos_type(_State, _Off); // return new position

  000a5	eb 23		 jmp	 SHORT $LN20@seekpos
$LN3@seekpos:
  000a7	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  000aa	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [edi], -1
  000b0	c7 47 04 ff ff
	ff ff		 mov	 DWORD PTR [edi+4], -1
  000b7	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  000be	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  000c5	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
$LN20@seekpos:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 663  :     }

  000ca	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  000ce	8b c7		 mov	 eax, edi
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	33 cc		 xor	 ecx, esp
  000d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
__Off$2$ = -20						; size = 4
__Fileposition$ = -16					; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 632  :         ios_base::openmode = ios_base::in | ios_base::out) override { // change position by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 10	 mov	 DWORD PTR __$ArrayPad$[esp+20], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  0001c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 637  :             && !_Pcvt) { // not converting

  0001f	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  00022	39 08		 cmp	 DWORD PTR [eax], ecx
  00024	75 1a		 jne	 SHORT $LN21@seekoff
  00026	83 7d 14 01	 cmp	 DWORD PTR __Way$[ebp], 1
  0002a	75 14		 jne	 SHORT $LN21@seekoff
  0002c	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00030	75 0e		 jne	 SHORT $LN21@seekoff

; 638  :             _Off -= static_cast<off_type>(sizeof(_Elem)); // back up over _Elem bytes

  00032	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
  00035	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp+4]
  00038	83 c3 ff	 add	 ebx, -1
  0003b	83 d0 ff	 adc	 eax, -1
  0003e	eb 06		 jmp	 SHORT $LN23@seekoff
$LN21@seekoff:

; 637  :             && !_Pcvt) { // not converting

  00040	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp+4]
  00043	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
$LN23@seekoff:

; 639  :         }
; 640  : 
; 641  :         if (!_Myfile || !_Endwrite()
; 642  :             || ((_Off != 0 || _Way != ios_base::cur) && _CSTD _fseeki64(_Myfile, _Off, _Way) != 0)
; 643  :             || _CSTD fgetpos(_Myfile, &_Fileposition) != 0) {

  00046	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0004a	89 44 24 0c	 mov	 DWORD PTR __Off$2$[esp+32], eax
  0004e	0f 84 90 00 00
	00		 je	 $LN4@seekoff
  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0005b	84 c0		 test	 al, al
  0005d	0f 84 81 00 00
	00		 je	 $LN4@seekoff
  00063	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$2$[esp+32]
  00067	8b c3		 mov	 eax, ebx
  00069	0b c1		 or	 eax, ecx
  0006b	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  0006e	75 05		 jne	 SHORT $LN6@seekoff
  00070	83 f8 01	 cmp	 eax, 1
  00073	74 13		 je	 SHORT $LN5@seekoff
$LN6@seekoff:
  00075	50		 push	 eax
  00076	51		 push	 ecx
  00077	53		 push	 ebx
  00078	ff 76 4c	 push	 DWORD PTR [esi+76]
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___fseeki64
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	85 c0		 test	 eax, eax
  00086	75 5c		 jne	 SHORT $LN4@seekoff
$LN5@seekoff:
  00088	8d 44 24 10	 lea	 eax, DWORD PTR __Fileposition$[esp+32]
  0008c	50		 push	 eax
  0008d	ff 76 4c	 push	 DWORD PTR [esi+76]
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetpos
  00096	83 c4 08	 add	 esp, 8
  00099	85 c0		 test	 eax, eax
  0009b	75 47		 jne	 SHORT $LN4@seekoff
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  0009d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

  000a0	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  000a3	39 08		 cmp	 DWORD PTR [eax], ecx
  000a5	75 14		 jne	 SHORT $LN13@seekoff

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  000a7	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  000aa	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  000ad	2b d1		 sub	 edx, ecx
  000af	89 08		 mov	 DWORD PTR [eax], ecx
  000b1	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000b4	89 08		 mov	 DWORD PTR [eax], ecx
  000b6	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000b9	89 10		 mov	 DWORD PTR [eax], edx
$LN13@seekoff:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 648  :         return pos_type(_State, _Fileposition); // return new position

  000bb	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  000be	8b 76 44	 mov	 esi, DWORD PTR [esi+68]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  000c1	8b 4c 24 10	 mov	 ecx, DWORD PTR __Fileposition$[esp+32]
  000c5	89 0f		 mov	 DWORD PTR [edi], ecx
  000c7	8b 4c 24 14	 mov	 ecx, DWORD PTR __Fileposition$[esp+36]
  000cb	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  000ce	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  000d5	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  000dc	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000df	89 77 14	 mov	 DWORD PTR [edi+20], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 648  :         return pos_type(_State, _Fileposition); // return new position

  000e2	eb 23		 jmp	 SHORT $LN24@seekoff
$LN4@seekoff:
  000e4	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  000e7	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [edi], -1
  000ed	c7 47 04 ff ff
	ff ff		 mov	 DWORD PTR [edi+4], -1
  000f4	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  000fb	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00102	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
$LN24@seekoff:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 649  :     }

  00107	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  0010b	8b c7		 mov	 eax, edi
  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	5b		 pop	 ebx
  00110	33 cc		 xor	 ecx, esp
  00112	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
_TEXT	SEGMENT
__Off$1$ = -20						; size = 4
__Size$2$ = -16						; size = 4
tv248 = -12						; size = 4
__Start_count$1$ = -8					; size = 4
__Start_count$2$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 598  :     virtual streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 599  :         // put _Count characters to stream
; 600  :         if
; 601  :             _CONSTEXPR_IF(sizeof(_Elem) == 1) {
; 602  :                 if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

  0000e	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00012	74 18		 je	 SHORT $LN2@xsputn

; 603  :                     return _Mysb::xsputn(_Ptr, _Count);

  00014	ff 75 10	 push	 DWORD PTR __Count$[ebp+4]
  00017	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z

; 624  :             }
; 625  :         else { // non-chars always get element-by-element processing
; 626  :             return _Mysb::xsputn(_Ptr, _Count);
; 627  :         }
; 628  :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 0c 00	 ret	 12			; 0000000cH
$LN2@xsputn:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 260  :         return *_IPnext ? *_IPcount : 0;

  0002c	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 606  :                 const streamsize _Start_count = _Count;

  0002f	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  00032	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp+4]
  00035	89 74 24 18	 mov	 DWORD PTR __Start_count$1$[esp+32], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 260  :         return *_IPnext ? *_IPcount : 0;

  00039	8b 00		 mov	 eax, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 606  :                 const streamsize _Start_count = _Count;

  0003b	89 7c 24 1c	 mov	 DWORD PTR __Start_count$2$[esp+32], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 260  :         return *_IPnext ? *_IPcount : 0;

  0003f	89 44 24 14	 mov	 DWORD PTR tv248[esp+32], eax
  00043	85 c0		 test	 eax, eax
  00045	74 07		 je	 SHORT $LN9@xsputn
  00047	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	eb 02		 jmp	 SHORT $LN10@xsputn
$LN9@xsputn:
  0004e	33 c0		 xor	 eax, eax
$LN10@xsputn:
  00050	99		 cdq
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 607  :                 streamsize _Size              = _Mysb::_Pnavail();

  00051	89 44 24 0c	 mov	 DWORD PTR __Off$1$[esp+32], eax
  00055	8b ca		 mov	 ecx, edx
  00057	89 4c 24 10	 mov	 DWORD PTR __Size$2$[esp+32], ecx

; 608  :                 if (0 < _Count && 0 < _Size) { // copy to write buffer

  0005b	85 ff		 test	 edi, edi
  0005d	7c 76		 jl	 SHORT $LN5@xsputn
  0005f	7f 04		 jg	 SHORT $LN18@xsputn
  00061	85 f6		 test	 esi, esi
  00063	74 70		 je	 SHORT $LN5@xsputn
$LN18@xsputn:
  00065	85 c9		 test	 ecx, ecx
  00067	7c 4f		 jl	 SHORT $LN22@xsputn
  00069	7f 04		 jg	 SHORT $LN19@xsputn
  0006b	85 c0		 test	 eax, eax
  0006d	74 49		 je	 SHORT $LN22@xsputn
$LN19@xsputn:

; 609  :                     if (_Count < _Size) {

  0006f	3b f9		 cmp	 edi, ecx
  00071	7f 10		 jg	 SHORT $LN4@xsputn
  00073	7c 04		 jl	 SHORT $LN20@xsputn
  00075	3b f0		 cmp	 esi, eax
  00077	73 0a		 jae	 SHORT $LN4@xsputn
$LN20@xsputn:

; 610  :                         _Size = _Count;

  00079	8b c6		 mov	 eax, esi
  0007b	89 74 24 0c	 mov	 DWORD PTR __Off$1$[esp+32], esi
  0007f	89 7c 24 10	 mov	 DWORD PTR __Size$2$[esp+32], edi
$LN4@xsputn:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00083	50		 push	 eax
  00084	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00087	ff 74 24 1c	 push	 DWORD PTR tv248[esp+40]
  0008b	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 615  :                     _Count -= _Size;

  00090	8b 4c 24 18	 mov	 ecx, DWORD PTR __Off$1$[esp+44]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 237  :         *_IPcount -= _Off;

  00097	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 615  :                     _Count -= _Size;

  0009a	2b f1		 sub	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 238  :         *_IPnext += _Off;

  0009c	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 615  :                     _Count -= _Size;

  0009f	1b 7c 24 10	 sbb	 edi, DWORD PTR __Size$2$[esp+32]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 238  :         *_IPnext += _Off;

  000a3	03 d1		 add	 edx, ecx
  000a5	29 08		 sub	 DWORD PTR [eax], ecx
  000a7	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000aa	01 08		 add	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 619  :                 if (0 < _Count && _Myfile) { // open C stream, attempt write

  000ac	85 ff		 test	 edi, edi
  000ae	7c 25		 jl	 SHORT $LN5@xsputn
  000b0	7f 09		 jg	 SHORT $LN21@xsputn
  000b2	85 f6		 test	 esi, esi
  000b4	74 1f		 je	 SHORT $LN5@xsputn

; 608  :                 if (0 < _Count && 0 < _Size) { // copy to write buffer

  000b6	eb 03		 jmp	 SHORT $LN21@xsputn
$LN22@xsputn:
  000b8	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN21@xsputn:

; 619  :                 if (0 < _Count && _Myfile) { // open C stream, attempt write

  000bb	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
  000be	85 c0		 test	 eax, eax
  000c0	74 13		 je	 SHORT $LN5@xsputn

; 620  :                     _Count -= _CSTD fwrite(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);

  000c2	50		 push	 eax
  000c3	56		 push	 esi
  000c4	6a 01		 push	 1
  000c6	52		 push	 edx
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  000cd	83 c4 10	 add	 esp, 16			; 00000010H
  000d0	2b f0		 sub	 esi, eax
  000d2	83 df 00	 sbb	 edi, 0
$LN5@xsputn:

; 621  :                 }
; 622  : 
; 623  :                 return _Start_count - _Count;

  000d5	8b 44 24 18	 mov	 eax, DWORD PTR __Start_count$1$[esp+32]
  000d9	8b 54 24 1c	 mov	 edx, DWORD PTR __Start_count$2$[esp+32]
  000dd	2b c6		 sub	 eax, esi
  000df	1b d7		 sbb	 edx, edi

; 624  :             }
; 625  :         else { // non-chars always get element-by-element processing
; 626  :             return _Mysb::xsputn(_Ptr, _Count);
; 627  :         }
; 628  :     }

  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
_TEXT	SEGMENT
tv409 = -12						; size = 4
__Ptr$GSCopy$1$ = -8					; size = 4
$T5 = -4						; size = 4
$T6 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 548  :     virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 549  :         // get _Count characters from stream
; 550  :         if
; 551  :             _CONSTEXPR_IF(sizeof(_Elem) == 1) {
; 552  :                 if (_Count <= 0) {

  00006	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp+4]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d f8	 mov	 DWORD PTR __Ptr$GSCopy$1$[ebp], ecx
  00012	56		 push	 esi
  00013	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  00016	85 c0		 test	 eax, eax
  00018	7f 12		 jg	 SHORT $LN4@xsgetn
  0001a	7c 04		 jl	 SHORT $LN34@xsgetn
  0001c	85 f6		 test	 esi, esi
  0001e	75 0c		 jne	 SHORT $LN4@xsgetn
$LN34@xsgetn:
  00020	5e		 pop	 esi

; 553  :                     return 0;

  00021	33 c0		 xor	 eax, eax
  00023	33 d2		 xor	 edx, edx

; 592  :             }
; 593  :         else { // non-chars always get element-by-element processing
; 594  :             return _Mysb::xsgetn(_Ptr, _Count);
; 595  :         }
; 596  :     }

  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 0c 00	 ret	 12			; 0000000cH
$LN4@xsgetn:

; 554  :                 }
; 555  : 
; 556  :                 if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

  0002c	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00030	74 13		 je	 SHORT $LN5@xsgetn

; 557  :                     return _Mysb::xsgetn(_Ptr, _Count);

  00032	50		 push	 eax
  00033	56		 push	 esi
  00034	51		 push	 ecx
  00035	8b cb		 mov	 ecx, ebx
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
  0003d	5e		 pop	 esi

; 592  :             }
; 593  :         else { // non-chars always get element-by-element processing
; 594  :             return _Mysb::xsgetn(_Ptr, _Count);
; 595  :         }
; 596  :     }

  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
$LN5@xsgetn:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 233  :         return *_IGnext ? *_IGcount : 0;

  00045	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00048	57		 push	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 561  :                 auto _Count_s           = static_cast<size_t>(_Count);

  00049	8b fe		 mov	 edi, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 233  :         return *_IGnext ? *_IGcount : 0;

  0004b	89 75 fc	 mov	 DWORD PTR $T5[ebp], esi
  0004e	8b 10		 mov	 edx, DWORD PTR [eax]
  00050	85 d2		 test	 edx, edx
  00052	74 31		 je	 SHORT $LN6@xsgetn
  00054	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 564  :                 if (0 < _Available) { // copy from get area

  00059	85 c0		 test	 eax, eax
  0005b	74 28		 je	 SHORT $LN6@xsgetn
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  0005d	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00060	3b c7		 cmp	 eax, edi
  00062	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00065	56		 push	 esi
  00066	52		 push	 edx
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 203  :         *_IGcount -= _Off;

  0006d	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 567  :                     _Ptr += _Read_size;

  00070	2b fe		 sub	 edi, esi
  00072	01 75 f8	 add	 DWORD PTR __Ptr$GSCopy$1$[ebp], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 204  :         *_IGnext += _Off;

  00078	89 7d fc	 mov	 DWORD PTR $T5[ebp], edi
  0007b	29 30		 sub	 DWORD PTR [eax], esi
  0007d	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00080	01 30		 add	 DWORD PTR [eax], esi
  00082	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
$LN6@xsgetn:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 572  :                 if (_Myfile) { // open C stream, attempt read

  00085	83 7b 4c 00	 cmp	 DWORD PTR [ebx+76], 0
  00089	0f 84 ad 00 00
	00		 je	 $LN36@xsgetn
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  0008f	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

  00092	8d 43 3c	 lea	 eax, DWORD PTR [ebx+60]
  00095	39 01		 cmp	 DWORD PTR [ecx], eax
  00097	75 17		 jne	 SHORT $LN24@xsgetn
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 208  :         *_IGfirst = _First;

  00099	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0009c	8b 53 54	 mov	 edx, DWORD PTR [ebx+84]
  0009f	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  000a2	2b d1		 sub	 edx, ecx
  000a4	89 08		 mov	 DWORD PTR [eax], ecx
  000a6	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000a9	89 08		 mov	 DWORD PTR [eax], ecx
  000ab	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  000ae	89 10		 mov	 DWORD PTR [eax], edx
$LN24@xsgetn:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 577  :                     while (_Read_size < _Count_s) {

  000b0	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  000b3	8b d0		 mov	 edx, eax
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$GSCopy$1$[ebp]
  000b8	3d ff 0f 00 00	 cmp	 eax, 4095		; 00000fffH
  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__fread
  000c2	89 55 fc	 mov	 DWORD PTR $T6[ebp], edx
  000c5	76 38		 jbe	 SHORT $LN3@xsgetn
  000c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@xsgetn:

; 578  :                         const auto _Actual_read = _CSTD fread(_Ptr, sizeof(_Elem), _Read_size, _Myfile);

  000d0	ff 73 4c	 push	 DWORD PTR [ebx+76]
  000d3	68 ff 0f 00 00	 push	 4095			; 00000fffH
  000d8	6a 01		 push	 1
  000da	51		 push	 ecx
  000db	ff d0		 call	 eax

; 579  :                         _Ptr += _Actual_read;

  000dd	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$GSCopy$1$[ebp]

; 580  :                         _Count_s -= _Actual_read;

  000e0	2b f8		 sub	 edi, eax
  000e2	03 c8		 add	 ecx, eax
  000e4	89 7d fc	 mov	 DWORD PTR $T6[ebp], edi
  000e7	83 c4 10	 add	 esp, 16			; 00000010H
  000ea	89 4d f8	 mov	 DWORD PTR __Ptr$GSCopy$1$[ebp], ecx
  000ed	8b d7		 mov	 edx, edi

; 581  :                         if (_Actual_read != _Read_size) {

  000ef	3d ff 0f 00 00	 cmp	 eax, 4095		; 00000fffH
  000f4	75 33		 jne	 SHORT $LN31@xsgetn

; 577  :                     while (_Read_size < _Count_s) {

  000f6	3b f8		 cmp	 edi, eax
  000f8	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__fread
  000fd	77 d1		 ja	 SHORT $LL2@xsgetn
$LN3@xsgetn:

; 582  :                             return static_cast<streamsize>(_Start_count - _Count_s);
; 583  :                         }
; 584  :                     }
; 585  : 
; 586  :                     if (0 < _Count_s) {

  000ff	83 7d fc 00	 cmp	 DWORD PTR $T6[ebp], 0
  00103	76 3a		 jbe	 SHORT $LN9@xsgetn

; 587  :                         _Count_s -= _CSTD fread(_Ptr, sizeof(_Elem), _Count_s, _Myfile);

  00105	ff 73 4c	 push	 DWORD PTR [ebx+76]
  00108	57		 push	 edi
  00109	6a 01		 push	 1
  0010b	51		 push	 ecx
  0010c	ff d0		 call	 eax
  0010e	8b 55 fc	 mov	 edx, DWORD PTR $T6[ebp]
  00111	83 c4 10	 add	 esp, 16			; 00000010H
  00114	2b d0		 sub	 edx, eax

; 588  :                     }
; 589  :                 }
; 590  : 
; 591  :                 return static_cast<streamsize>(_Start_count - _Count_s);

  00116	2b f2		 sub	 esi, edx
  00118	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp+4]
  0011b	8b c6		 mov	 eax, esi
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	83 da 00	 sbb	 edx, 0

; 592  :             }
; 593  :         else { // non-chars always get element-by-element processing
; 594  :             return _Mysb::xsgetn(_Ptr, _Count);
; 595  :         }
; 596  :     }

  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c2 0c 00	 ret	 12			; 0000000cH
$LN31@xsgetn:

; 588  :                     }
; 589  :                 }
; 590  : 
; 591  :                 return static_cast<streamsize>(_Start_count - _Count_s);

  00129	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp+4]
  0012c	2b f7		 sub	 esi, edi
  0012e	5f		 pop	 edi
  0012f	8b c6		 mov	 eax, esi
  00131	83 da 00	 sbb	 edx, 0
  00134	5e		 pop	 esi

; 592  :             }
; 593  :         else { // non-chars always get element-by-element processing
; 594  :             return _Mysb::xsgetn(_Ptr, _Count);
; 595  :         }
; 596  :     }

  00135	5b		 pop	 ebx
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c2 0c 00	 ret	 12			; 0000000cH
$LN36@xsgetn:

; 572  :                 if (_Myfile) { // open C stream, attempt read

  0013c	8b 55 fc	 mov	 edx, DWORD PTR $T5[ebp]
$LN9@xsgetn:

; 588  :                     }
; 589  :                 }
; 590  : 
; 591  :                 return static_cast<streamsize>(_Start_count - _Count_s);

  0013f	2b f2		 sub	 esi, edx
  00141	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp+4]
  00144	5f		 pop	 edi
  00145	8b c6		 mov	 eax, esi
  00147	83 da 00	 sbb	 edx, 0
  0014a	5e		 pop	 esi

; 592  :             }
; 593  :         else { // non-chars always get element-by-element processing
; 594  :             return _Mysb::xsgetn(_Ptr, _Count);
; 595  :         }
; 596  :     }

  0014b	5b		 pop	 ebx
  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
$T16 = -56						; size = 1
__Dest$49 = -56						; size = 4
__Src$50 = -52						; size = 4
__Ch$ = -48						; size = 1
__Str$ = -44						; size = 24
__Ch$51 = -17						; size = 1
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 490  :     virtual int_type __CLR_OR_THIS_CALL uflow() override { // get an element from stream, point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  0002d	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 491  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  00032	85 c9		 test	 ecx, ecx
  00034	74 23		 je	 SHORT $LN268@uflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

  00036	8b 53 2c	 mov	 edx, DWORD PTR [ebx+44]
  00039	8b 32		 mov	 esi, DWORD PTR [edx]
  0003b	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 491  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  0003e	3b c8		 cmp	 ecx, eax
  00040	73 17		 jae	 SHORT $LN268@uflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 223  :         --*_IGcount;

  00042	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00045	89 02		 mov	 DWORD PTR [edx], eax

; 224  :         return (*_IGnext)++;

  00047	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0004f	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

  00051	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 492  :             return _Traits::to_int_type(*_Mysb::_Gninc()); // return buffered

  00054	e9 d8 01 00 00	 jmp	 $LN232@uflow
$LN268@uflow:

; 493  :         }
; 494  : 
; 495  :         if (!_Myfile) {

  00059	83 7b 4c 00	 cmp	 DWORD PTR [ebx+76], 0
  0005d	75 08		 jne	 SHORT $LN10@uflow
$LN275@uflow:

; 542  :             }
; 543  :         }
; 544  :     }

  0005f	83 c8 ff	 or	 eax, -1
  00062	e9 ca 01 00 00	 jmp	 $LN232@uflow
$LN10@uflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00067	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

  0006a	8d 43 3c	 lea	 eax, DWORD PTR [ebx+60]
  0006d	39 06		 cmp	 DWORD PTR [esi], eax
  0006f	75 14		 jne	 SHORT $LN35@uflow

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00071	8b 53 54	 mov	 edx, DWORD PTR [ebx+84]
  00074	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00077	2b d1		 sub	 edx, ecx
  00079	89 0e		 mov	 DWORD PTR [esi], ecx
  0007b	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0007e	89 08		 mov	 DWORD PTR [eax], ecx
  00080	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  00083	89 10		 mov	 DWORD PTR [eax], edx
$LN35@uflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 500  :         if (!_Pcvt) { // no codecvt facet, just get it

  00085	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00089	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
  0008c	75 17		 jne	 SHORT $LN11@uflow

; 67   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

  0008e	50		 push	 eax
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00095	83 c4 04	 add	 esp, 4
  00098	83 f8 ff	 cmp	 eax, -1
  0009b	74 c2		 je	 SHORT $LN275@uflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

  0009d	0f b6 c0	 movzx	 eax, al
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 502  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

  000a0	e9 8c 01 00 00	 jmp	 $LN232@uflow
$LN11@uflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4301 :         _Mypair._Myval2._Mysize = 0;

  000a5	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Str$[ebp+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  000ac	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR __Str$[ebp+20], 15 ; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  000b3	c6 45 d4 00	 mov	 BYTE PTR __Str$[ebp], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 510  :             int _Meta = _CSTD fgetc(_Myfile);

  000b7	50		 push	 eax
  000b8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  000c5	8b d0		 mov	 edx, eax
  000c7	83 c4 04	 add	 esp, 4

; 511  : 
; 512  :             if (_Meta == EOF) {

  000ca	83 fa ff	 cmp	 edx, -1
  000cd	0f 84 d0 00 00
	00		 je	 $LN256@uflow
$LL2@uflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 3616 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  000d3	8b 4d e4	 mov	 ecx, DWORD PTR __Str$[ebp+16]
  000d6	8b 75 e8	 mov	 esi, DWORD PTR __Str$[ebp+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 516  :             _Str.push_back(static_cast<char>(_Meta)); // append byte and convert

  000d9	88 55 d0	 mov	 BYTE PTR __Ch$[ebp], dl
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 3616 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  000dc	3b ce		 cmp	 ecx, esi

; 3617 :         if (_Old_size < _Mypair._Myval2._Myres) {

  000de	73 1a		 jae	 SHORT $LN85@uflow

; 3618 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  000e0	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 2158 :         return _BUF_SIZE <= _Myres;

  000e3	83 fe 10	 cmp	 esi, 16			; 00000010H

; 3618 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  000e6	89 45 e4	 mov	 DWORD PTR __Str$[ebp+16], eax

; 2140 :         value_type* _Result = _Bx._Buf;

  000e9	8d 45 d4	 lea	 eax, DWORD PTR __Str$[ebp]

; 2141 :         if (_Large_string_engaged()) {

  000ec	0f 43 45 d4	 cmovae	 eax, DWORD PTR __Str$[ebp]

; 3620 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  000f0	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 3621 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  000f3	c6 44 08 01 00	 mov	 BYTE PTR [eax+ecx+1], 0

; 3622 :             return;

  000f8	eb 0f		 jmp	 SHORT $LN84@uflow
$LN85@uflow:

; 3623 :         }
; 3624 : 
; 3625 :         _Reallocate_grow_by(

  000fa	ff 75 d0	 push	 DWORD PTR __Ch$[ebp]
  000fd	ff 75 c8	 push	 DWORD PTR $T16[ebp]
  00100	51		 push	 ecx
  00101	8d 4d d4	 lea	 ecx, DWORD PTR __Str$[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN84@uflow:

; 2158 :         return _BUF_SIZE <= _Myres;

  00109	83 7d e8 10	 cmp	 DWORD PTR __Str$[ebp+20], 16 ; 00000010H

; 2140 :         value_type* _Result = _Bx._Buf;

  0010d	8d 4d d4	 lea	 ecx, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  00110	8b 7d e4	 mov	 edi, DWORD PTR __Str$[ebp+16]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2140 :         value_type* _Result = _Bx._Buf;

  00113	8d 45 d4	 lea	 eax, DWORD PTR __Str$[ebp]

; 2141 :         if (_Large_string_engaged()) {

  00116	0f 43 4d d4	 cmovae	 ecx, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  0011a	03 f9		 add	 edi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  0011c	83 7d e8 10	 cmp	 DWORD PTR __Str$[ebp+20], 16 ; 00000010H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  00120	8d 4d c8	 lea	 ecx, DWORD PTR __Dest$49[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2141 :         if (_Large_string_engaged()) {

  00123	0f 43 45 d4	 cmovae	 eax, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  00127	51		 push	 ecx
  00128	8d 4d f0	 lea	 ecx, DWORD PTR __Ch$51[ebp+1]
  0012b	51		 push	 ecx
  0012c	8d 4d ef	 lea	 ecx, DWORD PTR __Ch$51[ebp]
  0012f	51		 push	 ecx
  00130	8d 4d cc	 lea	 ecx, DWORD PTR __Src$50[ebp]
  00133	51		 push	 ecx
  00134	8b 4b 38	 mov	 ecx, DWORD PTR [ebx+56]
  00137	57		 push	 edi
  00138	50		 push	 eax
  00139	8d 43 40	 lea	 eax, DWORD PTR [ebx+64]
  0013c	50		 push	 eax
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
  00143	85 c0		 test	 eax, eax
  00145	78 5c		 js	 SHORT $LN256@uflow
  00147	83 f8 01	 cmp	 eax, 1
  0014a	0f 8f c0 00 00
	00		 jg	 $LN257@uflow

; 521  :                 _Dest)) { // test result of converting one element
; 522  :             case codecvt_base::partial:
; 523  :             case codecvt_base::ok:
; 524  :                 if (_Dest != &_Ch) { // got an element, put back excess and deliver it

  00150	8d 45 ef	 lea	 eax, DWORD PTR __Ch$51[ebp]
  00153	39 45 c8	 cmp	 DWORD PTR __Dest$49[ebp], eax
  00156	8d 45 d4	 lea	 eax, DWORD PTR __Str$[ebp]
  00159	75 7b		 jne	 SHORT $LN258@uflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  0015b	83 7d e8 10	 cmp	 DWORD PTR __Str$[ebp+20], 16 ; 00000010H

; 2140 :         value_type* _Result = _Bx._Buf;

  0015f	8d 55 d4	 lea	 edx, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 533  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

  00162	8b 7d cc	 mov	 edi, DWORD PTR __Src$50[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2141 :         if (_Large_string_engaged()) {

  00165	0f 43 45 d4	 cmovae	 eax, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 533  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

  00169	2b f8		 sub	 edi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  0016b	8b 45 e4	 mov	 eax, DWORD PTR __Str$[ebp+16]
  0016e	3b c7		 cmp	 eax, edi
  00170	0f 42 f8	 cmovb	 edi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00173	83 7d e8 10	 cmp	 DWORD PTR __Str$[ebp+20], 16 ; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  00177	0f 43 55 d4	 cmovae	 edx, DWORD PTR __Str$[ebp]

; 3229 :         const size_type _New_size = _Old_size - _Count;

  0017b	2b c7		 sub	 eax, edi

; 3230 :         _Mypair._Myval2._Mysize   = _New_size;

  0017d	89 45 e4	 mov	 DWORD PTR __Str$[ebp+16], eax

; 3231 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00180	40		 inc	 eax

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00181	50		 push	 eax

; 3231 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00182	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00185	50		 push	 eax
  00186	52		 push	 edx
  00187	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 510  :             int _Meta = _CSTD fgetc(_Myfile);

  0018c	ff 73 4c	 push	 DWORD PTR [ebx+76]
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00195	8b d0		 mov	 edx, eax
  00197	83 c4 10	 add	 esp, 16			; 00000010H

; 511  : 
; 512  :             if (_Meta == EOF) {

  0019a	83 fa ff	 cmp	 edx, -1
  0019d	0f 85 30 ff ff
	ff		 jne	 $LL2@uflow
$LN256@uflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  001a3	83 ce ff	 or	 esi, -1
$LN23@uflow:
  001a6	8b 55 e8	 mov	 edx, DWORD PTR __Str$[ebp+20]
  001a9	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001ac	0f 82 7d 00 00
	00		 jb	 $LN212@uflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b2	8b 4d d4	 mov	 ecx, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001b5	42		 inc	 edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b6	8b c1		 mov	 eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001b8	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001be	72 65		 jb	 SHORT $LN222@uflow

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001c0	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001c3	83 c2 23	 add	 edx, 35			; 00000023H
  001c6	2b c1		 sub	 eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c8	83 c0 fc	 add	 eax, -4			; fffffffcH
  001cb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001ce	76 55		 jbe	 SHORT $LN222@uflow
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN258@uflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  001d6	83 7d e8 10	 cmp	 DWORD PTR __Str$[ebp+20], 16 ; 00000010H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 525  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

  001da	8b 75 e4	 mov	 esi, DWORD PTR __Str$[ebp+16]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2141 :         if (_Large_string_engaged()) {

  001dd	0f 43 45 d4	 cmovae	 eax, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 525  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

  001e1	8b 4d cc	 mov	 ecx, DWORD PTR __Src$50[ebp]
  001e4	2b f1		 sub	 esi, ecx
  001e6	03 f0		 add	 esi, eax

; 526  :                     while (0 < _Nleft) {

  001e8	85 f6		 test	 esi, esi
  001ea	7e 1e		 jle	 SHORT $LN271@uflow
  001ec	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ungetc
$LL261@uflow:

; 527  :                         _CSTD ungetc(_Src[--_Nleft], _Myfile);

  001f2	ff 73 4c	 push	 DWORD PTR [ebx+76]
  001f5	0f be 44 0e ff	 movsx	 eax, BYTE PTR [esi+ecx-1]
  001fa	4e		 dec	 esi
  001fb	50		 push	 eax
  001fc	ff d7		 call	 edi
  001fe	83 c4 08	 add	 esp, 8
  00201	85 f6		 test	 esi, esi
  00203	7e 05		 jle	 SHORT $LN271@uflow

; 526  :                     while (0 < _Nleft) {

  00205	8b 4d cc	 mov	 ecx, DWORD PTR __Src$50[ebp]
  00208	eb e8		 jmp	 SHORT $LL261@uflow
$LN271@uflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

  0020a	0f b6 75 ef	 movzx	 esi, BYTE PTR __Ch$51[ebp]
  0020e	eb 96		 jmp	 SHORT $LN23@uflow
$LN257@uflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  00210	83 f8 03	 cmp	 eax, 3
  00213	75 8e		 jne	 SHORT $LN256@uflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00215	83 7d e8 10	 cmp	 DWORD PTR __Str$[ebp+20], 16 ; 00000010H

; 2140 :         value_type* _Result = _Bx._Buf;

  00219	8d 45 d4	 lea	 eax, DWORD PTR __Str$[ebp]

; 2141 :         if (_Large_string_engaged()) {

  0021c	0f 43 45 d4	 cmovae	 eax, DWORD PTR __Str$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 538  :                 return static_cast<int_type>(_Str.front());

  00220	0f be 30	 movsx	 esi, BYTE PTR [eax]
  00223	eb 81		 jmp	 SHORT $LN23@uflow
$LN222@uflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00225	52		 push	 edx
  00226	51		 push	 ecx
  00227	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0022c	83 c4 08	 add	 esp, 8
$LN212@uflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 541  :                 return _Traits::eof(); // conversion failed

  0022f	8b c6		 mov	 eax, esi
$LN232@uflow:

; 542  :             }
; 543  :         }
; 544  :     }

  00231	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00234	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0023b	59		 pop	 ecx
  0023c	5f		 pop	 edi
  0023d	5e		 pop	 esi
  0023e	5b		 pop	 ebx
  0023f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00242	33 cd		 xor	 ecx, ebp
  00244	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00249	8b e5		 mov	 esp, ebp
  0024b	5d		 pop	 ebp
  0024c	c3		 ret	 0
$LN274@uflow:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Str$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 478  :     virtual int_type __CLR_OR_THIS_CALL underflow() override { // get an element from stream, but don't point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  00003	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 480  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	85 c9		 test	 ecx, ecx
  0000a	74 10		 je	 SHORT $LN2@underflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

  0000c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	03 c1		 add	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 480  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  00013	3b c8		 cmp	 ecx, eax
  00015	73 05		 jae	 SHORT $LN2@underflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

  00017	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0001a	5e		 pop	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 488  :     }

  0001b	c3		 ret	 0
$LN2@underflow:

; 482  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8b ce		 mov	 ecx, esi
  00020	57		 push	 edi
  00021	ff 50 1c	 call	 DWORD PTR [eax+28]
  00024	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 397  :         return _Left == _Right;

  00026	83 ff ff	 cmp	 edi, -1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 482  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

  00029	75 05		 jne	 SHORT $LN4@underflow

; 483  :             return _Meta; // uflow failed, return EOF

  0002b	5f		 pop	 edi
  0002c	0b c0		 or	 eax, eax
  0002e	5e		 pop	 esi

; 488  :     }

  0002f	c3		 ret	 0
$LN4@underflow:

; 484  :         } else { // get a char, don't point past it
; 485  :             pbackfail(_Meta);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b ce		 mov	 ecx, esi
  00034	57		 push	 edi
  00035	ff 50 10	 call	 DWORD PTR [eax+16]

; 486  :             return _Meta;

  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi

; 488  :     }

  0003c	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 457  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  0000a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 2e		 je	 SHORT $LN2@pbackfail
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00013	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00016	39 08		 cmp	 DWORD PTR [eax], ecx
  00018	73 27		 jae	 SHORT $LN2@pbackfail
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 397  :         return _Left == _Right;

  0001a	83 fb ff	 cmp	 ebx, -1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001d	74 08		 je	 SHORT $LN4@pbackfail
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

  0001f	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]

; 397  :         return _Left == _Right;

  00023	3b c3		 cmp	 eax, ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00025	75 1a		 jne	 SHORT $LN2@pbackfail
$LN4@pbackfail:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 218  :         ++*_IGcount;

  00027	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0002a	ff 00		 inc	 DWORD PTR [eax]

; 219  :         return --*_IGnext;

  0002c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0002f	ff 08		 dec	 DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 464  :             return _Traits::not_eof(_Meta);

  00031	33 c0		 xor	 eax, eax
  00033	83 fb ff	 cmp	 ebx, -1
  00036	0f 44 d8	 cmove	 ebx, eax
$LN54@pbackfail:

; 473  :         } else {
; 474  :             return _Traits::eof(); // nowhere to put back
; 475  :         }
; 476  :     }

  00039	5e		 pop	 esi
  0003a	8b c3		 mov	 eax, ebx
  0003c	5b		 pop	 ebx
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN2@pbackfail:

; 465  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00041	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00044	85 c0		 test	 eax, eax
  00046	74 5a		 je	 SHORT $LN7@pbackfail
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 397  :         return _Left == _Right;

  00048	83 fb ff	 cmp	 ebx, -1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 465  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

  0004b	74 55		 je	 SHORT $LN7@pbackfail

; 467  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

  0004d	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00051	75 13		 jne	 SHORT $LN52@pbackfail

; 130  :     return _CSTD ungetc(static_cast<unsigned char>(_Byte), _File) != EOF;

  00053	50		 push	 eax
  00054	0f b6 cb	 movzx	 ecx, bl
  00057	51		 push	 ecx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ungetc
  0005e	83 c4 08	 add	 esp, 8
  00061	83 f8 ff	 cmp	 eax, -1

; 467  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

  00064	75 d3		 jne	 SHORT $LN54@pbackfail
$LN52@pbackfail:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  00066	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 469  :         } else if (_Mysb::gptr() != &_Mychar) { // putback to _Mychar

  00069	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  0006c	39 0a		 cmp	 DWORD PTR [edx], ecx
  0006e	74 32		 je	 SHORT $LN7@pbackfail

; 470  :             _Mychar = _Traits::to_char_type(_Meta);

  00070	57		 push	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00071	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 470  :             _Mychar = _Traits::to_char_type(_Meta);

  00074	88 19		 mov	 BYTE PTR [ecx], bl

; 784  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

  00076	8b 07		 mov	 eax, DWORD PTR [edi]
  00078	3b c1		 cmp	 eax, ecx
  0007a	74 0d		 je	 SHORT $LN53@pbackfail

; 785  :             _Set_eback = _Mysb::eback();

  0007c	89 46 50	 mov	 DWORD PTR [esi+80], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

  0007f	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00082	8b 00		 mov	 eax, DWORD PTR [eax]
  00084	03 02		 add	 eax, DWORD PTR [edx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 786  :             _Set_egptr = _Mysb::egptr();

  00086	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN53@pbackfail:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 208  :         *_IGfirst = _First;

  00089	89 0f		 mov	 DWORD PTR [edi], ecx

; 209  :         *_IGnext  = _Next;

  0008b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 472  :             return _Meta;

  0008e	5f		 pop	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 209  :         *_IGnext  = _Next;

  0008f	89 08		 mov	 DWORD PTR [eax], ecx

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00091	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00094	5e		 pop	 esi
  00095	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 472  :             return _Meta;

  0009b	8b c3		 mov	 eax, ebx

; 473  :         } else {
; 474  :             return _Traits::eof(); // nowhere to put back
; 475  :         }
; 476  :     }

  0009d	5b		 pop	 ebx
  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
$LN7@pbackfail:
  000a2	5e		 pop	 esi

; 466  :             return _Traits::eof(); // no open C stream or EOF, fail

  000a3	83 c8 ff	 or	 eax, -1

; 473  :         } else {
; 474  :             return _Traits::eof(); // nowhere to put back
; 475  :         }
; 476  :     }

  000a6	5b		 pop	 ebx
  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Src$ = -48						; size = 4
__Dest$ = -44						; size = 4
__Ch$ = -37						; size = 1
__Str$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 406  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 397  :         return _Left == _Right;

  00011	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 406  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 397  :         return _Left == _Right;

  00017	83 fb ff	 cmp	 ebx, -1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 407  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  0001a	75 14		 jne	 SHORT $LN4@overflow

; 408  :             return _Traits::not_eof(_Meta); // EOF, return success code

  0001c	5e		 pop	 esi
  0001d	33 c0		 xor	 eax, eax

; 451  : 
; 452  :         default:
; 453  :             return _Traits::eof(); // conversion failed
; 454  :         }
; 455  :     }

  0001f	5b		 pop	 ebx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00023	33 cd		 xor	 ecx, ebp
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
$LN4@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 195  :         return *_IPnext;

  00030	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 411  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	85 c0		 test	 eax, eax
  00037	74 27		 je	 SHORT $LN5@overflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 214  :         return *_IPnext + *_IPcount;

  00039	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0003c	8b 12		 mov	 edx, DWORD PTR [edx]
  0003e	03 d0		 add	 edx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 411  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

  00040	3b c2		 cmp	 eax, edx
  00042	73 1c		 jae	 SHORT $LN5@overflow

; 412  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
  0004a	5e		 pop	 esi
  0004b	88 18		 mov	 BYTE PTR [eax], bl

; 413  :             return _Meta;

  0004d	8b c3		 mov	 eax, ebx

; 451  : 
; 452  :         default:
; 453  :             return _Traits::eof(); // conversion failed
; 454  :         }
; 455  :     }

  0004f	5b		 pop	 ebx
  00050	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00053	33 cd		 xor	 ecx, ebp
  00055	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
$LN5@overflow:

; 414  :         }
; 415  : 
; 416  :         if (!_Myfile) {

  00060	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00064	57		 push	 edi
  00065	0f 84 ca 00 00
	00		 je	 $LN12@overflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  0006b	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

  0006e	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  00071	39 07		 cmp	 DWORD PTR [edi], eax
  00073	75 14		 jne	 SHORT $LN33@overflow

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00075	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  00078	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  0007b	2b d1		 sub	 edx, ecx
  0007d	89 0f		 mov	 DWORD PTR [edi], ecx
  0007f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00082	89 08		 mov	 DWORD PTR [eax], ecx
  00084	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00087	89 10		 mov	 DWORD PTR [eax], edx
$LN33@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 421  :         if (!_Pcvt) { // no codecvt facet, put as is

  00089	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0008c	85 c9		 test	 ecx, ecx
  0008e	75 05		 jne	 SHORT $LN7@overflow

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

  00090	0f be c3	 movsx	 eax, bl

; 422  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

  00093	eb 37		 jmp	 SHORT $LN45@overflow
$LN7@overflow:

; 423  :         }
; 424  : 
; 425  :         // put using codecvt facet
; 426  :         constexpr size_t _Codecvt_temp_buf = 32;
; 427  :         char _Str[_Codecvt_temp_buf];
; 428  :         const _Elem _Ch = _Traits::to_char_type(_Meta);
; 429  :         const _Elem* _Src;
; 430  :         char* _Dest;
; 431  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf,

  00095	8d 45 d4	 lea	 eax, DWORD PTR __Dest$[ebp]
  00098	88 5d db	 mov	 BYTE PTR __Ch$[ebp], bl
  0009b	50		 push	 eax
  0009c	8d 45 fc	 lea	 eax, DWORD PTR __Str$[ebp+32]
  0009f	50		 push	 eax
  000a0	8d 45 dc	 lea	 eax, DWORD PTR __Str$[ebp]
  000a3	50		 push	 eax
  000a4	8d 45 d0	 lea	 eax, DWORD PTR __Src$[ebp]
  000a7	50		 push	 eax
  000a8	8d 45 dc	 lea	 eax, DWORD PTR __Ch$[ebp+1]
  000ab	50		 push	 eax
  000ac	8d 45 db	 lea	 eax, DWORD PTR __Ch$[ebp]
  000af	50		 push	 eax
  000b0	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  000b3	50		 push	 eax
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
  000ba	85 c0		 test	 eax, eax
  000bc	78 77		 js	 SHORT $LN12@overflow
  000be	83 f8 01	 cmp	 eax, 1
  000c1	7e 33		 jle	 SHORT $LN8@overflow
  000c3	83 f8 03	 cmp	 eax, 3
  000c6	75 6d		 jne	 SHORT $LN12@overflow

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

  000c8	0f be 45 db	 movsx	 eax, BYTE PTR __Ch$[ebp]
$LN45@overflow:
  000cc	ff 76 4c	 push	 DWORD PTR [esi+76]
  000cf	50		 push	 eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputc
  000d6	83 c4 08	 add	 esp, 8

; 443  :             }
; 444  : 
; 445  :             return _Traits::eof(); // conversion failed
; 446  :         }
; 447  : 
; 448  :         case codecvt_base::noconv:
; 449  :             // no conversion, put as is
; 450  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

  000d9	83 c9 ff	 or	 ecx, -1

; 107  :     return _CSTD fputc(_Byte, _File) != EOF;

  000dc	3b c1		 cmp	 eax, ecx

; 443  :             }
; 444  : 
; 445  :             return _Traits::eof(); // conversion failed
; 446  :         }
; 447  : 
; 448  :         case codecvt_base::noconv:
; 449  :             // no conversion, put as is
; 450  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

  000de	0f 45 cb	 cmovne	 ecx, ebx
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	8b c1		 mov	 eax, ecx

; 451  : 
; 452  :         default:
; 453  :             return _Traits::eof(); // conversion failed
; 454  :         }
; 455  :     }

  000e5	5b		 pop	 ebx
  000e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e9	33 cd		 xor	 ecx, ebp
  000eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c2 04 00	 ret	 4
$LN8@overflow:

; 432  :             _Dest)) { // test result of converting one element
; 433  :         case codecvt_base::partial:
; 434  :         case codecvt_base::ok: { // converted something, try to put it out
; 435  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

  000f6	8b 7d d4	 mov	 edi, DWORD PTR __Dest$[ebp]
  000f9	8d 45 dc	 lea	 eax, DWORD PTR __Str$[ebp]
  000fc	2b f8		 sub	 edi, eax

; 436  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  000fe	74 14		 je	 SHORT $LN9@overflow
  00100	ff 76 4c	 push	 DWORD PTR [esi+76]
  00103	57		 push	 edi
  00104	6a 01		 push	 1
  00106	50		 push	 eax
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0010d	83 c4 10	 add	 esp, 16			; 00000010H
  00110	3b f8		 cmp	 edi, eax
  00112	75 21		 jne	 SHORT $LN12@overflow
$LN9@overflow:

; 437  :                 return _Traits::eof(); // write failed
; 438  :             }
; 439  : 
; 440  :             _Wrotesome = true; // write succeeded
; 441  :             if (_Src != &_Ch) {

  00114	8d 45 db	 lea	 eax, DWORD PTR __Ch$[ebp]
  00117	c6 46 3d 01	 mov	 BYTE PTR [esi+61], 1
  0011b	39 45 d0	 cmp	 DWORD PTR __Src$[ebp], eax
  0011e	74 15		 je	 SHORT $LN12@overflow

; 442  :                 return _Meta; // converted whole element

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	8b c3		 mov	 eax, ebx

; 451  : 
; 452  :         default:
; 453  :             return _Traits::eof(); // conversion failed
; 454  :         }
; 455  :     }

  00124	5b		 pop	 ebx
  00125	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00128	33 cd		 xor	 ecx, ebp
  0012a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 04 00	 ret	 4
$LN12@overflow:
  00135	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00138	83 c8 ff	 or	 eax, -1
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	33 cd		 xor	 ecx, ebp
  0013f	5b		 pop	 ebx
  00140	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 04 00	 ret	 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?to_char_type@?$_Narrow_char_traits@DH@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$_Narrow_char_traits@DH@std@@SADABH@Z PROC ; std::_Narrow_char_traits<char,int>::to_char_type, COMDAT

; 388  :     _NODISCARD static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 389  :         return static_cast<_Elem>(_Meta);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]

; 390  :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?to_char_type@?$_Narrow_char_traits@DH@std@@SADABH@Z ENDP ; std::_Narrow_char_traits<char,int>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 400  :         if (_Myfile) {

  00000	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00003	85 c0		 test	 eax, eax
  00005	74 08		 je	 SHORT $LN2@Unlock

; 401  :             _CSTD _unlock_file(_Myfile);

  00007	50		 push	 eax
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___unlock_file
  0000e	59		 pop	 ecx
$LN2@Unlock:

; 402  :         }
; 403  :     }

  0000f	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 394  :         if (_Myfile) {

  00000	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00003	85 c0		 test	 eax, eax
  00005	74 08		 je	 SHORT $LN2@Lock

; 395  :             _CSTD _lock_file(_Myfile);

  00007	50		 push	 eax
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___lock_file
  0000e	59		 pop	 ecx
$LN2@Lock:

; 396  :         }
; 397  :     }

  0000f	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 170  :     virtual __CLR_OR_THIS_CALL ~basic_filebuf() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 171  :         if (_Myfile) {

  00026	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00030	74 1e		 je	 SHORT $LN6@basic_file
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00032	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

  00035	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  00038	39 07		 cmp	 DWORD PTR [edi], eax
  0003a	75 14		 jne	 SHORT $LN6@basic_file

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0003c	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  0003f	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00042	2b d1		 sub	 edx, ecx
  00044	89 0f		 mov	 DWORD PTR [edi], ecx
  00046	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
  0004b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0004e	89 10		 mov	 DWORD PTR [eax], edx
$LN6@basic_file:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 175  :         if (_Closef) {

  00050	80 7e 48 00	 cmp	 BYTE PTR [esi+72], 0
  00054	74 07		 je	 SHORT $LN3@basic_file

; 176  :             close();

  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN3@basic_file:

; 177  :         }
; 178  :     }

  0005d	8b ce		 mov	 ecx, esi
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
  00076	cc		 int	 3
  00077	cc		 int	 3
  00078	cc		 int	 3
  00079	cc		 int	 3
  0007a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1141 :     virtual __CLR_OR_THIS_CALL ~basic_ofstream() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00035	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  00038	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003b	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  0003e	89 44 3a 94	 mov	 DWORD PTR [edx+edi-108], eax

; 170  :     virtual __CLR_OR_THIS_CALL ~basic_filebuf() noexcept {

  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 171  :         if (_Myfile) {

  00049	83 7f e8 00	 cmp	 DWORD PTR [edi-24], 0
  0004d	c7 47 9c 00 00
	00 00		 mov	 DWORD PTR [edi-100], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00054	74 1e		 je	 SHORT $LN9@basic_ofst
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00056	8b 5f a8	 mov	 ebx, DWORD PTR [edi-88]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

  00059	8d 47 d8	 lea	 eax, DWORD PTR [edi-40]
  0005c	39 03		 cmp	 DWORD PTR [ebx], eax
  0005e	75 14		 jne	 SHORT $LN9@basic_ofst

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00060	8b 57 f0	 mov	 edx, DWORD PTR [edi-16]
  00063	8b 4f ec	 mov	 ecx, DWORD PTR [edi-20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00066	2b d1		 sub	 edx, ecx
  00068	89 0b		 mov	 DWORD PTR [ebx], ecx
  0006a	8b 47 b8	 mov	 eax, DWORD PTR [edi-72]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx
  0006f	8b 47 c8	 mov	 eax, DWORD PTR [edi-56]
  00072	89 10		 mov	 DWORD PTR [eax], edx
$LN9@basic_ofst:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 175  :         if (_Closef) {

  00074	80 7f e4 00	 cmp	 BYTE PTR [edi-28], 0
  00078	74 08		 je	 SHORT $LN5@basic_ofst

; 176  :             close();

  0007a	8d 4f 9c	 lea	 ecx, DWORD PTR [edi-100]
  0007d	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN5@basic_ofst:

; 177  :         }
; 178  :     }

  00082	8d 4f 9c	 lea	 ecx, DWORD PTR [edi-100]
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ

; 1141 :     virtual __CLR_OR_THIS_CALL ~basic_ofstream() noexcept {}

  0008b	8d 4f a0	 lea	 ecx, DWORD PTR [edi-96]
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00094	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00097	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009e	59		 pop	 ecx
  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
  000a6	cc		 int	 3
  000a7	cc		 int	 3
  000a8	cc		 int	 3
  000a9	cc		 int	 3
  000aa	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Mode$dead$ = 12					; size = 4
__Prot$dead$ = 16					; size = 4
_$initVBases$dead$ = 20					; size = 4
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$dead$ = ecx

; 1012 :     explicit basic_ofstream(

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2149 :         const value_type* _Result = _Bx._Buf;

  00004	8b 45 08	 mov	 eax, DWORD PTR __Str$[ebp]

; 2158 :         return _BUF_SIZE <= _Myres;

  00007	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2150 :         if (_Large_string_engaged()) {

  0000b	72 02		 jb	 SHORT $LN7@basic_ofst

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@basic_ofst:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 1014 :         : basic_ofstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

  0000f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A
  0001d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00020	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A[eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00035	89 81 fc ff ff
	ff		 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A[ecx-4], eax
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2150 :         if (_Large_string_engaged()) {

  00004	72 03		 jb	 SHORT $LN8@c_str

; 3676 :         return _Mypair._Myval2._Myptr();

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3677 :     }

  00008	c3		 ret	 0
$LN8@c_str:

; 3676 :         return _Mypair._Myval2._Myptr();

  00009	8b c1		 mov	 eax, ecx

; 3677 :     }

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2887 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 322  :             return __builtin_strlen(_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]

; 2887 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 322  :             return __builtin_strlen(_First);

  00009	8b fa		 mov	 edi, edx

; 2887 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  0000b	8b d9		 mov	 ebx, ecx

; 322  :             return __builtin_strlen(_First);

  0000d	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL15@append:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL15@append

; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00017	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 322  :             return __builtin_strlen(_First);

  0001a	2b f9		 sub	 edi, ecx

; 2867 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0001c	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  0001f	8b c6		 mov	 eax, esi
  00021	2b c1		 sub	 eax, ecx
  00023	3b f8		 cmp	 edi, eax
  00025	77 2a		 ja	 SHORT $LN6@append

; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 2140 :         value_type* _Result = _Bx._Buf;

  0002d	8b c3		 mov	 eax, ebx

; 2158 :         return _BUF_SIZE <= _Myres;

  0002f	83 fe 10	 cmp	 esi, 16			; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  00032	72 02		 jb	 SHORT $LN9@append

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  00034	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN9@append:

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00036	57		 push	 edi

; 2871 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0003a	52		 push	 edx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2872 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00044	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 2888 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00048	8b c3		 mov	 eax, ebx
  0004a	5f		 pop	 edi

; 2889 :     }

  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN6@append:

; 2876 :         return _Reallocate_grow_by(

  00051	57		 push	 edi
  00052	52		 push	 edx
  00053	ff 75 08	 push	 DWORD PTR $T5[ebp]
  00056	8b cb		 mov	 ecx, ebx
  00058	57		 push	 edi
  00059	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
  0005e	5f		 pop	 edi

; 2889 :     }

  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2728 :     ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN22@basic_stri

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN19@basic_stri

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN22@basic_stri:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4317 :         _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4318 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4319 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4320 :         // write can alias this
; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 2736 :     }

  00044	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
  0004b	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2423 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00006	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0000d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00014	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00017	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0001a	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001f	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00024	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0002b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00032	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2424 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2425 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2426 :     }

  00035	8b c1		 mov	 eax, ecx
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2340 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 322  :             return __builtin_strlen(_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx

; 2340 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {

  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi

; 322  :             return __builtin_strlen(_First);

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 4301 :         _Mypair._Myval2._Mysize = 0;

  0000f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00016	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0001d	c6 06 00	 mov	 BYTE PTR [esi], 0
$LL13@basic_stri:

; 322  :             return __builtin_strlen(_First);

  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL13@basic_stri
  00027	2b c7		 sub	 eax, edi

; 2992 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00029	8b ce		 mov	 ecx, esi
  0002b	50		 push	 eax
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2341 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2342 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2343 :         _Tidy_init();
; 2344 :         assign(_Ptr);
; 2345 :         _Proxy._Release();
; 2346 :     }

  00032	5f		 pop	 edi
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 2293 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2294 :         _Tidy_init();
; 2295 :     }

  00007	8b c1		 mov	 eax, ecx

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00009	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 2293 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2294 :         _Tidy_init();
; 2295 :     }

  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 170  :     virtual __CLR_OR_THIS_CALL ~basic_filebuf() noexcept {

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 171  :         if (_Myfile) {

  0002d	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00031	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00037	74 1e		 je	 SHORT $LN10@scalar
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00039	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

  0003c	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  0003f	39 07		 cmp	 DWORD PTR [edi], eax
  00041	75 14		 jne	 SHORT $LN10@scalar

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00043	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  00046	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00049	2b d1		 sub	 edx, ecx
  0004b	89 0f		 mov	 DWORD PTR [edi], ecx
  0004d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00050	89 08		 mov	 DWORD PTR [eax], ecx
  00052	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00055	89 10		 mov	 DWORD PTR [eax], edx
$LN10@scalar:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 175  :         if (_Closef) {

  00057	80 7e 48 00	 cmp	 BYTE PTR [esi+72], 0
  0005b	74 07		 je	 SHORT $LN6@scalar

; 176  :             close();

  0005d	8b ce		 mov	 ecx, esi
  0005f	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN6@scalar:

; 177  :         }
; 178  :     }

  00064	8b ce		 mov	 ecx, esi
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0006c	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00070	74 0b		 je	 SHORT $LN16@scalar
  00072	6a 58		 push	 88			; 00000058H
  00074	56		 push	 esi
  00075	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0007a	83 c4 08	 add	 esp, 8
$LN16@scalar:
  0007d	8b c6		 mov	 eax, esi
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00082	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00089	59		 pop	 ecx
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
  00092	cc		 int	 3
  00093	cc		 int	 3
  00094	cc		 int	 3
  00095	cc		 int	 3
  00096	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 98	 lea	 esi, DWORD PTR [ecx-104]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	74 0e		 je	 SHORT $LN4@scalar
  00014	68 b0 00 00 00	 push	 176			; 000000b0H
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001f	83 c4 08	 add	 esp, 8
$LN4@scalar:
  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	c2 00 00	 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	c2 00 00	 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT
; _this$ = ecx

; 783  :     void _Set_back() { // set up putback area

  00000	8b d1		 mov	 edx, ecx
  00002	56		 push	 esi
  00003	57		 push	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00004	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 784  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

  00007	8d 72 3c	 lea	 esi, DWORD PTR [edx+60]
  0000a	8b 07		 mov	 eax, DWORD PTR [edi]
  0000c	3b c6		 cmp	 eax, esi
  0000e	74 10		 je	 SHORT $LN13@Set_back
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

  00010	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 785  :             _Set_eback = _Mysb::eback();

  00013	89 42 50	 mov	 DWORD PTR [edx+80], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

  00016	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	03 01		 add	 eax, DWORD PTR [ecx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 786  :             _Set_egptr = _Mysb::egptr();

  0001d	89 42 54	 mov	 DWORD PTR [edx+84], eax
$LN13@Set_back:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 208  :         *_IGfirst = _First;

  00020	89 37		 mov	 DWORD PTR [edi], esi

; 209  :         *_IGnext  = _Next;

  00022	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00025	5f		 pop	 edi
  00026	89 30		 mov	 DWORD PTR [eax], esi
  00028	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0002b	5e		 pop	 esi
  0002c	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 789  :     }

  00032	c3		 ret	 0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; _this$ = ecx

; 777  :     void _Reset_back() { // restore buffer after putback

  00000	57		 push	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00001	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 778  :         if (_Mysb::eback() == &_Mychar) {

  00004	8d 41 3c	 lea	 eax, DWORD PTR [ecx+60]
  00007	39 07		 cmp	 DWORD PTR [edi], eax
  00009	75 16		 jne	 SHORT $LN2@Reset_back

; 779  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0000b	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0000e	56		 push	 esi
  0000f	8b 71 54	 mov	 esi, DWORD PTR [ecx+84]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 208  :         *_IGfirst = _First;

  00012	89 17		 mov	 DWORD PTR [edi], edx

; 209  :         *_IGnext  = _Next;
; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00014	2b f2		 sub	 esi, edx
  00016	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00019	89 10		 mov	 DWORD PTR [eax], edx
  0001b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi
$LN2@Reset_back:
  00021	5f		 pop	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 781  :     }

  00022	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
__Newcvt$ = 8						; size = 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT
; _this$ = ecx

; 760  :     void _Initcvt(const _Cvt& _Newcvt) { // initialize codecvt pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 761  :         if (_Newcvt.always_noconv()) {

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Newcvt$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b cf		 mov	 ecx, edi
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
  00012	84 c0		 test	 al, al
  00014	74 0d		 je	 SHORT $LN2@Initcvt

; 762  :             _Pcvt = nullptr; // nothing to do

  00016	5f		 pop	 edi
  00017	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 766  :         }
; 767  :     }

  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN2@Initcvt:

; 763  :         } else { // set up for nontrivial codecvt facet
; 764  :             _Pcvt = _STD addressof(_Newcvt);
; 765  :             _Mysb::_Init(); // reset any buffering

  00023	8b ce		 mov	 ecx, esi
  00025	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
  0002e	5f		 pop	 edi

; 766  :         }
; 767  :     }

  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
__Dest$ = -40						; size = 4
__Str$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT
; _this$ = ecx

; 724  :     bool _Endwrite() { // put shift to initial conversion state, as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx

; 725  :         if (!_Pcvt || !_Wrotesome) {

  00013	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00017	0f 84 9f 00 00
	00		 je	 $LN5@Endwrite
  0001d	80 7e 3d 00	 cmp	 BYTE PTR [esi+61], 0
  00021	0f 84 95 00 00
	00		 je	 $LN5@Endwrite

; 730  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	57		 push	 edi
  0002a	6a ff		 push	 -1
  0002c	ff 50 0c	 call	 DWORD PTR [eax+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 397  :         return _Left == _Right;

  0002f	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 730  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

  00032	74 76		 je	 SHORT $LN15@Endwrite

; 731  :             return false;
; 732  :         }
; 733  : 
; 734  :         constexpr size_t _Codecvt_temp_buf = 32;
; 735  :         char _Str[_Codecvt_temp_buf];
; 736  :         char* _Dest;
; 737  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

  00034	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00037	8d 45 d8	 lea	 eax, DWORD PTR __Dest$[ebp]
  0003a	50		 push	 eax
  0003b	8d 45 fc	 lea	 eax, DWORD PTR __Str$[ebp+32]
  0003e	50		 push	 eax
  0003f	8d 45 dc	 lea	 eax, DWORD PTR __Str$[ebp]
  00042	50		 push	 eax
  00043	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z
  0004d	83 e8 00	 sub	 eax, 0
  00050	74 1f		 je	 SHORT $LN7@Endwrite
  00052	83 e8 01	 sub	 eax, 1
  00055	74 1e		 je	 SHORT $LN8@Endwrite
  00057	83 e8 02	 sub	 eax, 2
  0005a	75 4e		 jne	 SHORT $LN15@Endwrite

; 749  :         }
; 750  : 
; 751  :         case codecvt_base::noconv:
; 752  :             _Wrotesome = false; // homed successfully

  0005c	88 46 3d	 mov	 BYTE PTR [esi+61], al

; 753  :             return true; // nothing else to do

  0005f	b0 01		 mov	 al, 1
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 754  : 
; 755  :         default:
; 756  :             return false; // conversion failed
; 757  :         }
; 758  :     }

  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN7@Endwrite:

; 738  :         case codecvt_base::ok:
; 739  :             _Wrotesome = false; // homed successfully

  00071	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0
$LN8@Endwrite:

; 740  : 
; 741  :         case codecvt_base::partial: // fall through
; 742  :         { // put any generated bytes
; 743  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

  00075	8b 7d d8	 mov	 edi, DWORD PTR __Dest$[ebp]
  00078	8d 45 dc	 lea	 eax, DWORD PTR __Str$[ebp]
  0007b	2b f8		 sub	 edi, eax

; 744  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  0007d	74 14		 je	 SHORT $LN9@Endwrite
  0007f	ff 76 4c	 push	 DWORD PTR [esi+76]
  00082	57		 push	 edi
  00083	6a 01		 push	 1
  00085	50		 push	 eax
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0008c	83 c4 10	 add	 esp, 16			; 00000010H
  0008f	3b f8		 cmp	 edi, eax
  00091	75 17		 jne	 SHORT $LN15@Endwrite
$LN9@Endwrite:

; 746  :             }
; 747  : 
; 748  :             return !_Wrotesome;

  00093	80 7e 3d 00	 cmp	 BYTE PTR [esi+61], 0
  00097	5f		 pop	 edi
  00098	0f 94 c0	 sete	 al
  0009b	5e		 pop	 esi

; 754  : 
; 755  :         default:
; 756  :             return false; // conversion failed
; 757  :         }
; 758  :     }

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	33 cd		 xor	 ecx, ebp
  000a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN15@Endwrite:
  000aa	5f		 pop	 edi

; 745  :                 return false; // write failed

  000ab	32 c0		 xor	 al, al
  000ad	5e		 pop	 esi

; 754  : 
; 755  :         default:
; 756  :             return false; // conversion failed
; 757  :         }
; 758  :     }

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b1	33 cd		 xor	 ecx, ebp
  000b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
$LN5@Endwrite:
  000bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bf	b0 01		 mov	 al, 1
  000c1	33 cd		 xor	 ecx, ebp
  000c3	5e		 pop	 esi
  000c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__Nr$1 = -16						; size = 4
__Pn$2 = -12						; size = 4
__Pb$3 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__File$ = 8						; size = 4
__Which$ = 12						; size = 4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 697  :     void _Init(FILE* _File, _Initfl _Which) { // initialize to C stream _File after {new, open, close}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 698  :         using _State_type = typename _Traits::state_type;
; 699  : 
; 700  :         __PURE_APPDOMAIN_GLOBAL static _State_type _Stinit; // initial state
; 701  : 
; 702  :         _Closef    = _Which == _Openfl;

  00010	83 7d 0c 01	 cmp	 DWORD PTR __Which$[ebp], 1
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
  00017	0f 94 c0	 sete	 al
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR __File$[ebp]
  0001e	88 46 48	 mov	 BYTE PTR [esi+72], al

; 703  :         _Wrotesome = false;

  00021	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

  0002b	85 ff		 test	 edi, edi
  0002d	74 46		 je	 SHORT $LN2@Init

; 712  :             ::_get_stream_buffer_pointers(

  0002f	8d 45 f0	 lea	 eax, DWORD PTR __Nr$1[ebp]
  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Pb$3[ebp], 0
  00039	50		 push	 eax
  0003a	8d 45 f4	 lea	 eax, DWORD PTR __Pn$2[ebp]
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Pn$2[ebp], 0
  00044	50		 push	 eax
  00045	8d 45 f8	 lea	 eax, DWORD PTR __Pb$3[ebp]
  00048	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Nr$1[ebp], 0
  0004f	50		 push	 eax
  00050	57		 push	 edi
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___get_stream_buffer_pointers
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 276  :         _IGfirst = _Gf;

  00057	8b 45 f8	 mov	 eax, DWORD PTR __Pb$3[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 712  :             ::_get_stream_buffer_pointers(

  0005a	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 276  :         _IGfirst = _Gf;

  0005d	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 277  :         _IPfirst = _Pf;

  00060	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 278  :         _IGnext  = _Gn;

  00063	8b 45 f4	 mov	 eax, DWORD PTR __Pn$2[ebp]
  00066	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 279  :         _IPnext  = _Pn;

  00069	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 280  :         _IGcount = _Gc;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR __Nr$1[ebp]
  0006f	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 281  :         _IPcount = _Pc;

  00072	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN2@Init:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 720  :         _State  = _Stinit;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet
; 722  :     }

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007d	89 7e 4c	 mov	 DWORD PTR [esi+76], edi
  00080	33 cd		 xor	 ecx, ebp
  00082	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00085	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  0008a	5f		 pop	 edi
  0008b	89 46 44	 mov	 DWORD PTR [esi+68], eax
  0008e	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00095	5e		 pop	 esi
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 374  :     basic_filebuf* close() {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 375  :         basic_filebuf* _Ans;
; 376  :         if (_Myfile) { // put any homing sequence and close file

  00004	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00008	74 1e		 je	 SHORT $LN2@close

; 377  :             _Ans = this;
; 378  :             if (!_Endwrite()) {

  0000a	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 379  :                 _Ans = nullptr;
; 380  :             }
; 381  : 
; 382  :             if (_CSTD fclose(_Myfile) != 0) {

  0000f	ff 76 4c	 push	 DWORD PTR [esi+76]
  00012	33 c9		 xor	 ecx, ecx
  00014	8b fe		 mov	 edi, esi
  00016	84 c0		 test	 al, al
  00018	0f 44 f9	 cmove	 edi, ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	74 02		 je	 SHORT $LN3@close
$LN2@close:

; 702  :         _Closef    = _Which == _Openfl;

  00028	33 ff		 xor	 edi, edi
$LN3@close:

; 703  :         _Wrotesome = false;
; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

  0002a	8b ce		 mov	 ecx, esi
  0002c	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0
  00030	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 720  :         _State  = _Stinit;

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 383  :                 _Ans = nullptr;
; 384  :             }
; 385  :         } else {
; 386  :             _Ans = nullptr;
; 387  :         }
; 388  : 
; 389  :         _Init(nullptr, _Closefl);
; 390  :         return _Ans;

  00040	8b c7		 mov	 eax, edi

; 720  :         _State  = _Stinit;

  00042	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00045	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4

; 383  :                 _Ans = nullptr;
; 384  :             }
; 385  :         } else {
; 386  :             _Ans = nullptr;
; 387  :         }
; 388  : 
; 389  :         _Init(nullptr, _Closefl);
; 390  :         return _Ans;

  0004b	5f		 pop	 edi

; 719  :         _Myfile = _File;

  0004c	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0

; 720  :         _State  = _Stinit;

  00053	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

  00056	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 383  :                 _Ans = nullptr;
; 384  :             }
; 385  :         } else {
; 386  :             _Ans = nullptr;
; 387  :         }
; 388  : 
; 389  :         _Init(nullptr, _Closefl);
; 390  :         return _Ans;

  0005d	5e		 pop	 esi

; 391  :     }

  0005e	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xlocale
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
_TEXT	SEGMENT
$T4 = -44						; size = 8
_this$GSCopy$ = -36					; size = 4
$T1 = -32						; size = 4
_this$ = -32						; size = 4
__Pn$7 = -28						; size = 4
__Pb$8 = -24						; size = 4
__Nr$9 = -20						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$dead$ = 12					; size = 4
__Prot$dead$ = 16					; size = 4
_$initVBases$dead$ = 20					; size = 4
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$dead$ = ecx

; 1004 :     explicit basic_ofstream(const char* _Filename, ios_base::openmode _Mode = ios_base::out,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]

; 1005 :         int _Prot = ios_base::_Default_open_prot)
; 1006 :         : _Mybase(_STD addressof(_Filebuffer)) { // _Prot is an extension

  0002c	b9 68 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+104
  00031	8b 75 08	 mov	 esi, DWORD PTR __Filename$[ebp]
  00034	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0003b	89 45 dc	 mov	 DWORD PTR _this$GSCopy$[ebp], eax
  0003e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _this$GSCopy$[ebp], OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  00045	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A, OFFSET ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00055	6a 00		 push	 0
  00057	6a 00		 push	 0
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  00065	68 04 00 00 00	 push	 OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+4
  0006a	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00077	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A
  00083	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _this$[ebp], OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+4
  0008a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008d	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A[eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A
  0009c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009f	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  000a2	89 81 fc ff ff
	ff		 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A[ecx-4], eax

; 162  :     basic_filebuf() : _Mysb() {

  000a8	b9 04 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+4
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  000b3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

  000b7	b9 04 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+4

; 162  :     basic_filebuf() : _Mysb() {

  000bc	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+4, OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 702  :         _Closef    = _Which == _Openfl;

  000c6	c6 05 4c 00 00
	00 00		 mov	 BYTE PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+76, 0

; 703  :         _Wrotesome = false;

  000cd	c6 05 41 00 00
	00 00		 mov	 BYTE PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+65, 0

; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 720  :         _State  = _Stinit;

  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  000df	a3 44 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+68, eax
  000e4	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000e9	c7 05 50 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+80, 0
  000f3	a3 48 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+72, eax

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

  000f8	c7 05 3c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+60, 0

; 281  :         const auto _File = _Fiopen(_Filename, _Mode, _Prot);

  00102	6a 40		 push	 64			; 00000040H
  00104	6a 02		 push	 2
  00106	56		 push	 esi

; 1005 :         int _Prot = ios_base::_Default_open_prot)
; 1006 :         : _Mybase(_STD addressof(_Filebuffer)) { // _Prot is an extension

  00107	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 281  :         const auto _File = _Fiopen(_Filename, _Mode, _Prot);

  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z
  00111	8b f0		 mov	 esi, eax
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH

; 282  :         if (!_File) {

  00116	85 f6		 test	 esi, esi
  00118	0f 84 ee 00 00
	00		 je	 $LN54@basic_ofst

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

  0011e	b9 04 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+4
  00123	c6 05 4c 00 00
	00 01		 mov	 BYTE PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+76, 1
  0012a	c6 05 41 00 00
	00 00		 mov	 BYTE PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+65, 0
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 712  :             ::_get_stream_buffer_pointers(

  00137	8d 45 ec	 lea	 eax, DWORD PTR __Nr$9[ebp]
  0013a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Pb$8[ebp], 0
  00141	50		 push	 eax
  00142	8d 45 e4	 lea	 eax, DWORD PTR __Pn$7[ebp]
  00145	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Pn$7[ebp], 0
  0014c	50		 push	 eax
  0014d	8d 45 e8	 lea	 eax, DWORD PTR __Pb$8[ebp]
  00150	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Nr$9[ebp], 0
  00157	50		 push	 eax
  00158	56		 push	 esi
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___get_stream_buffer_pointers
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 276  :         _IGfirst = _Gf;

  0015f	8b 45 e8	 mov	 eax, DWORD PTR __Pb$8[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 712  :             ::_get_stream_buffer_pointers(

  00162	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 276  :         _IGfirst = _Gf;

  00165	a3 10 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+16, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

  0016a	b9 04 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 277  :         _IPfirst = _Pf;

  0016f	a3 14 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+20, eax

; 278  :         _IGnext  = _Gn;

  00174	8b 45 e4	 mov	 eax, DWORD PTR __Pn$7[ebp]
  00177	a3 20 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+32, eax

; 279  :         _IPnext  = _Pn;

  0017c	a3 24 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+36, eax

; 280  :         _IGcount = _Gc;

  00181	8b 45 ec	 mov	 eax, DWORD PTR __Nr$9[ebp]
  00184	a3 30 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+48, eax

; 281  :         _IPcount = _Pc;

  00189	a3 34 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+52, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 720  :         _State  = _Stinit;

  0018e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  00193	a3 44 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+68, eax
  00198	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  0019d	a3 48 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+72, eax

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

  001a2	8d 45 d4	 lea	 eax, DWORD PTR $T4[ebp]
  001a5	50		 push	 eax

; 719  :         _Myfile = _File;

  001a6	89 35 50 00 00
	00		 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+80, esi

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

  001ac	c7 05 3c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+60, 0

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
  001bc	8b c8		 mov	 ecx, eax
  001be	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  001c2	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  001c7	8b f0		 mov	 esi, eax

; 761  :         if (_Newcvt.always_noconv()) {

  001c9	8b ce		 mov	 ecx, esi
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
  001d1	84 c0		 test	 al, al
  001d3	74 0c		 je	 SHORT $LN40@basic_ofst

; 762  :             _Pcvt = nullptr; // nothing to do

  001d5	c7 05 3c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+60, 0

; 763  :         } else { // set up for nontrivial codecvt facet

  001df	eb 11		 jmp	 SHORT $LN41@basic_ofst
$LN40@basic_ofst:

; 764  :             _Pcvt = _STD addressof(_Newcvt);
; 765  :             _Mysb::_Init(); // reset any buffering

  001e1	b9 04 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+4
  001e6	89 35 3c 00 00
	00		 mov	 DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A+60, esi
  001ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
$LN41@basic_ofst:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xlocale

; 352  :         if (_Ptr) {

  001f2	8b 4d d8	 mov	 ecx, DWORD PTR $T4[ebp+4]
  001f5	85 c9		 test	 ecx, ecx
  001f7	74 2b		 je	 SHORT $LN58@basic_ofst

; 353  :             delete _Ptr->_Decref();

  001f9	8b 01		 mov	 eax, DWORD PTR [ecx]
  001fb	ff 50 08	 call	 DWORD PTR [eax+8]
  001fe	85 c0		 test	 eax, eax
  00200	74 22		 je	 SHORT $LN58@basic_ofst
  00202	8b 10		 mov	 edx, DWORD PTR [eax]
  00204	8b c8		 mov	 ecx, eax
  00206	6a 01		 push	 1
  00208	ff 12		 call	 DWORD PTR [edx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 1007 :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot)) {

  0020a	eb 18		 jmp	 SHORT $LN58@basic_ofst
$LN54@basic_ofst:

; 1008 :             _Myios::setstate(ios_base::failbit);

  0020c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A
  00211	6a 00		 push	 0
  00213	6a 02		 push	 2
  00215	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00218	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  0021e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN58@basic_ofst:

; 1009 :         }
; 1010 :     }

  00224	b8 00 00 00 00	 mov	 eax, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  00229	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0022c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00233	59		 pop	 ecx
  00234	5e		 pop	 esi
  00235	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00238	33 cd		 xor	 ecx, ebp
  0023a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023f	8b e5		 mov	 esp, ebp
  00241	5d		 pop	 ebp
  00242	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0:
  00000	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 10 00 00
	00		 je	 $LN6@basic_ofst
  0000c	83 65 e0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d dc	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN6@basic_ofst:
  0001c	c3		 ret	 0
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1:
  0001d	8b 4d dc	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00020	83 c1 08	 add	 ecx, 8
  00023	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$3:
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2:
  00032	8b 4d dc	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00035	83 c1 04	 add	 ecx, 4
  00038	e9 00 00 00 00	 jmp	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$4:
  0003d	8d 4d d4	 lea	 ecx, DWORD PTR $T4[ebp]
  00040	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z:
  0004a	90		 npad	 1
  0004b	90		 npad	 1
  0004c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00050	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00053	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00056	33 c8		 xor	 ecx, eax
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00060	33 c8		 xor	 ecx, eax
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
  0006c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT
; _this$ = ecx

; 68   :         // TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old
; 69   :         // basic_filebuf would set _Fpos.
; 70   :         return _Myoff + _Fpos;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	03 01		 add	 eax, DWORD PTR [ecx]
  00005	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00008	13 51 04	 adc	 edx, DWORD PTR [ecx+4]

; 71   :     }

  0000b	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT
; _this$ = ecx

; 59   :     _NODISCARD _Statetype state() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   :         return _Mystate;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00009	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 61   :     }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
__State$ = 8						; size = 8
__Fileposition$ = 16					; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __Fileposition$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 14	 mov	 eax, DWORD PTR __Fileposition$[ebp+4]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000e	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00011	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00014	8b 45 0c	 mov	 eax, DWORD PTR __State$[ebp+4]
  00017	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0001a	8b c1		 mov	 eax, ecx
  0001c	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00023	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	89 01		 mov	 DWORD PTR [ecx], eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp+4]
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00011	8b c1		 mov	 eax, ecx
  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00021	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4339 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 4340 :     }

  00002	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4335 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 4336 :     }

  00002	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4308 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4309 :         _Mypair._Myval2._Orphan_all();
; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN10@Tidy_deall
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN20@Tidy_deall

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN17@Tidy_deall

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN20@Tidy_deall:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN10@Tidy_deall:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4317 :         _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4318 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4319 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4320 :         // write can alias this
; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 4322 :     }

  00044	c3		 ret	 0
$LN17@Tidy_deall:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Tidy_deall:
  0004b	cc		 int	 3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00007	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0000e	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 4306 :     }

  00011	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3694 :         return _Mypair._Myval2._Mysize;

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 3695 :     }

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  00004	72 03		 jb	 SHORT $LN8@data

; 3685 :         return _Mypair._Myval2._Myptr();

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3686 :     }

  00008	c3		 ret	 0
$LN8@data:

; 3685 :         return _Mypair._Myval2._Myptr();

  00009	8b c1		 mov	 eax, ecx

; 3686 :     }

  0000b	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ
_TEXT	SEGMENT
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  00004	72 03		 jb	 SHORT $LN8@front

; 3644 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3645 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
; 3646 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3647 : 
; 3648 :         return _Mypair._Myval2._Myptr()[0];

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3649 :     }

  00008	c3		 ret	 0
$LN8@front:

; 3644 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3645 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
; 3646 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3647 : 
; 3648 :         return _Mypair._Myval2._Myptr()[0];

  00009	8b c1		 mov	 eax, ecx

; 3649 :     }

  0000b	c3		 ret	 0
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
$T3 = -4						; size = 1
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 3615 :     void push_back(const _Elem _Ch) { // insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3616 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]

; 3617 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00007	3b 51 14	 cmp	 edx, DWORD PTR [ecx+20]
  0000a	73 1f		 jae	 SHORT $LN2@push_back

; 2158 :         return _BUF_SIZE <= _Myres;

  0000c	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 3618 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  00010	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00013	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2141 :         if (_Large_string_engaged()) {

  00016	72 02		 jb	 SHORT $LN5@push_back

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@push_back:

; 3619 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 3620 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  0001a	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  0001d	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3621 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00020	c6 44 11 01 00	 mov	 BYTE PTR [ecx+edx+1], 0

; 3626 :             1,
; 3627 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 3628 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3629 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 3630 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 3631 :             },
; 3632 :             _Ch);
; 3633 :     }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN2@push_back:

; 3622 :             return;
; 3623 :         }
; 3624 : 
; 3625 :         _Reallocate_grow_by(

  0002b	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0002e	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>

; 3626 :             1,
; 3627 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 3628 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3629 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 3630 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 3631 :             },
; 3632 :             _Ch);
; 3633 :     }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBEXQADQBDID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBEXQADQBDID@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator(), COMDAT
; _this$dead$ = ecx

; 3631 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Old_ptr$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Old_size$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR __New_ptr$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0000e	56		 push	 esi
  0000f	50		 push	 eax
  00010	57		 push	 edi
  00011	e8 00 00 00 00	 call	 _memcpy

; 333  :     }
; 334  : 
; 335  :     _Pre_satisfies_(_Size_in_bytes >= _Count) static _Elem* _Copy_s(_Out_writes_all_(_Size_in_bytes)
; 336  :                                                                         _Elem* const _First1,
; 337  :         const size_t _Size_in_bytes, _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept {
; 338  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 339  :         _STL_VERIFY(_Count <= _Size_in_bytes, "invalid argument");
; 340  :         return copy(_First1, _First2, _Count);
; 341  :     }
; 342  : 
; 343  :     _NODISCARD static _CONSTEXPR17 const _Elem* find(_In_reads_(_Count) const _Elem* const _First, const size_t _Count,
; 344  :         const _Elem& _Ch) noexcept /* strengthened */ {
; 345  :         // look for _Ch in [_First, _First + _Count)
; 346  : #if _HAS_CXX17
; 347  : #ifdef __cpp_char8_t
; 348  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 349  : #if _HAS_U8_INTRINSICS
; 350  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 351  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 352  :             return _Char_traits<_Elem, _Int_type>::find(_First, _Count, _Ch);
; 353  : #endif // _HAS_U8_INTRINSICS
; 354  :         } else
; 355  : #endif // __cpp_char8_t
; 356  :         {
; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);
; 358  :         }
; 359  : #else // _HAS_CXX17
; 360  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));
; 361  : #endif // _HAS_CXX17
; 362  :     }
; 363  : 
; 364  :     static _Elem* move(_Out_writes_all_(_Count) _Elem* const _First1, _In_reads_(_Count) const _Elem* const _First2,
; 365  :         const size_t _Count) noexcept /* strengthened */ {
; 366  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));
; 368  :     }
; 369  : 
; 370  :     static _Elem* assign(_Out_writes_all_(_Count) _Elem* const _First, const size_t _Count,
; 371  :         const _Elem _Ch) noexcept /* strengthened */ {
; 372  :         // assign _Count * _Ch to [_First, ...)
; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));
; 374  :     }
; 375  : 
; 376  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {
; 377  :         _Left = _Right;
; 378  :     }
; 379  : 
; 380  :     _NODISCARD static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
; 381  :         return _Left == _Right;
; 382  :     }
; 383  : 
; 384  :     _NODISCARD static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
; 385  :         return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
; 386  :     }
; 387  : 
; 388  :     _NODISCARD static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
; 389  :         return static_cast<_Elem>(_Meta);
; 390  :     }
; 391  : 
; 392  :     _NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
; 393  :         return static_cast<unsigned char>(_Ch);
; 394  :     }
; 395  : 
; 396  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
; 397  :         return _Left == _Right;
; 398  :     }
; 399  : 
; 400  :     _NODISCARD static constexpr int_type not_eof(const int_type& _Meta) noexcept {
; 401  :         return _Meta != eof() ? _Meta : !eof();
; 402  :     }
; 403  : 
; 404  :     _NODISCARD static constexpr int_type eof() noexcept {
; 405  :         return static_cast<int_type>(EOF);
; 406  :     }
; 407  : };
; 408  : 
; 409  : #undef _HAS_U8_INTRINSICS
; 410  : 
; 411  : // STRUCT char_traits<char> (FROM <string>)
; 412  : template <>
; 413  : struct char_traits<char> : _Narrow_char_traits<char, int> {}; // properties of a string or stream char element
; 414  : 
; 415  : #ifdef __cpp_char8_t
; 416  : // STRUCT char_traits<char8_t>
; 417  : template <>
; 418  : struct char_traits<char8_t> : _Narrow_char_traits<char8_t, unsigned int> {};
; 419  : 
; 420  : #ifdef __cpp_lib_char8_t
; 421  : using u8streampos = streampos;
; 422  : #endif // __cpp_lib_char8_t
; 423  : #endif // __cpp_char8_t
; 424  : 
; 425  : template <class _Elem, class _Traits, class _SizeT>
; 426  : basic_ostream<_Elem, _Traits>& _Insert_string(
; 427  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {
; 428  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 429  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 430  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;
; 431  : 
; 432  :     _SizeT _Pad;
; 433  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
; 434  :         _Pad = 0;
; 435  :     } else {
; 436  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
; 437  :     }
; 438  : 
; 439  :     const typename _Ostr_t::sentry _Ok(_Ostr);
; 440  : 
; 441  :     if (!_Ok) {
; 442  :         _State |= _Ostr_t::badbit;
; 443  :     } else { // state okay, insert characters
; 444  :         _TRY_IO_BEGIN
; 445  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
; 446  :             for (; 0 < _Pad; --_Pad) { // pad on left
; 447  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 448  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 449  :                     break;
; 450  :                 }
; 451  :             }
; 452  :         }
; 453  : 
; 454  :         if (_State == _Ostr_t::goodbit
; 455  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
; 456  :             _State |= _Ostr_t::badbit;
; 457  :         } else {
; 458  :             for (; 0 < _Pad; --_Pad) { // pad on right
; 459  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 460  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 461  :                     break;
; 462  :                 }
; 463  :             }
; 464  :         }
; 465  : 
; 466  :         _Ostr.width(0);
; 467  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 468  :     }
; 469  : 
; 470  :     _Ostr.setstate(_State);
; 471  :     return _Ostr;
; 472  : }
; 473  : 
; 474  : // STRUCT TEMPLATE _Char_traits_eq
; 475  : template <class _Traits>
; 476  : struct _Char_traits_eq {
; 477  :     using _Elem = typename _Traits::char_type;
; 478  : 
; 479  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 480  :         return _Traits::eq(_Left, _Right);
; 481  :     }
; 482  : };
; 483  : 
; 484  : // STRUCT TEMPLATE _Char_traits_lt
; 485  : template <class _Traits>
; 486  : struct _Char_traits_lt {
; 487  :     using _Elem = typename _Traits::char_type;
; 488  : 
; 489  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 490  :         return _Traits::lt(_Left, _Right);
; 491  :     }
; 492  : };
; 493  : 
; 494  : template <class _Elem>
; 495  : struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
; 496  :     : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type { // builtin char_traits::eq behaves like equal_to<>
; 497  : };
; 498  : 
; 499  : template <class _Traits>
; 500  : using _Traits_ch_t = typename _Traits::char_type;
; 501  : 
; 502  : template <class _Traits>
; 503  : using _Traits_ptr_t = const typename _Traits::char_type*;
; 504  : 
; 505  : template <class _Traits>
; 506  : constexpr bool _Traits_equal(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 507  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
; 508  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
; 510  : }
; 511  : 
; 512  : template <class _Traits>
; 513  : constexpr int _Traits_compare(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 514  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
; 515  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 516  :     const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));
; 517  : 
; 518  :     if (_Ans != 0) {
; 519  :         return _Ans;
; 520  :     }
; 521  : 
; 522  :     if (_Left_size < _Right_size) {
; 523  :         return -1;
; 524  :     }
; 525  : 
; 526  :     if (_Left_size > _Right_size) {
; 527  :         return 1;
; 528  :     }
; 529  : 
; 530  :     return 0;
; 531  : }
; 532  : 
; 533  : template <class _Traits>
; 534  : constexpr size_t _Traits_find(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 535  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 536  :     const size_t _Needle_size) noexcept {
; 537  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 538  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
; 539  :         // xpos cannot exist, report failure
; 540  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 541  :         // 1. _Start_at <= xpos
; 542  :         // 2. xpos + _Needle_size <= _Hay_size;
; 543  :         // therefore:
; 544  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 545  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 546  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 547  :         return static_cast<size_t>(-1);
; 548  :     }
; 549  : 
; 550  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 551  :         return _Start_at;
; 552  :     }
; 553  : 
; 554  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
; 555  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 556  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
; 557  :         if (!_Match_try) { // didn't find first character; report failure
; 558  :             return static_cast<size_t>(-1);
; 559  :         }
; 560  : 
; 561  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match
; 562  :             return static_cast<size_t>(_Match_try - _Haystack);
; 563  :         }
; 564  :     }
; 565  : }
; 566  : 
; 567  : template <class _Traits>
; 568  : constexpr size_t _Traits_find_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 569  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 570  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch, at/after _Start_at
; 571  :     if (_Start_at < _Hay_size) {
; 572  :         const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
; 573  :         if (_Found_at) {
; 574  :             return static_cast<size_t>(_Found_at - _Haystack);
; 575  :         }
; 576  :     }
; 577  : 
; 578  :     return static_cast<size_t>(-1); // (npos) no match
; 579  : }
; 580  : 
; 581  : template <class _Traits>
; 582  : constexpr size_t _Traits_rfind(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 583  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 584  :     const size_t _Needle_size) noexcept {
; 585  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size) beginning before _Start_at
; 586  :     if (_Needle_size == 0) {
; 587  :         return _Min_value(_Start_at, _Hay_size); // empty string always matches
; 588  :     }
; 589  : 
; 590  :     if (_Needle_size <= _Hay_size) { // room for match, look for it
; 591  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
; 592  :             if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
; 593  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 594  :             }
; 595  : 
; 596  :             if (_Match_try == _Haystack) {
; 597  :                 break; // at beginning, no more chance for match
; 598  :             }
; 599  :         }
; 600  :     }
; 601  : 
; 602  :     return static_cast<size_t>(-1); // no match
; 603  : }
; 604  : 
; 605  : template <class _Traits>
; 606  : constexpr size_t _Traits_rfind_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 607  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 608  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
; 609  :     if (_Hay_size != 0) { // room for match, look for it
; 610  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 611  :             if (_Traits::eq(*_Match_try, _Ch)) {
; 612  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 613  :             }
; 614  : 
; 615  :             if (_Match_try == _Haystack) {
; 616  :                 break; // at beginning, no more chance for match
; 617  :             }
; 618  :         }
; 619  :     }
; 620  : 
; 621  :     return static_cast<size_t>(-1); // no match
; 622  : }
; 623  : 
; 624  : template <class _Elem, bool = _Is_character<_Elem>::value>
; 625  : class _String_bitmap { // _String_bitmap for character types
; 626  : public:
; 627  :     constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
; 628  :         // mark this bitmap such that the characters in [_First, _Last) are intended to match
; 629  :         // returns whether all inputs can be placed in the bitmap
; 630  :         for (; _First != _Last; ++_First) {
; 631  :             _Matches[static_cast<unsigned char>(*_First)] = true;
; 632  :         }
; 633  : 
; 634  :         return true;
; 635  :     }
; 636  : 
; 637  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 638  :         return _Matches[static_cast<unsigned char>(_Ch)];
; 639  :     }
; 640  : 
; 641  : private:
; 642  :     bool _Matches[256] = {};
; 643  : };
; 644  : 
; 645  : template <class _Elem>
; 646  : class _String_bitmap<_Elem, false> { // _String_bitmap for wchar_t/unsigned short/char16_t/char32_t/etc. types
; 647  : public:
; 648  :     static_assert(is_unsigned_v<_Elem>,
; 649  :         "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
; 650  :         "Visual C++ accepts other unsigned integral types as an extension.");
; 651  : 
; 652  :     constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
; 653  :         // mark this bitmap such that the characters in [_First, _Last) are intended to match
; 654  :         // returns whether all inputs can be placed in the bitmap
; 655  :         for (; _First != _Last; ++_First) {
; 656  :             const auto _Ch = *_First;
; 657  :             if (_Ch >= 256U) {
; 658  :                 return false;
; 659  :             }
; 660  : 
; 661  :             _Matches[static_cast<unsigned char>(_Ch)] = true;
; 662  :         }
; 663  : 
; 664  :         return true;
; 665  :     }
; 666  : 
; 667  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 668  :         return _Ch < 256U && _Matches[_Ch];
; 669  :     }
; 670  : 
; 671  : private:
; 672  :     bool _Matches[256] = {};
; 673  : };
; 674  : 
; 675  : template <class _Traits>
; 676  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 677  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 678  :     const size_t _Needle_size, false_type) noexcept {
; 679  :     // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 680  :     // general algorithm
; 681  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 682  :         const auto _End = _Haystack + _Hay_size;
; 683  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 684  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 685  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 686  :             }
; 687  :         }
; 688  :     }
; 689  : 
; 690  :     return static_cast<size_t>(-1); // no match
; 691  : }
; 692  : 
; 693  : template <class _Traits>
; 694  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 695  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 696  :     const size_t _Needle_size, true_type) noexcept {
; 697  :     // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 698  :     // special case for std::char_traits
; 699  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 700  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 701  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 702  :                                                                 // fall back to the serial algorithm
; 703  :             return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 704  :         }
; 705  : 
; 706  :         const auto _End = _Haystack + _Hay_size;
; 707  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 708  :             if (_Matches._Match(*_Match_try)) {
; 709  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 710  :             }
; 711  :         }
; 712  :     }
; 713  : 
; 714  :     return static_cast<size_t>(-1); // no match
; 715  : }
; 716  : 
; 717  : template <class _Traits>
; 718  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 719  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 720  :     const size_t _Needle_size, false_type) noexcept {
; 721  :     // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
; 722  :     // general algorithm
; 723  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 724  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 725  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 726  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 727  :             }
; 728  : 
; 729  :             if (_Match_try == _Haystack) {
; 730  :                 break; // at beginning, no more chance for match
; 731  :             }
; 732  :         }
; 733  :     }
; 734  : 
; 735  :     return static_cast<size_t>(-1); // no match
; 736  : }
; 737  : 
; 738  : template <class _Traits>
; 739  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 740  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 741  :     const size_t _Needle_size, true_type) noexcept {
; 742  :     // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
; 743  :     // special case for std::char_traits
; 744  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 745  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 746  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 747  :                                                                 // fall back to the serial algorithm
; 748  :             return _Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 749  :         }
; 750  : 
; 751  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 752  :             if (_Matches._Match(*_Match_try)) {
; 753  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 754  :             }
; 755  : 
; 756  :             if (_Match_try == _Haystack) {
; 757  :                 break; // at beginning, no more chance for match
; 758  :             }
; 759  :         }
; 760  :     }
; 761  : 
; 762  :     return static_cast<size_t>(-1); // no match
; 763  : }
; 764  : 
; 765  : template <class _Traits>
; 766  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 767  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 768  :     const size_t _Needle_size, false_type) noexcept {
; 769  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 770  :     // general algorithm
; 771  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 772  :         const auto _End = _Haystack + _Hay_size;
; 773  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 774  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 775  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 776  :             }
; 777  :         }
; 778  :     }
; 779  : 
; 780  :     return static_cast<size_t>(-1); // no match
; 781  : }
; 782  : 
; 783  : template <class _Traits>
; 784  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 785  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 786  :     const size_t _Needle_size, true_type) noexcept {
; 787  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 788  :     // special case for std::char_traits
; 789  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 790  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 791  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 792  :                                                                 // fall back to the serial algorithm
; 793  :             return _Traits_find_first_not_of<_Traits>(
; 794  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 795  :         }
; 796  : 
; 797  :         const auto _End = _Haystack + _Hay_size;
; 798  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 799  :             if (!_Matches._Match(*_Match_try)) {
; 800  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 801  :             }
; 802  :         }
; 803  :     }
; 804  : 
; 805  :     return static_cast<size_t>(-1); // no match
; 806  : }
; 807  : 
; 808  : template <class _Traits>
; 809  : constexpr size_t _Traits_find_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 810  :     const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 811  :     // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch, at/after _Start_at
; 812  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 813  :         const auto _End = _Haystack + _Hay_size;
; 814  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 815  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 816  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 817  :             }
; 818  :         }
; 819  :     }
; 820  : 
; 821  :     return static_cast<size_t>(-1); // no match
; 822  : }
; 823  : 
; 824  : template <class _Traits>
; 825  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 826  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 827  :     const size_t _Needle_size, false_type) noexcept {
; 828  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
; 829  :     // general algorithm
; 830  :     if (_Hay_size != 0) { // worth searching, do it
; 831  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 832  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 833  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 834  :             }
; 835  : 
; 836  :             if (_Match_try == _Haystack) {
; 837  :                 break; // at beginning, no more chance for match
; 838  :             }
; 839  :         }
; 840  :     }
; 841  : 
; 842  :     return static_cast<size_t>(-1); // no match
; 843  : }
; 844  : 
; 845  : template <class _Traits>
; 846  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 847  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 848  :     const size_t _Needle_size, true_type) noexcept {
; 849  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
; 850  :     // special case for std::char_traits
; 851  :     if (_Hay_size != 0) { // worth searching, do it
; 852  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 853  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 854  :                                                                 // fall back to the serial algorithm
; 855  :             return _Traits_find_last_not_of<_Traits>(
; 856  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 857  :         }
; 858  : 
; 859  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 860  :             if (!_Matches._Match(*_Match_try)) {
; 861  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 862  :             }
; 863  : 
; 864  :             if (_Match_try == _Haystack) {
; 865  :                 break; // at beginning, no more chance for match
; 866  :             }
; 867  :         }
; 868  :     }
; 869  : 
; 870  :     return static_cast<size_t>(-1); // no match
; 871  : }
; 872  : 
; 873  : template <class _Traits>
; 874  : constexpr size_t _Traits_rfind_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 875  :     const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 876  :     // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch before _Start_at
; 877  :     if (_Hay_size != 0) { // room for match, look for it
; 878  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 879  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 880  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 881  :             }
; 882  : 
; 883  :             if (_Match_try == _Haystack) {
; 884  :                 break; // at beginning, no more chance for match
; 885  :             }
; 886  :         }
; 887  :     }
; 888  : 
; 889  :     return static_cast<size_t>(-1); // no match
; 890  : }
; 891  : 
; 892  : 
; 893  : #if _HAS_CXX17
; 894  : // CLASS TEMPLATE _String_view_iterator
; 895  : template <class _Elem, class _Traits = char_traits<_Elem>>
; 896  : class basic_string_view;
; 897  : 
; 898  : template <class _Traits>
; 899  : class _String_view_iterator {
; 900  : public:
; 901  : #ifdef __cpp_lib_concepts
; 902  :     using iterator_concept = contiguous_iterator_tag;
; 903  : #endif // __cpp_lib_concepts
; 904  :     using iterator_category = random_access_iterator_tag;
; 905  :     using value_type        = typename _Traits::char_type;
; 906  :     using difference_type   = ptrdiff_t;
; 907  :     using pointer           = const value_type*;
; 908  :     using reference         = const value_type&;
; 909  : 
; 910  :     constexpr _String_view_iterator() noexcept = default;
; 911  : 
; 912  : private:
; 913  :     friend basic_string_view<value_type, _Traits>;
; 914  : 
; 915  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 916  :     constexpr _String_view_iterator(const pointer _Data, const size_t _Size, const size_t _Off) noexcept
; 917  :         : _Mydata(_Data), _Mysize(_Size), _Myoff(_Off) {}
; 918  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 919  :     constexpr explicit _String_view_iterator(const pointer _Ptr) noexcept : _Myptr(_Ptr) {}
; 920  : #endif // _ITERATOR_DEBUG_LEVEL
; 921  : 
; 922  : public:
; 923  :     _NODISCARD constexpr reference operator*() const noexcept {
; 924  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 925  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 926  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 927  :         return _Mydata[_Myoff];
; 928  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 929  :         return *_Myptr;
; 930  : #endif // _ITERATOR_DEBUG_LEVEL
; 931  :     }
; 932  : 
; 933  :     _NODISCARD constexpr pointer operator->() const noexcept {
; 934  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 935  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 936  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 937  :         return _Mydata + _Myoff;
; 938  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 939  :         return _Myptr;
; 940  : #endif // _ITERATOR_DEBUG_LEVEL
; 941  :     }
; 942  : 
; 943  :     constexpr _String_view_iterator& operator++() noexcept {
; 944  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 945  :         _STL_VERIFY(_Mydata, "cannot increment value-initialized string_view iterator");
; 946  :         _STL_VERIFY(_Myoff < _Mysize, "cannot increment string_view iterator past end");
; 947  :         ++_Myoff;
; 948  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 949  :         ++_Myptr;
; 950  : #endif // _ITERATOR_DEBUG_LEVEL
; 951  :         return *this;
; 952  :     }
; 953  : 
; 954  :     constexpr _String_view_iterator operator++(int) noexcept {
; 955  :         _String_view_iterator _Tmp{*this};
; 956  :         ++*this;
; 957  :         return _Tmp;
; 958  :     }
; 959  : 
; 960  :     constexpr _String_view_iterator& operator--() noexcept {
; 961  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 962  :         _STL_VERIFY(_Mydata, "cannot decrement value-initialized string_view iterator");
; 963  :         _STL_VERIFY(_Myoff != 0, "cannot decrement string_view iterator before begin");
; 964  :         --_Myoff;
; 965  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 966  :         --_Myptr;
; 967  : #endif // _ITERATOR_DEBUG_LEVEL
; 968  :         return *this;
; 969  :     }
; 970  : 
; 971  :     constexpr _String_view_iterator operator--(int) noexcept {
; 972  :         _String_view_iterator _Tmp{*this};
; 973  :         --*this;
; 974  :         return _Tmp;
; 975  :     }
; 976  : 
; 977  :     constexpr void _Verify_offset(const difference_type _Off) const noexcept {
; 978  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 979  :         if (_Off != 0) {
; 980  :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 981  :         }
; 982  : 
; 983  :         if (_Off < 0) {
; 984  : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 985  :             _STL_VERIFY(_Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 986  :         }
; 987  : 
; 988  :         if (_Off > 0) {
; 989  :             _STL_VERIFY(_Mysize - _Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 990  :         }
; 991  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 992  :         (void) _Off;
; 993  : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 994  :     }
; 995  : 
; 996  :     constexpr _String_view_iterator& operator+=(const difference_type _Off) noexcept {
; 997  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 998  :         _Verify_offset(_Off);
; 999  :         _Myoff += _Off;
; 1000 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1001 :         _Myptr += _Off;
; 1002 : #endif // _ITERATOR_DEBUG_LEVEL
; 1003 : 
; 1004 :         return *this;
; 1005 :     }
; 1006 : 
; 1007 :     _NODISCARD constexpr _String_view_iterator operator+(const difference_type _Off) const noexcept {
; 1008 :         _String_view_iterator _Tmp{*this};
; 1009 :         _Tmp += _Off;
; 1010 :         return _Tmp;
; 1011 :     }
; 1012 : 
; 1013 :     constexpr _String_view_iterator& operator-=(const difference_type _Off) noexcept {
; 1014 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1015 :         if (_Off != 0) {
; 1016 :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 1017 :         }
; 1018 : 
; 1019 :         if (_Off > 0) {
; 1020 :             _STL_VERIFY(_Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 1021 :         }
; 1022 : 
; 1023 :         if (_Off < 0) {
; 1024 : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 1025 :             _STL_VERIFY(_Mysize - _Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 1026 :         }
; 1027 : 
; 1028 :         _Myoff -= _Off;
; 1029 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1030 :         _Myptr -= _Off;
; 1031 : #endif // _ITERATOR_DEBUG_LEVEL
; 1032 : 
; 1033 :         return *this;
; 1034 :     }
; 1035 : 
; 1036 :     _NODISCARD constexpr _String_view_iterator operator-(const difference_type _Off) const noexcept {
; 1037 :         _String_view_iterator _Tmp{*this};
; 1038 :         _Tmp -= _Off;
; 1039 :         return _Tmp;
; 1040 :     }
; 1041 : 
; 1042 :     _NODISCARD constexpr difference_type operator-(const _String_view_iterator& _Right) const noexcept {
; 1043 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1044 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1045 :             "cannot subtract incompatible string_view iterators");
; 1046 :         return static_cast<difference_type>(_Myoff - _Right._Myoff);
; 1047 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1048 :         return _Myptr - _Right._Myptr;
; 1049 : #endif // _ITERATOR_DEBUG_LEVEL
; 1050 :     }
; 1051 : 
; 1052 :     _NODISCARD constexpr reference operator[](const difference_type _Off) const noexcept {
; 1053 :         return *(*this + _Off);
; 1054 :     }
; 1055 : 
; 1056 :     _NODISCARD constexpr bool operator==(const _String_view_iterator& _Right) const noexcept {
; 1057 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1058 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1059 :             "cannot compare incompatible string_view iterators for equality");
; 1060 :         return _Myoff == _Right._Myoff;
; 1061 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1062 :         return _Myptr == _Right._Myptr;
; 1063 : #endif // _ITERATOR_DEBUG_LEVEL
; 1064 :     }
; 1065 : 
; 1066 :     _NODISCARD constexpr bool operator!=(const _String_view_iterator& _Right) const noexcept {
; 1067 :         return !(*this == _Right);
; 1068 :     }
; 1069 : 
; 1070 :     _NODISCARD constexpr bool operator<(const _String_view_iterator& _Right) const noexcept {
; 1071 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1072 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1073 :             "cannot compare incompatible string_view iterators");
; 1074 :         return _Myoff < _Right._Myoff;
; 1075 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1076 :         return _Myptr < _Right._Myptr;
; 1077 : #endif // _ITERATOR_DEBUG_LEVEL
; 1078 :     }
; 1079 : 
; 1080 :     _NODISCARD constexpr bool operator>(const _String_view_iterator& _Right) const noexcept {
; 1081 :         return _Right < *this;
; 1082 :     }
; 1083 : 
; 1084 :     _NODISCARD constexpr bool operator<=(const _String_view_iterator& _Right) const noexcept {
; 1085 :         return !(_Right < *this);
; 1086 :     }
; 1087 : 
; 1088 :     _NODISCARD constexpr bool operator>=(const _String_view_iterator& _Right) const noexcept {
; 1089 :         return !(*this < _Right);
; 1090 :     }
; 1091 : 
; 1092 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1093 :     friend constexpr void _Verify_range(const _String_view_iterator& _First, const _String_view_iterator& _Last) {
; 1094 :         _STL_VERIFY(_First._Mydata == _Last._Mydata && _First._Mysize == _Last._Mysize,
; 1095 :             "string_view iterators in range are from different views");
; 1096 :         _STL_VERIFY(_First._Myoff <= _Last._Myoff, "string_view iterator range transposed");
; 1097 :     }
; 1098 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1099 : 
; 1100 :     using _Prevent_inheriting_unwrap = _String_view_iterator;
; 1101 : 
; 1102 :     _NODISCARD constexpr pointer _Unwrapped() const noexcept {
; 1103 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1104 :         return _Mydata + _Myoff;
; 1105 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1106 :         return _Myptr;
; 1107 : #endif // _ITERATOR_DEBUG_LEVEL
; 1108 :     }
; 1109 : 
; 1110 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1111 : 
; 1112 :     constexpr void _Seek_to(pointer _It) noexcept {
; 1113 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1114 :         _Myoff = static_cast<size_t>(_It - _Mydata);
; 1115 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1116 :         _Myptr = _It;
; 1117 : #endif // _ITERATOR_DEBUG_LEVEL
; 1118 :     }
; 1119 : 
; 1120 : private:
; 1121 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1122 :     pointer _Mydata = nullptr;
; 1123 :     size_t _Mysize  = 0;
; 1124 :     size_t _Myoff   = 0;
; 1125 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1126 :     pointer _Myptr = nullptr;
; 1127 : #endif // _ITERATOR_DEBUG_LEVEL
; 1128 : };
; 1129 : 
; 1130 : template <class _Traits>
; 1131 : _NODISCARD constexpr _String_view_iterator<_Traits> operator+(
; 1132 :     const typename _String_view_iterator<_Traits>::difference_type _Off,
; 1133 :     _String_view_iterator<_Traits> _Right) noexcept {
; 1134 :     _Right += _Off;
; 1135 :     return _Right;
; 1136 : }
; 1137 : 
; 1138 : #if _HAS_CXX20
; 1139 : template <class _Traits>
; 1140 : struct pointer_traits<_String_view_iterator<_Traits>> {
; 1141 :     using pointer         = _String_view_iterator<_Traits>;
; 1142 :     using element_type    = const typename pointer::value_type;
; 1143 :     using difference_type = typename pointer::difference_type;
; 1144 : 
; 1145 :     _NODISCARD static constexpr element_type* to_address(const pointer& _Iter) noexcept {
; 1146 :         return _Iter._Unwrapped();
; 1147 :     }
; 1148 : };
; 1149 : #endif // _HAS_CXX20
; 1150 : 
; 1151 : 
; 1152 : // CLASS TEMPLATE basic_string_view
; 1153 : template <class _Elem, class _Traits>
; 1154 : class basic_string_view { // wrapper for any kind of contiguous character buffer
; 1155 : public:
; 1156 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 1157 :         "Bad char_traits for basic_string_view; "
; 1158 :         "N4659 24.4.2 [string.view.template]/1 \"the type traits::char_type shall name the same type as charT.\"");
; 1159 : 
; 1160 :     using traits_type            = _Traits;
; 1161 :     using value_type             = _Elem;
; 1162 :     using pointer                = _Elem*;
; 1163 :     using const_pointer          = const _Elem*;
; 1164 :     using reference              = _Elem&;
; 1165 :     using const_reference        = const _Elem&;
; 1166 :     using const_iterator         = _String_view_iterator<_Traits>;
; 1167 :     using iterator               = const_iterator;
; 1168 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 1169 :     using reverse_iterator       = const_reverse_iterator;
; 1170 :     using size_type              = size_t;
; 1171 :     using difference_type        = ptrdiff_t;
; 1172 : 
; 1173 :     static constexpr auto npos{static_cast<size_type>(-1)};
; 1174 : 
; 1175 :     constexpr basic_string_view() noexcept : _Mydata(), _Mysize(0) {}
; 1176 : 
; 1177 :     constexpr basic_string_view(const basic_string_view&) noexcept = default;
; 1178 :     constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;
; 1179 : 
; 1180 :     /* implicit */ constexpr basic_string_view(_In_z_ const const_pointer _Ntcts) noexcept // strengthened
; 1181 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}
; 1182 : 
; 1183 :     constexpr basic_string_view(
; 1184 :         _In_reads_(_Count) const const_pointer _Cts, const size_type _Count) noexcept // strengthened
; 1185 :         : _Mydata(_Cts), _Mysize(_Count) {
; 1186 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1187 :         _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
; 1188 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1189 :     }
; 1190 : 
; 1191 :     _NODISCARD constexpr const_iterator begin() const noexcept {
; 1192 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1193 :         return const_iterator(_Mydata, _Mysize, 0);
; 1194 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1195 :         return const_iterator(_Mydata);
; 1196 : #endif // _ITERATOR_DEBUG_LEVEL
; 1197 :     }
; 1198 : 
; 1199 :     _NODISCARD constexpr const_iterator end() const noexcept {
; 1200 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1201 :         return const_iterator(_Mydata, _Mysize, _Mysize);
; 1202 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1203 :         return const_iterator(_Mydata + _Mysize);
; 1204 : #endif // _ITERATOR_DEBUG_LEVEL
; 1205 :     }
; 1206 : 
; 1207 :     _NODISCARD constexpr const_iterator cbegin() const noexcept {
; 1208 :         return begin();
; 1209 :     }
; 1210 : 
; 1211 :     _NODISCARD constexpr const_iterator cend() const noexcept {
; 1212 :         return end();
; 1213 :     }
; 1214 : 
; 1215 :     _NODISCARD constexpr const_reverse_iterator rbegin() const noexcept {
; 1216 :         return const_reverse_iterator{end()};
; 1217 :     }
; 1218 : 
; 1219 :     _NODISCARD constexpr const_reverse_iterator rend() const noexcept {
; 1220 :         return const_reverse_iterator{begin()};
; 1221 :     }
; 1222 : 
; 1223 :     _NODISCARD constexpr const_reverse_iterator crbegin() const noexcept {
; 1224 :         return rbegin();
; 1225 :     }
; 1226 : 
; 1227 :     _NODISCARD constexpr const_reverse_iterator crend() const noexcept {
; 1228 :         return rend();
; 1229 :     }
; 1230 : 
; 1231 :     constexpr const_pointer _Unchecked_begin() const noexcept {
; 1232 :         return _Mydata;
; 1233 :     }
; 1234 : 
; 1235 :     constexpr const_pointer _Unchecked_end() const noexcept {
; 1236 :         return _Mydata + _Mysize;
; 1237 :     }
; 1238 : 
; 1239 :     _NODISCARD constexpr size_type size() const noexcept {
; 1240 :         return _Mysize;
; 1241 :     }
; 1242 : 
; 1243 :     _NODISCARD constexpr size_type length() const noexcept {
; 1244 :         return _Mysize;
; 1245 :     }
; 1246 : 
; 1247 :     _NODISCARD constexpr bool empty() const noexcept {
; 1248 :         return _Mysize == 0;
; 1249 :     }
; 1250 : 
; 1251 :     _NODISCARD constexpr const_pointer data() const noexcept {
; 1252 :         return _Mydata;
; 1253 :     }
; 1254 : 
; 1255 :     _NODISCARD constexpr size_type max_size() const noexcept {
; 1256 :         // bound to PTRDIFF_MAX to make end() - begin() well defined (also makes room for npos)
; 1257 :         // bound to static_cast<size_t>(-1) / sizeof(_Elem) by address space limits
; 1258 :         return _Min_value(static_cast<size_t>(PTRDIFF_MAX), static_cast<size_t>(-1) / sizeof(_Elem));
; 1259 :     }
; 1260 : 
; 1261 :     _NODISCARD constexpr const_reference operator[](const size_type _Off) const noexcept /* strengthened */ {
; 1262 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1263 :         _STL_VERIFY(_Off < _Mysize, "string_view subscript out of range");
; 1264 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1265 :         return _Mydata[_Off];
; 1266 :     }
; 1267 : 
; 1268 :     _NODISCARD constexpr const_reference at(const size_type _Off) const {
; 1269 :         // get the character at _Off or throw if that is out of range
; 1270 :         _Check_offset_exclusive(_Off);
; 1271 :         return _Mydata[_Off];
; 1272 :     }
; 1273 : 
; 1274 :     _NODISCARD constexpr const_reference front() const noexcept /* strengthened */ {
; 1275 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1276 :         _STL_VERIFY(_Mysize != 0, "cannot call front on empty string_view");
; 1277 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1278 :         return _Mydata[0];
; 1279 :     }
; 1280 : 
; 1281 :     _NODISCARD constexpr const_reference back() const noexcept /* strengthened */ {
; 1282 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1283 :         _STL_VERIFY(_Mysize != 0, "cannot call back on empty string_view");
; 1284 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1285 :         return _Mydata[_Mysize - 1];
; 1286 :     }
; 1287 : 
; 1288 :     constexpr void remove_prefix(const size_type _Count) noexcept /* strengthened */ {
; 1289 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1290 :         _STL_VERIFY(_Mysize >= _Count, "cannot remove prefix longer than total size");
; 1291 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1292 :         _Mydata += _Count;
; 1293 :         _Mysize -= _Count;
; 1294 :     }
; 1295 : 
; 1296 :     constexpr void remove_suffix(const size_type _Count) noexcept /* strengthened */ {
; 1297 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1298 :         _STL_VERIFY(_Mysize >= _Count, "cannot remove suffix longer than total size");
; 1299 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1300 :         _Mysize -= _Count;
; 1301 :     }
; 1302 : 
; 1303 :     constexpr void swap(basic_string_view& _Other) noexcept {
; 1304 :         const basic_string_view _Tmp{_Other}; // note: std::swap is not constexpr before C++20
; 1305 :         _Other = *this;
; 1306 :         *this  = _Tmp;
; 1307 :     }
; 1308 : 
; 1309 :     constexpr size_type copy(_Out_writes_(_Count) _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
; 1310 :         // copy [_Off, _Off + Count) to [_Ptr, _Ptr + _Count)
; 1311 :         _Check_offset(_Off);
; 1312 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1313 :         _Traits::copy(_Ptr, _Mydata + _Off, _Count);
; 1314 :         return _Count;
; 1315 :     }
; 1316 : 
; 1317 :     _Pre_satisfies_(_Dest_size >= _Count) constexpr size_type _Copy_s(_Out_writes_all_(_Dest_size) _Elem* const _Dest,
; 1318 :         const size_type _Dest_size, size_type _Count, const size_type _Off = 0) const {
; 1319 :         // copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1320 :         _Check_offset(_Off);
; 1321 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1322 :         _Traits::_Copy_s(_Dest, _Dest_size, _Mydata + _Off, _Count);
; 1323 :         return _Count;
; 1324 :     }
; 1325 : 
; 1326 :     _NODISCARD constexpr basic_string_view substr(const size_type _Off = 0, size_type _Count = npos) const {
; 1327 :         // return a new basic_string_view moved forward by _Off and trimmed to _Count elements
; 1328 :         _Check_offset(_Off);
; 1329 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1330 :         return basic_string_view(_Mydata + _Off, _Count);
; 1331 :     }
; 1332 : 
; 1333 :     constexpr bool _Equal(const basic_string_view _Right) const noexcept {
; 1334 :         return _Traits_equal<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
; 1335 :     }
; 1336 : 
; 1337 :     _NODISCARD constexpr int compare(const basic_string_view _Right) const noexcept {
; 1338 :         return _Traits_compare<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
; 1339 :     }
; 1340 : 
; 1341 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right) const {
; 1342 :         // compare [_Off, _Off + _N0) with _Right
; 1343 :         return substr(_Off, _N0).compare(_Right);
; 1344 :     }
; 1345 : 
; 1346 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right,
; 1347 :         const size_type _Roff, const size_type _Count) const {
; 1348 :         // compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1349 :         return substr(_Off, _N0).compare(_Right.substr(_Roff, _Count));
; 1350 :     }
; 1351 : 
; 1352 :     _NODISCARD constexpr int compare(_In_z_ const _Elem* const _Ptr) const { // compare [0, _Mysize) with [_Ptr, <null>)
; 1353 :         return compare(basic_string_view(_Ptr));
; 1354 :     }
; 1355 : 
; 1356 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, _In_z_ const _Elem* const _Ptr) const {
; 1357 :         // compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 1358 :         return substr(_Off, _N0).compare(basic_string_view(_Ptr));
; 1359 :     }
; 1360 : 
; 1361 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0,
; 1362 :         _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) const {
; 1363 :         // compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1364 :         return substr(_Off, _N0).compare(basic_string_view(_Ptr, _Count));
; 1365 :     }
; 1366 : 
; 1367 : #if _HAS_CXX20
; 1368 :     _NODISCARD constexpr bool starts_with(const basic_string_view _Right) const noexcept {
; 1369 :         const auto _Rightsize = _Right._Mysize;
; 1370 :         if (_Mysize < _Rightsize) {
; 1371 :             return false;
; 1372 :         }
; 1373 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;
; 1374 :     }
; 1375 : 
; 1376 :     _NODISCARD constexpr bool starts_with(const _Elem _Right) const noexcept {
; 1377 :         return !empty() && _Traits::eq(front(), _Right);
; 1378 :     }
; 1379 : 
; 1380 :     _NODISCARD constexpr bool starts_with(const _Elem* const _Right) const noexcept /* strengthened */ {
; 1381 :         return starts_with(basic_string_view(_Right));
; 1382 :     }
; 1383 : 
; 1384 :     _NODISCARD constexpr bool ends_with(const basic_string_view _Right) const noexcept {
; 1385 :         const auto _Rightsize = _Right._Mysize;
; 1386 :         if (_Mysize < _Rightsize) {
; 1387 :             return false;
; 1388 :         }
; 1389 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;
; 1390 :     }
; 1391 : 
; 1392 :     _NODISCARD constexpr bool ends_with(const _Elem _Right) const noexcept {
; 1393 :         return !empty() && _Traits::eq(back(), _Right);
; 1394 :     }
; 1395 : 
; 1396 :     _NODISCARD constexpr bool ends_with(const _Elem* const _Right) const noexcept /* strengthened */ {
; 1397 :         return ends_with(basic_string_view(_Right));
; 1398 :     }
; 1399 : #endif // _HAS_CXX20
; 1400 : 
; 1401 :     _NODISCARD constexpr size_type find(const basic_string_view _Right, const size_type _Off = 0) const noexcept {
; 1402 :         // look for _Right beginning at or after _Off
; 1403 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
; 1404 :     }
; 1405 : 
; 1406 :     _NODISCARD constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1407 :         // look for _Ch at or after _Off
; 1408 :         return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1409 :     }
; 1410 : 
; 1411 :     _NODISCARD constexpr size_type find(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1412 :         const size_type _Count) const noexcept /* strengthened */ {
; 1413 :         // look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1414 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
; 1415 :     }
; 1416 : 
; 1417 :     _NODISCARD constexpr size_type find(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1418 :         noexcept /* strengthened */ {
; 1419 :         // look for [_Ptr, <null>) beginning at or after _Off
; 1420 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
; 1421 :     }
; 1422 : 
; 1423 :     _NODISCARD constexpr size_type rfind(const basic_string_view _Right, const size_type _Off = npos) const noexcept {
; 1424 :         // look for _Right beginning before _Off
; 1425 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
; 1426 :     }
; 1427 : 
; 1428 :     _NODISCARD constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1429 :         // look for _Ch before _Off
; 1430 :         return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1431 :     }
; 1432 : 
; 1433 :     _NODISCARD constexpr size_type rfind(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1434 :         const size_type _Count) const noexcept /* strengthened */ {
; 1435 :         // look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1436 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
; 1437 :     }
; 1438 : 
; 1439 :     _NODISCARD constexpr size_type rfind(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1440 :         noexcept /* strengthened */ {
; 1441 :         // look for [_Ptr, <null>) beginning before _Off
; 1442 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
; 1443 :     }
; 1444 : 
; 1445 :     _NODISCARD constexpr size_type find_first_of(const basic_string_view _Right,
; 1446 :         const size_type _Off = 0) const noexcept { // look for one of _Right at or after _Off
; 1447 :         return _Traits_find_first_of<_Traits>(
; 1448 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1449 :     }
; 1450 : 
; 1451 :     _NODISCARD constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1452 :         // look for _Ch at or after _Off
; 1453 :         return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1454 :     }
; 1455 : 
; 1456 :     _NODISCARD constexpr size_type find_first_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1457 :         const size_type _Count) const noexcept /* strengthened */ {
; 1458 :         // look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1459 :         return _Traits_find_first_of<_Traits>(
; 1460 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1461 :     }
; 1462 : 
; 1463 :     _NODISCARD constexpr size_type find_first_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1464 :         noexcept /* strengthened */ {
; 1465 :         // look for one of [_Ptr, <null>) at or after _Off
; 1466 :         return _Traits_find_first_of<_Traits>(
; 1467 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1468 :     }
; 1469 : 
; 1470 :     _NODISCARD constexpr size_type find_last_of(const basic_string_view _Right, const size_type _Off = npos) const
; 1471 :         noexcept { // look for one of _Right before _Off
; 1472 :         return _Traits_find_last_of<_Traits>(
; 1473 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1474 :     }
; 1475 : 
; 1476 :     _NODISCARD constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1477 :         // look for _Ch before _Off
; 1478 :         return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1479 :     }
; 1480 : 
; 1481 :     _NODISCARD constexpr size_type find_last_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1482 :         const size_type _Count) const noexcept /* strengthened */ {
; 1483 :         // look for one of [_Ptr, _Ptr + _Count) before _Off
; 1484 :         return _Traits_find_last_of<_Traits>(
; 1485 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1486 :     }
; 1487 : 
; 1488 :     _NODISCARD constexpr size_type find_last_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1489 :         noexcept /* strengthened */ {
; 1490 :         // look for one of [_Ptr, <null>) before _Off
; 1491 :         return _Traits_find_last_of<_Traits>(
; 1492 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1493 :     }
; 1494 : 
; 1495 :     _NODISCARD constexpr size_type find_first_not_of(const basic_string_view _Right,
; 1496 :         const size_type _Off = 0) const noexcept { // look for none of _Right at or after _Off
; 1497 :         return _Traits_find_first_not_of<_Traits>(
; 1498 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1499 :     }
; 1500 : 
; 1501 :     _NODISCARD constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1502 :         // look for any value other than _Ch at or after _Off
; 1503 :         return _Traits_find_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1504 :     }
; 1505 : 
; 1506 :     _NODISCARD constexpr size_type find_first_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1507 :         const size_type _Count) const noexcept /* strengthened */ {
; 1508 :         // look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 1509 :         return _Traits_find_first_not_of<_Traits>(
; 1510 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1511 :     }
; 1512 : 
; 1513 :     _NODISCARD constexpr size_type find_first_not_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1514 :         noexcept /* strengthened */ {
; 1515 :         // look for none of [_Ptr, <null>) at or after _Off
; 1516 :         return _Traits_find_first_not_of<_Traits>(
; 1517 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1518 :     }
; 1519 : 
; 1520 :     _NODISCARD constexpr size_type find_last_not_of(const basic_string_view _Right,
; 1521 :         const size_type _Off = npos) const noexcept { // look for none of _Right before _Off
; 1522 :         return _Traits_find_last_not_of<_Traits>(
; 1523 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1524 :     }
; 1525 : 
; 1526 :     _NODISCARD constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1527 :         // look for any value other than _Ch before _Off
; 1528 :         return _Traits_rfind_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1529 :     }
; 1530 : 
; 1531 :     _NODISCARD constexpr size_type find_last_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1532 :         const size_type _Count) const noexcept /* strengthened */ {
; 1533 :         // look for none of [_Ptr, _Ptr + _Count) before _Off
; 1534 :         return _Traits_find_last_not_of<_Traits>(
; 1535 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1536 :     }
; 1537 : 
; 1538 :     _NODISCARD constexpr size_type find_last_not_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1539 :         noexcept /* strengthened */ {
; 1540 :         // look for none of [_Ptr, <null>) before _Off
; 1541 :         return _Traits_find_last_not_of<_Traits>(
; 1542 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1543 :     }
; 1544 : 
; 1545 :     _NODISCARD constexpr bool _Starts_with(const basic_string_view _View) const noexcept {
; 1546 :         return _Mysize >= _View._Mysize && _Traits::compare(_Mydata, _View._Mydata, _View._Mysize) == 0;
; 1547 :     }
; 1548 : 
; 1549 : private:
; 1550 :     constexpr void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 1551 :         if (_Mysize < _Off) {
; 1552 :             _Xran();
; 1553 :         }
; 1554 :     }
; 1555 : 
; 1556 :     constexpr void _Check_offset_exclusive(const size_type _Off) const {
; 1557 :         // checks whether _Off is in the bounds of [0, size())
; 1558 :         if (_Mysize <= _Off) {
; 1559 :             _Xran();
; 1560 :         }
; 1561 :     }
; 1562 : 
; 1563 :     constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 1564 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 1565 :         return _Min_value(_Size, _Mysize - _Off);
; 1566 :     }
; 1567 : 
; 1568 :     [[noreturn]] static void _Xran() {
; 1569 :         _Xout_of_range("invalid string_view position");
; 1570 :     }
; 1571 : 
; 1572 :     const_pointer _Mydata;
; 1573 :     size_type _Mysize;
; 1574 : };
; 1575 : 
; 1576 : #ifdef __cpp_lib_concepts
; 1577 : namespace ranges {
; 1578 :     template <class _Elem, class _Traits>
; 1579 :     inline constexpr bool enable_view<basic_string_view<_Elem, _Traits>> = true;
; 1580 :     template <class _Elem, class _Traits>
; 1581 :     inline constexpr bool enable_borrowed_range<basic_string_view<_Elem, _Traits>> = true;
; 1582 : } // namespace ranges
; 1583 : #endif // __cpp_lib_concepts
; 1584 : 
; 1585 : // FUNCTION TEMPLATES operator== FOR basic_string_view
; 1586 : template <class _Elem, class _Traits>
; 1587 : _NODISCARD constexpr bool operator==(
; 1588 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1589 :     return _Lhs._Equal(_Rhs);
; 1590 : }
; 1591 : 
; 1592 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1593 : _NODISCARD constexpr bool operator==(
; 1594 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1595 :     return _Lhs._Equal(_Rhs);
; 1596 : }
; 1597 : 
; 1598 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1599 : _NODISCARD constexpr bool operator==(
; 1600 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1601 :     return _Lhs._Equal(_Rhs);
; 1602 : }
; 1603 : 
; 1604 : 
; 1605 : // FUNCTION TEMPLATES operator!= FOR basic_string_view
; 1606 : template <class _Elem, class _Traits>
; 1607 : _NODISCARD constexpr bool operator!=(
; 1608 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1609 :     return !_Lhs._Equal(_Rhs);
; 1610 : }
; 1611 : 
; 1612 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1613 : _NODISCARD constexpr bool operator!=(
; 1614 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1615 :     return !_Lhs._Equal(_Rhs);
; 1616 : }
; 1617 : 
; 1618 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1619 : _NODISCARD constexpr bool operator!=(
; 1620 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1621 :     return !_Lhs._Equal(_Rhs);
; 1622 : }
; 1623 : 
; 1624 : 
; 1625 : // FUNCTION TEMPLATES operator< FOR basic_string_view
; 1626 : template <class _Elem, class _Traits>
; 1627 : _NODISCARD constexpr bool operator<(
; 1628 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1629 :     return _Lhs.compare(_Rhs) < 0;
; 1630 : }
; 1631 : 
; 1632 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1633 : _NODISCARD constexpr bool operator<(
; 1634 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1635 :     return _Lhs.compare(_Rhs) < 0;
; 1636 : }
; 1637 : 
; 1638 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1639 : _NODISCARD constexpr bool operator<(
; 1640 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1641 :     return _Lhs.compare(_Rhs) < 0;
; 1642 : }
; 1643 : 
; 1644 : 
; 1645 : // FUNCTION TEMPLATES operator> FOR basic_string_view
; 1646 : template <class _Elem, class _Traits>
; 1647 : _NODISCARD constexpr bool operator>(
; 1648 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1649 :     return _Lhs.compare(_Rhs) > 0;
; 1650 : }
; 1651 : 
; 1652 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1653 : _NODISCARD constexpr bool operator>(
; 1654 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1655 :     return _Lhs.compare(_Rhs) > 0;
; 1656 : }
; 1657 : 
; 1658 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1659 : _NODISCARD constexpr bool operator>(
; 1660 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1661 :     return _Lhs.compare(_Rhs) > 0;
; 1662 : }
; 1663 : 
; 1664 : 
; 1665 : // FUNCTION TEMPLATES operator<= FOR basic_string_view
; 1666 : template <class _Elem, class _Traits>
; 1667 : _NODISCARD constexpr bool operator<=(
; 1668 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1669 :     return _Lhs.compare(_Rhs) <= 0;
; 1670 : }
; 1671 : 
; 1672 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1673 : _NODISCARD constexpr bool operator<=(
; 1674 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1675 :     return _Lhs.compare(_Rhs) <= 0;
; 1676 : }
; 1677 : 
; 1678 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1679 : _NODISCARD constexpr bool operator<=(
; 1680 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1681 :     return _Lhs.compare(_Rhs) <= 0;
; 1682 : }
; 1683 : 
; 1684 : 
; 1685 : // FUNCTION TEMPLATES operator>= FOR basic_string_view
; 1686 : template <class _Elem, class _Traits>
; 1687 : _NODISCARD constexpr bool operator>=(
; 1688 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1689 :     return _Lhs.compare(_Rhs) >= 0;
; 1690 : }
; 1691 : 
; 1692 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1693 : _NODISCARD constexpr bool operator>=(
; 1694 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1695 :     return _Lhs.compare(_Rhs) >= 0;
; 1696 : }
; 1697 : 
; 1698 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1699 : _NODISCARD constexpr bool operator>=(
; 1700 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1701 :     return _Lhs.compare(_Rhs) >= 0;
; 1702 : }
; 1703 : 
; 1704 : 
; 1705 : // TYPEDEFS FOR basic_string_view
; 1706 : using string_view = basic_string_view<char>;
; 1707 : #ifdef __cpp_lib_char8_t
; 1708 : using u8string_view = basic_string_view<char8_t>;
; 1709 : #endif // __cpp_lib_char8_t
; 1710 : using u16string_view = basic_string_view<char16_t>;
; 1711 : using u32string_view = basic_string_view<char32_t>;
; 1712 : using wstring_view   = basic_string_view<wchar_t>;
; 1713 : 
; 1714 : 
; 1715 : // STRUCT TEMPLATE SPECIALIZATION hash FOR basic_string_view
; 1716 : template <class _Elem, class _Traits>
; 1717 : struct hash<basic_string_view<_Elem, _Traits>> {
; 1718 :     _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef basic_string_view<_Elem, _Traits> _ARGUMENT_TYPE_NAME;
; 1719 :     _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t _RESULT_TYPE_NAME;
; 1720 : 
; 1721 :     _NODISCARD size_t operator()(const basic_string_view<_Elem, _Traits> _Keyval) const noexcept {
; 1722 :         return _Hash_array_representation(_Keyval.data(), _Keyval.size());
; 1723 :     }
; 1724 : };
; 1725 : 
; 1726 : template <class _Elem, class _Traits>
; 1727 : basic_ostream<_Elem, _Traits>& operator<<(
; 1728 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string_view<_Elem, _Traits> _Str) {
; 1729 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());
; 1730 : }
; 1731 : 
; 1732 : 
; 1733 : // basic_string_view LITERALS
; 1734 : inline namespace literals {
; 1735 :     inline namespace string_view_literals {
; 1736 :         _NODISCARD constexpr string_view operator"" sv(const char* _Str, size_t _Len) noexcept {
; 1737 :             return string_view(_Str, _Len);
; 1738 :         }
; 1739 : 
; 1740 :         _NODISCARD constexpr wstring_view operator"" sv(const wchar_t* _Str, size_t _Len) noexcept {
; 1741 :             return wstring_view(_Str, _Len);
; 1742 :         }
; 1743 : 
; 1744 : #ifdef __cpp_char8_t
; 1745 :         _NODISCARD constexpr basic_string_view<char8_t> operator"" sv(const char8_t* _Str, size_t _Len) noexcept {
; 1746 :             return basic_string_view<char8_t>(_Str, _Len);
; 1747 :         }
; 1748 : #endif // __cpp_char8_t
; 1749 : 
; 1750 :         _NODISCARD constexpr u16string_view operator"" sv(const char16_t* _Str, size_t _Len) noexcept {
; 1751 :             return u16string_view(_Str, _Len);
; 1752 :         }
; 1753 : 
; 1754 :         _NODISCARD constexpr u32string_view operator"" sv(const char32_t* _Str, size_t _Len) noexcept {
; 1755 :             return u32string_view(_Str, _Len);
; 1756 :         }
; 1757 :     } // namespace string_view_literals
; 1758 : } // namespace literals
; 1759 : #endif // _HAS_CXX17
; 1760 : 
; 1761 : // CLASS TEMPLATE _String_const_iterator
; 1762 : template <class _Mystr>
; 1763 : class _String_const_iterator : public _Iterator_base {
; 1764 : public:
; 1765 : #ifdef __cpp_lib_concepts
; 1766 :     using iterator_concept = contiguous_iterator_tag;
; 1767 : #endif // __cpp_lib_concepts
; 1768 :     using iterator_category = random_access_iterator_tag;
; 1769 :     using value_type        = typename _Mystr::value_type;
; 1770 :     using difference_type   = typename _Mystr::difference_type;
; 1771 :     using pointer           = typename _Mystr::const_pointer;
; 1772 :     using reference         = const value_type&;
; 1773 : 
; 1774 :     _String_const_iterator() noexcept : _Ptr() {}
; 1775 : 
; 1776 :     _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {
; 1777 :         this->_Adopt(_Pstring);
; 1778 :     }
; 1779 : 
; 1780 :     _NODISCARD reference operator*() const {
; 1781 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1782 :         _STL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1783 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1784 :         _STL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1785 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1786 :         const auto _Contptr = _Mycont->_Myptr();
; 1787 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1788 :         _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1789 :             "cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1790 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1791 : 
; 1792 :         _Analysis_assume_(_Ptr);
; 1793 :         return *_Ptr;
; 1794 :     }
; 1795 : 
; 1796 :     _NODISCARD pointer operator->() const {
; 1797 :         return pointer_traits<pointer>::pointer_to(**this);
; 1798 :     }
; 1799 : 
; 1800 :     _String_const_iterator& operator++() {
; 1801 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1802 :         _STL_VERIFY(_Ptr, "cannot increment value-initialized string iterator");
; 1803 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1804 :         _STL_VERIFY(_Mycont, "cannot increment string iterator because the iterator was"
; 1805 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1806 :         _STL_VERIFY(_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize, "cannot increment string iterator past end");
; 1807 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1808 : 
; 1809 :         ++_Ptr;
; 1810 :         return *this;
; 1811 :     }
; 1812 : 
; 1813 :     _String_const_iterator operator++(int) {
; 1814 :         _String_const_iterator _Tmp = *this;
; 1815 :         ++*this;
; 1816 :         return _Tmp;
; 1817 :     }
; 1818 : 
; 1819 :     _String_const_iterator& operator--() {
; 1820 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1821 :         _STL_VERIFY(_Ptr, "cannot decrement value-initialized string iterator");
; 1822 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1823 :         _STL_VERIFY(_Mycont, "cannot decrement string iterator because the iterator was"
; 1824 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1825 :         _STL_VERIFY(_Mycont->_Myptr() < _Unfancy(_Ptr), "cannot decrement string iterator before begin");
; 1826 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1827 : 
; 1828 :         --_Ptr;
; 1829 :         return *this;
; 1830 :     }
; 1831 : 
; 1832 :     _String_const_iterator operator--(int) {
; 1833 :         _String_const_iterator _Tmp = *this;
; 1834 :         --*this;
; 1835 :         return _Tmp;
; 1836 :     }
; 1837 : 
; 1838 :     void _Verify_offset(const difference_type _Off) const noexcept {
; 1839 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1840 :         if (_Off == 0) {
; 1841 :             return;
; 1842 :         }
; 1843 : 
; 1844 :         _STL_ASSERT(_Ptr, "cannot seek value-initialized string iterator");
; 1845 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1846 :         _STL_ASSERT(_Mycont, "cannot seek string iterator because the iterator was"
; 1847 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1848 :         const auto _Contptr = _Mycont->_Myptr();
; 1849 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1850 : 
; 1851 :         if (_Off < 0) {
; 1852 : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 1853 :             _STL_VERIFY(_Contptr - _Rawptr <= _Off, "cannot seek string iterator before begin");
; 1854 :         }
; 1855 : 
; 1856 :         if (_Off > 0) {
; 1857 :             using _Size_type = typename _Mystr::size_type;
; 1858 :             const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
; 1859 :             _STL_VERIFY(static_cast<_Size_type>(_Off) <= _Left, "cannot seek string iterator after end");
; 1860 :         }
; 1861 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1862 :         (void) _Off;
; 1863 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1864 :     }
; 1865 : 
; 1866 :     _String_const_iterator& operator+=(const difference_type _Off) {
; 1867 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1868 :         _Verify_offset(_Off);
; 1869 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1870 :         _Ptr += _Off;
; 1871 :         return *this;
; 1872 :     }
; 1873 : 
; 1874 :     _NODISCARD _String_const_iterator operator+(const difference_type _Off) const {
; 1875 :         _String_const_iterator _Tmp = *this;
; 1876 :         return _Tmp += _Off;
; 1877 :     }
; 1878 : 
; 1879 :     _String_const_iterator& operator-=(const difference_type _Off) {
; 1880 :         return *this += -_Off;
; 1881 :     }
; 1882 : 
; 1883 :     _NODISCARD _String_const_iterator operator-(const difference_type _Off) const {
; 1884 :         _String_const_iterator _Tmp = *this;
; 1885 :         return _Tmp -= _Off;
; 1886 :     }
; 1887 : 
; 1888 :     _NODISCARD difference_type operator-(const _String_const_iterator& _Right) const {
; 1889 :         _Compat(_Right);
; 1890 :         return _Ptr - _Right._Ptr;
; 1891 :     }
; 1892 : 
; 1893 :     _NODISCARD reference operator[](const difference_type _Off) const {
; 1894 :         return *(*this + _Off);
; 1895 :     }
; 1896 : 
; 1897 :     _NODISCARD bool operator==(const _String_const_iterator& _Right) const {
; 1898 :         _Compat(_Right);
; 1899 :         return _Ptr == _Right._Ptr;
; 1900 :     }
; 1901 : 
; 1902 :     _NODISCARD bool operator!=(const _String_const_iterator& _Right) const {
; 1903 :         return !(*this == _Right);
; 1904 :     }
; 1905 : 
; 1906 :     _NODISCARD bool operator<(const _String_const_iterator& _Right) const {
; 1907 :         _Compat(_Right);
; 1908 :         return _Ptr < _Right._Ptr;
; 1909 :     }
; 1910 : 
; 1911 :     _NODISCARD bool operator>(const _String_const_iterator& _Right) const {
; 1912 :         return _Right < *this;
; 1913 :     }
; 1914 : 
; 1915 :     _NODISCARD bool operator<=(const _String_const_iterator& _Right) const {
; 1916 :         return !(_Right < *this);
; 1917 :     }
; 1918 : 
; 1919 :     _NODISCARD bool operator>=(const _String_const_iterator& _Right) const {
; 1920 :         return !(*this < _Right);
; 1921 :     }
; 1922 : 
; 1923 :     void _Compat(const _String_const_iterator& _Right) const { // test for compatible iterator pair
; 1924 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1925 :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "string iterators incompatible (e.g."
; 1926 :                                                            " point to different string instances)");
; 1927 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1928 :         (void) _Right;
; 1929 : #endif // _ITERATOR_DEBUG_LEVEL
; 1930 :     }
; 1931 : 
; 1932 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1933 :     friend void _Verify_range(const _String_const_iterator& _First, const _String_const_iterator& _Last) {
; 1934 :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "string iterators in range are from different containers");
; 1935 :         _STL_VERIFY(_First._Ptr <= _Last._Ptr, "string iterator range transposed");
; 1936 :     }
; 1937 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1938 : 
; 1939 :     using _Prevent_inheriting_unwrap = _String_const_iterator;
; 1940 : 
; 1941 :     _NODISCARD const value_type* _Unwrapped() const {
; 1942 :         return _Unfancy(_Ptr);
; 1943 :     }
; 1944 : 
; 1945 :     void _Seek_to(const value_type* _It) {
; 1946 :         _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
; 1947 :     }
; 1948 : 
; 1949 :     pointer _Ptr; // pointer to element in string
; 1950 : };
; 1951 : 
; 1952 : template <class _Mystr>
; 1953 : _NODISCARD _String_const_iterator<_Mystr> operator+(
; 1954 :     typename _String_const_iterator<_Mystr>::difference_type _Off, _String_const_iterator<_Mystr> _Next) {
; 1955 :     return _Next += _Off;
; 1956 : }
; 1957 : 
; 1958 : #if _HAS_CXX20
; 1959 : template <class _Mystr>
; 1960 : struct pointer_traits<_String_const_iterator<_Mystr>> {
; 1961 :     using pointer         = _String_const_iterator<_Mystr>;
; 1962 :     using element_type    = const typename pointer::value_type;
; 1963 :     using difference_type = typename pointer::difference_type;
; 1964 : 
; 1965 :     _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
; 1966 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1967 :         const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
; 1968 :         if (!_Mycont) {
; 1969 :             _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
; 1970 :                                      "(e.g. reallocation occurred, or the string was destroyed)");
; 1971 :         }
; 1972 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1973 : 
; 1974 :         const auto _Rawptr = _STD to_address(_Iter._Ptr);
; 1975 : 
; 1976 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1977 :         if (_Mycont) {
; 1978 :             const auto _Contptr = _Mycont->_Myptr();
; 1979 :             _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
; 1980 :                 "cannot convert string iterator to pointer because it is out of range");
; 1981 :         }
; 1982 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1983 : 
; 1984 :         return _Rawptr;
; 1985 :     }
; 1986 : };
; 1987 : #endif // _HAS_CXX20
; 1988 : 
; 1989 : // CLASS TEMPLATE _String_iterator
; 1990 : template <class _Mystr>
; 1991 : class _String_iterator : public _String_const_iterator<_Mystr> {
; 1992 : public:
; 1993 :     using _Mybase = _String_const_iterator<_Mystr>;
; 1994 : 
; 1995 : #ifdef __cpp_lib_concepts
; 1996 :     using iterator_concept = contiguous_iterator_tag;
; 1997 : #endif // __cpp_lib_concepts
; 1998 :     using iterator_category = random_access_iterator_tag;
; 1999 :     using value_type        = typename _Mystr::value_type;
; 2000 :     using difference_type   = typename _Mystr::difference_type;
; 2001 :     using pointer           = typename _Mystr::pointer;
; 2002 :     using reference         = value_type&;
; 2003 : 
; 2004 :     using _Mybase::_Mybase;
; 2005 : 
; 2006 :     _NODISCARD reference operator*() const {
; 2007 :         return const_cast<reference>(_Mybase::operator*());
; 2008 :     }
; 2009 : 
; 2010 :     _NODISCARD pointer operator->() const {
; 2011 :         return pointer_traits<pointer>::pointer_to(**this);
; 2012 :     }
; 2013 : 
; 2014 :     _String_iterator& operator++() {
; 2015 :         _Mybase::operator++();
; 2016 :         return *this;
; 2017 :     }
; 2018 : 
; 2019 :     _String_iterator operator++(int) {
; 2020 :         _String_iterator _Tmp = *this;
; 2021 :         _Mybase::operator++();
; 2022 :         return _Tmp;
; 2023 :     }
; 2024 : 
; 2025 :     _String_iterator& operator--() {
; 2026 :         _Mybase::operator--();
; 2027 :         return *this;
; 2028 :     }
; 2029 : 
; 2030 :     _String_iterator operator--(int) {
; 2031 :         _String_iterator _Tmp = *this;
; 2032 :         _Mybase::operator--();
; 2033 :         return _Tmp;
; 2034 :     }
; 2035 : 
; 2036 :     _String_iterator& operator+=(const difference_type _Off) {
; 2037 :         _Mybase::operator+=(_Off);
; 2038 :         return *this;
; 2039 :     }
; 2040 : 
; 2041 :     _NODISCARD _String_iterator operator+(const difference_type _Off) const {
; 2042 :         _String_iterator _Tmp = *this;
; 2043 :         return _Tmp += _Off;
; 2044 :     }
; 2045 : 
; 2046 :     _String_iterator& operator-=(const difference_type _Off) {
; 2047 :         _Mybase::operator-=(_Off);
; 2048 :         return *this;
; 2049 :     }
; 2050 : 
; 2051 :     using _Mybase::operator-;
; 2052 : 
; 2053 :     _NODISCARD _String_iterator operator-(const difference_type _Off) const {
; 2054 :         _String_iterator _Tmp = *this;
; 2055 :         return _Tmp -= _Off;
; 2056 :     }
; 2057 : 
; 2058 :     _NODISCARD reference operator[](const difference_type _Off) const {
; 2059 :         return const_cast<reference>(_Mybase::operator[](_Off));
; 2060 :     }
; 2061 : 
; 2062 :     using _Prevent_inheriting_unwrap = _String_iterator;
; 2063 : 
; 2064 :     _NODISCARD value_type* _Unwrapped() const {
; 2065 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));
; 2066 :     }
; 2067 : };
; 2068 : 
; 2069 : template <class _Mystr>
; 2070 : _NODISCARD _String_iterator<_Mystr> operator+(
; 2071 :     typename _String_iterator<_Mystr>::difference_type _Off, _String_iterator<_Mystr> _Next) {
; 2072 :     return _Next += _Off;
; 2073 : }
; 2074 : 
; 2075 : #if _HAS_CXX20
; 2076 : template <class _Mystr>
; 2077 : struct pointer_traits<_String_iterator<_Mystr>> {
; 2078 :     using pointer         = _String_iterator<_Mystr>;
; 2079 :     using element_type    = typename pointer::value_type;
; 2080 :     using difference_type = typename pointer::difference_type;
; 2081 : 
; 2082 :     _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
; 2083 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 2084 :         const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
; 2085 :         if (!_Mycont) {
; 2086 :             _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
; 2087 :                                      "(e.g. reallocation occurred, or the string was destroyed)");
; 2088 :         }
; 2089 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 2090 : 
; 2091 :         const auto _Rawptr = _STD to_address(_Iter._Ptr);
; 2092 : 
; 2093 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 2094 :         if (_Mycont) {
; 2095 :             const auto _Contptr = _Mycont->_Myptr();
; 2096 :             _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
; 2097 :                 "cannot convert string iterator to pointer because it is out of range");
; 2098 :         }
; 2099 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 2100 : 
; 2101 :         return const_cast<element_type*>(_Rawptr);
; 2102 :     }
; 2103 : };
; 2104 : #endif // _HAS_CXX20
; 2105 : 
; 2106 : // basic_string TYPE WRAPPERS
; 2107 : template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
; 2108 :     class _Reference, class _Const_reference>
; 2109 : struct _String_iter_types {
; 2110 :     using value_type      = _Value_type;
; 2111 :     using size_type       = _Size_type;
; 2112 :     using difference_type = _Difference_type;
; 2113 :     using pointer         = _Pointer;
; 2114 :     using const_pointer   = _Const_pointer;
; 2115 : };
; 2116 : 
; 2117 : // CLASS TEMPLATE _String_val
; 2118 : template <class _Val_types>
; 2119 : class _String_val : public _Container_base {
; 2120 : public:
; 2121 :     using value_type      = typename _Val_types::value_type;
; 2122 :     using size_type       = typename _Val_types::size_type;
; 2123 :     using difference_type = typename _Val_types::difference_type;
; 2124 :     using pointer         = typename _Val_types::pointer;
; 2125 :     using const_pointer   = typename _Val_types::const_pointer;
; 2126 :     using reference       = value_type&;
; 2127 :     using const_reference = const value_type&;
; 2128 : 
; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}
; 2130 : 
; 2131 :     // length of internal buffer, [1, 16]:
; 2132 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2133 :     // roundup mask for allocated buffers, [0, 15]:
; 2134 :     static constexpr size_type _ALLOC_MASK =
; 2135 :         sizeof(value_type) <= 1
; 2136 :             ? 15
; 2137 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2138 : 
; 2139 :     value_type* _Myptr() noexcept {
; 2140 :         value_type* _Result = _Bx._Buf;
; 2141 :         if (_Large_string_engaged()) {
; 2142 :             _Result = _Unfancy(_Bx._Ptr);
; 2143 :         }
; 2144 : 
; 2145 :         return _Result;
; 2146 :     }
; 2147 : 
; 2148 :     const value_type* _Myptr() const noexcept {
; 2149 :         const value_type* _Result = _Bx._Buf;
; 2150 :         if (_Large_string_engaged()) {
; 2151 :             _Result = _Unfancy(_Bx._Ptr);
; 2152 :         }
; 2153 : 
; 2154 :         return _Result;
; 2155 :     }
; 2156 : 
; 2157 :     bool _Large_string_engaged() const noexcept {
; 2158 :         return _BUF_SIZE <= _Myres;
; 2159 :     }
; 2160 : 
; 2161 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2162 :         if (_Mysize < _Off) {
; 2163 :             _Xran();
; 2164 :         }
; 2165 :     }
; 2166 : 
; 2167 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2168 :         if (_Mysize <= _Off) {
; 2169 :             _Xran();
; 2170 :         }
; 2171 :     }
; 2172 : 
; 2173 :     [[noreturn]] static void _Xran() {
; 2174 :         _Xout_of_range("invalid string position");
; 2175 :     }
; 2176 : 
; 2177 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2178 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2179 :         return _Min_value(_Size, _Mysize - _Off);
; 2180 :     }
; 2181 : 
; 2182 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2183 :         _Bxty() {} // user-provided, for fancy pointers
; 2184 : 
; 2185 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2186 : 
; 2187 :         value_type _Buf[_BUF_SIZE];
; 2188 :         pointer _Ptr;
; 2189 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2190 :     } _Bx;
; 2191 : 
; 2192 :     size_type _Mysize; // current length of string
; 2193 :     size_type _Myres; // current storage reserved for string
; 2194 : };
; 2195 : 
; 2196 : // CLASS TEMPLATE basic_string
; 2197 : template <class _Ty>
; 2198 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2199 : 
; 2200 : struct _String_constructor_concat_tag {
; 2201 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2202 :     explicit _String_constructor_concat_tag() = default;
; 2203 : };
; 2204 : 
; 2205 : [[noreturn]] inline void _Xlen_string() {
; 2206 :     _Xlength_error("string too long");
; 2207 : }
; 2208 : 
; 2209 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2210 : class basic_string { // null-terminated transparent array of elements
; 2211 : private:
; 2212 :     friend _Tidy_deallocate_guard<basic_string>;
; 2213 : 
; 2214 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2215 :     using _Alty_traits = allocator_traits<_Alty>;
; 2216 : 
; 2217 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2218 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2219 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2220 : 
; 2221 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2222 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2223 : 
; 2224 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2225 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2226 :         "char_traits character type match the string's character type.");
; 2227 : 
; 2228 : public:
; 2229 :     using traits_type    = _Traits;
; 2230 :     using allocator_type = _Alloc;
; 2231 : 
; 2232 :     using value_type      = _Elem;
; 2233 :     using size_type       = typename _Alty_traits::size_type;
; 2234 :     using difference_type = typename _Alty_traits::difference_type;
; 2235 :     using pointer         = typename _Alty_traits::pointer;
; 2236 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2237 :     using reference       = value_type&;
; 2238 :     using const_reference = const value_type&;
; 2239 : 
; 2240 :     using iterator       = _String_iterator<_Scary_val>;
; 2241 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2242 : 
; 2243 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2244 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2245 : 
; 2246 : private:
; 2247 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2248 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2249 : 
; 2250 :     // When doing _String_val operations by memcpy, we are touching:
; 2251 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2252 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2253 :     //   _String_val::_Mysize   (type is size_type)
; 2254 :     //   _String_val::_Myres    (type is size_type)
; 2255 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2256 :     // We need to ask if pointer is safe to memcpy.
; 2257 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2258 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2259 :     //   they can observe traits::assign and similar.
; 2260 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2261 :     // This offset skips over the _Container_base members, if any
; 2262 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2263 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2264 : 
; 2265 :     template <class _Iter>
; 2266 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2267 : 
; 2268 : #if _HAS_CXX17
; 2269 :     template <class _StringViewIsh>
; 2270 :     using _Is_string_view_ish =
; 2271 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2272 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2273 :             int>;
; 2274 : #endif // _HAS_CXX17
; 2275 : 
; 2276 : public:
; 2277 :     basic_string(const basic_string& _Right)
; 2278 :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2279 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2280 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2281 :         _Construct_lv_contents(_Right);
; 2282 :         _Proxy._Release();
; 2283 :     }
; 2284 : 
; 2285 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2286 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2287 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2288 :         _Construct_lv_contents(_Right);
; 2289 :         _Proxy._Release();
; 2290 :     }
; 2291 : 
; 2292 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t()) {
; 2293 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2294 :         _Tidy_init();
; 2295 :     }
; 2296 : 
; 2297 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2298 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2299 :         _Tidy_init();
; 2300 :     }
; 2301 : 
; 2302 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2303 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, <end>)
; 2304 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2305 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2306 :         _Tidy_init();
; 2307 :         assign(_Right, _Roff, npos);
; 2308 :         _Proxy._Release();
; 2309 :     }
; 2310 : 
; 2311 :     basic_string(
; 2312 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2313 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2314 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2315 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2316 :         _Tidy_init();
; 2317 :         assign(_Right, _Roff, _Count);
; 2318 :         _Proxy._Release();
; 2319 :     }
; 2320 : 
; 2321 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2322 :         : _Mypair(_Zero_then_variadic_args_t()) {
; 2323 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2324 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2325 :         _Tidy_init();
; 2326 :         assign(_Ptr, _Count);
; 2327 :         _Proxy._Release();
; 2328 :     }
; 2329 : 
; 2330 :     basic_string(
; 2331 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2332 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2333 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2334 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2335 :         _Tidy_init();
; 2336 :         assign(_Ptr, _Count);
; 2337 :         _Proxy._Release();
; 2338 :     }
; 2339 : 
; 2340 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {
; 2341 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2342 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2343 :         _Tidy_init();
; 2344 :         assign(_Ptr);
; 2345 :         _Proxy._Release();
; 2346 :     }
; 2347 : 
; 2348 : #if _HAS_CXX17
; 2349 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2350 : #endif // _HAS_CXX17
; 2351 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Tidy_init();
; 2355 :         assign(_Ptr);
; 2356 :         _Proxy._Release();
; 2357 :     }
; 2358 : 
; 2359 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t()) {
; 2360 :         // construct from _Count * _Ch
; 2361 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2362 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2363 :         _Tidy_init();
; 2364 :         assign(_Count, _Ch);
; 2365 :         _Proxy._Release();
; 2366 :     }
; 2367 : 
; 2368 : #if _HAS_CXX17
; 2369 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2370 : #endif // _HAS_CXX17
; 2371 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2372 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Count * _Ch with allocator
; 2373 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2374 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2375 :         _Tidy_init();
; 2376 :         assign(_Count, _Ch);
; 2377 :         _Proxy._Release();
; 2378 :     }
; 2379 : 
; 2380 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2381 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2382 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2383 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2384 :         _Tidy_init();
; 2385 :         _Adl_verify_range(_First, _Last);
; 2386 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
; 2387 :         _Proxy._Release();
; 2388 :     }
; 2389 : 
; 2390 :     template <class _Iter>
; 2391 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2392 :         // initialize from [_First, _Last), input iterators
; 2393 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2394 :         for (; _First != _Last; ++_First) {
; 2395 :             push_back(*_First);
; 2396 :         }
; 2397 : 
; 2398 :         _Guard._Target = nullptr;
; 2399 :     }
; 2400 : 
; 2401 :     template <class _Iter>
; 2402 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2403 :         // initialize from [_First, _Last), forward iterators
; 2404 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2405 :         reserve(_Count);
; 2406 :         _Construct(_First, _Last, input_iterator_tag());
; 2407 :     }
; 2408 : 
; 2409 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2410 :         // initialize from [_First, _Last), pointers
; 2411 :         if (_First != _Last) {
; 2412 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2413 :         }
; 2414 :     }
; 2415 : 
; 2416 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2417 :         // initialize from [_First, _Last), const pointers
; 2418 :         if (_First != _Last) {
; 2419 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2420 :         }
; 2421 :     }
; 2422 : 
; 2423 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) {
; 2424 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2425 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2426 :     }
; 2427 : 
; 2428 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2429 :         _Alty_traits::is_always_equal::value) // strengthened
; 2430 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2431 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2432 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2433 :         if
; 2434 :             _CONSTEXPR_IF(!_Alty_traits::is_always_equal::value) {
; 2435 :                 if (_Getal() != _Right._Getal()) {
; 2436 :                     _Construct_lv_contents(_Right);
; 2437 :                     _Proxy._Release();
; 2438 :                     return;
; 2439 :                 }
; 2440 :             }
; 2441 : 
; 2442 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2443 :         _Proxy._Release();
; 2444 :     }
; 2445 : 
; 2446 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2447 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2448 :         : _Mypair(
; 2449 :             _One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {
; 2450 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2451 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2452 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2453 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);
; 2454 :         size_type _New_capacity = _BUF_SIZE - 1;
; 2455 :         auto& _My_data          = _Mypair._Myval2;
; 2456 :         _Elem* _Ptr             = _My_data._Bx._Buf;
; 2457 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2458 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2459 :         if (_New_capacity < _New_size) {
; 2460 :             _New_capacity           = _Calculate_growth(_New_size, _BUF_SIZE - 1, max_size());
; 2461 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws
; 2462 :             _Ptr                    = _Unfancy(_Fancyptr);
; 2463 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
; 2464 :         }
; 2465 : 
; 2466 :         _My_data._Mysize = _New_size;
; 2467 :         _My_data._Myres  = _New_capacity;
; 2468 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2469 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
; 2470 :         _Traits::assign(_Ptr[_New_size], _Elem());
; 2471 :         _Proxy._Release();
; 2472 :     }
; 2473 : 
; 2474 :     basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
; 2475 :         : _Mypair(_One_then_variadic_args_t(), _Left._Getal()) {
; 2476 :         auto& _My_data    = _Mypair._Myval2;
; 2477 :         auto& _Left_data  = _Left._Mypair._Myval2;
; 2478 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2479 :         _Left_data._Orphan_all();
; 2480 :         _Right_data._Orphan_all();
; 2481 :         const auto _Left_size  = _Left_data._Mysize;
; 2482 :         const auto _Right_size = _Right_data._Mysize;
; 2483 : 
; 2484 :         const auto _Left_capacity  = _Left_data._Myres;
; 2485 :         const auto _Right_capacity = _Right_data._Myres;
; 2486 :         // overflow is OK due to max_size() checks:
; 2487 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);
; 2488 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
; 2489 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
; 2490 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 2491 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2492 :             _Take_contents(_Left, bool_constant<_Can_memcpy_val>{});
; 2493 :             const auto _Ptr = _My_data._Myptr();
; 2494 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
; 2495 :             _My_data._Mysize = _New_size;
; 2496 :             return;
; 2497 :         }
; 2498 : 
; 2499 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
; 2500 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
; 2501 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 2502 :             // At this point, we have tested:
; 2503 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 2504 :             // therefore: (by De Morgan's Laws)
; 2505 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 2506 :             // therefore: (by the distributive property)
; 2507 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 2508 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 2509 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_string_engaged()
; 2510 :             _STL_INTERNAL_CHECK(_Right_data._Large_string_engaged());
; 2511 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2512 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2513 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
; 2514 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
; 2515 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2516 :             _My_data._Mysize = _New_size;
; 2517 :             return;
; 2518 :         }
; 2519 : 
; 2520 :         // can't use either buffer, reallocate
; 2521 :         const auto _Max = max_size();
; 2522 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK
; 2523 :             _Xlen_string();
; 2524 :         }
; 2525 : 
; 2526 :         const auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);
; 2527 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2528 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2529 :         const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws
; 2530 :         // nothrow hereafter
; 2531 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
; 2532 :         _My_data._Mysize = _New_size;
; 2533 :         _My_data._Myres  = _New_capacity;
; 2534 :         const auto _Ptr  = _Unfancy(_Fancyptr);
; 2535 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2536 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
; 2537 :         _Proxy._Release();
; 2538 :     }
; 2539 : 
; 2540 : #if _HAS_CXX17
; 2541 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2542 :     explicit basic_string(const _StringViewIsh& _Right, const _Alloc& _Al = _Alloc())
; 2543 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2544 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2545 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2546 :         _Tidy_init();
; 2547 :         assign(_Right);
; 2548 :         _Proxy._Release();
; 2549 :     }
; 2550 : 
; 2551 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2552 :     basic_string(
; 2553 :         const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2554 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count) using _Al
; 2555 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2556 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2557 :         _Tidy_init();
; 2558 :         assign(_Right, _Roff, _Count);
; 2559 :         _Proxy._Release();
; 2560 :     }
; 2561 : #endif // _HAS_CXX17
; 2562 : 
; 2563 : private:
; 2564 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {
; 2565 :         _Tidy_deallocate();
; 2566 :         _Pocma(_Getal(), _Right._Getal());
; 2567 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2568 :     }
; 2569 : 
; 2570 :     void _Move_assign(basic_string& _Right, _Propagate_allocators) noexcept {
; 2571 :         if (_Getal() == _Right._Getal()) {
; 2572 :             _Move_assign(_Right, _Equal_allocators{});
; 2573 :         } else {
; 2574 :             // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2575 :             _Mypair._Myval2._Orphan_all();
; 2576 :             _Mypair._Myval2._Reload_proxy(
; 2577 :                 _GET_PROXY_ALLOCATOR(_Alty, _Getal()), _GET_PROXY_ALLOCATOR(_Alty, _Right._Getal()));
; 2578 :             _Pocma(_Getal(), _Right._Getal());
; 2579 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2580 :         }
; 2581 :     }
; 2582 : 
; 2583 :     void _Move_assign(basic_string& _Right, _No_propagate_allocators) {
; 2584 :         if (_Getal() == _Right._Getal()) {
; 2585 :             _Move_assign(_Right, _Equal_allocators{});
; 2586 :         } else {
; 2587 :             assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2588 :         }
; 2589 :     }
; 2590 : 
; 2591 : public:
; 2592 :     basic_string& operator=(basic_string&& _Right) noexcept(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
; 2593 :         if (this != _STD addressof(_Right)) {
; 2594 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});
; 2595 :         }
; 2596 : 
; 2597 :         return *this;
; 2598 :     }
; 2599 : 
; 2600 :     basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = _STD move(_Right))) {
; 2601 :         *this = _STD move(_Right);
; 2602 :         return *this;
; 2603 :     }
; 2604 : 
; 2605 : private:
; 2606 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {
; 2607 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2608 :         const auto _My_data_mem =
; 2609 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2610 :         const auto _Right_data_mem =
; 2611 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
; 2613 :     }
; 2614 : 
; 2615 :     void _Take_contents(basic_string& _Right, true_type) noexcept {
; 2616 :         // assign by stealing _Right's buffer, memcpy optimization
; 2617 :         // pre: this != &_Right
; 2618 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2619 :         // pre: *this owns no memory, iterators orphaned (note:
; 2620 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2621 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2622 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2623 :             // take ownership of _Right's iterators along with its buffer
; 2624 :             _Swap_proxy_and_iterators(_Right);
; 2625 :         } else {
; 2626 :             _Right._Mypair._Myval2._Orphan_all();
; 2627 :         }
; 2628 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2629 : 
; 2630 :         _Memcpy_val_from(_Right);
; 2631 :         _Right._Tidy_init();
; 2632 :     }
; 2633 : 
; 2634 :     void _Take_contents(basic_string& _Right, false_type) noexcept {
; 2635 :         // assign by stealing _Right's buffer, general case
; 2636 :         // pre: this != &_Right
; 2637 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2638 :         // pre: *this owns no memory, iterators orphaned
; 2639 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2640 :         auto& _My_data    = _Mypair._Myval2;
; 2641 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2642 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 2643 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 2644 :             _Right_data._Bx._Ptr = pointer();
; 2645 :             _Swap_proxy_and_iterators(_Right);
; 2646 :         } else { // copy small string buffer
; 2647 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 2648 :             _Right_data._Orphan_all();
; 2649 :         }
; 2650 : 
; 2651 :         _My_data._Mysize = _Right_data._Mysize;
; 2652 :         _My_data._Myres  = _Right_data._Myres;
; 2653 :         _Right._Tidy_init();
; 2654 :     }
; 2655 : 
; 2656 :     void _Construct_lv_contents(const basic_string& _Right) {
; 2657 :         // assign by copying data stored in _Right
; 2658 :         // pre: this != &_Right
; 2659 :         // pre: *this owns no memory, iterators orphaned (note:
; 2660 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2661 :         auto& _Right_data             = _Right._Mypair._Myval2;
; 2662 :         const size_type _Right_size   = _Right_data._Mysize;
; 2663 :         const _Elem* const _Right_ptr = _Right_data._Myptr();
; 2664 :         auto& _My_data                = _Mypair._Myval2;
; 2665 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate
; 2666 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
; 2667 :             _My_data._Mysize = _Right_size;
; 2668 :             _My_data._Myres  = _BUF_SIZE - 1;
; 2669 :             return;
; 2670 :         }
; 2671 : 
; 2672 :         auto& _Al                     = _Getal();
; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());
; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws
; 2675 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);
; 2676 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
; 2677 :         _My_data._Mysize = _Right_size;
; 2678 :         _My_data._Myres  = _New_capacity;
; 2679 :     }
; 2680 : 
; 2681 : public:
; 2682 :     basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
; 2683 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2684 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2685 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2686 :         _Tidy_init();
; 2687 :         assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2688 :         _Proxy._Release();
; 2689 :     }
; 2690 : 
; 2691 :     basic_string& operator=(initializer_list<_Elem> _Ilist) {
; 2692 :         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2693 :     }
; 2694 : 
; 2695 :     basic_string& operator+=(initializer_list<_Elem> _Ilist) {
; 2696 :         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2697 :     }
; 2698 : 
; 2699 :     basic_string& assign(initializer_list<_Elem> _Ilist) {
; 2700 :         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2701 :     }
; 2702 : 
; 2703 :     basic_string& append(initializer_list<_Elem> _Ilist) {
; 2704 :         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2705 :     }
; 2706 : 
; 2707 :     iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) {
; 2708 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2709 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 2710 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2711 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 2712 :         insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2713 :         return begin() + static_cast<difference_type>(_Off);
; 2714 :     }
; 2715 : 
; 2716 :     basic_string& replace(
; 2717 :         const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
; 2718 :         // replace with initializer_list
; 2719 :         _Adl_verify_range(_First, _Last);
; 2720 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2721 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 2722 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2723 :         const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
; 2724 :         const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
; 2725 :         return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2726 :     }
; 2727 : 
; 2728 :     ~basic_string() noexcept {
; 2729 :         _Tidy_deallocate();
; 2730 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2731 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2732 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2733 :         _Mypair._Myval2._Myproxy = nullptr;
; 2734 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2735 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2736 :     }
; 2737 : 
; 2738 :     static constexpr auto npos{static_cast<size_type>(-1)};
; 2739 : 
; 2740 : private:
; 2741 :     void _Copy_assign_val_from_small(const basic_string& _Right) {
; 2742 :         // TRANSITION, VSO-761321; inline into only caller when that's fixed
; 2743 :         _Tidy_deallocate();
; 2744 :         if
; 2745 :             _CONSTEXPR_IF(_Can_memcpy_val) {
; 2746 :                 _Memcpy_val_from(_Right);
; 2747 :             }
; 2748 :         else {
; 2749 :             _Traits::copy(
; 2750 :                 _Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Mysize + 1);
; 2751 :             _Mypair._Myval2._Mysize = _Right._Mypair._Myval2._Mysize;
; 2752 :             _Mypair._Myval2._Myres  = _Right._Mypair._Myval2._Myres;
; 2753 :         }
; 2754 :     }
; 2755 : 
; 2756 :     void _Copy_assign(const basic_string& _Right, false_type) {
; 2757 :         _Pocca(_Getal(), _Right._Getal());
; 2758 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2759 :     }
; 2760 : 
; 2761 :     void _Copy_assign(const basic_string& _Right, true_type) {
; 2762 :         auto& _Al             = _Getal();
; 2763 :         const auto& _Right_al = _Right._Getal();
; 2764 :         if (_Al == _Right_al) {
; 2765 :             _Copy_assign(_Right, false_type{});
; 2766 :             return;
; 2767 :         }
; 2768 : 
; 2769 :         auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2770 :         auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 2771 :         _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 2772 : 
; 2773 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2774 :             const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 2775 :             const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 2776 :             auto _Right_al_non_const = _Right_al;
; 2777 :             const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity); // throws
; 2778 :             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 2779 :             _Tidy_deallocate();
; 2780 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 2781 :             _Mypair._Myval2._Mysize  = _New_size;
; 2782 :             _Mypair._Myval2._Myres   = _New_capacity;
; 2783 :         } else {
; 2784 :             _Copy_assign_val_from_small(_Right);
; 2785 :         }
; 2786 : 
; 2787 :         _Pocca(_Al, _Right_al);
; 2788 :         _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 2789 :     }
; 2790 : 
; 2791 : public:
; 2792 :     basic_string& operator=(const basic_string& _Right) {
; 2793 :         if (this != _STD addressof(_Right)) {
; 2794 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});
; 2795 :         }
; 2796 : 
; 2797 :         return *this;
; 2798 :     }
; 2799 : 
; 2800 : #if _HAS_CXX17
; 2801 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2802 :     basic_string& operator=(const _StringViewIsh& _Right) {
; 2803 :         return assign(_Right);
; 2804 :     }
; 2805 : #endif // _HAS_CXX17
; 2806 : 
; 2807 :     basic_string& operator=(_In_z_ const _Elem* const _Ptr) {
; 2808 :         return assign(_Ptr);
; 2809 :     }
; 2810 : 
; 2811 :     basic_string& operator=(const _Elem _Ch) { // assign {_Ch, _Elem()}
; 2812 :         _Mypair._Myval2._Mysize = 1;
; 2813 :         _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 2814 :         _Traits::assign(_Ptr[0], _Ch);
; 2815 :         _Traits::assign(_Ptr[1], _Elem());
; 2816 :         return *this;
; 2817 :     }
; 2818 : 
; 2819 :     basic_string& operator+=(const basic_string& _Right) {
; 2820 :         return append(_Right);
; 2821 :     }
; 2822 : 
; 2823 : #if _HAS_CXX17
; 2824 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2825 :     basic_string& operator+=(const _StringViewIsh& _Right) {
; 2826 :         return append(_Right);
; 2827 :     }
; 2828 : #endif // _HAS_CXX17
; 2829 : 
; 2830 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
; 2831 :         return append(_Ptr);
; 2832 :     }
; 2833 : 
; 2834 :     basic_string& operator+=(_Elem _Ch) {
; 2835 :         push_back(_Ch);
; 2836 :         return *this;
; 2837 :     }
; 2838 : 
; 2839 :     basic_string& append(const basic_string& _Right) {
; 2840 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2841 :     }
; 2842 : 
; 2843 :     basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 2844 :         // append _Right [_Roff, _Roff + _Count)
; 2845 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 2846 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 2847 :         return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 2848 :     }
; 2849 : 
; 2850 : #if _HAS_CXX17
; 2851 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2852 :     basic_string& append(const _StringViewIsh& _Right) {
; 2853 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2854 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2855 :     }
; 2856 : 
; 2857 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2858 :     basic_string& append(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
; 2859 :         // append _Right [_Roff, _Roff + _Count)
; 2860 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2861 :         return append(_As_view.substr(_Roff, _Count));
; 2862 :     }
; 2863 : #endif // _HAS_CXX17
; 2864 : 
; 2865 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 2866 :         // append [_Ptr, _Ptr + _Count)
; 2867 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 2870 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2871 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
; 2872 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
; 2873 :             return *this;
; 2874 :         }
; 2875 : 
; 2876 :         return _Reallocate_grow_by(
; 2877 :             _Count,
; 2878 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2879 :                 const size_type _Count) {
; 2880 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2881 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2882 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2883 :             },
; 2884 :             _Ptr, _Count);
; 2885 :     }
; 2886 : 
; 2887 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
; 2888 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 2889 :     }
; 2890 : 
; 2891 :     basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // append _Count * _Ch
; 2892 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2893 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 2894 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 2895 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2896 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
; 2897 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
; 2898 :             return *this;
; 2899 :         }
; 2900 : 
; 2901 :         return _Reallocate_grow_by(
; 2902 :             _Count,
; 2903 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2904 :                 const _Elem _Ch) {
; 2905 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2906 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2907 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2908 :             },
; 2909 :             _Count, _Ch);
; 2910 :     }
; 2911 : 
; 2912 : #if _HAS_IF_CONSTEXPR
; 2913 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2914 :     basic_string& append(const _Iter _First, const _Iter _Last) { // append [_First, _Last), input iterators
; 2915 :         _Adl_verify_range(_First, _Last);
; 2916 :         const auto _UFirst = _Get_unwrapped(_First);
; 2917 :         const auto _ULast  = _Get_unwrapped(_Last);
; 2918 :         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2919 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2920 :         } else {
; 2921 :             const basic_string _Right(_UFirst, _ULast, get_allocator());
; 2922 :             return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2923 :         }
; 2924 :     }
; 2925 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 2926 :     template <class _Iter>
; 2927 :     basic_string& _Append_range(const _Iter _UFirst, const _Iter _ULast, true_type) {
; 2928 :         return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2929 :     }
; 2930 : 
; 2931 :     template <class _Iter>
; 2932 :     basic_string& _Append_range(const _Iter _UFirst, const _Iter _ULast, false_type) {
; 2933 :         const basic_string _Right(_UFirst, _ULast, get_allocator());
; 2934 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2935 :     }
; 2936 : 
; 2937 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2938 :     basic_string& append(const _Iter _First, const _Iter _Last) { // append [_First, _Last), input iterators {
; 2939 :         _Adl_verify_range(_First, _Last);
; 2940 :         const auto _UFirst = _Get_unwrapped(_First);
; 2941 :         return _Append_range(_UFirst, _Get_unwrapped(_Last), _Is_elem_cptr<decltype(_UFirst)>{});
; 2942 :     }
; 2943 : #endif // _HAS_IF_CONSTEXPR
; 2944 : 
; 2945 :     basic_string& assign(const basic_string& _Right) {
; 2946 :         *this = _Right;
; 2947 :         return *this;
; 2948 :     }
; 2949 : 
; 2950 :     basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 2951 :         // assign _Right [_Roff, _Roff + _Count)
; 2952 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 2953 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 2954 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 2955 :     }
; 2956 : 
; 2957 : #if _HAS_CXX17
; 2958 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2959 :     basic_string& assign(const _StringViewIsh& _Right) {
; 2960 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2961 :         return assign(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2962 :     }
; 2963 : 
; 2964 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2965 :     basic_string& assign(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
; 2966 :         // assign _Right [_Roff, _Roff + _Count)
; 2967 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2968 :         return assign(_As_view.substr(_Roff, _Count));
; 2969 :     }
; 2970 : #endif // _HAS_CXX17
; 2971 : 
; 2972 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 2973 :         // assign [_Ptr, _Ptr + _Count)
; 2974 :         if (_Count <= _Mypair._Myval2._Myres) {
; 2975 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2976 :             _Mypair._Myval2._Mysize = _Count;
; 2977 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 2978 :             _Traits::assign(_Old_ptr[_Count], _Elem());
; 2979 :             return *this;
; 2980 :         }
; 2981 : 
; 2982 :         return _Reallocate_for(
; 2983 :             _Count,
; 2984 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2985 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2987 :             },
; 2988 :             _Ptr);
; 2989 :     }
; 2990 : 
; 2991 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {
; 2992 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 2993 :     }
; 2994 : 
; 2995 :     basic_string& assign(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // assign _Count * _Ch
; 2996 :         if (_Count <= _Mypair._Myval2._Myres) {
; 2997 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2998 :             _Mypair._Myval2._Mysize = _Count;
; 2999 :             _Traits::assign(_Old_ptr, _Count, _Ch);
; 3000 :             _Traits::assign(_Old_ptr[_Count], _Elem());
; 3001 :             return *this;
; 3002 :         }
; 3003 : 
; 3004 :         return _Reallocate_for(
; 3005 :             _Count,
; 3006 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
; 3007 :                 _Traits::assign(_New_ptr, _Count, _Ch);
; 3008 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3009 :             },
; 3010 :             _Ch);
; 3011 :     }
; 3012 : 
; 3013 : #if _HAS_IF_CONSTEXPR
; 3014 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3015 :     basic_string& assign(const _Iter _First, const _Iter _Last) {
; 3016 :         _Adl_verify_range(_First, _Last);
; 3017 :         const auto _UFirst = _Get_unwrapped(_First);
; 3018 :         const auto _ULast  = _Get_unwrapped(_Last);
; 3019 :         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 3020 :             return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3021 :         } else {
; 3022 :             basic_string _Right(_UFirst, _ULast, get_allocator());
; 3023 :             if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
; 3024 :                 _Mypair._Myval2._Orphan_all();
; 3025 :                 _Swap_data(_Right, bool_constant<_Can_memcpy_val>{});
; 3026 :                 return *this;
; 3027 :             } else {
; 3028 :                 return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3029 :             }
; 3030 :         }
; 3031 :     }
; 3032 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 3033 :     template <class _Iter>
; 3034 :     basic_string& _Assign_range(const _Iter _UFirst, const _Iter _ULast, true_type) {
; 3035 :         return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3036 :     }
; 3037 : 
; 3038 :     template <class _Iter>
; 3039 :     basic_string& _Assign_range(const _Iter _UFirst, const _Iter _ULast, false_type) {
; 3040 :         basic_string _Right(_UFirst, _ULast, get_allocator());
; 3041 :         if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
; 3042 :             _Mypair._Myval2._Orphan_all();
; 3043 :             _Swap_data(_Right, bool_constant<_Can_memcpy_val>{});
; 3044 :             return *this;
; 3045 :         } else {
; 3046 :             return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3047 :         }
; 3048 :     }
; 3049 : 
; 3050 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3051 :     basic_string& assign(const _Iter _First, const _Iter _Last) {
; 3052 :         _Adl_verify_range(_First, _Last);
; 3053 :         const auto _UFirst = _Get_unwrapped(_First);
; 3054 :         return _Assign_range(_UFirst, _Get_unwrapped(_Last), _Is_elem_cptr<decltype(_UFirst)>{});
; 3055 :     }
; 3056 : #endif // _HAS_IF_CONSTEXPR
; 3057 : 
; 3058 :     basic_string& insert(const size_type _Off, const basic_string& _Right) { // insert _Right at _Off
; 3059 :         return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3060 :     }
; 3061 : 
; 3062 :     basic_string& insert(
; 3063 :         const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 3064 :         // insert _Right [_Roff, _Roff + _Count) at _Off
; 3065 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 3066 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 3067 :         return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 3068 :     }
; 3069 : 
; 3070 : #if _HAS_CXX17
; 3071 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3072 :     basic_string& insert(const size_type _Off, const _StringViewIsh& _Right) { // insert _Right at _Off
; 3073 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3074 :         return insert(_Off, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 3075 :     }
; 3076 : 
; 3077 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3078 :     basic_string& insert(const size_type _Off, const _StringViewIsh& _Right, const size_type _Roff,
; 3079 :         const size_type _Count = npos) { // insert _Right [_Roff, _Roff + _Count) at _Off
; 3080 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3081 :         return insert(_Off, _As_view.substr(_Roff, _Count));
; 3082 :     }
; 3083 : #endif // _HAS_CXX17
; 3084 : 
; 3085 :     basic_string& insert(
; 3086 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 3087 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 3088 :         _Mypair._Myval2._Check_offset(_Off);
; 3089 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3090 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 3091 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 3092 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3093 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3094 :             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
; 3095 :             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
; 3096 :             size_type _Ptr_shifted_after;
; 3097 :             if (_Ptr + _Count <= _Insert_at
; 3098 :                 || _Ptr > _Old_ptr + _Old_size) { // inserted content is before the shifted region, or does not alias
; 3099 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts
; 3100 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts
; 3101 :                 _Ptr_shifted_after = 0;
; 3102 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
; 3103 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
; 3104 :             }
; 3105 : 
; 3106 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
; 3107 :             _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
; 3108 :             _Traits::copy(
; 3109 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 3110 :             return *this;
; 3111 :         }
; 3112 : 
; 3113 :         return _Reallocate_grow_by(
; 3114 :             _Count,
; 3115 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3116 :                 const _Elem* const _Ptr, const size_type _Count) {
; 3117 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3118 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3119 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3120 :             },
; 3121 :             _Off, _Ptr, _Count);
; 3122 :     }
; 3123 : 
; 3124 :     basic_string& insert(const size_type _Off, _In_z_ const _Elem* const _Ptr) { // insert [_Ptr, <null>) at _Off
; 3125 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 3126 :     }
; 3127 : 
; 3128 :     basic_string& insert(const size_type _Off, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
; 3129 :         // insert _Count * _Ch at _Off
; 3130 :         _Mypair._Myval2._Check_offset(_Off);
; 3131 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3132 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 3133 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 3134 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3135 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3136 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
; 3137 :             _Traits::assign(_Insert_at, _Count, _Ch); // fill hole
; 3138 :             return *this;
; 3139 :         }
; 3140 : 
; 3141 :         return _Reallocate_grow_by(
; 3142 :             _Count,
; 3143 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3144 :                 const size_type _Count, const _Elem _Ch) {
; 3145 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3146 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 3147 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3148 :             },
; 3149 :             _Off, _Count, _Ch);
; 3150 :     }
; 3151 : 
; 3152 :     iterator insert(const const_iterator _Where, const _Elem _Ch) { // insert _Ch at _Where
; 3153 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3154 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3155 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3156 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3157 :         insert(_Off, 1, _Ch);
; 3158 :         return begin() + static_cast<difference_type>(_Off);
; 3159 :     }
; 3160 : 
; 3161 :     iterator insert(const const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
; 3162 :         // insert _Count * _Elem at _Where
; 3163 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3164 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3165 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3166 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3167 :         insert(_Off, _Count, _Ch);
; 3168 :         return begin() + static_cast<difference_type>(_Off);
; 3169 :     }
; 3170 : 
; 3171 : #if _HAS_IF_CONSTEXPR
; 3172 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3173 :     iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
; 3174 :         // insert [_First, _Last) at _Where, input iterators
; 3175 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3176 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3177 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3178 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3179 :         _Adl_verify_range(_First, _Last);
; 3180 :         const auto _UFirst = _Get_unwrapped(_First);
; 3181 :         const auto _ULast  = _Get_unwrapped(_Last);
; 3182 :         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 3183 :             insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3184 :         } else {
; 3185 :             const basic_string _Right(_UFirst, _ULast, get_allocator());
; 3186 :             insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3187 :         }
; 3188 : 
; 3189 :         return begin() + static_cast<difference_type>(_Off);
; 3190 :     }
; 3191 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 3192 :     template <class _Iter>
; 3193 :     void _Insert_range(const size_type _Off, const _Iter _UFirst, const _Iter _ULast, true_type) {
; 3194 :         insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3195 :     }
; 3196 : 
; 3197 :     template <class _Iter>
; 3198 :     void _Insert_range(const size_type _Off, const _Iter _UFirst, const _Iter _ULast, false_type) {
; 3199 :         const basic_string _Right(_UFirst, _ULast, get_allocator());
; 3200 :         insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3201 :     }
; 3202 : 
; 3203 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3204 :     iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
; 3205 :         // insert [_First, _Last) at _Where, input iterators
; 3206 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3207 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3208 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3209 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3210 :         _Adl_verify_range(_First, _Last);
; 3211 :         const auto _UFirst = _Get_unwrapped(_First);
; 3212 :         _Insert_range(_Off, _UFirst, _Get_unwrapped(_Last), _Is_elem_cptr<decltype(_UFirst)>{});
; 3213 :         return begin() + static_cast<difference_type>(_Off);
; 3214 :     }
; 3215 : #endif // _HAS_IF_CONSTEXPR
; 3216 : 
; 3217 :     basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)
; 3218 :         _Mypair._Myval2._Check_offset(_Off);
; 3219 :         _Eos(_Off);
; 3220 :         return *this;
; 3221 :     }
; 3222 : 
; 3223 :     basic_string& erase(const size_type _Off, size_type _Count) { // erase elements [_Off, _Off + _Count)
; 3224 :         _Mypair._Myval2._Check_offset(_Off);
; 3225 :         _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
; 3226 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3227 :         _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
; 3228 :         _Elem* const _Erase_at    = _My_ptr + _Off;
; 3229 :         const size_type _New_size = _Old_size - _Count;
; 3230 :         _Mypair._Myval2._Mysize   = _New_size;
; 3231 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up
; 3232 :         return *this;
; 3233 :     }
; 3234 : 
; 3235 :     iterator erase(const const_iterator _Where) noexcept /* strengthened */ {
; 3236 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3237 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3238 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3239 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3240 :         erase(_Off, 1);
; 3241 :         return begin() + static_cast<difference_type>(_Off);
; 3242 :     }
; 3243 : 
; 3244 :     iterator erase(const const_iterator _First, const const_iterator _Last) noexcept /* strengthened */ {
; 3245 :         _Adl_verify_range(_First, _Last);
; 3246 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3247 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3248 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3249 :         const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
; 3250 :         erase(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
; 3251 :         return begin() + static_cast<difference_type>(_Off);
; 3252 :     }
; 3253 : 
; 3254 :     void clear() noexcept { // erase all
; 3255 :         _Eos(0);
; 3256 :     }
; 3257 : 
; 3258 :     basic_string& replace(const size_type _Off, const size_type _N0, const basic_string& _Right) {
; 3259 :         // replace [_Off, _Off + _N0) with _Right
; 3260 :         return replace(_Off, _N0, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3261 :     }
; 3262 : 
; 3263 :     basic_string& replace(const size_type _Off, size_type _N0, const basic_string& _Right, const size_type _Roff,
; 3264 :         size_type _Count = npos) {
; 3265 :         // replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 3266 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 3267 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 3268 :         return replace(_Off, _N0, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 3269 :     }
; 3270 : 
; 3271 : #if _HAS_CXX17
; 3272 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3273 :     basic_string& replace(const size_type _Off, const size_type _N0, const _StringViewIsh& _Right) {
; 3274 :         // replace [_Off, _Off + _N0) with _Right
; 3275 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3276 :         return replace(_Off, _N0, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 3277 :     }
; 3278 : 
; 3279 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3280 :     basic_string& replace(const size_type _Off, const size_type _N0, const _StringViewIsh& _Right,
; 3281 :         const size_type _Roff, const size_type _Count = npos) {
; 3282 :         // replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 3283 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3284 :         return replace(_Off, _N0, _As_view.substr(_Roff, _Count));
; 3285 :     }
; 3286 : #endif // _HAS_CXX17
; 3287 : 
; 3288 :     basic_string& replace(
; 3289 :         const size_type _Off, size_type _N0, _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {
; 3290 :         // replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 3291 :         _Mypair._Myval2._Check_offset(_Off);
; 3292 :         _N0 = _Mypair._Myval2._Clamp_suffix_size(_Off, _N0);
; 3293 :         if (_N0 == _Count) { // size doesn't change, so a single move does the trick
; 3294 :             _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
; 3295 :             return *this;
; 3296 :         }
; 3297 : 
; 3298 :         const size_type _Old_size    = _Mypair._Myval2._Mysize;
; 3299 :         const size_type _Suffix_size = _Old_size - _N0 - _Off + 1;
; 3300 :         if (_Count < _N0) { // suffix shifts backwards; we don't have to move anything out of the way
; 3301 :             _Mypair._Myval2._Mysize = _Old_size - (_N0 - _Count);
; 3302 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3303 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3304 :             _Traits::move(_Insert_at, _Ptr, _Count);
; 3305 :             _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Suffix_size);
; 3306 :             return *this;
; 3307 :         }
; 3308 : 
; 3309 :         const size_type _Growth = static_cast<size_type>(_Count - _N0);
; 3310 :         if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { // growth fits
; 3311 :             _Mypair._Myval2._Mysize = _Old_size + _Growth;
; 3312 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3313 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3314 :             _Elem* const _Suffix_at = _Insert_at + _N0;
; 3315 : 
; 3316 :             size_type _Ptr_shifted_after; // see rationale in insert
; 3317 :             if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
; 3318 :                 _Ptr_shifted_after = _Count;
; 3319 :             } else if (_Suffix_at <= _Ptr) {
; 3320 :                 _Ptr_shifted_after = 0;
; 3321 :             } else {
; 3322 :                 _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
; 3323 :             }
; 3324 : 
; 3325 :             _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
; 3326 :             // next case must be move, in case _Ptr begins before _Insert_at and contains part of the hole;
; 3327 :             // this case doesn't occur in insert because the new content must come from outside the removed
; 3328 :             // content there (because in insert there is no removed content)
; 3329 :             _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
; 3330 :             // the next case can be copy, because it comes from the chunk moved out of the way in the
; 3331 :             // first move, and the hole we're filling can't alias the chunk we moved out of the way
; 3332 :             _Traits::copy(
; 3333 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 3334 :             return *this;
; 3335 :         }
; 3336 : 
; 3337 :         return _Reallocate_grow_by(
; 3338 :             _Growth,
; 3339 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3340 :                 const size_type _N0, const _Elem* const _Ptr, const size_type _Count) {
; 3341 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3342 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3343 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
; 3344 :             },
; 3345 :             _Off, _N0, _Ptr, _Count);
; 3346 :     }
; 3347 : 
; 3348 :     basic_string& replace(const size_type _Off, const size_type _N0, _In_z_ const _Elem* const _Ptr) {
; 3349 :         // replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 3350 :         return replace(_Off, _N0, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 3351 :     }
; 3352 : 
; 3353 :     basic_string& replace(const size_type _Off, size_type _N0, const size_type _Count, const _Elem _Ch) {
; 3354 :         // replace [_Off, _Off + _N0) with _Count * _Ch
; 3355 :         _Mypair._Myval2._Check_offset(_Off);
; 3356 :         _N0 = _Mypair._Myval2._Clamp_suffix_size(_Off, _N0);
; 3357 :         if (_Count == _N0) {
; 3358 :             _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
; 3359 :             return *this;
; 3360 :         }
; 3361 : 
; 3362 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3363 :         if (_Count < _N0
; 3364 :             || _Count - _N0 <= _Mypair._Myval2._Myres - _Old_size) { // either we are shrinking, or the growth fits
; 3365 :             _Mypair._Myval2._Mysize = _Old_size + _Count - _N0; // may temporarily overflow;
; 3366 :                                                                 // OK because size_type must be unsigned
; 3367 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3368 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3369 :             _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Old_size - _N0 - _Off + 1);
; 3370 :             _Traits::assign(_Insert_at, _Count, _Ch);
; 3371 :             return *this;
; 3372 :         }
; 3373 : 
; 3374 :         return _Reallocate_grow_by(
; 3375 :             _Count - _N0,
; 3376 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3377 :                 const size_type _N0, const size_type _Count, const _Elem _Ch) {
; 3378 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3379 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 3380 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
; 3381 :             },
; 3382 :             _Off, _N0, _Count, _Ch);
; 3383 :     }
; 3384 : 
; 3385 :     basic_string& replace(const const_iterator _First, const const_iterator _Last, const basic_string& _Right) {
; 3386 :         // replace [_First, _Last) with _Right
; 3387 :         _Adl_verify_range(_First, _Last);
; 3388 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3389 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3390 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3391 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3392 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
; 3393 :     }
; 3394 : 
; 3395 : #if _HAS_CXX17
; 3396 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3397 :     basic_string& replace(const const_iterator _First, const const_iterator _Last, const _StringViewIsh& _Right) {
; 3398 :         // replace [_First, _Last) with _Right
; 3399 :         _Adl_verify_range(_First, _Last);
; 3400 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3401 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3402 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3403 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3404 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
; 3405 :     }
; 3406 : #endif // _HAS_CXX17
; 3407 : 
; 3408 :     basic_string& replace(const const_iterator _First, const const_iterator _Last,
; 3409 :         _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {
; 3410 :         // replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 3411 :         _Adl_verify_range(_First, _Last);
; 3412 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3413 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3414 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3415 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3416 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
; 3417 :     }
; 3418 : 
; 3419 :     basic_string& replace(const const_iterator _First, const const_iterator _Last, _In_z_ const _Elem* const _Ptr) {
; 3420 :         // replace [_First, _Last) with [_Ptr, <null>)
; 3421 :         _Adl_verify_range(_First, _Last);
; 3422 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3423 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3424 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3425 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3426 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
; 3427 :     }
; 3428 : 
; 3429 :     basic_string& replace(
; 3430 :         const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch) {
; 3431 :         // replace [_First, _Last) with _Count * _Ch
; 3432 :         _Adl_verify_range(_First, _Last);
; 3433 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3434 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3435 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3436 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3437 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
; 3438 :     }
; 3439 : 
; 3440 : #if _HAS_IF_CONSTEXPR
; 3441 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3442 :     basic_string& replace(
; 3443 :         const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
; 3444 :         // replace [_First, _Last) with [_First2, _Last2), input iterators
; 3445 :         _Adl_verify_range(_First, _Last);
; 3446 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3447 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3448 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3449 :         const auto _Off    = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
; 3450 :         const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
; 3451 :         _Adl_verify_range(_First2, _Last2);
; 3452 :         const auto _UFirst2 = _Get_unwrapped(_First2);
; 3453 :         const auto _ULast2  = _Get_unwrapped(_Last2);
; 3454 :         if constexpr (_Is_elem_cptr<decltype(_UFirst2)>::value) {
; 3455 :             return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
; 3456 :         } else {
; 3457 :             const basic_string _Right(_UFirst2, _ULast2, get_allocator());
; 3458 :             return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3459 :         }
; 3460 :     }
; 3461 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 3462 :     template <class _Ptr>
; 3463 :     basic_string& _Replace_range(
; 3464 :         const size_type _Off, const size_type _Length, const _Ptr _UFirst2, const _Ptr _ULast2, true_type) {
; 3465 :         // replace [_First, _Last) with [_First2, _Last2), pointers
; 3466 :         return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
; 3467 :     }
; 3468 : 
; 3469 :     template <class _Iter>
; 3470 :     basic_string& _Replace_range(
; 3471 :         const size_type _Off, const size_type _Length, const _Iter _First2, const _Iter _Last2, false_type) {
; 3472 :         // replace [_First, _Last) with [_First2, _Last2), input iterators
; 3473 :         const basic_string _Right(_First2, _Last2, get_allocator());
; 3474 :         return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3475 :     }
; 3476 : 
; 3477 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3478 :     basic_string& replace(
; 3479 :         const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
; 3480 :         // replace [_First, _Last) with [_First2, _Last2), input iterators
; 3481 :         _Adl_verify_range(_First, _Last);
; 3482 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3483 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3484 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3485 :         _Adl_verify_range(_First2, _Last2);
; 3486 :         const auto _UFirst2 = _Get_unwrapped(_First2);
; 3487 :         const auto _ULast2 = _Get_unwrapped(_Last2);
; 3488 :         return _Replace_range(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3489 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _UFirst2, _ULast2, _Is_elem_cptr<decltype(_UFirst2)>{});
; 3490 :     }
; 3491 : #endif // _HAS_IF_CONSTEXPR
; 3492 : 
; 3493 :     _NODISCARD iterator begin() noexcept {
; 3494 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
; 3495 :     }
; 3496 : 
; 3497 :     _NODISCARD const_iterator begin() const noexcept {
; 3498 :         return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
; 3499 :     }
; 3500 : 
; 3501 :     _NODISCARD iterator end() noexcept {
; 3502 :         return iterator(
; 3503 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3504 :             _STD addressof(_Mypair._Myval2));
; 3505 :     }
; 3506 : 
; 3507 :     _NODISCARD const_iterator end() const noexcept {
; 3508 :         return const_iterator(
; 3509 :             _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3510 :             _STD addressof(_Mypair._Myval2));
; 3511 :     }
; 3512 : 
; 3513 :     _Elem* _Unchecked_begin() noexcept {
; 3514 :         return _Mypair._Myval2._Myptr();
; 3515 :     }
; 3516 : 
; 3517 :     const _Elem* _Unchecked_begin() const noexcept {
; 3518 :         return _Mypair._Myval2._Myptr();
; 3519 :     }
; 3520 : 
; 3521 :     _Elem* _Unchecked_end() noexcept {
; 3522 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
; 3523 :     }
; 3524 : 
; 3525 :     const _Elem* _Unchecked_end() const noexcept {
; 3526 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
; 3527 :     }
; 3528 : 
; 3529 :     _NODISCARD reverse_iterator rbegin() noexcept {
; 3530 :         return reverse_iterator(end());
; 3531 :     }
; 3532 : 
; 3533 :     _NODISCARD const_reverse_iterator rbegin() const noexcept {
; 3534 :         return const_reverse_iterator(end());
; 3535 :     }
; 3536 : 
; 3537 :     _NODISCARD reverse_iterator rend() noexcept {
; 3538 :         return reverse_iterator(begin());
; 3539 :     }
; 3540 : 
; 3541 :     _NODISCARD const_reverse_iterator rend() const noexcept {
; 3542 :         return const_reverse_iterator(begin());
; 3543 :     }
; 3544 : 
; 3545 :     _NODISCARD const_iterator cbegin() const noexcept {
; 3546 :         return begin();
; 3547 :     }
; 3548 : 
; 3549 :     _NODISCARD const_iterator cend() const noexcept {
; 3550 :         return end();
; 3551 :     }
; 3552 : 
; 3553 :     _NODISCARD const_reverse_iterator crbegin() const noexcept {
; 3554 :         return rbegin();
; 3555 :     }
; 3556 : 
; 3557 :     _NODISCARD const_reverse_iterator crend() const noexcept {
; 3558 :         return rend();
; 3559 :     }
; 3560 : 
; 3561 :     void shrink_to_fit() { // reduce capacity
; 3562 :         auto& _My_data = _Mypair._Myval2;
; 3563 :         if (!_My_data._Large_string_engaged()) { // can't shrink from small mode
; 3564 :             return;
; 3565 :         }
; 3566 : 
; 3567 :         if (_My_data._Mysize < _BUF_SIZE) {
; 3568 :             _Become_small();
; 3569 :             return;
; 3570 :         }
; 3571 : 
; 3572 :         const size_type _Target_capacity = _Min_value(_My_data._Mysize | _ALLOC_MASK, max_size());
; 3573 :         if (_Target_capacity < _My_data._Myres) { // worth shrinking, do it
; 3574 :             auto& _Al              = _Getal();
; 3575 :             const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); // throws
; 3576 :             _My_data._Orphan_all();
; 3577 :             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
; 3578 :             _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
; 3579 :             _My_data._Bx._Ptr = _New_ptr;
; 3580 :             _My_data._Myres   = _Target_capacity;
; 3581 :         }
; 3582 :     }
; 3583 : 
; 3584 :     _NODISCARD reference at(const size_type _Off) {
; 3585 :         _Mypair._Myval2._Check_offset_exclusive(_Off);
; 3586 :         return _Mypair._Myval2._Myptr()[_Off];
; 3587 :     }
; 3588 : 
; 3589 :     _NODISCARD const_reference at(const size_type _Off) const {
; 3590 :         _Mypair._Myval2._Check_offset_exclusive(_Off);
; 3591 :         return _Mypair._Myval2._Myptr()[_Off];
; 3592 :     }
; 3593 : 
; 3594 :     _NODISCARD reference operator[](const size_type _Off) noexcept /* strengthened */ {
; 3595 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3596 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3597 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3598 :         return _Mypair._Myval2._Myptr()[_Off];
; 3599 :     }
; 3600 : 
; 3601 :     _NODISCARD const_reference operator[](const size_type _Off) const noexcept /* strengthened */ {
; 3602 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3603 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3604 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3605 :         return _Mypair._Myval2._Myptr()[_Off];
; 3606 :     }
; 3607 : 
; 3608 : #if _HAS_CXX17
; 3609 :     /* implicit */ operator basic_string_view<_Elem, _Traits>() const noexcept {
; 3610 :         // return a string_view around *this's character-type sequence
; 3611 :         return basic_string_view<_Elem, _Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize);
; 3612 :     }
; 3613 : #endif // _HAS_CXX17
; 3614 : 
; 3615 :     void push_back(const _Elem _Ch) { // insert element at end
; 3616 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3617 :         if (_Old_size < _Mypair._Myval2._Myres) {
; 3618 :             _Mypair._Myval2._Mysize = _Old_size + 1;
; 3619 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 3620 :             _Traits::assign(_Ptr[_Old_size], _Ch);
; 3621 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 3622 :             return;
; 3623 :         }
; 3624 : 
; 3625 :         _Reallocate_grow_by(
; 3626 :             1,
; 3627 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 3628 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3629 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  00016	8a 45 14	 mov	 al, BYTE PTR __Ch$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 333  :     }
; 334  : 
; 335  :     _Pre_satisfies_(_Size_in_bytes >= _Count) static _Elem* _Copy_s(_Out_writes_all_(_Size_in_bytes)
; 336  :                                                                         _Elem* const _First1,
; 337  :         const size_t _Size_in_bytes, _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept {
; 338  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 339  :         _STL_VERIFY(_Count <= _Size_in_bytes, "invalid argument");
; 340  :         return copy(_First1, _First2, _Count);
; 341  :     }
; 342  : 
; 343  :     _NODISCARD static _CONSTEXPR17 const _Elem* find(_In_reads_(_Count) const _Elem* const _First, const size_t _Count,
; 344  :         const _Elem& _Ch) noexcept /* strengthened */ {
; 345  :         // look for _Ch in [_First, _First + _Count)
; 346  : #if _HAS_CXX17
; 347  : #ifdef __cpp_char8_t
; 348  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 349  : #if _HAS_U8_INTRINSICS
; 350  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 351  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 352  :             return _Char_traits<_Elem, _Int_type>::find(_First, _Count, _Ch);
; 353  : #endif // _HAS_U8_INTRINSICS
; 354  :         } else
; 355  : #endif // __cpp_char8_t
; 356  :         {
; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);
; 358  :         }
; 359  : #else // _HAS_CXX17
; 360  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));
; 361  : #endif // _HAS_CXX17
; 362  :     }
; 363  : 
; 364  :     static _Elem* move(_Out_writes_all_(_Count) _Elem* const _First1, _In_reads_(_Count) const _Elem* const _First2,
; 365  :         const size_t _Count) noexcept /* strengthened */ {
; 366  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));
; 368  :     }
; 369  : 
; 370  :     static _Elem* assign(_Out_writes_all_(_Count) _Elem* const _First, const size_t _Count,
; 371  :         const _Elem _Ch) noexcept /* strengthened */ {
; 372  :         // assign _Count * _Ch to [_First, ...)
; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));
; 374  :     }
; 375  : 
; 376  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {
; 377  :         _Left = _Right;
; 378  :     }
; 379  : 
; 380  :     _NODISCARD static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
; 381  :         return _Left == _Right;
; 382  :     }
; 383  : 
; 384  :     _NODISCARD static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
; 385  :         return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
; 386  :     }
; 387  : 
; 388  :     _NODISCARD static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
; 389  :         return static_cast<_Elem>(_Meta);
; 390  :     }
; 391  : 
; 392  :     _NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
; 393  :         return static_cast<unsigned char>(_Ch);
; 394  :     }
; 395  : 
; 396  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
; 397  :         return _Left == _Right;
; 398  :     }
; 399  : 
; 400  :     _NODISCARD static constexpr int_type not_eof(const int_type& _Meta) noexcept {
; 401  :         return _Meta != eof() ? _Meta : !eof();
; 402  :     }
; 403  : 
; 404  :     _NODISCARD static constexpr int_type eof() noexcept {
; 405  :         return static_cast<int_type>(EOF);
; 406  :     }
; 407  : };
; 408  : 
; 409  : #undef _HAS_U8_INTRINSICS
; 410  : 
; 411  : // STRUCT char_traits<char> (FROM <string>)
; 412  : template <>
; 413  : struct char_traits<char> : _Narrow_char_traits<char, int> {}; // properties of a string or stream char element
; 414  : 
; 415  : #ifdef __cpp_char8_t
; 416  : // STRUCT char_traits<char8_t>
; 417  : template <>
; 418  : struct char_traits<char8_t> : _Narrow_char_traits<char8_t, unsigned int> {};
; 419  : 
; 420  : #ifdef __cpp_lib_char8_t
; 421  : using u8streampos = streampos;
; 422  : #endif // __cpp_lib_char8_t
; 423  : #endif // __cpp_char8_t
; 424  : 
; 425  : template <class _Elem, class _Traits, class _SizeT>
; 426  : basic_ostream<_Elem, _Traits>& _Insert_string(
; 427  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {
; 428  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 429  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 430  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;
; 431  : 
; 432  :     _SizeT _Pad;
; 433  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
; 434  :         _Pad = 0;
; 435  :     } else {
; 436  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
; 437  :     }
; 438  : 
; 439  :     const typename _Ostr_t::sentry _Ok(_Ostr);
; 440  : 
; 441  :     if (!_Ok) {
; 442  :         _State |= _Ostr_t::badbit;
; 443  :     } else { // state okay, insert characters
; 444  :         _TRY_IO_BEGIN
; 445  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
; 446  :             for (; 0 < _Pad; --_Pad) { // pad on left
; 447  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 448  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 449  :                     break;
; 450  :                 }
; 451  :             }
; 452  :         }
; 453  : 
; 454  :         if (_State == _Ostr_t::goodbit
; 455  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
; 456  :             _State |= _Ostr_t::badbit;
; 457  :         } else {
; 458  :             for (; 0 < _Pad; --_Pad) { // pad on right
; 459  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 460  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 461  :                     break;
; 462  :                 }
; 463  :             }
; 464  :         }
; 465  : 
; 466  :         _Ostr.width(0);
; 467  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 468  :     }
; 469  : 
; 470  :     _Ostr.setstate(_State);
; 471  :     return _Ostr;
; 472  : }
; 473  : 
; 474  : // STRUCT TEMPLATE _Char_traits_eq
; 475  : template <class _Traits>
; 476  : struct _Char_traits_eq {
; 477  :     using _Elem = typename _Traits::char_type;
; 478  : 
; 479  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 480  :         return _Traits::eq(_Left, _Right);
; 481  :     }
; 482  : };
; 483  : 
; 484  : // STRUCT TEMPLATE _Char_traits_lt
; 485  : template <class _Traits>
; 486  : struct _Char_traits_lt {
; 487  :     using _Elem = typename _Traits::char_type;
; 488  : 
; 489  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 490  :         return _Traits::lt(_Left, _Right);
; 491  :     }
; 492  : };
; 493  : 
; 494  : template <class _Elem>
; 495  : struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
; 496  :     : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type { // builtin char_traits::eq behaves like equal_to<>
; 497  : };
; 498  : 
; 499  : template <class _Traits>
; 500  : using _Traits_ch_t = typename _Traits::char_type;
; 501  : 
; 502  : template <class _Traits>
; 503  : using _Traits_ptr_t = const typename _Traits::char_type*;
; 504  : 
; 505  : template <class _Traits>
; 506  : constexpr bool _Traits_equal(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 507  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
; 508  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
; 510  : }
; 511  : 
; 512  : template <class _Traits>
; 513  : constexpr int _Traits_compare(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 514  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
; 515  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 516  :     const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));
; 517  : 
; 518  :     if (_Ans != 0) {
; 519  :         return _Ans;
; 520  :     }
; 521  : 
; 522  :     if (_Left_size < _Right_size) {
; 523  :         return -1;
; 524  :     }
; 525  : 
; 526  :     if (_Left_size > _Right_size) {
; 527  :         return 1;
; 528  :     }
; 529  : 
; 530  :     return 0;
; 531  : }
; 532  : 
; 533  : template <class _Traits>
; 534  : constexpr size_t _Traits_find(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 535  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 536  :     const size_t _Needle_size) noexcept {
; 537  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 538  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
; 539  :         // xpos cannot exist, report failure
; 540  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 541  :         // 1. _Start_at <= xpos
; 542  :         // 2. xpos + _Needle_size <= _Hay_size;
; 543  :         // therefore:
; 544  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 545  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 546  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 547  :         return static_cast<size_t>(-1);
; 548  :     }
; 549  : 
; 550  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 551  :         return _Start_at;
; 552  :     }
; 553  : 
; 554  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
; 555  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 556  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
; 557  :         if (!_Match_try) { // didn't find first character; report failure
; 558  :             return static_cast<size_t>(-1);
; 559  :         }
; 560  : 
; 561  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match
; 562  :             return static_cast<size_t>(_Match_try - _Haystack);
; 563  :         }
; 564  :     }
; 565  : }
; 566  : 
; 567  : template <class _Traits>
; 568  : constexpr size_t _Traits_find_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 569  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 570  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch, at/after _Start_at
; 571  :     if (_Start_at < _Hay_size) {
; 572  :         const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
; 573  :         if (_Found_at) {
; 574  :             return static_cast<size_t>(_Found_at - _Haystack);
; 575  :         }
; 576  :     }
; 577  : 
; 578  :     return static_cast<size_t>(-1); // (npos) no match
; 579  : }
; 580  : 
; 581  : template <class _Traits>
; 582  : constexpr size_t _Traits_rfind(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 583  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 584  :     const size_t _Needle_size) noexcept {
; 585  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size) beginning before _Start_at
; 586  :     if (_Needle_size == 0) {
; 587  :         return _Min_value(_Start_at, _Hay_size); // empty string always matches
; 588  :     }
; 589  : 
; 590  :     if (_Needle_size <= _Hay_size) { // room for match, look for it
; 591  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
; 592  :             if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
; 593  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 594  :             }
; 595  : 
; 596  :             if (_Match_try == _Haystack) {
; 597  :                 break; // at beginning, no more chance for match
; 598  :             }
; 599  :         }
; 600  :     }
; 601  : 
; 602  :     return static_cast<size_t>(-1); // no match
; 603  : }
; 604  : 
; 605  : template <class _Traits>
; 606  : constexpr size_t _Traits_rfind_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 607  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 608  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
; 609  :     if (_Hay_size != 0) { // room for match, look for it
; 610  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 611  :             if (_Traits::eq(*_Match_try, _Ch)) {
; 612  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 613  :             }
; 614  : 
; 615  :             if (_Match_try == _Haystack) {
; 616  :                 break; // at beginning, no more chance for match
; 617  :             }
; 618  :         }
; 619  :     }
; 620  : 
; 621  :     return static_cast<size_t>(-1); // no match
; 622  : }
; 623  : 
; 624  : template <class _Elem, bool = _Is_character<_Elem>::value>
; 625  : class _String_bitmap { // _String_bitmap for character types
; 626  : public:
; 627  :     constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
; 628  :         // mark this bitmap such that the characters in [_First, _Last) are intended to match
; 629  :         // returns whether all inputs can be placed in the bitmap
; 630  :         for (; _First != _Last; ++_First) {
; 631  :             _Matches[static_cast<unsigned char>(*_First)] = true;
; 632  :         }
; 633  : 
; 634  :         return true;
; 635  :     }
; 636  : 
; 637  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 638  :         return _Matches[static_cast<unsigned char>(_Ch)];
; 639  :     }
; 640  : 
; 641  : private:
; 642  :     bool _Matches[256] = {};
; 643  : };
; 644  : 
; 645  : template <class _Elem>
; 646  : class _String_bitmap<_Elem, false> { // _String_bitmap for wchar_t/unsigned short/char16_t/char32_t/etc. types
; 647  : public:
; 648  :     static_assert(is_unsigned_v<_Elem>,
; 649  :         "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
; 650  :         "Visual C++ accepts other unsigned integral types as an extension.");
; 651  : 
; 652  :     constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
; 653  :         // mark this bitmap such that the characters in [_First, _Last) are intended to match
; 654  :         // returns whether all inputs can be placed in the bitmap
; 655  :         for (; _First != _Last; ++_First) {
; 656  :             const auto _Ch = *_First;
; 657  :             if (_Ch >= 256U) {
; 658  :                 return false;
; 659  :             }
; 660  : 
; 661  :             _Matches[static_cast<unsigned char>(_Ch)] = true;
; 662  :         }
; 663  : 
; 664  :         return true;
; 665  :     }
; 666  : 
; 667  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 668  :         return _Ch < 256U && _Matches[_Ch];
; 669  :     }
; 670  : 
; 671  : private:
; 672  :     bool _Matches[256] = {};
; 673  : };
; 674  : 
; 675  : template <class _Traits>
; 676  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 677  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 678  :     const size_t _Needle_size, false_type) noexcept {
; 679  :     // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 680  :     // general algorithm
; 681  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 682  :         const auto _End = _Haystack + _Hay_size;
; 683  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 684  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 685  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 686  :             }
; 687  :         }
; 688  :     }
; 689  : 
; 690  :     return static_cast<size_t>(-1); // no match
; 691  : }
; 692  : 
; 693  : template <class _Traits>
; 694  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 695  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 696  :     const size_t _Needle_size, true_type) noexcept {
; 697  :     // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 698  :     // special case for std::char_traits
; 699  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 700  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 701  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 702  :                                                                 // fall back to the serial algorithm
; 703  :             return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 704  :         }
; 705  : 
; 706  :         const auto _End = _Haystack + _Hay_size;
; 707  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 708  :             if (_Matches._Match(*_Match_try)) {
; 709  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 710  :             }
; 711  :         }
; 712  :     }
; 713  : 
; 714  :     return static_cast<size_t>(-1); // no match
; 715  : }
; 716  : 
; 717  : template <class _Traits>
; 718  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 719  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 720  :     const size_t _Needle_size, false_type) noexcept {
; 721  :     // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
; 722  :     // general algorithm
; 723  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 724  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 725  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 726  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 727  :             }
; 728  : 
; 729  :             if (_Match_try == _Haystack) {
; 730  :                 break; // at beginning, no more chance for match
; 731  :             }
; 732  :         }
; 733  :     }
; 734  : 
; 735  :     return static_cast<size_t>(-1); // no match
; 736  : }
; 737  : 
; 738  : template <class _Traits>
; 739  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 740  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 741  :     const size_t _Needle_size, true_type) noexcept {
; 742  :     // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
; 743  :     // special case for std::char_traits
; 744  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 745  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 746  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 747  :                                                                 // fall back to the serial algorithm
; 748  :             return _Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 749  :         }
; 750  : 
; 751  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 752  :             if (_Matches._Match(*_Match_try)) {
; 753  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 754  :             }
; 755  : 
; 756  :             if (_Match_try == _Haystack) {
; 757  :                 break; // at beginning, no more chance for match
; 758  :             }
; 759  :         }
; 760  :     }
; 761  : 
; 762  :     return static_cast<size_t>(-1); // no match
; 763  : }
; 764  : 
; 765  : template <class _Traits>
; 766  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 767  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 768  :     const size_t _Needle_size, false_type) noexcept {
; 769  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 770  :     // general algorithm
; 771  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 772  :         const auto _End = _Haystack + _Hay_size;
; 773  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 774  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 775  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 776  :             }
; 777  :         }
; 778  :     }
; 779  : 
; 780  :     return static_cast<size_t>(-1); // no match
; 781  : }
; 782  : 
; 783  : template <class _Traits>
; 784  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 785  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 786  :     const size_t _Needle_size, true_type) noexcept {
; 787  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 788  :     // special case for std::char_traits
; 789  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 790  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 791  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 792  :                                                                 // fall back to the serial algorithm
; 793  :             return _Traits_find_first_not_of<_Traits>(
; 794  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 795  :         }
; 796  : 
; 797  :         const auto _End = _Haystack + _Hay_size;
; 798  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 799  :             if (!_Matches._Match(*_Match_try)) {
; 800  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 801  :             }
; 802  :         }
; 803  :     }
; 804  : 
; 805  :     return static_cast<size_t>(-1); // no match
; 806  : }
; 807  : 
; 808  : template <class _Traits>
; 809  : constexpr size_t _Traits_find_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 810  :     const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 811  :     // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch, at/after _Start_at
; 812  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 813  :         const auto _End = _Haystack + _Hay_size;
; 814  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 815  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 816  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 817  :             }
; 818  :         }
; 819  :     }
; 820  : 
; 821  :     return static_cast<size_t>(-1); // no match
; 822  : }
; 823  : 
; 824  : template <class _Traits>
; 825  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 826  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 827  :     const size_t _Needle_size, false_type) noexcept {
; 828  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
; 829  :     // general algorithm
; 830  :     if (_Hay_size != 0) { // worth searching, do it
; 831  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 832  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 833  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 834  :             }
; 835  : 
; 836  :             if (_Match_try == _Haystack) {
; 837  :                 break; // at beginning, no more chance for match
; 838  :             }
; 839  :         }
; 840  :     }
; 841  : 
; 842  :     return static_cast<size_t>(-1); // no match
; 843  : }
; 844  : 
; 845  : template <class _Traits>
; 846  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 847  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 848  :     const size_t _Needle_size, true_type) noexcept {
; 849  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
; 850  :     // special case for std::char_traits
; 851  :     if (_Hay_size != 0) { // worth searching, do it
; 852  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 853  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 854  :                                                                 // fall back to the serial algorithm
; 855  :             return _Traits_find_last_not_of<_Traits>(
; 856  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 857  :         }
; 858  : 
; 859  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 860  :             if (!_Matches._Match(*_Match_try)) {
; 861  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 862  :             }
; 863  : 
; 864  :             if (_Match_try == _Haystack) {
; 865  :                 break; // at beginning, no more chance for match
; 866  :             }
; 867  :         }
; 868  :     }
; 869  : 
; 870  :     return static_cast<size_t>(-1); // no match
; 871  : }
; 872  : 
; 873  : template <class _Traits>
; 874  : constexpr size_t _Traits_rfind_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 875  :     const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 876  :     // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch before _Start_at
; 877  :     if (_Hay_size != 0) { // room for match, look for it
; 878  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 879  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 880  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 881  :             }
; 882  : 
; 883  :             if (_Match_try == _Haystack) {
; 884  :                 break; // at beginning, no more chance for match
; 885  :             }
; 886  :         }
; 887  :     }
; 888  : 
; 889  :     return static_cast<size_t>(-1); // no match
; 890  : }
; 891  : 
; 892  : 
; 893  : #if _HAS_CXX17
; 894  : // CLASS TEMPLATE _String_view_iterator
; 895  : template <class _Elem, class _Traits = char_traits<_Elem>>
; 896  : class basic_string_view;
; 897  : 
; 898  : template <class _Traits>
; 899  : class _String_view_iterator {
; 900  : public:
; 901  : #ifdef __cpp_lib_concepts
; 902  :     using iterator_concept = contiguous_iterator_tag;
; 903  : #endif // __cpp_lib_concepts
; 904  :     using iterator_category = random_access_iterator_tag;
; 905  :     using value_type        = typename _Traits::char_type;
; 906  :     using difference_type   = ptrdiff_t;
; 907  :     using pointer           = const value_type*;
; 908  :     using reference         = const value_type&;
; 909  : 
; 910  :     constexpr _String_view_iterator() noexcept = default;
; 911  : 
; 912  : private:
; 913  :     friend basic_string_view<value_type, _Traits>;
; 914  : 
; 915  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 916  :     constexpr _String_view_iterator(const pointer _Data, const size_t _Size, const size_t _Off) noexcept
; 917  :         : _Mydata(_Data), _Mysize(_Size), _Myoff(_Off) {}
; 918  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 919  :     constexpr explicit _String_view_iterator(const pointer _Ptr) noexcept : _Myptr(_Ptr) {}
; 920  : #endif // _ITERATOR_DEBUG_LEVEL
; 921  : 
; 922  : public:
; 923  :     _NODISCARD constexpr reference operator*() const noexcept {
; 924  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 925  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 926  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 927  :         return _Mydata[_Myoff];
; 928  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 929  :         return *_Myptr;
; 930  : #endif // _ITERATOR_DEBUG_LEVEL
; 931  :     }
; 932  : 
; 933  :     _NODISCARD constexpr pointer operator->() const noexcept {
; 934  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 935  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 936  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 937  :         return _Mydata + _Myoff;
; 938  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 939  :         return _Myptr;
; 940  : #endif // _ITERATOR_DEBUG_LEVEL
; 941  :     }
; 942  : 
; 943  :     constexpr _String_view_iterator& operator++() noexcept {
; 944  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 945  :         _STL_VERIFY(_Mydata, "cannot increment value-initialized string_view iterator");
; 946  :         _STL_VERIFY(_Myoff < _Mysize, "cannot increment string_view iterator past end");
; 947  :         ++_Myoff;
; 948  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 949  :         ++_Myptr;
; 950  : #endif // _ITERATOR_DEBUG_LEVEL
; 951  :         return *this;
; 952  :     }
; 953  : 
; 954  :     constexpr _String_view_iterator operator++(int) noexcept {
; 955  :         _String_view_iterator _Tmp{*this};
; 956  :         ++*this;
; 957  :         return _Tmp;
; 958  :     }
; 959  : 
; 960  :     constexpr _String_view_iterator& operator--() noexcept {
; 961  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 962  :         _STL_VERIFY(_Mydata, "cannot decrement value-initialized string_view iterator");
; 963  :         _STL_VERIFY(_Myoff != 0, "cannot decrement string_view iterator before begin");
; 964  :         --_Myoff;
; 965  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 966  :         --_Myptr;
; 967  : #endif // _ITERATOR_DEBUG_LEVEL
; 968  :         return *this;
; 969  :     }
; 970  : 
; 971  :     constexpr _String_view_iterator operator--(int) noexcept {
; 972  :         _String_view_iterator _Tmp{*this};
; 973  :         --*this;
; 974  :         return _Tmp;
; 975  :     }
; 976  : 
; 977  :     constexpr void _Verify_offset(const difference_type _Off) const noexcept {
; 978  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 979  :         if (_Off != 0) {
; 980  :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 981  :         }
; 982  : 
; 983  :         if (_Off < 0) {
; 984  : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 985  :             _STL_VERIFY(_Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 986  :         }
; 987  : 
; 988  :         if (_Off > 0) {
; 989  :             _STL_VERIFY(_Mysize - _Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 990  :         }
; 991  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 992  :         (void) _Off;
; 993  : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 994  :     }
; 995  : 
; 996  :     constexpr _String_view_iterator& operator+=(const difference_type _Off) noexcept {
; 997  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 998  :         _Verify_offset(_Off);
; 999  :         _Myoff += _Off;
; 1000 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1001 :         _Myptr += _Off;
; 1002 : #endif // _ITERATOR_DEBUG_LEVEL
; 1003 : 
; 1004 :         return *this;
; 1005 :     }
; 1006 : 
; 1007 :     _NODISCARD constexpr _String_view_iterator operator+(const difference_type _Off) const noexcept {
; 1008 :         _String_view_iterator _Tmp{*this};
; 1009 :         _Tmp += _Off;
; 1010 :         return _Tmp;
; 1011 :     }
; 1012 : 
; 1013 :     constexpr _String_view_iterator& operator-=(const difference_type _Off) noexcept {
; 1014 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1015 :         if (_Off != 0) {
; 1016 :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 1017 :         }
; 1018 : 
; 1019 :         if (_Off > 0) {
; 1020 :             _STL_VERIFY(_Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 1021 :         }
; 1022 : 
; 1023 :         if (_Off < 0) {
; 1024 : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 1025 :             _STL_VERIFY(_Mysize - _Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 1026 :         }
; 1027 : 
; 1028 :         _Myoff -= _Off;
; 1029 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1030 :         _Myptr -= _Off;
; 1031 : #endif // _ITERATOR_DEBUG_LEVEL
; 1032 : 
; 1033 :         return *this;
; 1034 :     }
; 1035 : 
; 1036 :     _NODISCARD constexpr _String_view_iterator operator-(const difference_type _Off) const noexcept {
; 1037 :         _String_view_iterator _Tmp{*this};
; 1038 :         _Tmp -= _Off;
; 1039 :         return _Tmp;
; 1040 :     }
; 1041 : 
; 1042 :     _NODISCARD constexpr difference_type operator-(const _String_view_iterator& _Right) const noexcept {
; 1043 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1044 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1045 :             "cannot subtract incompatible string_view iterators");
; 1046 :         return static_cast<difference_type>(_Myoff - _Right._Myoff);
; 1047 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1048 :         return _Myptr - _Right._Myptr;
; 1049 : #endif // _ITERATOR_DEBUG_LEVEL
; 1050 :     }
; 1051 : 
; 1052 :     _NODISCARD constexpr reference operator[](const difference_type _Off) const noexcept {
; 1053 :         return *(*this + _Off);
; 1054 :     }
; 1055 : 
; 1056 :     _NODISCARD constexpr bool operator==(const _String_view_iterator& _Right) const noexcept {
; 1057 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1058 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1059 :             "cannot compare incompatible string_view iterators for equality");
; 1060 :         return _Myoff == _Right._Myoff;
; 1061 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1062 :         return _Myptr == _Right._Myptr;
; 1063 : #endif // _ITERATOR_DEBUG_LEVEL
; 1064 :     }
; 1065 : 
; 1066 :     _NODISCARD constexpr bool operator!=(const _String_view_iterator& _Right) const noexcept {
; 1067 :         return !(*this == _Right);
; 1068 :     }
; 1069 : 
; 1070 :     _NODISCARD constexpr bool operator<(const _String_view_iterator& _Right) const noexcept {
; 1071 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1072 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1073 :             "cannot compare incompatible string_view iterators");
; 1074 :         return _Myoff < _Right._Myoff;
; 1075 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1076 :         return _Myptr < _Right._Myptr;
; 1077 : #endif // _ITERATOR_DEBUG_LEVEL
; 1078 :     }
; 1079 : 
; 1080 :     _NODISCARD constexpr bool operator>(const _String_view_iterator& _Right) const noexcept {
; 1081 :         return _Right < *this;
; 1082 :     }
; 1083 : 
; 1084 :     _NODISCARD constexpr bool operator<=(const _String_view_iterator& _Right) const noexcept {
; 1085 :         return !(_Right < *this);
; 1086 :     }
; 1087 : 
; 1088 :     _NODISCARD constexpr bool operator>=(const _String_view_iterator& _Right) const noexcept {
; 1089 :         return !(*this < _Right);
; 1090 :     }
; 1091 : 
; 1092 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1093 :     friend constexpr void _Verify_range(const _String_view_iterator& _First, const _String_view_iterator& _Last) {
; 1094 :         _STL_VERIFY(_First._Mydata == _Last._Mydata && _First._Mysize == _Last._Mysize,
; 1095 :             "string_view iterators in range are from different views");
; 1096 :         _STL_VERIFY(_First._Myoff <= _Last._Myoff, "string_view iterator range transposed");
; 1097 :     }
; 1098 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1099 : 
; 1100 :     using _Prevent_inheriting_unwrap = _String_view_iterator;
; 1101 : 
; 1102 :     _NODISCARD constexpr pointer _Unwrapped() const noexcept {
; 1103 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1104 :         return _Mydata + _Myoff;
; 1105 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1106 :         return _Myptr;
; 1107 : #endif // _ITERATOR_DEBUG_LEVEL
; 1108 :     }
; 1109 : 
; 1110 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1111 : 
; 1112 :     constexpr void _Seek_to(pointer _It) noexcept {
; 1113 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1114 :         _Myoff = static_cast<size_t>(_It - _Mydata);
; 1115 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1116 :         _Myptr = _It;
; 1117 : #endif // _ITERATOR_DEBUG_LEVEL
; 1118 :     }
; 1119 : 
; 1120 : private:
; 1121 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1122 :     pointer _Mydata = nullptr;
; 1123 :     size_t _Mysize  = 0;
; 1124 :     size_t _Myoff   = 0;
; 1125 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1126 :     pointer _Myptr = nullptr;
; 1127 : #endif // _ITERATOR_DEBUG_LEVEL
; 1128 : };
; 1129 : 
; 1130 : template <class _Traits>
; 1131 : _NODISCARD constexpr _String_view_iterator<_Traits> operator+(
; 1132 :     const typename _String_view_iterator<_Traits>::difference_type _Off,
; 1133 :     _String_view_iterator<_Traits> _Right) noexcept {
; 1134 :     _Right += _Off;
; 1135 :     return _Right;
; 1136 : }
; 1137 : 
; 1138 : #if _HAS_CXX20
; 1139 : template <class _Traits>
; 1140 : struct pointer_traits<_String_view_iterator<_Traits>> {
; 1141 :     using pointer         = _String_view_iterator<_Traits>;
; 1142 :     using element_type    = const typename pointer::value_type;
; 1143 :     using difference_type = typename pointer::difference_type;
; 1144 : 
; 1145 :     _NODISCARD static constexpr element_type* to_address(const pointer& _Iter) noexcept {
; 1146 :         return _Iter._Unwrapped();
; 1147 :     }
; 1148 : };
; 1149 : #endif // _HAS_CXX20
; 1150 : 
; 1151 : 
; 1152 : // CLASS TEMPLATE basic_string_view
; 1153 : template <class _Elem, class _Traits>
; 1154 : class basic_string_view { // wrapper for any kind of contiguous character buffer
; 1155 : public:
; 1156 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 1157 :         "Bad char_traits for basic_string_view; "
; 1158 :         "N4659 24.4.2 [string.view.template]/1 \"the type traits::char_type shall name the same type as charT.\"");
; 1159 : 
; 1160 :     using traits_type            = _Traits;
; 1161 :     using value_type             = _Elem;
; 1162 :     using pointer                = _Elem*;
; 1163 :     using const_pointer          = const _Elem*;
; 1164 :     using reference              = _Elem&;
; 1165 :     using const_reference        = const _Elem&;
; 1166 :     using const_iterator         = _String_view_iterator<_Traits>;
; 1167 :     using iterator               = const_iterator;
; 1168 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 1169 :     using reverse_iterator       = const_reverse_iterator;
; 1170 :     using size_type              = size_t;
; 1171 :     using difference_type        = ptrdiff_t;
; 1172 : 
; 1173 :     static constexpr auto npos{static_cast<size_type>(-1)};
; 1174 : 
; 1175 :     constexpr basic_string_view() noexcept : _Mydata(), _Mysize(0) {}
; 1176 : 
; 1177 :     constexpr basic_string_view(const basic_string_view&) noexcept = default;
; 1178 :     constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;
; 1179 : 
; 1180 :     /* implicit */ constexpr basic_string_view(_In_z_ const const_pointer _Ntcts) noexcept // strengthened
; 1181 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}
; 1182 : 
; 1183 :     constexpr basic_string_view(
; 1184 :         _In_reads_(_Count) const const_pointer _Cts, const size_type _Count) noexcept // strengthened
; 1185 :         : _Mydata(_Cts), _Mysize(_Count) {
; 1186 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1187 :         _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
; 1188 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1189 :     }
; 1190 : 
; 1191 :     _NODISCARD constexpr const_iterator begin() const noexcept {
; 1192 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1193 :         return const_iterator(_Mydata, _Mysize, 0);
; 1194 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1195 :         return const_iterator(_Mydata);
; 1196 : #endif // _ITERATOR_DEBUG_LEVEL
; 1197 :     }
; 1198 : 
; 1199 :     _NODISCARD constexpr const_iterator end() const noexcept {
; 1200 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1201 :         return const_iterator(_Mydata, _Mysize, _Mysize);
; 1202 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1203 :         return const_iterator(_Mydata + _Mysize);
; 1204 : #endif // _ITERATOR_DEBUG_LEVEL
; 1205 :     }
; 1206 : 
; 1207 :     _NODISCARD constexpr const_iterator cbegin() const noexcept {
; 1208 :         return begin();
; 1209 :     }
; 1210 : 
; 1211 :     _NODISCARD constexpr const_iterator cend() const noexcept {
; 1212 :         return end();
; 1213 :     }
; 1214 : 
; 1215 :     _NODISCARD constexpr const_reverse_iterator rbegin() const noexcept {
; 1216 :         return const_reverse_iterator{end()};
; 1217 :     }
; 1218 : 
; 1219 :     _NODISCARD constexpr const_reverse_iterator rend() const noexcept {
; 1220 :         return const_reverse_iterator{begin()};
; 1221 :     }
; 1222 : 
; 1223 :     _NODISCARD constexpr const_reverse_iterator crbegin() const noexcept {
; 1224 :         return rbegin();
; 1225 :     }
; 1226 : 
; 1227 :     _NODISCARD constexpr const_reverse_iterator crend() const noexcept {
; 1228 :         return rend();
; 1229 :     }
; 1230 : 
; 1231 :     constexpr const_pointer _Unchecked_begin() const noexcept {
; 1232 :         return _Mydata;
; 1233 :     }
; 1234 : 
; 1235 :     constexpr const_pointer _Unchecked_end() const noexcept {
; 1236 :         return _Mydata + _Mysize;
; 1237 :     }
; 1238 : 
; 1239 :     _NODISCARD constexpr size_type size() const noexcept {
; 1240 :         return _Mysize;
; 1241 :     }
; 1242 : 
; 1243 :     _NODISCARD constexpr size_type length() const noexcept {
; 1244 :         return _Mysize;
; 1245 :     }
; 1246 : 
; 1247 :     _NODISCARD constexpr bool empty() const noexcept {
; 1248 :         return _Mysize == 0;
; 1249 :     }
; 1250 : 
; 1251 :     _NODISCARD constexpr const_pointer data() const noexcept {
; 1252 :         return _Mydata;
; 1253 :     }
; 1254 : 
; 1255 :     _NODISCARD constexpr size_type max_size() const noexcept {
; 1256 :         // bound to PTRDIFF_MAX to make end() - begin() well defined (also makes room for npos)
; 1257 :         // bound to static_cast<size_t>(-1) / sizeof(_Elem) by address space limits
; 1258 :         return _Min_value(static_cast<size_t>(PTRDIFF_MAX), static_cast<size_t>(-1) / sizeof(_Elem));
; 1259 :     }
; 1260 : 
; 1261 :     _NODISCARD constexpr const_reference operator[](const size_type _Off) const noexcept /* strengthened */ {
; 1262 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1263 :         _STL_VERIFY(_Off < _Mysize, "string_view subscript out of range");
; 1264 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1265 :         return _Mydata[_Off];
; 1266 :     }
; 1267 : 
; 1268 :     _NODISCARD constexpr const_reference at(const size_type _Off) const {
; 1269 :         // get the character at _Off or throw if that is out of range
; 1270 :         _Check_offset_exclusive(_Off);
; 1271 :         return _Mydata[_Off];
; 1272 :     }
; 1273 : 
; 1274 :     _NODISCARD constexpr const_reference front() const noexcept /* strengthened */ {
; 1275 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1276 :         _STL_VERIFY(_Mysize != 0, "cannot call front on empty string_view");
; 1277 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1278 :         return _Mydata[0];
; 1279 :     }
; 1280 : 
; 1281 :     _NODISCARD constexpr const_reference back() const noexcept /* strengthened */ {
; 1282 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1283 :         _STL_VERIFY(_Mysize != 0, "cannot call back on empty string_view");
; 1284 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1285 :         return _Mydata[_Mysize - 1];
; 1286 :     }
; 1287 : 
; 1288 :     constexpr void remove_prefix(const size_type _Count) noexcept /* strengthened */ {
; 1289 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1290 :         _STL_VERIFY(_Mysize >= _Count, "cannot remove prefix longer than total size");
; 1291 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1292 :         _Mydata += _Count;
; 1293 :         _Mysize -= _Count;
; 1294 :     }
; 1295 : 
; 1296 :     constexpr void remove_suffix(const size_type _Count) noexcept /* strengthened */ {
; 1297 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1298 :         _STL_VERIFY(_Mysize >= _Count, "cannot remove suffix longer than total size");
; 1299 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1300 :         _Mysize -= _Count;
; 1301 :     }
; 1302 : 
; 1303 :     constexpr void swap(basic_string_view& _Other) noexcept {
; 1304 :         const basic_string_view _Tmp{_Other}; // note: std::swap is not constexpr before C++20
; 1305 :         _Other = *this;
; 1306 :         *this  = _Tmp;
; 1307 :     }
; 1308 : 
; 1309 :     constexpr size_type copy(_Out_writes_(_Count) _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
; 1310 :         // copy [_Off, _Off + Count) to [_Ptr, _Ptr + _Count)
; 1311 :         _Check_offset(_Off);
; 1312 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1313 :         _Traits::copy(_Ptr, _Mydata + _Off, _Count);
; 1314 :         return _Count;
; 1315 :     }
; 1316 : 
; 1317 :     _Pre_satisfies_(_Dest_size >= _Count) constexpr size_type _Copy_s(_Out_writes_all_(_Dest_size) _Elem* const _Dest,
; 1318 :         const size_type _Dest_size, size_type _Count, const size_type _Off = 0) const {
; 1319 :         // copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1320 :         _Check_offset(_Off);
; 1321 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1322 :         _Traits::_Copy_s(_Dest, _Dest_size, _Mydata + _Off, _Count);
; 1323 :         return _Count;
; 1324 :     }
; 1325 : 
; 1326 :     _NODISCARD constexpr basic_string_view substr(const size_type _Off = 0, size_type _Count = npos) const {
; 1327 :         // return a new basic_string_view moved forward by _Off and trimmed to _Count elements
; 1328 :         _Check_offset(_Off);
; 1329 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1330 :         return basic_string_view(_Mydata + _Off, _Count);
; 1331 :     }
; 1332 : 
; 1333 :     constexpr bool _Equal(const basic_string_view _Right) const noexcept {
; 1334 :         return _Traits_equal<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
; 1335 :     }
; 1336 : 
; 1337 :     _NODISCARD constexpr int compare(const basic_string_view _Right) const noexcept {
; 1338 :         return _Traits_compare<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
; 1339 :     }
; 1340 : 
; 1341 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right) const {
; 1342 :         // compare [_Off, _Off + _N0) with _Right
; 1343 :         return substr(_Off, _N0).compare(_Right);
; 1344 :     }
; 1345 : 
; 1346 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right,
; 1347 :         const size_type _Roff, const size_type _Count) const {
; 1348 :         // compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1349 :         return substr(_Off, _N0).compare(_Right.substr(_Roff, _Count));
; 1350 :     }
; 1351 : 
; 1352 :     _NODISCARD constexpr int compare(_In_z_ const _Elem* const _Ptr) const { // compare [0, _Mysize) with [_Ptr, <null>)
; 1353 :         return compare(basic_string_view(_Ptr));
; 1354 :     }
; 1355 : 
; 1356 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, _In_z_ const _Elem* const _Ptr) const {
; 1357 :         // compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 1358 :         return substr(_Off, _N0).compare(basic_string_view(_Ptr));
; 1359 :     }
; 1360 : 
; 1361 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0,
; 1362 :         _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) const {
; 1363 :         // compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1364 :         return substr(_Off, _N0).compare(basic_string_view(_Ptr, _Count));
; 1365 :     }
; 1366 : 
; 1367 : #if _HAS_CXX20
; 1368 :     _NODISCARD constexpr bool starts_with(const basic_string_view _Right) const noexcept {
; 1369 :         const auto _Rightsize = _Right._Mysize;
; 1370 :         if (_Mysize < _Rightsize) {
; 1371 :             return false;
; 1372 :         }
; 1373 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;
; 1374 :     }
; 1375 : 
; 1376 :     _NODISCARD constexpr bool starts_with(const _Elem _Right) const noexcept {
; 1377 :         return !empty() && _Traits::eq(front(), _Right);
; 1378 :     }
; 1379 : 
; 1380 :     _NODISCARD constexpr bool starts_with(const _Elem* const _Right) const noexcept /* strengthened */ {
; 1381 :         return starts_with(basic_string_view(_Right));
; 1382 :     }
; 1383 : 
; 1384 :     _NODISCARD constexpr bool ends_with(const basic_string_view _Right) const noexcept {
; 1385 :         const auto _Rightsize = _Right._Mysize;
; 1386 :         if (_Mysize < _Rightsize) {
; 1387 :             return false;
; 1388 :         }
; 1389 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;
; 1390 :     }
; 1391 : 
; 1392 :     _NODISCARD constexpr bool ends_with(const _Elem _Right) const noexcept {
; 1393 :         return !empty() && _Traits::eq(back(), _Right);
; 1394 :     }
; 1395 : 
; 1396 :     _NODISCARD constexpr bool ends_with(const _Elem* const _Right) const noexcept /* strengthened */ {
; 1397 :         return ends_with(basic_string_view(_Right));
; 1398 :     }
; 1399 : #endif // _HAS_CXX20
; 1400 : 
; 1401 :     _NODISCARD constexpr size_type find(const basic_string_view _Right, const size_type _Off = 0) const noexcept {
; 1402 :         // look for _Right beginning at or after _Off
; 1403 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
; 1404 :     }
; 1405 : 
; 1406 :     _NODISCARD constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1407 :         // look for _Ch at or after _Off
; 1408 :         return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1409 :     }
; 1410 : 
; 1411 :     _NODISCARD constexpr size_type find(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1412 :         const size_type _Count) const noexcept /* strengthened */ {
; 1413 :         // look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1414 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
; 1415 :     }
; 1416 : 
; 1417 :     _NODISCARD constexpr size_type find(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1418 :         noexcept /* strengthened */ {
; 1419 :         // look for [_Ptr, <null>) beginning at or after _Off
; 1420 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
; 1421 :     }
; 1422 : 
; 1423 :     _NODISCARD constexpr size_type rfind(const basic_string_view _Right, const size_type _Off = npos) const noexcept {
; 1424 :         // look for _Right beginning before _Off
; 1425 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
; 1426 :     }
; 1427 : 
; 1428 :     _NODISCARD constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1429 :         // look for _Ch before _Off
; 1430 :         return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1431 :     }
; 1432 : 
; 1433 :     _NODISCARD constexpr size_type rfind(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1434 :         const size_type _Count) const noexcept /* strengthened */ {
; 1435 :         // look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1436 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
; 1437 :     }
; 1438 : 
; 1439 :     _NODISCARD constexpr size_type rfind(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1440 :         noexcept /* strengthened */ {
; 1441 :         // look for [_Ptr, <null>) beginning before _Off
; 1442 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
; 1443 :     }
; 1444 : 
; 1445 :     _NODISCARD constexpr size_type find_first_of(const basic_string_view _Right,
; 1446 :         const size_type _Off = 0) const noexcept { // look for one of _Right at or after _Off
; 1447 :         return _Traits_find_first_of<_Traits>(
; 1448 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1449 :     }
; 1450 : 
; 1451 :     _NODISCARD constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1452 :         // look for _Ch at or after _Off
; 1453 :         return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1454 :     }
; 1455 : 
; 1456 :     _NODISCARD constexpr size_type find_first_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1457 :         const size_type _Count) const noexcept /* strengthened */ {
; 1458 :         // look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1459 :         return _Traits_find_first_of<_Traits>(
; 1460 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1461 :     }
; 1462 : 
; 1463 :     _NODISCARD constexpr size_type find_first_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1464 :         noexcept /* strengthened */ {
; 1465 :         // look for one of [_Ptr, <null>) at or after _Off
; 1466 :         return _Traits_find_first_of<_Traits>(
; 1467 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1468 :     }
; 1469 : 
; 1470 :     _NODISCARD constexpr size_type find_last_of(const basic_string_view _Right, const size_type _Off = npos) const
; 1471 :         noexcept { // look for one of _Right before _Off
; 1472 :         return _Traits_find_last_of<_Traits>(
; 1473 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1474 :     }
; 1475 : 
; 1476 :     _NODISCARD constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1477 :         // look for _Ch before _Off
; 1478 :         return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1479 :     }
; 1480 : 
; 1481 :     _NODISCARD constexpr size_type find_last_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1482 :         const size_type _Count) const noexcept /* strengthened */ {
; 1483 :         // look for one of [_Ptr, _Ptr + _Count) before _Off
; 1484 :         return _Traits_find_last_of<_Traits>(
; 1485 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1486 :     }
; 1487 : 
; 1488 :     _NODISCARD constexpr size_type find_last_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1489 :         noexcept /* strengthened */ {
; 1490 :         // look for one of [_Ptr, <null>) before _Off
; 1491 :         return _Traits_find_last_of<_Traits>(
; 1492 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1493 :     }
; 1494 : 
; 1495 :     _NODISCARD constexpr size_type find_first_not_of(const basic_string_view _Right,
; 1496 :         const size_type _Off = 0) const noexcept { // look for none of _Right at or after _Off
; 1497 :         return _Traits_find_first_not_of<_Traits>(
; 1498 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1499 :     }
; 1500 : 
; 1501 :     _NODISCARD constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1502 :         // look for any value other than _Ch at or after _Off
; 1503 :         return _Traits_find_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1504 :     }
; 1505 : 
; 1506 :     _NODISCARD constexpr size_type find_first_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1507 :         const size_type _Count) const noexcept /* strengthened */ {
; 1508 :         // look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 1509 :         return _Traits_find_first_not_of<_Traits>(
; 1510 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1511 :     }
; 1512 : 
; 1513 :     _NODISCARD constexpr size_type find_first_not_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1514 :         noexcept /* strengthened */ {
; 1515 :         // look for none of [_Ptr, <null>) at or after _Off
; 1516 :         return _Traits_find_first_not_of<_Traits>(
; 1517 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1518 :     }
; 1519 : 
; 1520 :     _NODISCARD constexpr size_type find_last_not_of(const basic_string_view _Right,
; 1521 :         const size_type _Off = npos) const noexcept { // look for none of _Right before _Off
; 1522 :         return _Traits_find_last_not_of<_Traits>(
; 1523 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1524 :     }
; 1525 : 
; 1526 :     _NODISCARD constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1527 :         // look for any value other than _Ch before _Off
; 1528 :         return _Traits_rfind_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1529 :     }
; 1530 : 
; 1531 :     _NODISCARD constexpr size_type find_last_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1532 :         const size_type _Count) const noexcept /* strengthened */ {
; 1533 :         // look for none of [_Ptr, _Ptr + _Count) before _Off
; 1534 :         return _Traits_find_last_not_of<_Traits>(
; 1535 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1536 :     }
; 1537 : 
; 1538 :     _NODISCARD constexpr size_type find_last_not_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1539 :         noexcept /* strengthened */ {
; 1540 :         // look for none of [_Ptr, <null>) before _Off
; 1541 :         return _Traits_find_last_not_of<_Traits>(
; 1542 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1543 :     }
; 1544 : 
; 1545 :     _NODISCARD constexpr bool _Starts_with(const basic_string_view _View) const noexcept {
; 1546 :         return _Mysize >= _View._Mysize && _Traits::compare(_Mydata, _View._Mydata, _View._Mysize) == 0;
; 1547 :     }
; 1548 : 
; 1549 : private:
; 1550 :     constexpr void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 1551 :         if (_Mysize < _Off) {
; 1552 :             _Xran();
; 1553 :         }
; 1554 :     }
; 1555 : 
; 1556 :     constexpr void _Check_offset_exclusive(const size_type _Off) const {
; 1557 :         // checks whether _Off is in the bounds of [0, size())
; 1558 :         if (_Mysize <= _Off) {
; 1559 :             _Xran();
; 1560 :         }
; 1561 :     }
; 1562 : 
; 1563 :     constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 1564 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 1565 :         return _Min_value(_Size, _Mysize - _Off);
; 1566 :     }
; 1567 : 
; 1568 :     [[noreturn]] static void _Xran() {
; 1569 :         _Xout_of_range("invalid string_view position");
; 1570 :     }
; 1571 : 
; 1572 :     const_pointer _Mydata;
; 1573 :     size_type _Mysize;
; 1574 : };
; 1575 : 
; 1576 : #ifdef __cpp_lib_concepts
; 1577 : namespace ranges {
; 1578 :     template <class _Elem, class _Traits>
; 1579 :     inline constexpr bool enable_view<basic_string_view<_Elem, _Traits>> = true;
; 1580 :     template <class _Elem, class _Traits>
; 1581 :     inline constexpr bool enable_borrowed_range<basic_string_view<_Elem, _Traits>> = true;
; 1582 : } // namespace ranges
; 1583 : #endif // __cpp_lib_concepts
; 1584 : 
; 1585 : // FUNCTION TEMPLATES operator== FOR basic_string_view
; 1586 : template <class _Elem, class _Traits>
; 1587 : _NODISCARD constexpr bool operator==(
; 1588 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1589 :     return _Lhs._Equal(_Rhs);
; 1590 : }
; 1591 : 
; 1592 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1593 : _NODISCARD constexpr bool operator==(
; 1594 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1595 :     return _Lhs._Equal(_Rhs);
; 1596 : }
; 1597 : 
; 1598 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1599 : _NODISCARD constexpr bool operator==(
; 1600 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1601 :     return _Lhs._Equal(_Rhs);
; 1602 : }
; 1603 : 
; 1604 : 
; 1605 : // FUNCTION TEMPLATES operator!= FOR basic_string_view
; 1606 : template <class _Elem, class _Traits>
; 1607 : _NODISCARD constexpr bool operator!=(
; 1608 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1609 :     return !_Lhs._Equal(_Rhs);
; 1610 : }
; 1611 : 
; 1612 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1613 : _NODISCARD constexpr bool operator!=(
; 1614 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1615 :     return !_Lhs._Equal(_Rhs);
; 1616 : }
; 1617 : 
; 1618 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1619 : _NODISCARD constexpr bool operator!=(
; 1620 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1621 :     return !_Lhs._Equal(_Rhs);
; 1622 : }
; 1623 : 
; 1624 : 
; 1625 : // FUNCTION TEMPLATES operator< FOR basic_string_view
; 1626 : template <class _Elem, class _Traits>
; 1627 : _NODISCARD constexpr bool operator<(
; 1628 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1629 :     return _Lhs.compare(_Rhs) < 0;
; 1630 : }
; 1631 : 
; 1632 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1633 : _NODISCARD constexpr bool operator<(
; 1634 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1635 :     return _Lhs.compare(_Rhs) < 0;
; 1636 : }
; 1637 : 
; 1638 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1639 : _NODISCARD constexpr bool operator<(
; 1640 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1641 :     return _Lhs.compare(_Rhs) < 0;
; 1642 : }
; 1643 : 
; 1644 : 
; 1645 : // FUNCTION TEMPLATES operator> FOR basic_string_view
; 1646 : template <class _Elem, class _Traits>
; 1647 : _NODISCARD constexpr bool operator>(
; 1648 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1649 :     return _Lhs.compare(_Rhs) > 0;
; 1650 : }
; 1651 : 
; 1652 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1653 : _NODISCARD constexpr bool operator>(
; 1654 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1655 :     return _Lhs.compare(_Rhs) > 0;
; 1656 : }
; 1657 : 
; 1658 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1659 : _NODISCARD constexpr bool operator>(
; 1660 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1661 :     return _Lhs.compare(_Rhs) > 0;
; 1662 : }
; 1663 : 
; 1664 : 
; 1665 : // FUNCTION TEMPLATES operator<= FOR basic_string_view
; 1666 : template <class _Elem, class _Traits>
; 1667 : _NODISCARD constexpr bool operator<=(
; 1668 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1669 :     return _Lhs.compare(_Rhs) <= 0;
; 1670 : }
; 1671 : 
; 1672 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1673 : _NODISCARD constexpr bool operator<=(
; 1674 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1675 :     return _Lhs.compare(_Rhs) <= 0;
; 1676 : }
; 1677 : 
; 1678 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1679 : _NODISCARD constexpr bool operator<=(
; 1680 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1681 :     return _Lhs.compare(_Rhs) <= 0;
; 1682 : }
; 1683 : 
; 1684 : 
; 1685 : // FUNCTION TEMPLATES operator>= FOR basic_string_view
; 1686 : template <class _Elem, class _Traits>
; 1687 : _NODISCARD constexpr bool operator>=(
; 1688 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1689 :     return _Lhs.compare(_Rhs) >= 0;
; 1690 : }
; 1691 : 
; 1692 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1693 : _NODISCARD constexpr bool operator>=(
; 1694 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1695 :     return _Lhs.compare(_Rhs) >= 0;
; 1696 : }
; 1697 : 
; 1698 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1699 : _NODISCARD constexpr bool operator>=(
; 1700 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1701 :     return _Lhs.compare(_Rhs) >= 0;
; 1702 : }
; 1703 : 
; 1704 : 
; 1705 : // TYPEDEFS FOR basic_string_view
; 1706 : using string_view = basic_string_view<char>;
; 1707 : #ifdef __cpp_lib_char8_t
; 1708 : using u8string_view = basic_string_view<char8_t>;
; 1709 : #endif // __cpp_lib_char8_t
; 1710 : using u16string_view = basic_string_view<char16_t>;
; 1711 : using u32string_view = basic_string_view<char32_t>;
; 1712 : using wstring_view   = basic_string_view<wchar_t>;
; 1713 : 
; 1714 : 
; 1715 : // STRUCT TEMPLATE SPECIALIZATION hash FOR basic_string_view
; 1716 : template <class _Elem, class _Traits>
; 1717 : struct hash<basic_string_view<_Elem, _Traits>> {
; 1718 :     _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef basic_string_view<_Elem, _Traits> _ARGUMENT_TYPE_NAME;
; 1719 :     _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t _RESULT_TYPE_NAME;
; 1720 : 
; 1721 :     _NODISCARD size_t operator()(const basic_string_view<_Elem, _Traits> _Keyval) const noexcept {
; 1722 :         return _Hash_array_representation(_Keyval.data(), _Keyval.size());
; 1723 :     }
; 1724 : };
; 1725 : 
; 1726 : template <class _Elem, class _Traits>
; 1727 : basic_ostream<_Elem, _Traits>& operator<<(
; 1728 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string_view<_Elem, _Traits> _Str) {
; 1729 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());
; 1730 : }
; 1731 : 
; 1732 : 
; 1733 : // basic_string_view LITERALS
; 1734 : inline namespace literals {
; 1735 :     inline namespace string_view_literals {
; 1736 :         _NODISCARD constexpr string_view operator"" sv(const char* _Str, size_t _Len) noexcept {
; 1737 :             return string_view(_Str, _Len);
; 1738 :         }
; 1739 : 
; 1740 :         _NODISCARD constexpr wstring_view operator"" sv(const wchar_t* _Str, size_t _Len) noexcept {
; 1741 :             return wstring_view(_Str, _Len);
; 1742 :         }
; 1743 : 
; 1744 : #ifdef __cpp_char8_t
; 1745 :         _NODISCARD constexpr basic_string_view<char8_t> operator"" sv(const char8_t* _Str, size_t _Len) noexcept {
; 1746 :             return basic_string_view<char8_t>(_Str, _Len);
; 1747 :         }
; 1748 : #endif // __cpp_char8_t
; 1749 : 
; 1750 :         _NODISCARD constexpr u16string_view operator"" sv(const char16_t* _Str, size_t _Len) noexcept {
; 1751 :             return u16string_view(_Str, _Len);
; 1752 :         }
; 1753 : 
; 1754 :         _NODISCARD constexpr u32string_view operator"" sv(const char32_t* _Str, size_t _Len) noexcept {
; 1755 :             return u32string_view(_Str, _Len);
; 1756 :         }
; 1757 :     } // namespace string_view_literals
; 1758 : } // namespace literals
; 1759 : #endif // _HAS_CXX17
; 1760 : 
; 1761 : // CLASS TEMPLATE _String_const_iterator
; 1762 : template <class _Mystr>
; 1763 : class _String_const_iterator : public _Iterator_base {
; 1764 : public:
; 1765 : #ifdef __cpp_lib_concepts
; 1766 :     using iterator_concept = contiguous_iterator_tag;
; 1767 : #endif // __cpp_lib_concepts
; 1768 :     using iterator_category = random_access_iterator_tag;
; 1769 :     using value_type        = typename _Mystr::value_type;
; 1770 :     using difference_type   = typename _Mystr::difference_type;
; 1771 :     using pointer           = typename _Mystr::const_pointer;
; 1772 :     using reference         = const value_type&;
; 1773 : 
; 1774 :     _String_const_iterator() noexcept : _Ptr() {}
; 1775 : 
; 1776 :     _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {
; 1777 :         this->_Adopt(_Pstring);
; 1778 :     }
; 1779 : 
; 1780 :     _NODISCARD reference operator*() const {
; 1781 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1782 :         _STL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1783 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1784 :         _STL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1785 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1786 :         const auto _Contptr = _Mycont->_Myptr();
; 1787 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1788 :         _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1789 :             "cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1790 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1791 : 
; 1792 :         _Analysis_assume_(_Ptr);
; 1793 :         return *_Ptr;
; 1794 :     }
; 1795 : 
; 1796 :     _NODISCARD pointer operator->() const {
; 1797 :         return pointer_traits<pointer>::pointer_to(**this);
; 1798 :     }
; 1799 : 
; 1800 :     _String_const_iterator& operator++() {
; 1801 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1802 :         _STL_VERIFY(_Ptr, "cannot increment value-initialized string iterator");
; 1803 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1804 :         _STL_VERIFY(_Mycont, "cannot increment string iterator because the iterator was"
; 1805 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1806 :         _STL_VERIFY(_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize, "cannot increment string iterator past end");
; 1807 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1808 : 
; 1809 :         ++_Ptr;
; 1810 :         return *this;
; 1811 :     }
; 1812 : 
; 1813 :     _String_const_iterator operator++(int) {
; 1814 :         _String_const_iterator _Tmp = *this;
; 1815 :         ++*this;
; 1816 :         return _Tmp;
; 1817 :     }
; 1818 : 
; 1819 :     _String_const_iterator& operator--() {
; 1820 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1821 :         _STL_VERIFY(_Ptr, "cannot decrement value-initialized string iterator");
; 1822 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1823 :         _STL_VERIFY(_Mycont, "cannot decrement string iterator because the iterator was"
; 1824 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1825 :         _STL_VERIFY(_Mycont->_Myptr() < _Unfancy(_Ptr), "cannot decrement string iterator before begin");
; 1826 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1827 : 
; 1828 :         --_Ptr;
; 1829 :         return *this;
; 1830 :     }
; 1831 : 
; 1832 :     _String_const_iterator operator--(int) {
; 1833 :         _String_const_iterator _Tmp = *this;
; 1834 :         --*this;
; 1835 :         return _Tmp;
; 1836 :     }
; 1837 : 
; 1838 :     void _Verify_offset(const difference_type _Off) const noexcept {
; 1839 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1840 :         if (_Off == 0) {
; 1841 :             return;
; 1842 :         }
; 1843 : 
; 1844 :         _STL_ASSERT(_Ptr, "cannot seek value-initialized string iterator");
; 1845 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1846 :         _STL_ASSERT(_Mycont, "cannot seek string iterator because the iterator was"
; 1847 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1848 :         const auto _Contptr = _Mycont->_Myptr();
; 1849 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1850 : 
; 1851 :         if (_Off < 0) {
; 1852 : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 1853 :             _STL_VERIFY(_Contptr - _Rawptr <= _Off, "cannot seek string iterator before begin");
; 1854 :         }
; 1855 : 
; 1856 :         if (_Off > 0) {
; 1857 :             using _Size_type = typename _Mystr::size_type;
; 1858 :             const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
; 1859 :             _STL_VERIFY(static_cast<_Size_type>(_Off) <= _Left, "cannot seek string iterator after end");
; 1860 :         }
; 1861 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1862 :         (void) _Off;
; 1863 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1864 :     }
; 1865 : 
; 1866 :     _String_const_iterator& operator+=(const difference_type _Off) {
; 1867 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1868 :         _Verify_offset(_Off);
; 1869 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1870 :         _Ptr += _Off;
; 1871 :         return *this;
; 1872 :     }
; 1873 : 
; 1874 :     _NODISCARD _String_const_iterator operator+(const difference_type _Off) const {
; 1875 :         _String_const_iterator _Tmp = *this;
; 1876 :         return _Tmp += _Off;
; 1877 :     }
; 1878 : 
; 1879 :     _String_const_iterator& operator-=(const difference_type _Off) {
; 1880 :         return *this += -_Off;
; 1881 :     }
; 1882 : 
; 1883 :     _NODISCARD _String_const_iterator operator-(const difference_type _Off) const {
; 1884 :         _String_const_iterator _Tmp = *this;
; 1885 :         return _Tmp -= _Off;
; 1886 :     }
; 1887 : 
; 1888 :     _NODISCARD difference_type operator-(const _String_const_iterator& _Right) const {
; 1889 :         _Compat(_Right);
; 1890 :         return _Ptr - _Right._Ptr;
; 1891 :     }
; 1892 : 
; 1893 :     _NODISCARD reference operator[](const difference_type _Off) const {
; 1894 :         return *(*this + _Off);
; 1895 :     }
; 1896 : 
; 1897 :     _NODISCARD bool operator==(const _String_const_iterator& _Right) const {
; 1898 :         _Compat(_Right);
; 1899 :         return _Ptr == _Right._Ptr;
; 1900 :     }
; 1901 : 
; 1902 :     _NODISCARD bool operator!=(const _String_const_iterator& _Right) const {
; 1903 :         return !(*this == _Right);
; 1904 :     }
; 1905 : 
; 1906 :     _NODISCARD bool operator<(const _String_const_iterator& _Right) const {
; 1907 :         _Compat(_Right);
; 1908 :         return _Ptr < _Right._Ptr;
; 1909 :     }
; 1910 : 
; 1911 :     _NODISCARD bool operator>(const _String_const_iterator& _Right) const {
; 1912 :         return _Right < *this;
; 1913 :     }
; 1914 : 
; 1915 :     _NODISCARD bool operator<=(const _String_const_iterator& _Right) const {
; 1916 :         return !(_Right < *this);
; 1917 :     }
; 1918 : 
; 1919 :     _NODISCARD bool operator>=(const _String_const_iterator& _Right) const {
; 1920 :         return !(*this < _Right);
; 1921 :     }
; 1922 : 
; 1923 :     void _Compat(const _String_const_iterator& _Right) const { // test for compatible iterator pair
; 1924 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1925 :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "string iterators incompatible (e.g."
; 1926 :                                                            " point to different string instances)");
; 1927 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1928 :         (void) _Right;
; 1929 : #endif // _ITERATOR_DEBUG_LEVEL
; 1930 :     }
; 1931 : 
; 1932 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1933 :     friend void _Verify_range(const _String_const_iterator& _First, const _String_const_iterator& _Last) {
; 1934 :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "string iterators in range are from different containers");
; 1935 :         _STL_VERIFY(_First._Ptr <= _Last._Ptr, "string iterator range transposed");
; 1936 :     }
; 1937 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1938 : 
; 1939 :     using _Prevent_inheriting_unwrap = _String_const_iterator;
; 1940 : 
; 1941 :     _NODISCARD const value_type* _Unwrapped() const {
; 1942 :         return _Unfancy(_Ptr);
; 1943 :     }
; 1944 : 
; 1945 :     void _Seek_to(const value_type* _It) {
; 1946 :         _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
; 1947 :     }
; 1948 : 
; 1949 :     pointer _Ptr; // pointer to element in string
; 1950 : };
; 1951 : 
; 1952 : template <class _Mystr>
; 1953 : _NODISCARD _String_const_iterator<_Mystr> operator+(
; 1954 :     typename _String_const_iterator<_Mystr>::difference_type _Off, _String_const_iterator<_Mystr> _Next) {
; 1955 :     return _Next += _Off;
; 1956 : }
; 1957 : 
; 1958 : #if _HAS_CXX20
; 1959 : template <class _Mystr>
; 1960 : struct pointer_traits<_String_const_iterator<_Mystr>> {
; 1961 :     using pointer         = _String_const_iterator<_Mystr>;
; 1962 :     using element_type    = const typename pointer::value_type;
; 1963 :     using difference_type = typename pointer::difference_type;
; 1964 : 
; 1965 :     _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
; 1966 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1967 :         const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
; 1968 :         if (!_Mycont) {
; 1969 :             _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
; 1970 :                                      "(e.g. reallocation occurred, or the string was destroyed)");
; 1971 :         }
; 1972 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1973 : 
; 1974 :         const auto _Rawptr = _STD to_address(_Iter._Ptr);
; 1975 : 
; 1976 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1977 :         if (_Mycont) {
; 1978 :             const auto _Contptr = _Mycont->_Myptr();
; 1979 :             _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
; 1980 :                 "cannot convert string iterator to pointer because it is out of range");
; 1981 :         }
; 1982 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1983 : 
; 1984 :         return _Rawptr;
; 1985 :     }
; 1986 : };
; 1987 : #endif // _HAS_CXX20
; 1988 : 
; 1989 : // CLASS TEMPLATE _String_iterator
; 1990 : template <class _Mystr>
; 1991 : class _String_iterator : public _String_const_iterator<_Mystr> {
; 1992 : public:
; 1993 :     using _Mybase = _String_const_iterator<_Mystr>;
; 1994 : 
; 1995 : #ifdef __cpp_lib_concepts
; 1996 :     using iterator_concept = contiguous_iterator_tag;
; 1997 : #endif // __cpp_lib_concepts
; 1998 :     using iterator_category = random_access_iterator_tag;
; 1999 :     using value_type        = typename _Mystr::value_type;
; 2000 :     using difference_type   = typename _Mystr::difference_type;
; 2001 :     using pointer           = typename _Mystr::pointer;
; 2002 :     using reference         = value_type&;
; 2003 : 
; 2004 :     using _Mybase::_Mybase;
; 2005 : 
; 2006 :     _NODISCARD reference operator*() const {
; 2007 :         return const_cast<reference>(_Mybase::operator*());
; 2008 :     }
; 2009 : 
; 2010 :     _NODISCARD pointer operator->() const {
; 2011 :         return pointer_traits<pointer>::pointer_to(**this);
; 2012 :     }
; 2013 : 
; 2014 :     _String_iterator& operator++() {
; 2015 :         _Mybase::operator++();
; 2016 :         return *this;
; 2017 :     }
; 2018 : 
; 2019 :     _String_iterator operator++(int) {
; 2020 :         _String_iterator _Tmp = *this;
; 2021 :         _Mybase::operator++();
; 2022 :         return _Tmp;
; 2023 :     }
; 2024 : 
; 2025 :     _String_iterator& operator--() {
; 2026 :         _Mybase::operator--();
; 2027 :         return *this;
; 2028 :     }
; 2029 : 
; 2030 :     _String_iterator operator--(int) {
; 2031 :         _String_iterator _Tmp = *this;
; 2032 :         _Mybase::operator--();
; 2033 :         return _Tmp;
; 2034 :     }
; 2035 : 
; 2036 :     _String_iterator& operator+=(const difference_type _Off) {
; 2037 :         _Mybase::operator+=(_Off);
; 2038 :         return *this;
; 2039 :     }
; 2040 : 
; 2041 :     _NODISCARD _String_iterator operator+(const difference_type _Off) const {
; 2042 :         _String_iterator _Tmp = *this;
; 2043 :         return _Tmp += _Off;
; 2044 :     }
; 2045 : 
; 2046 :     _String_iterator& operator-=(const difference_type _Off) {
; 2047 :         _Mybase::operator-=(_Off);
; 2048 :         return *this;
; 2049 :     }
; 2050 : 
; 2051 :     using _Mybase::operator-;
; 2052 : 
; 2053 :     _NODISCARD _String_iterator operator-(const difference_type _Off) const {
; 2054 :         _String_iterator _Tmp = *this;
; 2055 :         return _Tmp -= _Off;
; 2056 :     }
; 2057 : 
; 2058 :     _NODISCARD reference operator[](const difference_type _Off) const {
; 2059 :         return const_cast<reference>(_Mybase::operator[](_Off));
; 2060 :     }
; 2061 : 
; 2062 :     using _Prevent_inheriting_unwrap = _String_iterator;
; 2063 : 
; 2064 :     _NODISCARD value_type* _Unwrapped() const {
; 2065 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));
; 2066 :     }
; 2067 : };
; 2068 : 
; 2069 : template <class _Mystr>
; 2070 : _NODISCARD _String_iterator<_Mystr> operator+(
; 2071 :     typename _String_iterator<_Mystr>::difference_type _Off, _String_iterator<_Mystr> _Next) {
; 2072 :     return _Next += _Off;
; 2073 : }
; 2074 : 
; 2075 : #if _HAS_CXX20
; 2076 : template <class _Mystr>
; 2077 : struct pointer_traits<_String_iterator<_Mystr>> {
; 2078 :     using pointer         = _String_iterator<_Mystr>;
; 2079 :     using element_type    = typename pointer::value_type;
; 2080 :     using difference_type = typename pointer::difference_type;
; 2081 : 
; 2082 :     _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
; 2083 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 2084 :         const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
; 2085 :         if (!_Mycont) {
; 2086 :             _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
; 2087 :                                      "(e.g. reallocation occurred, or the string was destroyed)");
; 2088 :         }
; 2089 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 2090 : 
; 2091 :         const auto _Rawptr = _STD to_address(_Iter._Ptr);
; 2092 : 
; 2093 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 2094 :         if (_Mycont) {
; 2095 :             const auto _Contptr = _Mycont->_Myptr();
; 2096 :             _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
; 2097 :                 "cannot convert string iterator to pointer because it is out of range");
; 2098 :         }
; 2099 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 2100 : 
; 2101 :         return const_cast<element_type*>(_Rawptr);
; 2102 :     }
; 2103 : };
; 2104 : #endif // _HAS_CXX20
; 2105 : 
; 2106 : // basic_string TYPE WRAPPERS
; 2107 : template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
; 2108 :     class _Reference, class _Const_reference>
; 2109 : struct _String_iter_types {
; 2110 :     using value_type      = _Value_type;
; 2111 :     using size_type       = _Size_type;
; 2112 :     using difference_type = _Difference_type;
; 2113 :     using pointer         = _Pointer;
; 2114 :     using const_pointer   = _Const_pointer;
; 2115 : };
; 2116 : 
; 2117 : // CLASS TEMPLATE _String_val
; 2118 : template <class _Val_types>
; 2119 : class _String_val : public _Container_base {
; 2120 : public:
; 2121 :     using value_type      = typename _Val_types::value_type;
; 2122 :     using size_type       = typename _Val_types::size_type;
; 2123 :     using difference_type = typename _Val_types::difference_type;
; 2124 :     using pointer         = typename _Val_types::pointer;
; 2125 :     using const_pointer   = typename _Val_types::const_pointer;
; 2126 :     using reference       = value_type&;
; 2127 :     using const_reference = const value_type&;
; 2128 : 
; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}
; 2130 : 
; 2131 :     // length of internal buffer, [1, 16]:
; 2132 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2133 :     // roundup mask for allocated buffers, [0, 15]:
; 2134 :     static constexpr size_type _ALLOC_MASK =
; 2135 :         sizeof(value_type) <= 1
; 2136 :             ? 15
; 2137 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2138 : 
; 2139 :     value_type* _Myptr() noexcept {
; 2140 :         value_type* _Result = _Bx._Buf;
; 2141 :         if (_Large_string_engaged()) {
; 2142 :             _Result = _Unfancy(_Bx._Ptr);
; 2143 :         }
; 2144 : 
; 2145 :         return _Result;
; 2146 :     }
; 2147 : 
; 2148 :     const value_type* _Myptr() const noexcept {
; 2149 :         const value_type* _Result = _Bx._Buf;
; 2150 :         if (_Large_string_engaged()) {
; 2151 :             _Result = _Unfancy(_Bx._Ptr);
; 2152 :         }
; 2153 : 
; 2154 :         return _Result;
; 2155 :     }
; 2156 : 
; 2157 :     bool _Large_string_engaged() const noexcept {
; 2158 :         return _BUF_SIZE <= _Myres;
; 2159 :     }
; 2160 : 
; 2161 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2162 :         if (_Mysize < _Off) {
; 2163 :             _Xran();
; 2164 :         }
; 2165 :     }
; 2166 : 
; 2167 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2168 :         if (_Mysize <= _Off) {
; 2169 :             _Xran();
; 2170 :         }
; 2171 :     }
; 2172 : 
; 2173 :     [[noreturn]] static void _Xran() {
; 2174 :         _Xout_of_range("invalid string position");
; 2175 :     }
; 2176 : 
; 2177 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2178 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2179 :         return _Min_value(_Size, _Mysize - _Off);
; 2180 :     }
; 2181 : 
; 2182 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2183 :         _Bxty() {} // user-provided, for fancy pointers
; 2184 : 
; 2185 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2186 : 
; 2187 :         value_type _Buf[_BUF_SIZE];
; 2188 :         pointer _Ptr;
; 2189 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2190 :     } _Bx;
; 2191 : 
; 2192 :     size_type _Mysize; // current length of string
; 2193 :     size_type _Myres; // current storage reserved for string
; 2194 : };
; 2195 : 
; 2196 : // CLASS TEMPLATE basic_string
; 2197 : template <class _Ty>
; 2198 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2199 : 
; 2200 : struct _String_constructor_concat_tag {
; 2201 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2202 :     explicit _String_constructor_concat_tag() = default;
; 2203 : };
; 2204 : 
; 2205 : [[noreturn]] inline void _Xlen_string() {
; 2206 :     _Xlength_error("string too long");
; 2207 : }
; 2208 : 
; 2209 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2210 : class basic_string { // null-terminated transparent array of elements
; 2211 : private:
; 2212 :     friend _Tidy_deallocate_guard<basic_string>;
; 2213 : 
; 2214 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2215 :     using _Alty_traits = allocator_traits<_Alty>;
; 2216 : 
; 2217 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2218 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2219 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2220 : 
; 2221 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2222 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2223 : 
; 2224 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2225 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2226 :         "char_traits character type match the string's character type.");
; 2227 : 
; 2228 : public:
; 2229 :     using traits_type    = _Traits;
; 2230 :     using allocator_type = _Alloc;
; 2231 : 
; 2232 :     using value_type      = _Elem;
; 2233 :     using size_type       = typename _Alty_traits::size_type;
; 2234 :     using difference_type = typename _Alty_traits::difference_type;
; 2235 :     using pointer         = typename _Alty_traits::pointer;
; 2236 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2237 :     using reference       = value_type&;
; 2238 :     using const_reference = const value_type&;
; 2239 : 
; 2240 :     using iterator       = _String_iterator<_Scary_val>;
; 2241 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2242 : 
; 2243 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2244 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2245 : 
; 2246 : private:
; 2247 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2248 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2249 : 
; 2250 :     // When doing _String_val operations by memcpy, we are touching:
; 2251 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2252 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2253 :     //   _String_val::_Mysize   (type is size_type)
; 2254 :     //   _String_val::_Myres    (type is size_type)
; 2255 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2256 :     // We need to ask if pointer is safe to memcpy.
; 2257 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2258 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2259 :     //   they can observe traits::assign and similar.
; 2260 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2261 :     // This offset skips over the _Container_base members, if any
; 2262 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2263 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2264 : 
; 2265 :     template <class _Iter>
; 2266 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2267 : 
; 2268 : #if _HAS_CXX17
; 2269 :     template <class _StringViewIsh>
; 2270 :     using _Is_string_view_ish =
; 2271 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2272 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2273 :             int>;
; 2274 : #endif // _HAS_CXX17
; 2275 : 
; 2276 : public:
; 2277 :     basic_string(const basic_string& _Right)
; 2278 :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2279 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2280 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2281 :         _Construct_lv_contents(_Right);
; 2282 :         _Proxy._Release();
; 2283 :     }
; 2284 : 
; 2285 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2286 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2287 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2288 :         _Construct_lv_contents(_Right);
; 2289 :         _Proxy._Release();
; 2290 :     }
; 2291 : 
; 2292 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t()) {
; 2293 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2294 :         _Tidy_init();
; 2295 :     }
; 2296 : 
; 2297 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2298 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2299 :         _Tidy_init();
; 2300 :     }
; 2301 : 
; 2302 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2303 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, <end>)
; 2304 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2305 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2306 :         _Tidy_init();
; 2307 :         assign(_Right, _Roff, npos);
; 2308 :         _Proxy._Release();
; 2309 :     }
; 2310 : 
; 2311 :     basic_string(
; 2312 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2313 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2314 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2315 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2316 :         _Tidy_init();
; 2317 :         assign(_Right, _Roff, _Count);
; 2318 :         _Proxy._Release();
; 2319 :     }
; 2320 : 
; 2321 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2322 :         : _Mypair(_Zero_then_variadic_args_t()) {
; 2323 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2324 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2325 :         _Tidy_init();
; 2326 :         assign(_Ptr, _Count);
; 2327 :         _Proxy._Release();
; 2328 :     }
; 2329 : 
; 2330 :     basic_string(
; 2331 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2332 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2333 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2334 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2335 :         _Tidy_init();
; 2336 :         assign(_Ptr, _Count);
; 2337 :         _Proxy._Release();
; 2338 :     }
; 2339 : 
; 2340 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {
; 2341 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2342 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2343 :         _Tidy_init();
; 2344 :         assign(_Ptr);
; 2345 :         _Proxy._Release();
; 2346 :     }
; 2347 : 
; 2348 : #if _HAS_CXX17
; 2349 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2350 : #endif // _HAS_CXX17
; 2351 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Tidy_init();
; 2355 :         assign(_Ptr);
; 2356 :         _Proxy._Release();
; 2357 :     }
; 2358 : 
; 2359 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t()) {
; 2360 :         // construct from _Count * _Ch
; 2361 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2362 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2363 :         _Tidy_init();
; 2364 :         assign(_Count, _Ch);
; 2365 :         _Proxy._Release();
; 2366 :     }
; 2367 : 
; 2368 : #if _HAS_CXX17
; 2369 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2370 : #endif // _HAS_CXX17
; 2371 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2372 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Count * _Ch with allocator
; 2373 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2374 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2375 :         _Tidy_init();
; 2376 :         assign(_Count, _Ch);
; 2377 :         _Proxy._Release();
; 2378 :     }
; 2379 : 
; 2380 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2381 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2382 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2383 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2384 :         _Tidy_init();
; 2385 :         _Adl_verify_range(_First, _Last);
; 2386 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
; 2387 :         _Proxy._Release();
; 2388 :     }
; 2389 : 
; 2390 :     template <class _Iter>
; 2391 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2392 :         // initialize from [_First, _Last), input iterators
; 2393 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2394 :         for (; _First != _Last; ++_First) {
; 2395 :             push_back(*_First);
; 2396 :         }
; 2397 : 
; 2398 :         _Guard._Target = nullptr;
; 2399 :     }
; 2400 : 
; 2401 :     template <class _Iter>
; 2402 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2403 :         // initialize from [_First, _Last), forward iterators
; 2404 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2405 :         reserve(_Count);
; 2406 :         _Construct(_First, _Last, input_iterator_tag());
; 2407 :     }
; 2408 : 
; 2409 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2410 :         // initialize from [_First, _Last), pointers
; 2411 :         if (_First != _Last) {
; 2412 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2413 :         }
; 2414 :     }
; 2415 : 
; 2416 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2417 :         // initialize from [_First, _Last), const pointers
; 2418 :         if (_First != _Last) {
; 2419 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2420 :         }
; 2421 :     }
; 2422 : 
; 2423 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) {
; 2424 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2425 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2426 :     }
; 2427 : 
; 2428 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2429 :         _Alty_traits::is_always_equal::value) // strengthened
; 2430 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2431 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2432 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2433 :         if
; 2434 :             _CONSTEXPR_IF(!_Alty_traits::is_always_equal::value) {
; 2435 :                 if (_Getal() != _Right._Getal()) {
; 2436 :                     _Construct_lv_contents(_Right);
; 2437 :                     _Proxy._Release();
; 2438 :                     return;
; 2439 :                 }
; 2440 :             }
; 2441 : 
; 2442 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2443 :         _Proxy._Release();
; 2444 :     }
; 2445 : 
; 2446 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2447 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2448 :         : _Mypair(
; 2449 :             _One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {
; 2450 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2451 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2452 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2453 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);
; 2454 :         size_type _New_capacity = _BUF_SIZE - 1;
; 2455 :         auto& _My_data          = _Mypair._Myval2;
; 2456 :         _Elem* _Ptr             = _My_data._Bx._Buf;
; 2457 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2458 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2459 :         if (_New_capacity < _New_size) {
; 2460 :             _New_capacity           = _Calculate_growth(_New_size, _BUF_SIZE - 1, max_size());
; 2461 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws
; 2462 :             _Ptr                    = _Unfancy(_Fancyptr);
; 2463 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
; 2464 :         }
; 2465 : 
; 2466 :         _My_data._Mysize = _New_size;
; 2467 :         _My_data._Myres  = _New_capacity;
; 2468 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2469 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
; 2470 :         _Traits::assign(_Ptr[_New_size], _Elem());
; 2471 :         _Proxy._Release();
; 2472 :     }
; 2473 : 
; 2474 :     basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
; 2475 :         : _Mypair(_One_then_variadic_args_t(), _Left._Getal()) {
; 2476 :         auto& _My_data    = _Mypair._Myval2;
; 2477 :         auto& _Left_data  = _Left._Mypair._Myval2;
; 2478 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2479 :         _Left_data._Orphan_all();
; 2480 :         _Right_data._Orphan_all();
; 2481 :         const auto _Left_size  = _Left_data._Mysize;
; 2482 :         const auto _Right_size = _Right_data._Mysize;
; 2483 : 
; 2484 :         const auto _Left_capacity  = _Left_data._Myres;
; 2485 :         const auto _Right_capacity = _Right_data._Myres;
; 2486 :         // overflow is OK due to max_size() checks:
; 2487 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);
; 2488 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
; 2489 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
; 2490 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 2491 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2492 :             _Take_contents(_Left, bool_constant<_Can_memcpy_val>{});
; 2493 :             const auto _Ptr = _My_data._Myptr();
; 2494 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
; 2495 :             _My_data._Mysize = _New_size;
; 2496 :             return;
; 2497 :         }
; 2498 : 
; 2499 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
; 2500 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
; 2501 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 2502 :             // At this point, we have tested:
; 2503 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 2504 :             // therefore: (by De Morgan's Laws)
; 2505 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 2506 :             // therefore: (by the distributive property)
; 2507 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 2508 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 2509 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_string_engaged()
; 2510 :             _STL_INTERNAL_CHECK(_Right_data._Large_string_engaged());
; 2511 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2512 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2513 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
; 2514 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
; 2515 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2516 :             _My_data._Mysize = _New_size;
; 2517 :             return;
; 2518 :         }
; 2519 : 
; 2520 :         // can't use either buffer, reallocate
; 2521 :         const auto _Max = max_size();
; 2522 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK
; 2523 :             _Xlen_string();
; 2524 :         }
; 2525 : 
; 2526 :         const auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);
; 2527 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2528 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2529 :         const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws
; 2530 :         // nothrow hereafter
; 2531 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
; 2532 :         _My_data._Mysize = _New_size;
; 2533 :         _My_data._Myres  = _New_capacity;
; 2534 :         const auto _Ptr  = _Unfancy(_Fancyptr);
; 2535 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2536 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
; 2537 :         _Proxy._Release();
; 2538 :     }
; 2539 : 
; 2540 : #if _HAS_CXX17
; 2541 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2542 :     explicit basic_string(const _StringViewIsh& _Right, const _Alloc& _Al = _Alloc())
; 2543 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2544 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2545 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2546 :         _Tidy_init();
; 2547 :         assign(_Right);
; 2548 :         _Proxy._Release();
; 2549 :     }
; 2550 : 
; 2551 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2552 :     basic_string(
; 2553 :         const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2554 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count) using _Al
; 2555 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2556 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2557 :         _Tidy_init();
; 2558 :         assign(_Right, _Roff, _Count);
; 2559 :         _Proxy._Release();
; 2560 :     }
; 2561 : #endif // _HAS_CXX17
; 2562 : 
; 2563 : private:
; 2564 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {
; 2565 :         _Tidy_deallocate();
; 2566 :         _Pocma(_Getal(), _Right._Getal());
; 2567 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2568 :     }
; 2569 : 
; 2570 :     void _Move_assign(basic_string& _Right, _Propagate_allocators) noexcept {
; 2571 :         if (_Getal() == _Right._Getal()) {
; 2572 :             _Move_assign(_Right, _Equal_allocators{});
; 2573 :         } else {
; 2574 :             // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2575 :             _Mypair._Myval2._Orphan_all();
; 2576 :             _Mypair._Myval2._Reload_proxy(
; 2577 :                 _GET_PROXY_ALLOCATOR(_Alty, _Getal()), _GET_PROXY_ALLOCATOR(_Alty, _Right._Getal()));
; 2578 :             _Pocma(_Getal(), _Right._Getal());
; 2579 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2580 :         }
; 2581 :     }
; 2582 : 
; 2583 :     void _Move_assign(basic_string& _Right, _No_propagate_allocators) {
; 2584 :         if (_Getal() == _Right._Getal()) {
; 2585 :             _Move_assign(_Right, _Equal_allocators{});
; 2586 :         } else {
; 2587 :             assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2588 :         }
; 2589 :     }
; 2590 : 
; 2591 : public:
; 2592 :     basic_string& operator=(basic_string&& _Right) noexcept(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
; 2593 :         if (this != _STD addressof(_Right)) {
; 2594 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});
; 2595 :         }
; 2596 : 
; 2597 :         return *this;
; 2598 :     }
; 2599 : 
; 2600 :     basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = _STD move(_Right))) {
; 2601 :         *this = _STD move(_Right);
; 2602 :         return *this;
; 2603 :     }
; 2604 : 
; 2605 : private:
; 2606 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {
; 2607 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2608 :         const auto _My_data_mem =
; 2609 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2610 :         const auto _Right_data_mem =
; 2611 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
; 2613 :     }
; 2614 : 
; 2615 :     void _Take_contents(basic_string& _Right, true_type) noexcept {
; 2616 :         // assign by stealing _Right's buffer, memcpy optimization
; 2617 :         // pre: this != &_Right
; 2618 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2619 :         // pre: *this owns no memory, iterators orphaned (note:
; 2620 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2621 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2622 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2623 :             // take ownership of _Right's iterators along with its buffer
; 2624 :             _Swap_proxy_and_iterators(_Right);
; 2625 :         } else {
; 2626 :             _Right._Mypair._Myval2._Orphan_all();
; 2627 :         }
; 2628 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2629 : 
; 2630 :         _Memcpy_val_from(_Right);
; 2631 :         _Right._Tidy_init();
; 2632 :     }
; 2633 : 
; 2634 :     void _Take_contents(basic_string& _Right, false_type) noexcept {
; 2635 :         // assign by stealing _Right's buffer, general case
; 2636 :         // pre: this != &_Right
; 2637 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2638 :         // pre: *this owns no memory, iterators orphaned
; 2639 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2640 :         auto& _My_data    = _Mypair._Myval2;
; 2641 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2642 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 2643 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 2644 :             _Right_data._Bx._Ptr = pointer();
; 2645 :             _Swap_proxy_and_iterators(_Right);
; 2646 :         } else { // copy small string buffer
; 2647 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 2648 :             _Right_data._Orphan_all();
; 2649 :         }
; 2650 : 
; 2651 :         _My_data._Mysize = _Right_data._Mysize;
; 2652 :         _My_data._Myres  = _Right_data._Myres;
; 2653 :         _Right._Tidy_init();
; 2654 :     }
; 2655 : 
; 2656 :     void _Construct_lv_contents(const basic_string& _Right) {
; 2657 :         // assign by copying data stored in _Right
; 2658 :         // pre: this != &_Right
; 2659 :         // pre: *this owns no memory, iterators orphaned (note:
; 2660 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2661 :         auto& _Right_data             = _Right._Mypair._Myval2;
; 2662 :         const size_type _Right_size   = _Right_data._Mysize;
; 2663 :         const _Elem* const _Right_ptr = _Right_data._Myptr();
; 2664 :         auto& _My_data                = _Mypair._Myval2;
; 2665 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate
; 2666 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
; 2667 :             _My_data._Mysize = _Right_size;
; 2668 :             _My_data._Myres  = _BUF_SIZE - 1;
; 2669 :             return;
; 2670 :         }
; 2671 : 
; 2672 :         auto& _Al                     = _Getal();
; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());
; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws
; 2675 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);
; 2676 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
; 2677 :         _My_data._Mysize = _Right_size;
; 2678 :         _My_data._Myres  = _New_capacity;
; 2679 :     }
; 2680 : 
; 2681 : public:
; 2682 :     basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
; 2683 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2684 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2685 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2686 :         _Tidy_init();
; 2687 :         assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2688 :         _Proxy._Release();
; 2689 :     }
; 2690 : 
; 2691 :     basic_string& operator=(initializer_list<_Elem> _Ilist) {
; 2692 :         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2693 :     }
; 2694 : 
; 2695 :     basic_string& operator+=(initializer_list<_Elem> _Ilist) {
; 2696 :         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2697 :     }
; 2698 : 
; 2699 :     basic_string& assign(initializer_list<_Elem> _Ilist) {
; 2700 :         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2701 :     }
; 2702 : 
; 2703 :     basic_string& append(initializer_list<_Elem> _Ilist) {
; 2704 :         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2705 :     }
; 2706 : 
; 2707 :     iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) {
; 2708 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2709 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 2710 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2711 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 2712 :         insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2713 :         return begin() + static_cast<difference_type>(_Off);
; 2714 :     }
; 2715 : 
; 2716 :     basic_string& replace(
; 2717 :         const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
; 2718 :         // replace with initializer_list
; 2719 :         _Adl_verify_range(_First, _Last);
; 2720 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2721 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 2722 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2723 :         const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
; 2724 :         const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
; 2725 :         return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2726 :     }
; 2727 : 
; 2728 :     ~basic_string() noexcept {
; 2729 :         _Tidy_deallocate();
; 2730 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2731 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2732 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2733 :         _Mypair._Myval2._Myproxy = nullptr;
; 2734 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2735 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2736 :     }
; 2737 : 
; 2738 :     static constexpr auto npos{static_cast<size_type>(-1)};
; 2739 : 
; 2740 : private:
; 2741 :     void _Copy_assign_val_from_small(const basic_string& _Right) {
; 2742 :         // TRANSITION, VSO-761321; inline into only caller when that's fixed
; 2743 :         _Tidy_deallocate();
; 2744 :         if
; 2745 :             _CONSTEXPR_IF(_Can_memcpy_val) {
; 2746 :                 _Memcpy_val_from(_Right);
; 2747 :             }
; 2748 :         else {
; 2749 :             _Traits::copy(
; 2750 :                 _Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Mysize + 1);
; 2751 :             _Mypair._Myval2._Mysize = _Right._Mypair._Myval2._Mysize;
; 2752 :             _Mypair._Myval2._Myres  = _Right._Mypair._Myval2._Myres;
; 2753 :         }
; 2754 :     }
; 2755 : 
; 2756 :     void _Copy_assign(const basic_string& _Right, false_type) {
; 2757 :         _Pocca(_Getal(), _Right._Getal());
; 2758 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2759 :     }
; 2760 : 
; 2761 :     void _Copy_assign(const basic_string& _Right, true_type) {
; 2762 :         auto& _Al             = _Getal();
; 2763 :         const auto& _Right_al = _Right._Getal();
; 2764 :         if (_Al == _Right_al) {
; 2765 :             _Copy_assign(_Right, false_type{});
; 2766 :             return;
; 2767 :         }
; 2768 : 
; 2769 :         auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2770 :         auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 2771 :         _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 2772 : 
; 2773 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2774 :             const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 2775 :             const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 2776 :             auto _Right_al_non_const = _Right_al;
; 2777 :             const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity); // throws
; 2778 :             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 2779 :             _Tidy_deallocate();
; 2780 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 2781 :             _Mypair._Myval2._Mysize  = _New_size;
; 2782 :             _Mypair._Myval2._Myres   = _New_capacity;
; 2783 :         } else {
; 2784 :             _Copy_assign_val_from_small(_Right);
; 2785 :         }
; 2786 : 
; 2787 :         _Pocca(_Al, _Right_al);
; 2788 :         _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 2789 :     }
; 2790 : 
; 2791 : public:
; 2792 :     basic_string& operator=(const basic_string& _Right) {
; 2793 :         if (this != _STD addressof(_Right)) {
; 2794 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});
; 2795 :         }
; 2796 : 
; 2797 :         return *this;
; 2798 :     }
; 2799 : 
; 2800 : #if _HAS_CXX17
; 2801 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2802 :     basic_string& operator=(const _StringViewIsh& _Right) {
; 2803 :         return assign(_Right);
; 2804 :     }
; 2805 : #endif // _HAS_CXX17
; 2806 : 
; 2807 :     basic_string& operator=(_In_z_ const _Elem* const _Ptr) {
; 2808 :         return assign(_Ptr);
; 2809 :     }
; 2810 : 
; 2811 :     basic_string& operator=(const _Elem _Ch) { // assign {_Ch, _Elem()}
; 2812 :         _Mypair._Myval2._Mysize = 1;
; 2813 :         _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 2814 :         _Traits::assign(_Ptr[0], _Ch);
; 2815 :         _Traits::assign(_Ptr[1], _Elem());
; 2816 :         return *this;
; 2817 :     }
; 2818 : 
; 2819 :     basic_string& operator+=(const basic_string& _Right) {
; 2820 :         return append(_Right);
; 2821 :     }
; 2822 : 
; 2823 : #if _HAS_CXX17
; 2824 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2825 :     basic_string& operator+=(const _StringViewIsh& _Right) {
; 2826 :         return append(_Right);
; 2827 :     }
; 2828 : #endif // _HAS_CXX17
; 2829 : 
; 2830 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
; 2831 :         return append(_Ptr);
; 2832 :     }
; 2833 : 
; 2834 :     basic_string& operator+=(_Elem _Ch) {
; 2835 :         push_back(_Ch);
; 2836 :         return *this;
; 2837 :     }
; 2838 : 
; 2839 :     basic_string& append(const basic_string& _Right) {
; 2840 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2841 :     }
; 2842 : 
; 2843 :     basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 2844 :         // append _Right [_Roff, _Roff + _Count)
; 2845 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 2846 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 2847 :         return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 2848 :     }
; 2849 : 
; 2850 : #if _HAS_CXX17
; 2851 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2852 :     basic_string& append(const _StringViewIsh& _Right) {
; 2853 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2854 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2855 :     }
; 2856 : 
; 2857 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2858 :     basic_string& append(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
; 2859 :         // append _Right [_Roff, _Roff + _Count)
; 2860 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2861 :         return append(_As_view.substr(_Roff, _Count));
; 2862 :     }
; 2863 : #endif // _HAS_CXX17
; 2864 : 
; 2865 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 2866 :         // append [_Ptr, _Ptr + _Count)
; 2867 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 2870 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2871 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
; 2872 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
; 2873 :             return *this;
; 2874 :         }
; 2875 : 
; 2876 :         return _Reallocate_grow_by(
; 2877 :             _Count,
; 2878 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2879 :                 const size_type _Count) {
; 2880 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2881 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2882 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2883 :             },
; 2884 :             _Ptr, _Count);
; 2885 :     }
; 2886 : 
; 2887 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
; 2888 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 2889 :     }
; 2890 : 
; 2891 :     basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // append _Count * _Ch
; 2892 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2893 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 2894 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 2895 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2896 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
; 2897 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
; 2898 :             return *this;
; 2899 :         }
; 2900 : 
; 2901 :         return _Reallocate_grow_by(
; 2902 :             _Count,
; 2903 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2904 :                 const _Elem _Ch) {
; 2905 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2906 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2907 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2908 :             },
; 2909 :             _Count, _Ch);
; 2910 :     }
; 2911 : 
; 2912 : #if _HAS_IF_CONSTEXPR
; 2913 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2914 :     basic_string& append(const _Iter _First, const _Iter _Last) { // append [_First, _Last), input iterators
; 2915 :         _Adl_verify_range(_First, _Last);
; 2916 :         const auto _UFirst = _Get_unwrapped(_First);
; 2917 :         const auto _ULast  = _Get_unwrapped(_Last);
; 2918 :         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2919 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2920 :         } else {
; 2921 :             const basic_string _Right(_UFirst, _ULast, get_allocator());
; 2922 :             return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2923 :         }
; 2924 :     }
; 2925 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 2926 :     template <class _Iter>
; 2927 :     basic_string& _Append_range(const _Iter _UFirst, const _Iter _ULast, true_type) {
; 2928 :         return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2929 :     }
; 2930 : 
; 2931 :     template <class _Iter>
; 2932 :     basic_string& _Append_range(const _Iter _UFirst, const _Iter _ULast, false_type) {
; 2933 :         const basic_string _Right(_UFirst, _ULast, get_allocator());
; 2934 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2935 :     }
; 2936 : 
; 2937 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2938 :     basic_string& append(const _Iter _First, const _Iter _Last) { // append [_First, _Last), input iterators {
; 2939 :         _Adl_verify_range(_First, _Last);
; 2940 :         const auto _UFirst = _Get_unwrapped(_First);
; 2941 :         return _Append_range(_UFirst, _Get_unwrapped(_Last), _Is_elem_cptr<decltype(_UFirst)>{});
; 2942 :     }
; 2943 : #endif // _HAS_IF_CONSTEXPR
; 2944 : 
; 2945 :     basic_string& assign(const basic_string& _Right) {
; 2946 :         *this = _Right;
; 2947 :         return *this;
; 2948 :     }
; 2949 : 
; 2950 :     basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 2951 :         // assign _Right [_Roff, _Roff + _Count)
; 2952 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 2953 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 2954 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 2955 :     }
; 2956 : 
; 2957 : #if _HAS_CXX17
; 2958 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2959 :     basic_string& assign(const _StringViewIsh& _Right) {
; 2960 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2961 :         return assign(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2962 :     }
; 2963 : 
; 2964 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2965 :     basic_string& assign(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
; 2966 :         // assign _Right [_Roff, _Roff + _Count)
; 2967 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2968 :         return assign(_As_view.substr(_Roff, _Count));
; 2969 :     }
; 2970 : #endif // _HAS_CXX17
; 2971 : 
; 2972 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 2973 :         // assign [_Ptr, _Ptr + _Count)
; 2974 :         if (_Count <= _Mypair._Myval2._Myres) {
; 2975 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2976 :             _Mypair._Myval2._Mysize = _Count;
; 2977 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 2978 :             _Traits::assign(_Old_ptr[_Count], _Elem());
; 2979 :             return *this;
; 2980 :         }
; 2981 : 
; 2982 :         return _Reallocate_for(
; 2983 :             _Count,
; 2984 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2985 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2987 :             },
; 2988 :             _Ptr);
; 2989 :     }
; 2990 : 
; 2991 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {
; 2992 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 2993 :     }
; 2994 : 
; 2995 :     basic_string& assign(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // assign _Count * _Ch
; 2996 :         if (_Count <= _Mypair._Myval2._Myres) {
; 2997 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2998 :             _Mypair._Myval2._Mysize = _Count;
; 2999 :             _Traits::assign(_Old_ptr, _Count, _Ch);
; 3000 :             _Traits::assign(_Old_ptr[_Count], _Elem());
; 3001 :             return *this;
; 3002 :         }
; 3003 : 
; 3004 :         return _Reallocate_for(
; 3005 :             _Count,
; 3006 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
; 3007 :                 _Traits::assign(_New_ptr, _Count, _Ch);
; 3008 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3009 :             },
; 3010 :             _Ch);
; 3011 :     }
; 3012 : 
; 3013 : #if _HAS_IF_CONSTEXPR
; 3014 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3015 :     basic_string& assign(const _Iter _First, const _Iter _Last) {
; 3016 :         _Adl_verify_range(_First, _Last);
; 3017 :         const auto _UFirst = _Get_unwrapped(_First);
; 3018 :         const auto _ULast  = _Get_unwrapped(_Last);
; 3019 :         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 3020 :             return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3021 :         } else {
; 3022 :             basic_string _Right(_UFirst, _ULast, get_allocator());
; 3023 :             if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
; 3024 :                 _Mypair._Myval2._Orphan_all();
; 3025 :                 _Swap_data(_Right, bool_constant<_Can_memcpy_val>{});
; 3026 :                 return *this;
; 3027 :             } else {
; 3028 :                 return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3029 :             }
; 3030 :         }
; 3031 :     }
; 3032 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 3033 :     template <class _Iter>
; 3034 :     basic_string& _Assign_range(const _Iter _UFirst, const _Iter _ULast, true_type) {
; 3035 :         return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3036 :     }
; 3037 : 
; 3038 :     template <class _Iter>
; 3039 :     basic_string& _Assign_range(const _Iter _UFirst, const _Iter _ULast, false_type) {
; 3040 :         basic_string _Right(_UFirst, _ULast, get_allocator());
; 3041 :         if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
; 3042 :             _Mypair._Myval2._Orphan_all();
; 3043 :             _Swap_data(_Right, bool_constant<_Can_memcpy_val>{});
; 3044 :             return *this;
; 3045 :         } else {
; 3046 :             return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3047 :         }
; 3048 :     }
; 3049 : 
; 3050 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3051 :     basic_string& assign(const _Iter _First, const _Iter _Last) {
; 3052 :         _Adl_verify_range(_First, _Last);
; 3053 :         const auto _UFirst = _Get_unwrapped(_First);
; 3054 :         return _Assign_range(_UFirst, _Get_unwrapped(_Last), _Is_elem_cptr<decltype(_UFirst)>{});
; 3055 :     }
; 3056 : #endif // _HAS_IF_CONSTEXPR
; 3057 : 
; 3058 :     basic_string& insert(const size_type _Off, const basic_string& _Right) { // insert _Right at _Off
; 3059 :         return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3060 :     }
; 3061 : 
; 3062 :     basic_string& insert(
; 3063 :         const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 3064 :         // insert _Right [_Roff, _Roff + _Count) at _Off
; 3065 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 3066 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 3067 :         return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 3068 :     }
; 3069 : 
; 3070 : #if _HAS_CXX17
; 3071 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3072 :     basic_string& insert(const size_type _Off, const _StringViewIsh& _Right) { // insert _Right at _Off
; 3073 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3074 :         return insert(_Off, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 3075 :     }
; 3076 : 
; 3077 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3078 :     basic_string& insert(const size_type _Off, const _StringViewIsh& _Right, const size_type _Roff,
; 3079 :         const size_type _Count = npos) { // insert _Right [_Roff, _Roff + _Count) at _Off
; 3080 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3081 :         return insert(_Off, _As_view.substr(_Roff, _Count));
; 3082 :     }
; 3083 : #endif // _HAS_CXX17
; 3084 : 
; 3085 :     basic_string& insert(
; 3086 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 3087 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 3088 :         _Mypair._Myval2._Check_offset(_Off);
; 3089 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3090 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 3091 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 3092 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3093 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3094 :             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
; 3095 :             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
; 3096 :             size_type _Ptr_shifted_after;
; 3097 :             if (_Ptr + _Count <= _Insert_at
; 3098 :                 || _Ptr > _Old_ptr + _Old_size) { // inserted content is before the shifted region, or does not alias
; 3099 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts
; 3100 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts
; 3101 :                 _Ptr_shifted_after = 0;
; 3102 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
; 3103 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
; 3104 :             }
; 3105 : 
; 3106 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
; 3107 :             _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
; 3108 :             _Traits::copy(
; 3109 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 3110 :             return *this;
; 3111 :         }
; 3112 : 
; 3113 :         return _Reallocate_grow_by(
; 3114 :             _Count,
; 3115 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3116 :                 const _Elem* const _Ptr, const size_type _Count) {
; 3117 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3118 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3119 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3120 :             },
; 3121 :             _Off, _Ptr, _Count);
; 3122 :     }
; 3123 : 
; 3124 :     basic_string& insert(const size_type _Off, _In_z_ const _Elem* const _Ptr) { // insert [_Ptr, <null>) at _Off
; 3125 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 3126 :     }
; 3127 : 
; 3128 :     basic_string& insert(const size_type _Off, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
; 3129 :         // insert _Count * _Ch at _Off
; 3130 :         _Mypair._Myval2._Check_offset(_Off);
; 3131 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3132 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 3133 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 3134 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3135 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3136 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
; 3137 :             _Traits::assign(_Insert_at, _Count, _Ch); // fill hole
; 3138 :             return *this;
; 3139 :         }
; 3140 : 
; 3141 :         return _Reallocate_grow_by(
; 3142 :             _Count,
; 3143 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3144 :                 const size_type _Count, const _Elem _Ch) {
; 3145 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3146 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 3147 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3148 :             },
; 3149 :             _Off, _Count, _Ch);
; 3150 :     }
; 3151 : 
; 3152 :     iterator insert(const const_iterator _Where, const _Elem _Ch) { // insert _Ch at _Where
; 3153 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3154 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3155 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3156 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3157 :         insert(_Off, 1, _Ch);
; 3158 :         return begin() + static_cast<difference_type>(_Off);
; 3159 :     }
; 3160 : 
; 3161 :     iterator insert(const const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
; 3162 :         // insert _Count * _Elem at _Where
; 3163 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3164 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3165 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3166 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3167 :         insert(_Off, _Count, _Ch);
; 3168 :         return begin() + static_cast<difference_type>(_Off);
; 3169 :     }
; 3170 : 
; 3171 : #if _HAS_IF_CONSTEXPR
; 3172 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3173 :     iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
; 3174 :         // insert [_First, _Last) at _Where, input iterators
; 3175 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3176 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3177 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3178 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3179 :         _Adl_verify_range(_First, _Last);
; 3180 :         const auto _UFirst = _Get_unwrapped(_First);
; 3181 :         const auto _ULast  = _Get_unwrapped(_Last);
; 3182 :         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 3183 :             insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3184 :         } else {
; 3185 :             const basic_string _Right(_UFirst, _ULast, get_allocator());
; 3186 :             insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3187 :         }
; 3188 : 
; 3189 :         return begin() + static_cast<difference_type>(_Off);
; 3190 :     }
; 3191 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 3192 :     template <class _Iter>
; 3193 :     void _Insert_range(const size_type _Off, const _Iter _UFirst, const _Iter _ULast, true_type) {
; 3194 :         insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3195 :     }
; 3196 : 
; 3197 :     template <class _Iter>
; 3198 :     void _Insert_range(const size_type _Off, const _Iter _UFirst, const _Iter _ULast, false_type) {
; 3199 :         const basic_string _Right(_UFirst, _ULast, get_allocator());
; 3200 :         insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3201 :     }
; 3202 : 
; 3203 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3204 :     iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
; 3205 :         // insert [_First, _Last) at _Where, input iterators
; 3206 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3207 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3208 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3209 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3210 :         _Adl_verify_range(_First, _Last);
; 3211 :         const auto _UFirst = _Get_unwrapped(_First);
; 3212 :         _Insert_range(_Off, _UFirst, _Get_unwrapped(_Last), _Is_elem_cptr<decltype(_UFirst)>{});
; 3213 :         return begin() + static_cast<difference_type>(_Off);
; 3214 :     }
; 3215 : #endif // _HAS_IF_CONSTEXPR
; 3216 : 
; 3217 :     basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)
; 3218 :         _Mypair._Myval2._Check_offset(_Off);
; 3219 :         _Eos(_Off);
; 3220 :         return *this;
; 3221 :     }
; 3222 : 
; 3223 :     basic_string& erase(const size_type _Off, size_type _Count) { // erase elements [_Off, _Off + _Count)
; 3224 :         _Mypair._Myval2._Check_offset(_Off);
; 3225 :         _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
; 3226 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3227 :         _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
; 3228 :         _Elem* const _Erase_at    = _My_ptr + _Off;
; 3229 :         const size_type _New_size = _Old_size - _Count;
; 3230 :         _Mypair._Myval2._Mysize   = _New_size;
; 3231 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up
; 3232 :         return *this;
; 3233 :     }
; 3234 : 
; 3235 :     iterator erase(const const_iterator _Where) noexcept /* strengthened */ {
; 3236 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3237 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3238 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3239 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3240 :         erase(_Off, 1);
; 3241 :         return begin() + static_cast<difference_type>(_Off);
; 3242 :     }
; 3243 : 
; 3244 :     iterator erase(const const_iterator _First, const const_iterator _Last) noexcept /* strengthened */ {
; 3245 :         _Adl_verify_range(_First, _Last);
; 3246 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3247 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3248 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3249 :         const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
; 3250 :         erase(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
; 3251 :         return begin() + static_cast<difference_type>(_Off);
; 3252 :     }
; 3253 : 
; 3254 :     void clear() noexcept { // erase all
; 3255 :         _Eos(0);
; 3256 :     }
; 3257 : 
; 3258 :     basic_string& replace(const size_type _Off, const size_type _N0, const basic_string& _Right) {
; 3259 :         // replace [_Off, _Off + _N0) with _Right
; 3260 :         return replace(_Off, _N0, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3261 :     }
; 3262 : 
; 3263 :     basic_string& replace(const size_type _Off, size_type _N0, const basic_string& _Right, const size_type _Roff,
; 3264 :         size_type _Count = npos) {
; 3265 :         // replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 3266 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 3267 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 3268 :         return replace(_Off, _N0, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 3269 :     }
; 3270 : 
; 3271 : #if _HAS_CXX17
; 3272 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3273 :     basic_string& replace(const size_type _Off, const size_type _N0, const _StringViewIsh& _Right) {
; 3274 :         // replace [_Off, _Off + _N0) with _Right
; 3275 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3276 :         return replace(_Off, _N0, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 3277 :     }
; 3278 : 
; 3279 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3280 :     basic_string& replace(const size_type _Off, const size_type _N0, const _StringViewIsh& _Right,
; 3281 :         const size_type _Roff, const size_type _Count = npos) {
; 3282 :         // replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 3283 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3284 :         return replace(_Off, _N0, _As_view.substr(_Roff, _Count));
; 3285 :     }
; 3286 : #endif // _HAS_CXX17
; 3287 : 
; 3288 :     basic_string& replace(
; 3289 :         const size_type _Off, size_type _N0, _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {
; 3290 :         // replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 3291 :         _Mypair._Myval2._Check_offset(_Off);
; 3292 :         _N0 = _Mypair._Myval2._Clamp_suffix_size(_Off, _N0);
; 3293 :         if (_N0 == _Count) { // size doesn't change, so a single move does the trick
; 3294 :             _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
; 3295 :             return *this;
; 3296 :         }
; 3297 : 
; 3298 :         const size_type _Old_size    = _Mypair._Myval2._Mysize;
; 3299 :         const size_type _Suffix_size = _Old_size - _N0 - _Off + 1;
; 3300 :         if (_Count < _N0) { // suffix shifts backwards; we don't have to move anything out of the way
; 3301 :             _Mypair._Myval2._Mysize = _Old_size - (_N0 - _Count);
; 3302 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3303 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3304 :             _Traits::move(_Insert_at, _Ptr, _Count);
; 3305 :             _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Suffix_size);
; 3306 :             return *this;
; 3307 :         }
; 3308 : 
; 3309 :         const size_type _Growth = static_cast<size_type>(_Count - _N0);
; 3310 :         if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { // growth fits
; 3311 :             _Mypair._Myval2._Mysize = _Old_size + _Growth;
; 3312 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3313 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3314 :             _Elem* const _Suffix_at = _Insert_at + _N0;
; 3315 : 
; 3316 :             size_type _Ptr_shifted_after; // see rationale in insert
; 3317 :             if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
; 3318 :                 _Ptr_shifted_after = _Count;
; 3319 :             } else if (_Suffix_at <= _Ptr) {
; 3320 :                 _Ptr_shifted_after = 0;
; 3321 :             } else {
; 3322 :                 _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
; 3323 :             }
; 3324 : 
; 3325 :             _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
; 3326 :             // next case must be move, in case _Ptr begins before _Insert_at and contains part of the hole;
; 3327 :             // this case doesn't occur in insert because the new content must come from outside the removed
; 3328 :             // content there (because in insert there is no removed content)
; 3329 :             _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
; 3330 :             // the next case can be copy, because it comes from the chunk moved out of the way in the
; 3331 :             // first move, and the hole we're filling can't alias the chunk we moved out of the way
; 3332 :             _Traits::copy(
; 3333 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 3334 :             return *this;
; 3335 :         }
; 3336 : 
; 3337 :         return _Reallocate_grow_by(
; 3338 :             _Growth,
; 3339 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3340 :                 const size_type _N0, const _Elem* const _Ptr, const size_type _Count) {
; 3341 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3342 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3343 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
; 3344 :             },
; 3345 :             _Off, _N0, _Ptr, _Count);
; 3346 :     }
; 3347 : 
; 3348 :     basic_string& replace(const size_type _Off, const size_type _N0, _In_z_ const _Elem* const _Ptr) {
; 3349 :         // replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 3350 :         return replace(_Off, _N0, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 3351 :     }
; 3352 : 
; 3353 :     basic_string& replace(const size_type _Off, size_type _N0, const size_type _Count, const _Elem _Ch) {
; 3354 :         // replace [_Off, _Off + _N0) with _Count * _Ch
; 3355 :         _Mypair._Myval2._Check_offset(_Off);
; 3356 :         _N0 = _Mypair._Myval2._Clamp_suffix_size(_Off, _N0);
; 3357 :         if (_Count == _N0) {
; 3358 :             _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
; 3359 :             return *this;
; 3360 :         }
; 3361 : 
; 3362 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3363 :         if (_Count < _N0
; 3364 :             || _Count - _N0 <= _Mypair._Myval2._Myres - _Old_size) { // either we are shrinking, or the growth fits
; 3365 :             _Mypair._Myval2._Mysize = _Old_size + _Count - _N0; // may temporarily overflow;
; 3366 :                                                                 // OK because size_type must be unsigned
; 3367 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3368 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3369 :             _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Old_size - _N0 - _Off + 1);
; 3370 :             _Traits::assign(_Insert_at, _Count, _Ch);
; 3371 :             return *this;
; 3372 :         }
; 3373 : 
; 3374 :         return _Reallocate_grow_by(
; 3375 :             _Count - _N0,
; 3376 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3377 :                 const size_type _N0, const size_type _Count, const _Elem _Ch) {
; 3378 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3379 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 3380 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
; 3381 :             },
; 3382 :             _Off, _N0, _Count, _Ch);
; 3383 :     }
; 3384 : 
; 3385 :     basic_string& replace(const const_iterator _First, const const_iterator _Last, const basic_string& _Right) {
; 3386 :         // replace [_First, _Last) with _Right
; 3387 :         _Adl_verify_range(_First, _Last);
; 3388 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3389 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3390 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3391 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3392 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
; 3393 :     }
; 3394 : 
; 3395 : #if _HAS_CXX17
; 3396 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3397 :     basic_string& replace(const const_iterator _First, const const_iterator _Last, const _StringViewIsh& _Right) {
; 3398 :         // replace [_First, _Last) with _Right
; 3399 :         _Adl_verify_range(_First, _Last);
; 3400 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3401 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3402 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3403 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3404 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
; 3405 :     }
; 3406 : #endif // _HAS_CXX17
; 3407 : 
; 3408 :     basic_string& replace(const const_iterator _First, const const_iterator _Last,
; 3409 :         _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {
; 3410 :         // replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 3411 :         _Adl_verify_range(_First, _Last);
; 3412 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3413 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3414 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3415 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3416 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
; 3417 :     }
; 3418 : 
; 3419 :     basic_string& replace(const const_iterator _First, const const_iterator _Last, _In_z_ const _Elem* const _Ptr) {
; 3420 :         // replace [_First, _Last) with [_Ptr, <null>)
; 3421 :         _Adl_verify_range(_First, _Last);
; 3422 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3423 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3424 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3425 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3426 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
; 3427 :     }
; 3428 : 
; 3429 :     basic_string& replace(
; 3430 :         const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch) {
; 3431 :         // replace [_First, _Last) with _Count * _Ch
; 3432 :         _Adl_verify_range(_First, _Last);
; 3433 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3434 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3435 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3436 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3437 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
; 3438 :     }
; 3439 : 
; 3440 : #if _HAS_IF_CONSTEXPR
; 3441 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3442 :     basic_string& replace(
; 3443 :         const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
; 3444 :         // replace [_First, _Last) with [_First2, _Last2), input iterators
; 3445 :         _Adl_verify_range(_First, _Last);
; 3446 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3447 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3448 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3449 :         const auto _Off    = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
; 3450 :         const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
; 3451 :         _Adl_verify_range(_First2, _Last2);
; 3452 :         const auto _UFirst2 = _Get_unwrapped(_First2);
; 3453 :         const auto _ULast2  = _Get_unwrapped(_Last2);
; 3454 :         if constexpr (_Is_elem_cptr<decltype(_UFirst2)>::value) {
; 3455 :             return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
; 3456 :         } else {
; 3457 :             const basic_string _Right(_UFirst2, _ULast2, get_allocator());
; 3458 :             return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3459 :         }
; 3460 :     }
; 3461 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 3462 :     template <class _Ptr>
; 3463 :     basic_string& _Replace_range(
; 3464 :         const size_type _Off, const size_type _Length, const _Ptr _UFirst2, const _Ptr _ULast2, true_type) {
; 3465 :         // replace [_First, _Last) with [_First2, _Last2), pointers
; 3466 :         return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
; 3467 :     }
; 3468 : 
; 3469 :     template <class _Iter>
; 3470 :     basic_string& _Replace_range(
; 3471 :         const size_type _Off, const size_type _Length, const _Iter _First2, const _Iter _Last2, false_type) {
; 3472 :         // replace [_First, _Last) with [_First2, _Last2), input iterators
; 3473 :         const basic_string _Right(_First2, _Last2, get_allocator());
; 3474 :         return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3475 :     }
; 3476 : 
; 3477 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3478 :     basic_string& replace(
; 3479 :         const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
; 3480 :         // replace [_First, _Last) with [_First2, _Last2), input iterators
; 3481 :         _Adl_verify_range(_First, _Last);
; 3482 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3483 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3484 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3485 :         _Adl_verify_range(_First2, _Last2);
; 3486 :         const auto _UFirst2 = _Get_unwrapped(_First2);
; 3487 :         const auto _ULast2 = _Get_unwrapped(_Last2);
; 3488 :         return _Replace_range(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3489 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _UFirst2, _ULast2, _Is_elem_cptr<decltype(_UFirst2)>{});
; 3490 :     }
; 3491 : #endif // _HAS_IF_CONSTEXPR
; 3492 : 
; 3493 :     _NODISCARD iterator begin() noexcept {
; 3494 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
; 3495 :     }
; 3496 : 
; 3497 :     _NODISCARD const_iterator begin() const noexcept {
; 3498 :         return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
; 3499 :     }
; 3500 : 
; 3501 :     _NODISCARD iterator end() noexcept {
; 3502 :         return iterator(
; 3503 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3504 :             _STD addressof(_Mypair._Myval2));
; 3505 :     }
; 3506 : 
; 3507 :     _NODISCARD const_iterator end() const noexcept {
; 3508 :         return const_iterator(
; 3509 :             _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3510 :             _STD addressof(_Mypair._Myval2));
; 3511 :     }
; 3512 : 
; 3513 :     _Elem* _Unchecked_begin() noexcept {
; 3514 :         return _Mypair._Myval2._Myptr();
; 3515 :     }
; 3516 : 
; 3517 :     const _Elem* _Unchecked_begin() const noexcept {
; 3518 :         return _Mypair._Myval2._Myptr();
; 3519 :     }
; 3520 : 
; 3521 :     _Elem* _Unchecked_end() noexcept {
; 3522 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
; 3523 :     }
; 3524 : 
; 3525 :     const _Elem* _Unchecked_end() const noexcept {
; 3526 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
; 3527 :     }
; 3528 : 
; 3529 :     _NODISCARD reverse_iterator rbegin() noexcept {
; 3530 :         return reverse_iterator(end());
; 3531 :     }
; 3532 : 
; 3533 :     _NODISCARD const_reverse_iterator rbegin() const noexcept {
; 3534 :         return const_reverse_iterator(end());
; 3535 :     }
; 3536 : 
; 3537 :     _NODISCARD reverse_iterator rend() noexcept {
; 3538 :         return reverse_iterator(begin());
; 3539 :     }
; 3540 : 
; 3541 :     _NODISCARD const_reverse_iterator rend() const noexcept {
; 3542 :         return const_reverse_iterator(begin());
; 3543 :     }
; 3544 : 
; 3545 :     _NODISCARD const_iterator cbegin() const noexcept {
; 3546 :         return begin();
; 3547 :     }
; 3548 : 
; 3549 :     _NODISCARD const_iterator cend() const noexcept {
; 3550 :         return end();
; 3551 :     }
; 3552 : 
; 3553 :     _NODISCARD const_reverse_iterator crbegin() const noexcept {
; 3554 :         return rbegin();
; 3555 :     }
; 3556 : 
; 3557 :     _NODISCARD const_reverse_iterator crend() const noexcept {
; 3558 :         return rend();
; 3559 :     }
; 3560 : 
; 3561 :     void shrink_to_fit() { // reduce capacity
; 3562 :         auto& _My_data = _Mypair._Myval2;
; 3563 :         if (!_My_data._Large_string_engaged()) { // can't shrink from small mode
; 3564 :             return;
; 3565 :         }
; 3566 : 
; 3567 :         if (_My_data._Mysize < _BUF_SIZE) {
; 3568 :             _Become_small();
; 3569 :             return;
; 3570 :         }
; 3571 : 
; 3572 :         const size_type _Target_capacity = _Min_value(_My_data._Mysize | _ALLOC_MASK, max_size());
; 3573 :         if (_Target_capacity < _My_data._Myres) { // worth shrinking, do it
; 3574 :             auto& _Al              = _Getal();
; 3575 :             const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); // throws
; 3576 :             _My_data._Orphan_all();
; 3577 :             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
; 3578 :             _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
; 3579 :             _My_data._Bx._Ptr = _New_ptr;
; 3580 :             _My_data._Myres   = _Target_capacity;
; 3581 :         }
; 3582 :     }
; 3583 : 
; 3584 :     _NODISCARD reference at(const size_type _Off) {
; 3585 :         _Mypair._Myval2._Check_offset_exclusive(_Off);
; 3586 :         return _Mypair._Myval2._Myptr()[_Off];
; 3587 :     }
; 3588 : 
; 3589 :     _NODISCARD const_reference at(const size_type _Off) const {
; 3590 :         _Mypair._Myval2._Check_offset_exclusive(_Off);
; 3591 :         return _Mypair._Myval2._Myptr()[_Off];
; 3592 :     }
; 3593 : 
; 3594 :     _NODISCARD reference operator[](const size_type _Off) noexcept /* strengthened */ {
; 3595 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3596 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3597 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3598 :         return _Mypair._Myval2._Myptr()[_Off];
; 3599 :     }
; 3600 : 
; 3601 :     _NODISCARD const_reference operator[](const size_type _Off) const noexcept /* strengthened */ {
; 3602 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3603 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3604 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3605 :         return _Mypair._Myval2._Myptr()[_Off];
; 3606 :     }
; 3607 : 
; 3608 : #if _HAS_CXX17
; 3609 :     /* implicit */ operator basic_string_view<_Elem, _Traits>() const noexcept {
; 3610 :         // return a string_view around *this's character-type sequence
; 3611 :         return basic_string_view<_Elem, _Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize);
; 3612 :     }
; 3613 : #endif // _HAS_CXX17
; 3614 : 
; 3615 :     void push_back(const _Elem _Ch) { // insert element at end
; 3616 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3617 :         if (_Old_size < _Mypair._Myval2._Myres) {
; 3618 :             _Mypair._Myval2._Mysize = _Old_size + 1;
; 3619 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 3620 :             _Traits::assign(_Ptr[_Old_size], _Ch);
; 3621 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 3622 :             return;
; 3623 :         }
; 3624 : 
; 3625 :         _Reallocate_grow_by(
; 3626 :             1,
; 3627 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 3628 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3629 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0001c	88 04 3e	 mov	 BYTE PTR [esi+edi], al

; 3630 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  0001f	c6 44 3e 01 00	 mov	 BYTE PTR [esi+edi+1], 0
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi

; 3631 :             },

  00026	5d		 pop	 ebp
  00027	c2 10 00	 ret	 16			; 00000010H
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBEXQADQBDID@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 3223 :     basic_string& erase(const size_type _Off, size_type _Count) { // erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 2140 :         value_type* _Result = _Bx._Buf;

  00009	8b d6		 mov	 edx, esi

; 2162 :         if (_Mysize < _Off) {

  0000b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 42 c1	 cmovb	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00013	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  00017	72 02		 jb	 SHORT $LN12@erase

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  00019	8b 16		 mov	 edx, DWORD PTR [esi]
$LN12@erase:

; 3224 :         _Mypair._Myval2._Check_offset(_Off);
; 3225 :         _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
; 3226 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3227 :         _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
; 3228 :         _Elem* const _Erase_at    = _My_ptr + _Off;
; 3229 :         const size_type _New_size = _Old_size - _Count;

  0001b	2b c8		 sub	 ecx, eax

; 3230 :         _Mypair._Myval2._Mysize   = _New_size;

  0001d	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 3231 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00020	41		 inc	 ecx

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00021	51		 push	 ecx

; 3231 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00022	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00025	51		 push	 ecx
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3232 :         return *this;

  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi

; 3233 :     }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2991 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 322  :             return __builtin_strlen(_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx

; 2991 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx

; 322  :             return __builtin_strlen(_First);

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL5@assign:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL5@assign
  00017	2b c7		 sub	 eax, edi

; 2992 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00019	8b ce		 mov	 ecx, esi
  0001b	50		 push	 eax
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 2993 :     }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T15 = -12						; size = 4
__Ptr$GSCopy$1$ = -8					; size = 4
$T16 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2972 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 45 f8	 mov	 DWORD PTR __Ptr$GSCopy$1$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]

; 2973 :         // assign [_Ptr, _Ptr + _Count)
; 2974 :         if (_Count <= _Mypair._Myval2._Myres) {

  00014	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00017	89 4d f4	 mov	 DWORD PTR $T15[ebp], ecx
  0001a	3b f9		 cmp	 edi, ecx
  0001c	77 26		 ja	 SHORT $LN2@assign

; 2140 :         value_type* _Result = _Bx._Buf;

  0001e	8b de		 mov	 ebx, esi

; 2158 :         return _BUF_SIZE <= _Myres;

  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  00023	72 02		 jb	 SHORT $LN5@assign

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  00025	8b 1e		 mov	 ebx, DWORD PTR [esi]
$LN5@assign:

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	53		 push	 ebx

; 2975 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2976 :             _Mypair._Myval2._Mysize = _Count;

  0002a	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0002d	e8 00 00 00 00	 call	 _memmove
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2977 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 2978 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00035	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 2989 :     }

  00039	8b c6		 mov	 eax, esi
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN2@assign:

; 4229 :         if (_New_size > max_size()) {

  00044	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  0004a	0f 87 df 00 00
	00		 ja	 $LN74@assign

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00050	8b df		 mov	 ebx, edi
  00052	83 cb 0f	 or	 ebx, 15			; 0000000fH
  00055	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0005b	76 07		 jbe	 SHORT $LN19@assign

; 4211 :             return _Max;

  0005d	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00062	eb 1e		 jmp	 SHORT $LN18@assign
$LN19@assign:

; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00064	8b d1		 mov	 edx, ecx
  00066	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0006b	d1 ea		 shr	 edx, 1
  0006d	2b c2		 sub	 eax, edx
  0006f	3b c8		 cmp	 ecx, eax
  00071	76 07		 jbe	 SHORT $LN20@assign

; 4215 :             return _Max;

  00073	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00078	eb 08		 jmp	 SHORT $LN18@assign
$LN20@assign:

; 4216 :         }
; 4217 : 
; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  0007a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  0007d	3b d8		 cmp	 ebx, eax
  0007f	0f 42 d8	 cmovb	 ebx, eax
$LN18@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4236 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00082	33 c9		 xor	 ecx, ecx
  00084	8b c3		 mov	 eax, ebx
  00086	83 c0 01	 add	 eax, 1
  00089	0f 92 c1	 setb	 cl
  0008c	f7 d9		 neg	 ecx
  0008e	0b c8		 or	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00090	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00096	72 25		 jb	 SHORT $LN27@assign

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  00098	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 90   :     if (_Block_size <= _Bytes) {

  0009b	3b c1		 cmp	 eax, ecx
  0009d	0f 86 91 00 00
	00		 jbe	 $LN75@assign

; 51   :         return ::operator new(_Bytes);

  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  000a9	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  000ab	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000ae	85 c9		 test	 ecx, ecx
  000b0	74 77		 je	 SHORT $LN63@assign

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000b2	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  000b5	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000b8	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000bb	eb 11		 jmp	 SHORT $LN72@assign
$LN27@assign:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

  000bd	85 c9		 test	 ecx, ecx
  000bf	74 0b		 je	 SHORT $LN28@assign

; 51   :         return ::operator new(_Bytes);

  000c1	51		 push	 ecx
  000c2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c7	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  000ca	eb 02		 jmp	 SHORT $LN72@assign
$LN28@assign:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  000cc	33 c0		 xor	 eax, eax
$LN72@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000ce	57		 push	 edi
  000cf	ff 75 f8	 push	 DWORD PTR __Ptr$GSCopy$1$[ebp]

; 4238 :         _Mypair._Myval2._Mysize = _New_size;

  000d2	89 45 fc	 mov	 DWORD PTR $T16[ebp], eax

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000d5	50		 push	 eax

; 4238 :         _Mypair._Myval2._Mysize = _New_size;

  000d6	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 4239 :         _Mypair._Myval2._Myres  = _New_capacity;

  000d9	89 5e 14	 mov	 DWORD PTR [esi+20], ebx

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000dc	e8 00 00 00 00	 call	 _memcpy

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000e1	8b 5d fc	 mov	 ebx, DWORD PTR $T16[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4241 :         if (_BUF_SIZE <= _Old_capacity) {

  000e7	8b 45 f4	 mov	 eax, DWORD PTR $T15[ebp]

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000ea	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 4241 :         if (_BUF_SIZE <= _Old_capacity) {

  000ee	83 f8 10	 cmp	 eax, 16			; 00000010H
  000f1	72 29		 jb	 SHORT $LN13@assign

; 4242 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000f3	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f6	8b 06		 mov	 eax, DWORD PTR [esi]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000f8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000fe	72 12		 jb	 SHORT $LN66@assign

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00100	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00103	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00106	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00108	83 c0 fc	 add	 eax, -4			; fffffffcH
  0010b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0010e	77 19		 ja	 SHORT $LN63@assign

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00110	8b c2		 mov	 eax, edx
$LN66@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00112	51		 push	 ecx
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00119	83 c4 08	 add	 esp, 8
$LN13@assign:
  0011c	5f		 pop	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2982 :         return _Reallocate_for(

  0011d	89 1e		 mov	 DWORD PTR [esi], ebx

; 2989 :     }

  0011f	8b c6		 mov	 eax, esi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c2 08 00	 ret	 8
$LN63@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN74@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4230 :             _Xlen_string(); // result too long

  0012f	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN75@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00134	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN70@assign:
  00139	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBEXQADI0@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBEXQADI0@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator(), COMDAT
; _this$dead$ = ecx

; 2987 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]

; 2987 :             },

  00007	57		 push	 edi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 333  :     }
; 334  : 
; 335  :     _Pre_satisfies_(_Size_in_bytes >= _Count) static _Elem* _Copy_s(_Out_writes_all_(_Size_in_bytes)
; 336  :                                                                         _Elem* const _First1,
; 337  :         const size_t _Size_in_bytes, _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept {
; 338  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 339  :         _STL_VERIFY(_Count <= _Size_in_bytes, "invalid argument");
; 340  :         return copy(_First1, _First2, _Count);
; 341  :     }
; 342  : 
; 343  :     _NODISCARD static _CONSTEXPR17 const _Elem* find(_In_reads_(_Count) const _Elem* const _First, const size_t _Count,
; 344  :         const _Elem& _Ch) noexcept /* strengthened */ {
; 345  :         // look for _Ch in [_First, _First + _Count)
; 346  : #if _HAS_CXX17
; 347  : #ifdef __cpp_char8_t
; 348  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 349  : #if _HAS_U8_INTRINSICS
; 350  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 351  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 352  :             return _Char_traits<_Elem, _Int_type>::find(_First, _Count, _Ch);
; 353  : #endif // _HAS_U8_INTRINSICS
; 354  :         } else
; 355  : #endif // __cpp_char8_t
; 356  :         {
; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);
; 358  :         }
; 359  : #else // _HAS_CXX17
; 360  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));
; 361  : #endif // _HAS_CXX17
; 362  :     }
; 363  : 
; 364  :     static _Elem* move(_Out_writes_all_(_Count) _Elem* const _First1, _In_reads_(_Count) const _Elem* const _First2,
; 365  :         const size_t _Count) noexcept /* strengthened */ {
; 366  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));
; 368  :     }
; 369  : 
; 370  :     static _Elem* assign(_Out_writes_all_(_Count) _Elem* const _First, const size_t _Count,
; 371  :         const _Elem _Ch) noexcept /* strengthened */ {
; 372  :         // assign _Count * _Ch to [_First, ...)
; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));
; 374  :     }
; 375  : 
; 376  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {
; 377  :         _Left = _Right;
; 378  :     }
; 379  : 
; 380  :     _NODISCARD static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
; 381  :         return _Left == _Right;
; 382  :     }
; 383  : 
; 384  :     _NODISCARD static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
; 385  :         return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
; 386  :     }
; 387  : 
; 388  :     _NODISCARD static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
; 389  :         return static_cast<_Elem>(_Meta);
; 390  :     }
; 391  : 
; 392  :     _NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
; 393  :         return static_cast<unsigned char>(_Ch);
; 394  :     }
; 395  : 
; 396  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
; 397  :         return _Left == _Right;
; 398  :     }
; 399  : 
; 400  :     _NODISCARD static constexpr int_type not_eof(const int_type& _Meta) noexcept {
; 401  :         return _Meta != eof() ? _Meta : !eof();
; 402  :     }
; 403  : 
; 404  :     _NODISCARD static constexpr int_type eof() noexcept {
; 405  :         return static_cast<int_type>(EOF);
; 406  :     }
; 407  : };
; 408  : 
; 409  : #undef _HAS_U8_INTRINSICS
; 410  : 
; 411  : // STRUCT char_traits<char> (FROM <string>)
; 412  : template <>
; 413  : struct char_traits<char> : _Narrow_char_traits<char, int> {}; // properties of a string or stream char element
; 414  : 
; 415  : #ifdef __cpp_char8_t
; 416  : // STRUCT char_traits<char8_t>
; 417  : template <>
; 418  : struct char_traits<char8_t> : _Narrow_char_traits<char8_t, unsigned int> {};
; 419  : 
; 420  : #ifdef __cpp_lib_char8_t
; 421  : using u8streampos = streampos;
; 422  : #endif // __cpp_lib_char8_t
; 423  : #endif // __cpp_char8_t
; 424  : 
; 425  : template <class _Elem, class _Traits, class _SizeT>
; 426  : basic_ostream<_Elem, _Traits>& _Insert_string(
; 427  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {
; 428  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 429  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 430  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;
; 431  : 
; 432  :     _SizeT _Pad;
; 433  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
; 434  :         _Pad = 0;
; 435  :     } else {
; 436  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
; 437  :     }
; 438  : 
; 439  :     const typename _Ostr_t::sentry _Ok(_Ostr);
; 440  : 
; 441  :     if (!_Ok) {
; 442  :         _State |= _Ostr_t::badbit;
; 443  :     } else { // state okay, insert characters
; 444  :         _TRY_IO_BEGIN
; 445  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
; 446  :             for (; 0 < _Pad; --_Pad) { // pad on left
; 447  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 448  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 449  :                     break;
; 450  :                 }
; 451  :             }
; 452  :         }
; 453  : 
; 454  :         if (_State == _Ostr_t::goodbit
; 455  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
; 456  :             _State |= _Ostr_t::badbit;
; 457  :         } else {
; 458  :             for (; 0 < _Pad; --_Pad) { // pad on right
; 459  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 460  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 461  :                     break;
; 462  :                 }
; 463  :             }
; 464  :         }
; 465  : 
; 466  :         _Ostr.width(0);
; 467  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 468  :     }
; 469  : 
; 470  :     _Ostr.setstate(_State);
; 471  :     return _Ostr;
; 472  : }
; 473  : 
; 474  : // STRUCT TEMPLATE _Char_traits_eq
; 475  : template <class _Traits>
; 476  : struct _Char_traits_eq {
; 477  :     using _Elem = typename _Traits::char_type;
; 478  : 
; 479  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 480  :         return _Traits::eq(_Left, _Right);
; 481  :     }
; 482  : };
; 483  : 
; 484  : // STRUCT TEMPLATE _Char_traits_lt
; 485  : template <class _Traits>
; 486  : struct _Char_traits_lt {
; 487  :     using _Elem = typename _Traits::char_type;
; 488  : 
; 489  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 490  :         return _Traits::lt(_Left, _Right);
; 491  :     }
; 492  : };
; 493  : 
; 494  : template <class _Elem>
; 495  : struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
; 496  :     : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type { // builtin char_traits::eq behaves like equal_to<>
; 497  : };
; 498  : 
; 499  : template <class _Traits>
; 500  : using _Traits_ch_t = typename _Traits::char_type;
; 501  : 
; 502  : template <class _Traits>
; 503  : using _Traits_ptr_t = const typename _Traits::char_type*;
; 504  : 
; 505  : template <class _Traits>
; 506  : constexpr bool _Traits_equal(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 507  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
; 508  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
; 510  : }
; 511  : 
; 512  : template <class _Traits>
; 513  : constexpr int _Traits_compare(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 514  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
; 515  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 516  :     const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));
; 517  : 
; 518  :     if (_Ans != 0) {
; 519  :         return _Ans;
; 520  :     }
; 521  : 
; 522  :     if (_Left_size < _Right_size) {
; 523  :         return -1;
; 524  :     }
; 525  : 
; 526  :     if (_Left_size > _Right_size) {
; 527  :         return 1;
; 528  :     }
; 529  : 
; 530  :     return 0;
; 531  : }
; 532  : 
; 533  : template <class _Traits>
; 534  : constexpr size_t _Traits_find(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 535  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 536  :     const size_t _Needle_size) noexcept {
; 537  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 538  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
; 539  :         // xpos cannot exist, report failure
; 540  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 541  :         // 1. _Start_at <= xpos
; 542  :         // 2. xpos + _Needle_size <= _Hay_size;
; 543  :         // therefore:
; 544  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 545  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 546  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 547  :         return static_cast<size_t>(-1);
; 548  :     }
; 549  : 
; 550  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 551  :         return _Start_at;
; 552  :     }
; 553  : 
; 554  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
; 555  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 556  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
; 557  :         if (!_Match_try) { // didn't find first character; report failure
; 558  :             return static_cast<size_t>(-1);
; 559  :         }
; 560  : 
; 561  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match
; 562  :             return static_cast<size_t>(_Match_try - _Haystack);
; 563  :         }
; 564  :     }
; 565  : }
; 566  : 
; 567  : template <class _Traits>
; 568  : constexpr size_t _Traits_find_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 569  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 570  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch, at/after _Start_at
; 571  :     if (_Start_at < _Hay_size) {
; 572  :         const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
; 573  :         if (_Found_at) {
; 574  :             return static_cast<size_t>(_Found_at - _Haystack);
; 575  :         }
; 576  :     }
; 577  : 
; 578  :     return static_cast<size_t>(-1); // (npos) no match
; 579  : }
; 580  : 
; 581  : template <class _Traits>
; 582  : constexpr size_t _Traits_rfind(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 583  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 584  :     const size_t _Needle_size) noexcept {
; 585  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size) beginning before _Start_at
; 586  :     if (_Needle_size == 0) {
; 587  :         return _Min_value(_Start_at, _Hay_size); // empty string always matches
; 588  :     }
; 589  : 
; 590  :     if (_Needle_size <= _Hay_size) { // room for match, look for it
; 591  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
; 592  :             if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
; 593  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 594  :             }
; 595  : 
; 596  :             if (_Match_try == _Haystack) {
; 597  :                 break; // at beginning, no more chance for match
; 598  :             }
; 599  :         }
; 600  :     }
; 601  : 
; 602  :     return static_cast<size_t>(-1); // no match
; 603  : }
; 604  : 
; 605  : template <class _Traits>
; 606  : constexpr size_t _Traits_rfind_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 607  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 608  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
; 609  :     if (_Hay_size != 0) { // room for match, look for it
; 610  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 611  :             if (_Traits::eq(*_Match_try, _Ch)) {
; 612  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 613  :             }
; 614  : 
; 615  :             if (_Match_try == _Haystack) {
; 616  :                 break; // at beginning, no more chance for match
; 617  :             }
; 618  :         }
; 619  :     }
; 620  : 
; 621  :     return static_cast<size_t>(-1); // no match
; 622  : }
; 623  : 
; 624  : template <class _Elem, bool = _Is_character<_Elem>::value>
; 625  : class _String_bitmap { // _String_bitmap for character types
; 626  : public:
; 627  :     constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
; 628  :         // mark this bitmap such that the characters in [_First, _Last) are intended to match
; 629  :         // returns whether all inputs can be placed in the bitmap
; 630  :         for (; _First != _Last; ++_First) {
; 631  :             _Matches[static_cast<unsigned char>(*_First)] = true;
; 632  :         }
; 633  : 
; 634  :         return true;
; 635  :     }
; 636  : 
; 637  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 638  :         return _Matches[static_cast<unsigned char>(_Ch)];
; 639  :     }
; 640  : 
; 641  : private:
; 642  :     bool _Matches[256] = {};
; 643  : };
; 644  : 
; 645  : template <class _Elem>
; 646  : class _String_bitmap<_Elem, false> { // _String_bitmap for wchar_t/unsigned short/char16_t/char32_t/etc. types
; 647  : public:
; 648  :     static_assert(is_unsigned_v<_Elem>,
; 649  :         "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
; 650  :         "Visual C++ accepts other unsigned integral types as an extension.");
; 651  : 
; 652  :     constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
; 653  :         // mark this bitmap such that the characters in [_First, _Last) are intended to match
; 654  :         // returns whether all inputs can be placed in the bitmap
; 655  :         for (; _First != _Last; ++_First) {
; 656  :             const auto _Ch = *_First;
; 657  :             if (_Ch >= 256U) {
; 658  :                 return false;
; 659  :             }
; 660  : 
; 661  :             _Matches[static_cast<unsigned char>(_Ch)] = true;
; 662  :         }
; 663  : 
; 664  :         return true;
; 665  :     }
; 666  : 
; 667  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 668  :         return _Ch < 256U && _Matches[_Ch];
; 669  :     }
; 670  : 
; 671  : private:
; 672  :     bool _Matches[256] = {};
; 673  : };
; 674  : 
; 675  : template <class _Traits>
; 676  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 677  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 678  :     const size_t _Needle_size, false_type) noexcept {
; 679  :     // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 680  :     // general algorithm
; 681  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 682  :         const auto _End = _Haystack + _Hay_size;
; 683  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 684  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 685  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 686  :             }
; 687  :         }
; 688  :     }
; 689  : 
; 690  :     return static_cast<size_t>(-1); // no match
; 691  : }
; 692  : 
; 693  : template <class _Traits>
; 694  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 695  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 696  :     const size_t _Needle_size, true_type) noexcept {
; 697  :     // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 698  :     // special case for std::char_traits
; 699  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 700  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 701  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 702  :                                                                 // fall back to the serial algorithm
; 703  :             return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 704  :         }
; 705  : 
; 706  :         const auto _End = _Haystack + _Hay_size;
; 707  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 708  :             if (_Matches._Match(*_Match_try)) {
; 709  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 710  :             }
; 711  :         }
; 712  :     }
; 713  : 
; 714  :     return static_cast<size_t>(-1); // no match
; 715  : }
; 716  : 
; 717  : template <class _Traits>
; 718  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 719  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 720  :     const size_t _Needle_size, false_type) noexcept {
; 721  :     // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
; 722  :     // general algorithm
; 723  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 724  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 725  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 726  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 727  :             }
; 728  : 
; 729  :             if (_Match_try == _Haystack) {
; 730  :                 break; // at beginning, no more chance for match
; 731  :             }
; 732  :         }
; 733  :     }
; 734  : 
; 735  :     return static_cast<size_t>(-1); // no match
; 736  : }
; 737  : 
; 738  : template <class _Traits>
; 739  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 740  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 741  :     const size_t _Needle_size, true_type) noexcept {
; 742  :     // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
; 743  :     // special case for std::char_traits
; 744  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 745  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 746  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 747  :                                                                 // fall back to the serial algorithm
; 748  :             return _Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 749  :         }
; 750  : 
; 751  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 752  :             if (_Matches._Match(*_Match_try)) {
; 753  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 754  :             }
; 755  : 
; 756  :             if (_Match_try == _Haystack) {
; 757  :                 break; // at beginning, no more chance for match
; 758  :             }
; 759  :         }
; 760  :     }
; 761  : 
; 762  :     return static_cast<size_t>(-1); // no match
; 763  : }
; 764  : 
; 765  : template <class _Traits>
; 766  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 767  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 768  :     const size_t _Needle_size, false_type) noexcept {
; 769  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 770  :     // general algorithm
; 771  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 772  :         const auto _End = _Haystack + _Hay_size;
; 773  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 774  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 775  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 776  :             }
; 777  :         }
; 778  :     }
; 779  : 
; 780  :     return static_cast<size_t>(-1); // no match
; 781  : }
; 782  : 
; 783  : template <class _Traits>
; 784  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 785  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 786  :     const size_t _Needle_size, true_type) noexcept {
; 787  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 788  :     // special case for std::char_traits
; 789  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 790  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 791  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 792  :                                                                 // fall back to the serial algorithm
; 793  :             return _Traits_find_first_not_of<_Traits>(
; 794  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 795  :         }
; 796  : 
; 797  :         const auto _End = _Haystack + _Hay_size;
; 798  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 799  :             if (!_Matches._Match(*_Match_try)) {
; 800  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 801  :             }
; 802  :         }
; 803  :     }
; 804  : 
; 805  :     return static_cast<size_t>(-1); // no match
; 806  : }
; 807  : 
; 808  : template <class _Traits>
; 809  : constexpr size_t _Traits_find_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 810  :     const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 811  :     // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch, at/after _Start_at
; 812  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 813  :         const auto _End = _Haystack + _Hay_size;
; 814  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 815  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 816  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 817  :             }
; 818  :         }
; 819  :     }
; 820  : 
; 821  :     return static_cast<size_t>(-1); // no match
; 822  : }
; 823  : 
; 824  : template <class _Traits>
; 825  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 826  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 827  :     const size_t _Needle_size, false_type) noexcept {
; 828  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
; 829  :     // general algorithm
; 830  :     if (_Hay_size != 0) { // worth searching, do it
; 831  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 832  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 833  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 834  :             }
; 835  : 
; 836  :             if (_Match_try == _Haystack) {
; 837  :                 break; // at beginning, no more chance for match
; 838  :             }
; 839  :         }
; 840  :     }
; 841  : 
; 842  :     return static_cast<size_t>(-1); // no match
; 843  : }
; 844  : 
; 845  : template <class _Traits>
; 846  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 847  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 848  :     const size_t _Needle_size, true_type) noexcept {
; 849  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
; 850  :     // special case for std::char_traits
; 851  :     if (_Hay_size != 0) { // worth searching, do it
; 852  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 853  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 854  :                                                                 // fall back to the serial algorithm
; 855  :             return _Traits_find_last_not_of<_Traits>(
; 856  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 857  :         }
; 858  : 
; 859  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 860  :             if (!_Matches._Match(*_Match_try)) {
; 861  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 862  :             }
; 863  : 
; 864  :             if (_Match_try == _Haystack) {
; 865  :                 break; // at beginning, no more chance for match
; 866  :             }
; 867  :         }
; 868  :     }
; 869  : 
; 870  :     return static_cast<size_t>(-1); // no match
; 871  : }
; 872  : 
; 873  : template <class _Traits>
; 874  : constexpr size_t _Traits_rfind_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 875  :     const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 876  :     // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch before _Start_at
; 877  :     if (_Hay_size != 0) { // room for match, look for it
; 878  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 879  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 880  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 881  :             }
; 882  : 
; 883  :             if (_Match_try == _Haystack) {
; 884  :                 break; // at beginning, no more chance for match
; 885  :             }
; 886  :         }
; 887  :     }
; 888  : 
; 889  :     return static_cast<size_t>(-1); // no match
; 890  : }
; 891  : 
; 892  : 
; 893  : #if _HAS_CXX17
; 894  : // CLASS TEMPLATE _String_view_iterator
; 895  : template <class _Elem, class _Traits = char_traits<_Elem>>
; 896  : class basic_string_view;
; 897  : 
; 898  : template <class _Traits>
; 899  : class _String_view_iterator {
; 900  : public:
; 901  : #ifdef __cpp_lib_concepts
; 902  :     using iterator_concept = contiguous_iterator_tag;
; 903  : #endif // __cpp_lib_concepts
; 904  :     using iterator_category = random_access_iterator_tag;
; 905  :     using value_type        = typename _Traits::char_type;
; 906  :     using difference_type   = ptrdiff_t;
; 907  :     using pointer           = const value_type*;
; 908  :     using reference         = const value_type&;
; 909  : 
; 910  :     constexpr _String_view_iterator() noexcept = default;
; 911  : 
; 912  : private:
; 913  :     friend basic_string_view<value_type, _Traits>;
; 914  : 
; 915  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 916  :     constexpr _String_view_iterator(const pointer _Data, const size_t _Size, const size_t _Off) noexcept
; 917  :         : _Mydata(_Data), _Mysize(_Size), _Myoff(_Off) {}
; 918  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 919  :     constexpr explicit _String_view_iterator(const pointer _Ptr) noexcept : _Myptr(_Ptr) {}
; 920  : #endif // _ITERATOR_DEBUG_LEVEL
; 921  : 
; 922  : public:
; 923  :     _NODISCARD constexpr reference operator*() const noexcept {
; 924  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 925  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 926  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 927  :         return _Mydata[_Myoff];
; 928  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 929  :         return *_Myptr;
; 930  : #endif // _ITERATOR_DEBUG_LEVEL
; 931  :     }
; 932  : 
; 933  :     _NODISCARD constexpr pointer operator->() const noexcept {
; 934  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 935  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 936  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 937  :         return _Mydata + _Myoff;
; 938  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 939  :         return _Myptr;
; 940  : #endif // _ITERATOR_DEBUG_LEVEL
; 941  :     }
; 942  : 
; 943  :     constexpr _String_view_iterator& operator++() noexcept {
; 944  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 945  :         _STL_VERIFY(_Mydata, "cannot increment value-initialized string_view iterator");
; 946  :         _STL_VERIFY(_Myoff < _Mysize, "cannot increment string_view iterator past end");
; 947  :         ++_Myoff;
; 948  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 949  :         ++_Myptr;
; 950  : #endif // _ITERATOR_DEBUG_LEVEL
; 951  :         return *this;
; 952  :     }
; 953  : 
; 954  :     constexpr _String_view_iterator operator++(int) noexcept {
; 955  :         _String_view_iterator _Tmp{*this};
; 956  :         ++*this;
; 957  :         return _Tmp;
; 958  :     }
; 959  : 
; 960  :     constexpr _String_view_iterator& operator--() noexcept {
; 961  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 962  :         _STL_VERIFY(_Mydata, "cannot decrement value-initialized string_view iterator");
; 963  :         _STL_VERIFY(_Myoff != 0, "cannot decrement string_view iterator before begin");
; 964  :         --_Myoff;
; 965  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 966  :         --_Myptr;
; 967  : #endif // _ITERATOR_DEBUG_LEVEL
; 968  :         return *this;
; 969  :     }
; 970  : 
; 971  :     constexpr _String_view_iterator operator--(int) noexcept {
; 972  :         _String_view_iterator _Tmp{*this};
; 973  :         --*this;
; 974  :         return _Tmp;
; 975  :     }
; 976  : 
; 977  :     constexpr void _Verify_offset(const difference_type _Off) const noexcept {
; 978  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 979  :         if (_Off != 0) {
; 980  :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 981  :         }
; 982  : 
; 983  :         if (_Off < 0) {
; 984  : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 985  :             _STL_VERIFY(_Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 986  :         }
; 987  : 
; 988  :         if (_Off > 0) {
; 989  :             _STL_VERIFY(_Mysize - _Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 990  :         }
; 991  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 992  :         (void) _Off;
; 993  : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 994  :     }
; 995  : 
; 996  :     constexpr _String_view_iterator& operator+=(const difference_type _Off) noexcept {
; 997  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 998  :         _Verify_offset(_Off);
; 999  :         _Myoff += _Off;
; 1000 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1001 :         _Myptr += _Off;
; 1002 : #endif // _ITERATOR_DEBUG_LEVEL
; 1003 : 
; 1004 :         return *this;
; 1005 :     }
; 1006 : 
; 1007 :     _NODISCARD constexpr _String_view_iterator operator+(const difference_type _Off) const noexcept {
; 1008 :         _String_view_iterator _Tmp{*this};
; 1009 :         _Tmp += _Off;
; 1010 :         return _Tmp;
; 1011 :     }
; 1012 : 
; 1013 :     constexpr _String_view_iterator& operator-=(const difference_type _Off) noexcept {
; 1014 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1015 :         if (_Off != 0) {
; 1016 :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 1017 :         }
; 1018 : 
; 1019 :         if (_Off > 0) {
; 1020 :             _STL_VERIFY(_Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 1021 :         }
; 1022 : 
; 1023 :         if (_Off < 0) {
; 1024 : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 1025 :             _STL_VERIFY(_Mysize - _Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 1026 :         }
; 1027 : 
; 1028 :         _Myoff -= _Off;
; 1029 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1030 :         _Myptr -= _Off;
; 1031 : #endif // _ITERATOR_DEBUG_LEVEL
; 1032 : 
; 1033 :         return *this;
; 1034 :     }
; 1035 : 
; 1036 :     _NODISCARD constexpr _String_view_iterator operator-(const difference_type _Off) const noexcept {
; 1037 :         _String_view_iterator _Tmp{*this};
; 1038 :         _Tmp -= _Off;
; 1039 :         return _Tmp;
; 1040 :     }
; 1041 : 
; 1042 :     _NODISCARD constexpr difference_type operator-(const _String_view_iterator& _Right) const noexcept {
; 1043 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1044 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1045 :             "cannot subtract incompatible string_view iterators");
; 1046 :         return static_cast<difference_type>(_Myoff - _Right._Myoff);
; 1047 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1048 :         return _Myptr - _Right._Myptr;
; 1049 : #endif // _ITERATOR_DEBUG_LEVEL
; 1050 :     }
; 1051 : 
; 1052 :     _NODISCARD constexpr reference operator[](const difference_type _Off) const noexcept {
; 1053 :         return *(*this + _Off);
; 1054 :     }
; 1055 : 
; 1056 :     _NODISCARD constexpr bool operator==(const _String_view_iterator& _Right) const noexcept {
; 1057 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1058 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1059 :             "cannot compare incompatible string_view iterators for equality");
; 1060 :         return _Myoff == _Right._Myoff;
; 1061 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1062 :         return _Myptr == _Right._Myptr;
; 1063 : #endif // _ITERATOR_DEBUG_LEVEL
; 1064 :     }
; 1065 : 
; 1066 :     _NODISCARD constexpr bool operator!=(const _String_view_iterator& _Right) const noexcept {
; 1067 :         return !(*this == _Right);
; 1068 :     }
; 1069 : 
; 1070 :     _NODISCARD constexpr bool operator<(const _String_view_iterator& _Right) const noexcept {
; 1071 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1072 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1073 :             "cannot compare incompatible string_view iterators");
; 1074 :         return _Myoff < _Right._Myoff;
; 1075 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1076 :         return _Myptr < _Right._Myptr;
; 1077 : #endif // _ITERATOR_DEBUG_LEVEL
; 1078 :     }
; 1079 : 
; 1080 :     _NODISCARD constexpr bool operator>(const _String_view_iterator& _Right) const noexcept {
; 1081 :         return _Right < *this;
; 1082 :     }
; 1083 : 
; 1084 :     _NODISCARD constexpr bool operator<=(const _String_view_iterator& _Right) const noexcept {
; 1085 :         return !(_Right < *this);
; 1086 :     }
; 1087 : 
; 1088 :     _NODISCARD constexpr bool operator>=(const _String_view_iterator& _Right) const noexcept {
; 1089 :         return !(*this < _Right);
; 1090 :     }
; 1091 : 
; 1092 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1093 :     friend constexpr void _Verify_range(const _String_view_iterator& _First, const _String_view_iterator& _Last) {
; 1094 :         _STL_VERIFY(_First._Mydata == _Last._Mydata && _First._Mysize == _Last._Mysize,
; 1095 :             "string_view iterators in range are from different views");
; 1096 :         _STL_VERIFY(_First._Myoff <= _Last._Myoff, "string_view iterator range transposed");
; 1097 :     }
; 1098 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1099 : 
; 1100 :     using _Prevent_inheriting_unwrap = _String_view_iterator;
; 1101 : 
; 1102 :     _NODISCARD constexpr pointer _Unwrapped() const noexcept {
; 1103 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1104 :         return _Mydata + _Myoff;
; 1105 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1106 :         return _Myptr;
; 1107 : #endif // _ITERATOR_DEBUG_LEVEL
; 1108 :     }
; 1109 : 
; 1110 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1111 : 
; 1112 :     constexpr void _Seek_to(pointer _It) noexcept {
; 1113 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1114 :         _Myoff = static_cast<size_t>(_It - _Mydata);
; 1115 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1116 :         _Myptr = _It;
; 1117 : #endif // _ITERATOR_DEBUG_LEVEL
; 1118 :     }
; 1119 : 
; 1120 : private:
; 1121 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1122 :     pointer _Mydata = nullptr;
; 1123 :     size_t _Mysize  = 0;
; 1124 :     size_t _Myoff   = 0;
; 1125 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1126 :     pointer _Myptr = nullptr;
; 1127 : #endif // _ITERATOR_DEBUG_LEVEL
; 1128 : };
; 1129 : 
; 1130 : template <class _Traits>
; 1131 : _NODISCARD constexpr _String_view_iterator<_Traits> operator+(
; 1132 :     const typename _String_view_iterator<_Traits>::difference_type _Off,
; 1133 :     _String_view_iterator<_Traits> _Right) noexcept {
; 1134 :     _Right += _Off;
; 1135 :     return _Right;
; 1136 : }
; 1137 : 
; 1138 : #if _HAS_CXX20
; 1139 : template <class _Traits>
; 1140 : struct pointer_traits<_String_view_iterator<_Traits>> {
; 1141 :     using pointer         = _String_view_iterator<_Traits>;
; 1142 :     using element_type    = const typename pointer::value_type;
; 1143 :     using difference_type = typename pointer::difference_type;
; 1144 : 
; 1145 :     _NODISCARD static constexpr element_type* to_address(const pointer& _Iter) noexcept {
; 1146 :         return _Iter._Unwrapped();
; 1147 :     }
; 1148 : };
; 1149 : #endif // _HAS_CXX20
; 1150 : 
; 1151 : 
; 1152 : // CLASS TEMPLATE basic_string_view
; 1153 : template <class _Elem, class _Traits>
; 1154 : class basic_string_view { // wrapper for any kind of contiguous character buffer
; 1155 : public:
; 1156 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 1157 :         "Bad char_traits for basic_string_view; "
; 1158 :         "N4659 24.4.2 [string.view.template]/1 \"the type traits::char_type shall name the same type as charT.\"");
; 1159 : 
; 1160 :     using traits_type            = _Traits;
; 1161 :     using value_type             = _Elem;
; 1162 :     using pointer                = _Elem*;
; 1163 :     using const_pointer          = const _Elem*;
; 1164 :     using reference              = _Elem&;
; 1165 :     using const_reference        = const _Elem&;
; 1166 :     using const_iterator         = _String_view_iterator<_Traits>;
; 1167 :     using iterator               = const_iterator;
; 1168 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 1169 :     using reverse_iterator       = const_reverse_iterator;
; 1170 :     using size_type              = size_t;
; 1171 :     using difference_type        = ptrdiff_t;
; 1172 : 
; 1173 :     static constexpr auto npos{static_cast<size_type>(-1)};
; 1174 : 
; 1175 :     constexpr basic_string_view() noexcept : _Mydata(), _Mysize(0) {}
; 1176 : 
; 1177 :     constexpr basic_string_view(const basic_string_view&) noexcept = default;
; 1178 :     constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;
; 1179 : 
; 1180 :     /* implicit */ constexpr basic_string_view(_In_z_ const const_pointer _Ntcts) noexcept // strengthened
; 1181 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}
; 1182 : 
; 1183 :     constexpr basic_string_view(
; 1184 :         _In_reads_(_Count) const const_pointer _Cts, const size_type _Count) noexcept // strengthened
; 1185 :         : _Mydata(_Cts), _Mysize(_Count) {
; 1186 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1187 :         _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
; 1188 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1189 :     }
; 1190 : 
; 1191 :     _NODISCARD constexpr const_iterator begin() const noexcept {
; 1192 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1193 :         return const_iterator(_Mydata, _Mysize, 0);
; 1194 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1195 :         return const_iterator(_Mydata);
; 1196 : #endif // _ITERATOR_DEBUG_LEVEL
; 1197 :     }
; 1198 : 
; 1199 :     _NODISCARD constexpr const_iterator end() const noexcept {
; 1200 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1201 :         return const_iterator(_Mydata, _Mysize, _Mysize);
; 1202 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1203 :         return const_iterator(_Mydata + _Mysize);
; 1204 : #endif // _ITERATOR_DEBUG_LEVEL
; 1205 :     }
; 1206 : 
; 1207 :     _NODISCARD constexpr const_iterator cbegin() const noexcept {
; 1208 :         return begin();
; 1209 :     }
; 1210 : 
; 1211 :     _NODISCARD constexpr const_iterator cend() const noexcept {
; 1212 :         return end();
; 1213 :     }
; 1214 : 
; 1215 :     _NODISCARD constexpr const_reverse_iterator rbegin() const noexcept {
; 1216 :         return const_reverse_iterator{end()};
; 1217 :     }
; 1218 : 
; 1219 :     _NODISCARD constexpr const_reverse_iterator rend() const noexcept {
; 1220 :         return const_reverse_iterator{begin()};
; 1221 :     }
; 1222 : 
; 1223 :     _NODISCARD constexpr const_reverse_iterator crbegin() const noexcept {
; 1224 :         return rbegin();
; 1225 :     }
; 1226 : 
; 1227 :     _NODISCARD constexpr const_reverse_iterator crend() const noexcept {
; 1228 :         return rend();
; 1229 :     }
; 1230 : 
; 1231 :     constexpr const_pointer _Unchecked_begin() const noexcept {
; 1232 :         return _Mydata;
; 1233 :     }
; 1234 : 
; 1235 :     constexpr const_pointer _Unchecked_end() const noexcept {
; 1236 :         return _Mydata + _Mysize;
; 1237 :     }
; 1238 : 
; 1239 :     _NODISCARD constexpr size_type size() const noexcept {
; 1240 :         return _Mysize;
; 1241 :     }
; 1242 : 
; 1243 :     _NODISCARD constexpr size_type length() const noexcept {
; 1244 :         return _Mysize;
; 1245 :     }
; 1246 : 
; 1247 :     _NODISCARD constexpr bool empty() const noexcept {
; 1248 :         return _Mysize == 0;
; 1249 :     }
; 1250 : 
; 1251 :     _NODISCARD constexpr const_pointer data() const noexcept {
; 1252 :         return _Mydata;
; 1253 :     }
; 1254 : 
; 1255 :     _NODISCARD constexpr size_type max_size() const noexcept {
; 1256 :         // bound to PTRDIFF_MAX to make end() - begin() well defined (also makes room for npos)
; 1257 :         // bound to static_cast<size_t>(-1) / sizeof(_Elem) by address space limits
; 1258 :         return _Min_value(static_cast<size_t>(PTRDIFF_MAX), static_cast<size_t>(-1) / sizeof(_Elem));
; 1259 :     }
; 1260 : 
; 1261 :     _NODISCARD constexpr const_reference operator[](const size_type _Off) const noexcept /* strengthened */ {
; 1262 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1263 :         _STL_VERIFY(_Off < _Mysize, "string_view subscript out of range");
; 1264 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1265 :         return _Mydata[_Off];
; 1266 :     }
; 1267 : 
; 1268 :     _NODISCARD constexpr const_reference at(const size_type _Off) const {
; 1269 :         // get the character at _Off or throw if that is out of range
; 1270 :         _Check_offset_exclusive(_Off);
; 1271 :         return _Mydata[_Off];
; 1272 :     }
; 1273 : 
; 1274 :     _NODISCARD constexpr const_reference front() const noexcept /* strengthened */ {
; 1275 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1276 :         _STL_VERIFY(_Mysize != 0, "cannot call front on empty string_view");
; 1277 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1278 :         return _Mydata[0];
; 1279 :     }
; 1280 : 
; 1281 :     _NODISCARD constexpr const_reference back() const noexcept /* strengthened */ {
; 1282 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1283 :         _STL_VERIFY(_Mysize != 0, "cannot call back on empty string_view");
; 1284 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1285 :         return _Mydata[_Mysize - 1];
; 1286 :     }
; 1287 : 
; 1288 :     constexpr void remove_prefix(const size_type _Count) noexcept /* strengthened */ {
; 1289 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1290 :         _STL_VERIFY(_Mysize >= _Count, "cannot remove prefix longer than total size");
; 1291 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1292 :         _Mydata += _Count;
; 1293 :         _Mysize -= _Count;
; 1294 :     }
; 1295 : 
; 1296 :     constexpr void remove_suffix(const size_type _Count) noexcept /* strengthened */ {
; 1297 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1298 :         _STL_VERIFY(_Mysize >= _Count, "cannot remove suffix longer than total size");
; 1299 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1300 :         _Mysize -= _Count;
; 1301 :     }
; 1302 : 
; 1303 :     constexpr void swap(basic_string_view& _Other) noexcept {
; 1304 :         const basic_string_view _Tmp{_Other}; // note: std::swap is not constexpr before C++20
; 1305 :         _Other = *this;
; 1306 :         *this  = _Tmp;
; 1307 :     }
; 1308 : 
; 1309 :     constexpr size_type copy(_Out_writes_(_Count) _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
; 1310 :         // copy [_Off, _Off + Count) to [_Ptr, _Ptr + _Count)
; 1311 :         _Check_offset(_Off);
; 1312 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1313 :         _Traits::copy(_Ptr, _Mydata + _Off, _Count);
; 1314 :         return _Count;
; 1315 :     }
; 1316 : 
; 1317 :     _Pre_satisfies_(_Dest_size >= _Count) constexpr size_type _Copy_s(_Out_writes_all_(_Dest_size) _Elem* const _Dest,
; 1318 :         const size_type _Dest_size, size_type _Count, const size_type _Off = 0) const {
; 1319 :         // copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1320 :         _Check_offset(_Off);
; 1321 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1322 :         _Traits::_Copy_s(_Dest, _Dest_size, _Mydata + _Off, _Count);
; 1323 :         return _Count;
; 1324 :     }
; 1325 : 
; 1326 :     _NODISCARD constexpr basic_string_view substr(const size_type _Off = 0, size_type _Count = npos) const {
; 1327 :         // return a new basic_string_view moved forward by _Off and trimmed to _Count elements
; 1328 :         _Check_offset(_Off);
; 1329 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1330 :         return basic_string_view(_Mydata + _Off, _Count);
; 1331 :     }
; 1332 : 
; 1333 :     constexpr bool _Equal(const basic_string_view _Right) const noexcept {
; 1334 :         return _Traits_equal<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
; 1335 :     }
; 1336 : 
; 1337 :     _NODISCARD constexpr int compare(const basic_string_view _Right) const noexcept {
; 1338 :         return _Traits_compare<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
; 1339 :     }
; 1340 : 
; 1341 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right) const {
; 1342 :         // compare [_Off, _Off + _N0) with _Right
; 1343 :         return substr(_Off, _N0).compare(_Right);
; 1344 :     }
; 1345 : 
; 1346 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right,
; 1347 :         const size_type _Roff, const size_type _Count) const {
; 1348 :         // compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1349 :         return substr(_Off, _N0).compare(_Right.substr(_Roff, _Count));
; 1350 :     }
; 1351 : 
; 1352 :     _NODISCARD constexpr int compare(_In_z_ const _Elem* const _Ptr) const { // compare [0, _Mysize) with [_Ptr, <null>)
; 1353 :         return compare(basic_string_view(_Ptr));
; 1354 :     }
; 1355 : 
; 1356 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, _In_z_ const _Elem* const _Ptr) const {
; 1357 :         // compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 1358 :         return substr(_Off, _N0).compare(basic_string_view(_Ptr));
; 1359 :     }
; 1360 : 
; 1361 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0,
; 1362 :         _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) const {
; 1363 :         // compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1364 :         return substr(_Off, _N0).compare(basic_string_view(_Ptr, _Count));
; 1365 :     }
; 1366 : 
; 1367 : #if _HAS_CXX20
; 1368 :     _NODISCARD constexpr bool starts_with(const basic_string_view _Right) const noexcept {
; 1369 :         const auto _Rightsize = _Right._Mysize;
; 1370 :         if (_Mysize < _Rightsize) {
; 1371 :             return false;
; 1372 :         }
; 1373 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;
; 1374 :     }
; 1375 : 
; 1376 :     _NODISCARD constexpr bool starts_with(const _Elem _Right) const noexcept {
; 1377 :         return !empty() && _Traits::eq(front(), _Right);
; 1378 :     }
; 1379 : 
; 1380 :     _NODISCARD constexpr bool starts_with(const _Elem* const _Right) const noexcept /* strengthened */ {
; 1381 :         return starts_with(basic_string_view(_Right));
; 1382 :     }
; 1383 : 
; 1384 :     _NODISCARD constexpr bool ends_with(const basic_string_view _Right) const noexcept {
; 1385 :         const auto _Rightsize = _Right._Mysize;
; 1386 :         if (_Mysize < _Rightsize) {
; 1387 :             return false;
; 1388 :         }
; 1389 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;
; 1390 :     }
; 1391 : 
; 1392 :     _NODISCARD constexpr bool ends_with(const _Elem _Right) const noexcept {
; 1393 :         return !empty() && _Traits::eq(back(), _Right);
; 1394 :     }
; 1395 : 
; 1396 :     _NODISCARD constexpr bool ends_with(const _Elem* const _Right) const noexcept /* strengthened */ {
; 1397 :         return ends_with(basic_string_view(_Right));
; 1398 :     }
; 1399 : #endif // _HAS_CXX20
; 1400 : 
; 1401 :     _NODISCARD constexpr size_type find(const basic_string_view _Right, const size_type _Off = 0) const noexcept {
; 1402 :         // look for _Right beginning at or after _Off
; 1403 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
; 1404 :     }
; 1405 : 
; 1406 :     _NODISCARD constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1407 :         // look for _Ch at or after _Off
; 1408 :         return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1409 :     }
; 1410 : 
; 1411 :     _NODISCARD constexpr size_type find(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1412 :         const size_type _Count) const noexcept /* strengthened */ {
; 1413 :         // look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1414 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
; 1415 :     }
; 1416 : 
; 1417 :     _NODISCARD constexpr size_type find(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1418 :         noexcept /* strengthened */ {
; 1419 :         // look for [_Ptr, <null>) beginning at or after _Off
; 1420 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
; 1421 :     }
; 1422 : 
; 1423 :     _NODISCARD constexpr size_type rfind(const basic_string_view _Right, const size_type _Off = npos) const noexcept {
; 1424 :         // look for _Right beginning before _Off
; 1425 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
; 1426 :     }
; 1427 : 
; 1428 :     _NODISCARD constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1429 :         // look for _Ch before _Off
; 1430 :         return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1431 :     }
; 1432 : 
; 1433 :     _NODISCARD constexpr size_type rfind(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1434 :         const size_type _Count) const noexcept /* strengthened */ {
; 1435 :         // look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1436 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
; 1437 :     }
; 1438 : 
; 1439 :     _NODISCARD constexpr size_type rfind(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1440 :         noexcept /* strengthened */ {
; 1441 :         // look for [_Ptr, <null>) beginning before _Off
; 1442 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
; 1443 :     }
; 1444 : 
; 1445 :     _NODISCARD constexpr size_type find_first_of(const basic_string_view _Right,
; 1446 :         const size_type _Off = 0) const noexcept { // look for one of _Right at or after _Off
; 1447 :         return _Traits_find_first_of<_Traits>(
; 1448 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1449 :     }
; 1450 : 
; 1451 :     _NODISCARD constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1452 :         // look for _Ch at or after _Off
; 1453 :         return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1454 :     }
; 1455 : 
; 1456 :     _NODISCARD constexpr size_type find_first_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1457 :         const size_type _Count) const noexcept /* strengthened */ {
; 1458 :         // look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1459 :         return _Traits_find_first_of<_Traits>(
; 1460 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1461 :     }
; 1462 : 
; 1463 :     _NODISCARD constexpr size_type find_first_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1464 :         noexcept /* strengthened */ {
; 1465 :         // look for one of [_Ptr, <null>) at or after _Off
; 1466 :         return _Traits_find_first_of<_Traits>(
; 1467 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1468 :     }
; 1469 : 
; 1470 :     _NODISCARD constexpr size_type find_last_of(const basic_string_view _Right, const size_type _Off = npos) const
; 1471 :         noexcept { // look for one of _Right before _Off
; 1472 :         return _Traits_find_last_of<_Traits>(
; 1473 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1474 :     }
; 1475 : 
; 1476 :     _NODISCARD constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1477 :         // look for _Ch before _Off
; 1478 :         return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1479 :     }
; 1480 : 
; 1481 :     _NODISCARD constexpr size_type find_last_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1482 :         const size_type _Count) const noexcept /* strengthened */ {
; 1483 :         // look for one of [_Ptr, _Ptr + _Count) before _Off
; 1484 :         return _Traits_find_last_of<_Traits>(
; 1485 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1486 :     }
; 1487 : 
; 1488 :     _NODISCARD constexpr size_type find_last_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1489 :         noexcept /* strengthened */ {
; 1490 :         // look for one of [_Ptr, <null>) before _Off
; 1491 :         return _Traits_find_last_of<_Traits>(
; 1492 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1493 :     }
; 1494 : 
; 1495 :     _NODISCARD constexpr size_type find_first_not_of(const basic_string_view _Right,
; 1496 :         const size_type _Off = 0) const noexcept { // look for none of _Right at or after _Off
; 1497 :         return _Traits_find_first_not_of<_Traits>(
; 1498 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1499 :     }
; 1500 : 
; 1501 :     _NODISCARD constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1502 :         // look for any value other than _Ch at or after _Off
; 1503 :         return _Traits_find_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1504 :     }
; 1505 : 
; 1506 :     _NODISCARD constexpr size_type find_first_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1507 :         const size_type _Count) const noexcept /* strengthened */ {
; 1508 :         // look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 1509 :         return _Traits_find_first_not_of<_Traits>(
; 1510 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1511 :     }
; 1512 : 
; 1513 :     _NODISCARD constexpr size_type find_first_not_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1514 :         noexcept /* strengthened */ {
; 1515 :         // look for none of [_Ptr, <null>) at or after _Off
; 1516 :         return _Traits_find_first_not_of<_Traits>(
; 1517 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1518 :     }
; 1519 : 
; 1520 :     _NODISCARD constexpr size_type find_last_not_of(const basic_string_view _Right,
; 1521 :         const size_type _Off = npos) const noexcept { // look for none of _Right before _Off
; 1522 :         return _Traits_find_last_not_of<_Traits>(
; 1523 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1524 :     }
; 1525 : 
; 1526 :     _NODISCARD constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1527 :         // look for any value other than _Ch before _Off
; 1528 :         return _Traits_rfind_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1529 :     }
; 1530 : 
; 1531 :     _NODISCARD constexpr size_type find_last_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1532 :         const size_type _Count) const noexcept /* strengthened */ {
; 1533 :         // look for none of [_Ptr, _Ptr + _Count) before _Off
; 1534 :         return _Traits_find_last_not_of<_Traits>(
; 1535 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1536 :     }
; 1537 : 
; 1538 :     _NODISCARD constexpr size_type find_last_not_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1539 :         noexcept /* strengthened */ {
; 1540 :         // look for none of [_Ptr, <null>) before _Off
; 1541 :         return _Traits_find_last_not_of<_Traits>(
; 1542 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1543 :     }
; 1544 : 
; 1545 :     _NODISCARD constexpr bool _Starts_with(const basic_string_view _View) const noexcept {
; 1546 :         return _Mysize >= _View._Mysize && _Traits::compare(_Mydata, _View._Mydata, _View._Mysize) == 0;
; 1547 :     }
; 1548 : 
; 1549 : private:
; 1550 :     constexpr void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 1551 :         if (_Mysize < _Off) {
; 1552 :             _Xran();
; 1553 :         }
; 1554 :     }
; 1555 : 
; 1556 :     constexpr void _Check_offset_exclusive(const size_type _Off) const {
; 1557 :         // checks whether _Off is in the bounds of [0, size())
; 1558 :         if (_Mysize <= _Off) {
; 1559 :             _Xran();
; 1560 :         }
; 1561 :     }
; 1562 : 
; 1563 :     constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 1564 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 1565 :         return _Min_value(_Size, _Mysize - _Off);
; 1566 :     }
; 1567 : 
; 1568 :     [[noreturn]] static void _Xran() {
; 1569 :         _Xout_of_range("invalid string_view position");
; 1570 :     }
; 1571 : 
; 1572 :     const_pointer _Mydata;
; 1573 :     size_type _Mysize;
; 1574 : };
; 1575 : 
; 1576 : #ifdef __cpp_lib_concepts
; 1577 : namespace ranges {
; 1578 :     template <class _Elem, class _Traits>
; 1579 :     inline constexpr bool enable_view<basic_string_view<_Elem, _Traits>> = true;
; 1580 :     template <class _Elem, class _Traits>
; 1581 :     inline constexpr bool enable_borrowed_range<basic_string_view<_Elem, _Traits>> = true;
; 1582 : } // namespace ranges
; 1583 : #endif // __cpp_lib_concepts
; 1584 : 
; 1585 : // FUNCTION TEMPLATES operator== FOR basic_string_view
; 1586 : template <class _Elem, class _Traits>
; 1587 : _NODISCARD constexpr bool operator==(
; 1588 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1589 :     return _Lhs._Equal(_Rhs);
; 1590 : }
; 1591 : 
; 1592 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1593 : _NODISCARD constexpr bool operator==(
; 1594 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1595 :     return _Lhs._Equal(_Rhs);
; 1596 : }
; 1597 : 
; 1598 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1599 : _NODISCARD constexpr bool operator==(
; 1600 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1601 :     return _Lhs._Equal(_Rhs);
; 1602 : }
; 1603 : 
; 1604 : 
; 1605 : // FUNCTION TEMPLATES operator!= FOR basic_string_view
; 1606 : template <class _Elem, class _Traits>
; 1607 : _NODISCARD constexpr bool operator!=(
; 1608 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1609 :     return !_Lhs._Equal(_Rhs);
; 1610 : }
; 1611 : 
; 1612 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1613 : _NODISCARD constexpr bool operator!=(
; 1614 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1615 :     return !_Lhs._Equal(_Rhs);
; 1616 : }
; 1617 : 
; 1618 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1619 : _NODISCARD constexpr bool operator!=(
; 1620 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1621 :     return !_Lhs._Equal(_Rhs);
; 1622 : }
; 1623 : 
; 1624 : 
; 1625 : // FUNCTION TEMPLATES operator< FOR basic_string_view
; 1626 : template <class _Elem, class _Traits>
; 1627 : _NODISCARD constexpr bool operator<(
; 1628 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1629 :     return _Lhs.compare(_Rhs) < 0;
; 1630 : }
; 1631 : 
; 1632 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1633 : _NODISCARD constexpr bool operator<(
; 1634 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1635 :     return _Lhs.compare(_Rhs) < 0;
; 1636 : }
; 1637 : 
; 1638 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1639 : _NODISCARD constexpr bool operator<(
; 1640 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1641 :     return _Lhs.compare(_Rhs) < 0;
; 1642 : }
; 1643 : 
; 1644 : 
; 1645 : // FUNCTION TEMPLATES operator> FOR basic_string_view
; 1646 : template <class _Elem, class _Traits>
; 1647 : _NODISCARD constexpr bool operator>(
; 1648 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1649 :     return _Lhs.compare(_Rhs) > 0;
; 1650 : }
; 1651 : 
; 1652 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1653 : _NODISCARD constexpr bool operator>(
; 1654 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1655 :     return _Lhs.compare(_Rhs) > 0;
; 1656 : }
; 1657 : 
; 1658 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1659 : _NODISCARD constexpr bool operator>(
; 1660 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1661 :     return _Lhs.compare(_Rhs) > 0;
; 1662 : }
; 1663 : 
; 1664 : 
; 1665 : // FUNCTION TEMPLATES operator<= FOR basic_string_view
; 1666 : template <class _Elem, class _Traits>
; 1667 : _NODISCARD constexpr bool operator<=(
; 1668 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1669 :     return _Lhs.compare(_Rhs) <= 0;
; 1670 : }
; 1671 : 
; 1672 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1673 : _NODISCARD constexpr bool operator<=(
; 1674 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1675 :     return _Lhs.compare(_Rhs) <= 0;
; 1676 : }
; 1677 : 
; 1678 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1679 : _NODISCARD constexpr bool operator<=(
; 1680 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1681 :     return _Lhs.compare(_Rhs) <= 0;
; 1682 : }
; 1683 : 
; 1684 : 
; 1685 : // FUNCTION TEMPLATES operator>= FOR basic_string_view
; 1686 : template <class _Elem, class _Traits>
; 1687 : _NODISCARD constexpr bool operator>=(
; 1688 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1689 :     return _Lhs.compare(_Rhs) >= 0;
; 1690 : }
; 1691 : 
; 1692 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1693 : _NODISCARD constexpr bool operator>=(
; 1694 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1695 :     return _Lhs.compare(_Rhs) >= 0;
; 1696 : }
; 1697 : 
; 1698 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1699 : _NODISCARD constexpr bool operator>=(
; 1700 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1701 :     return _Lhs.compare(_Rhs) >= 0;
; 1702 : }
; 1703 : 
; 1704 : 
; 1705 : // TYPEDEFS FOR basic_string_view
; 1706 : using string_view = basic_string_view<char>;
; 1707 : #ifdef __cpp_lib_char8_t
; 1708 : using u8string_view = basic_string_view<char8_t>;
; 1709 : #endif // __cpp_lib_char8_t
; 1710 : using u16string_view = basic_string_view<char16_t>;
; 1711 : using u32string_view = basic_string_view<char32_t>;
; 1712 : using wstring_view   = basic_string_view<wchar_t>;
; 1713 : 
; 1714 : 
; 1715 : // STRUCT TEMPLATE SPECIALIZATION hash FOR basic_string_view
; 1716 : template <class _Elem, class _Traits>
; 1717 : struct hash<basic_string_view<_Elem, _Traits>> {
; 1718 :     _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef basic_string_view<_Elem, _Traits> _ARGUMENT_TYPE_NAME;
; 1719 :     _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t _RESULT_TYPE_NAME;
; 1720 : 
; 1721 :     _NODISCARD size_t operator()(const basic_string_view<_Elem, _Traits> _Keyval) const noexcept {
; 1722 :         return _Hash_array_representation(_Keyval.data(), _Keyval.size());
; 1723 :     }
; 1724 : };
; 1725 : 
; 1726 : template <class _Elem, class _Traits>
; 1727 : basic_ostream<_Elem, _Traits>& operator<<(
; 1728 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string_view<_Elem, _Traits> _Str) {
; 1729 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());
; 1730 : }
; 1731 : 
; 1732 : 
; 1733 : // basic_string_view LITERALS
; 1734 : inline namespace literals {
; 1735 :     inline namespace string_view_literals {
; 1736 :         _NODISCARD constexpr string_view operator"" sv(const char* _Str, size_t _Len) noexcept {
; 1737 :             return string_view(_Str, _Len);
; 1738 :         }
; 1739 : 
; 1740 :         _NODISCARD constexpr wstring_view operator"" sv(const wchar_t* _Str, size_t _Len) noexcept {
; 1741 :             return wstring_view(_Str, _Len);
; 1742 :         }
; 1743 : 
; 1744 : #ifdef __cpp_char8_t
; 1745 :         _NODISCARD constexpr basic_string_view<char8_t> operator"" sv(const char8_t* _Str, size_t _Len) noexcept {
; 1746 :             return basic_string_view<char8_t>(_Str, _Len);
; 1747 :         }
; 1748 : #endif // __cpp_char8_t
; 1749 : 
; 1750 :         _NODISCARD constexpr u16string_view operator"" sv(const char16_t* _Str, size_t _Len) noexcept {
; 1751 :             return u16string_view(_Str, _Len);
; 1752 :         }
; 1753 : 
; 1754 :         _NODISCARD constexpr u32string_view operator"" sv(const char32_t* _Str, size_t _Len) noexcept {
; 1755 :             return u32string_view(_Str, _Len);
; 1756 :         }
; 1757 :     } // namespace string_view_literals
; 1758 : } // namespace literals
; 1759 : #endif // _HAS_CXX17
; 1760 : 
; 1761 : // CLASS TEMPLATE _String_const_iterator
; 1762 : template <class _Mystr>
; 1763 : class _String_const_iterator : public _Iterator_base {
; 1764 : public:
; 1765 : #ifdef __cpp_lib_concepts
; 1766 :     using iterator_concept = contiguous_iterator_tag;
; 1767 : #endif // __cpp_lib_concepts
; 1768 :     using iterator_category = random_access_iterator_tag;
; 1769 :     using value_type        = typename _Mystr::value_type;
; 1770 :     using difference_type   = typename _Mystr::difference_type;
; 1771 :     using pointer           = typename _Mystr::const_pointer;
; 1772 :     using reference         = const value_type&;
; 1773 : 
; 1774 :     _String_const_iterator() noexcept : _Ptr() {}
; 1775 : 
; 1776 :     _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {
; 1777 :         this->_Adopt(_Pstring);
; 1778 :     }
; 1779 : 
; 1780 :     _NODISCARD reference operator*() const {
; 1781 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1782 :         _STL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1783 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1784 :         _STL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1785 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1786 :         const auto _Contptr = _Mycont->_Myptr();
; 1787 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1788 :         _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1789 :             "cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1790 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1791 : 
; 1792 :         _Analysis_assume_(_Ptr);
; 1793 :         return *_Ptr;
; 1794 :     }
; 1795 : 
; 1796 :     _NODISCARD pointer operator->() const {
; 1797 :         return pointer_traits<pointer>::pointer_to(**this);
; 1798 :     }
; 1799 : 
; 1800 :     _String_const_iterator& operator++() {
; 1801 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1802 :         _STL_VERIFY(_Ptr, "cannot increment value-initialized string iterator");
; 1803 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1804 :         _STL_VERIFY(_Mycont, "cannot increment string iterator because the iterator was"
; 1805 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1806 :         _STL_VERIFY(_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize, "cannot increment string iterator past end");
; 1807 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1808 : 
; 1809 :         ++_Ptr;
; 1810 :         return *this;
; 1811 :     }
; 1812 : 
; 1813 :     _String_const_iterator operator++(int) {
; 1814 :         _String_const_iterator _Tmp = *this;
; 1815 :         ++*this;
; 1816 :         return _Tmp;
; 1817 :     }
; 1818 : 
; 1819 :     _String_const_iterator& operator--() {
; 1820 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1821 :         _STL_VERIFY(_Ptr, "cannot decrement value-initialized string iterator");
; 1822 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1823 :         _STL_VERIFY(_Mycont, "cannot decrement string iterator because the iterator was"
; 1824 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1825 :         _STL_VERIFY(_Mycont->_Myptr() < _Unfancy(_Ptr), "cannot decrement string iterator before begin");
; 1826 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1827 : 
; 1828 :         --_Ptr;
; 1829 :         return *this;
; 1830 :     }
; 1831 : 
; 1832 :     _String_const_iterator operator--(int) {
; 1833 :         _String_const_iterator _Tmp = *this;
; 1834 :         --*this;
; 1835 :         return _Tmp;
; 1836 :     }
; 1837 : 
; 1838 :     void _Verify_offset(const difference_type _Off) const noexcept {
; 1839 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1840 :         if (_Off == 0) {
; 1841 :             return;
; 1842 :         }
; 1843 : 
; 1844 :         _STL_ASSERT(_Ptr, "cannot seek value-initialized string iterator");
; 1845 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1846 :         _STL_ASSERT(_Mycont, "cannot seek string iterator because the iterator was"
; 1847 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1848 :         const auto _Contptr = _Mycont->_Myptr();
; 1849 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1850 : 
; 1851 :         if (_Off < 0) {
; 1852 : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 1853 :             _STL_VERIFY(_Contptr - _Rawptr <= _Off, "cannot seek string iterator before begin");
; 1854 :         }
; 1855 : 
; 1856 :         if (_Off > 0) {
; 1857 :             using _Size_type = typename _Mystr::size_type;
; 1858 :             const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
; 1859 :             _STL_VERIFY(static_cast<_Size_type>(_Off) <= _Left, "cannot seek string iterator after end");
; 1860 :         }
; 1861 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1862 :         (void) _Off;
; 1863 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1864 :     }
; 1865 : 
; 1866 :     _String_const_iterator& operator+=(const difference_type _Off) {
; 1867 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1868 :         _Verify_offset(_Off);
; 1869 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1870 :         _Ptr += _Off;
; 1871 :         return *this;
; 1872 :     }
; 1873 : 
; 1874 :     _NODISCARD _String_const_iterator operator+(const difference_type _Off) const {
; 1875 :         _String_const_iterator _Tmp = *this;
; 1876 :         return _Tmp += _Off;
; 1877 :     }
; 1878 : 
; 1879 :     _String_const_iterator& operator-=(const difference_type _Off) {
; 1880 :         return *this += -_Off;
; 1881 :     }
; 1882 : 
; 1883 :     _NODISCARD _String_const_iterator operator-(const difference_type _Off) const {
; 1884 :         _String_const_iterator _Tmp = *this;
; 1885 :         return _Tmp -= _Off;
; 1886 :     }
; 1887 : 
; 1888 :     _NODISCARD difference_type operator-(const _String_const_iterator& _Right) const {
; 1889 :         _Compat(_Right);
; 1890 :         return _Ptr - _Right._Ptr;
; 1891 :     }
; 1892 : 
; 1893 :     _NODISCARD reference operator[](const difference_type _Off) const {
; 1894 :         return *(*this + _Off);
; 1895 :     }
; 1896 : 
; 1897 :     _NODISCARD bool operator==(const _String_const_iterator& _Right) const {
; 1898 :         _Compat(_Right);
; 1899 :         return _Ptr == _Right._Ptr;
; 1900 :     }
; 1901 : 
; 1902 :     _NODISCARD bool operator!=(const _String_const_iterator& _Right) const {
; 1903 :         return !(*this == _Right);
; 1904 :     }
; 1905 : 
; 1906 :     _NODISCARD bool operator<(const _String_const_iterator& _Right) const {
; 1907 :         _Compat(_Right);
; 1908 :         return _Ptr < _Right._Ptr;
; 1909 :     }
; 1910 : 
; 1911 :     _NODISCARD bool operator>(const _String_const_iterator& _Right) const {
; 1912 :         return _Right < *this;
; 1913 :     }
; 1914 : 
; 1915 :     _NODISCARD bool operator<=(const _String_const_iterator& _Right) const {
; 1916 :         return !(_Right < *this);
; 1917 :     }
; 1918 : 
; 1919 :     _NODISCARD bool operator>=(const _String_const_iterator& _Right) const {
; 1920 :         return !(*this < _Right);
; 1921 :     }
; 1922 : 
; 1923 :     void _Compat(const _String_const_iterator& _Right) const { // test for compatible iterator pair
; 1924 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1925 :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "string iterators incompatible (e.g."
; 1926 :                                                            " point to different string instances)");
; 1927 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1928 :         (void) _Right;
; 1929 : #endif // _ITERATOR_DEBUG_LEVEL
; 1930 :     }
; 1931 : 
; 1932 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1933 :     friend void _Verify_range(const _String_const_iterator& _First, const _String_const_iterator& _Last) {
; 1934 :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "string iterators in range are from different containers");
; 1935 :         _STL_VERIFY(_First._Ptr <= _Last._Ptr, "string iterator range transposed");
; 1936 :     }
; 1937 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1938 : 
; 1939 :     using _Prevent_inheriting_unwrap = _String_const_iterator;
; 1940 : 
; 1941 :     _NODISCARD const value_type* _Unwrapped() const {
; 1942 :         return _Unfancy(_Ptr);
; 1943 :     }
; 1944 : 
; 1945 :     void _Seek_to(const value_type* _It) {
; 1946 :         _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
; 1947 :     }
; 1948 : 
; 1949 :     pointer _Ptr; // pointer to element in string
; 1950 : };
; 1951 : 
; 1952 : template <class _Mystr>
; 1953 : _NODISCARD _String_const_iterator<_Mystr> operator+(
; 1954 :     typename _String_const_iterator<_Mystr>::difference_type _Off, _String_const_iterator<_Mystr> _Next) {
; 1955 :     return _Next += _Off;
; 1956 : }
; 1957 : 
; 1958 : #if _HAS_CXX20
; 1959 : template <class _Mystr>
; 1960 : struct pointer_traits<_String_const_iterator<_Mystr>> {
; 1961 :     using pointer         = _String_const_iterator<_Mystr>;
; 1962 :     using element_type    = const typename pointer::value_type;
; 1963 :     using difference_type = typename pointer::difference_type;
; 1964 : 
; 1965 :     _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
; 1966 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1967 :         const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
; 1968 :         if (!_Mycont) {
; 1969 :             _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
; 1970 :                                      "(e.g. reallocation occurred, or the string was destroyed)");
; 1971 :         }
; 1972 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1973 : 
; 1974 :         const auto _Rawptr = _STD to_address(_Iter._Ptr);
; 1975 : 
; 1976 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1977 :         if (_Mycont) {
; 1978 :             const auto _Contptr = _Mycont->_Myptr();
; 1979 :             _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
; 1980 :                 "cannot convert string iterator to pointer because it is out of range");
; 1981 :         }
; 1982 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1983 : 
; 1984 :         return _Rawptr;
; 1985 :     }
; 1986 : };
; 1987 : #endif // _HAS_CXX20
; 1988 : 
; 1989 : // CLASS TEMPLATE _String_iterator
; 1990 : template <class _Mystr>
; 1991 : class _String_iterator : public _String_const_iterator<_Mystr> {
; 1992 : public:
; 1993 :     using _Mybase = _String_const_iterator<_Mystr>;
; 1994 : 
; 1995 : #ifdef __cpp_lib_concepts
; 1996 :     using iterator_concept = contiguous_iterator_tag;
; 1997 : #endif // __cpp_lib_concepts
; 1998 :     using iterator_category = random_access_iterator_tag;
; 1999 :     using value_type        = typename _Mystr::value_type;
; 2000 :     using difference_type   = typename _Mystr::difference_type;
; 2001 :     using pointer           = typename _Mystr::pointer;
; 2002 :     using reference         = value_type&;
; 2003 : 
; 2004 :     using _Mybase::_Mybase;
; 2005 : 
; 2006 :     _NODISCARD reference operator*() const {
; 2007 :         return const_cast<reference>(_Mybase::operator*());
; 2008 :     }
; 2009 : 
; 2010 :     _NODISCARD pointer operator->() const {
; 2011 :         return pointer_traits<pointer>::pointer_to(**this);
; 2012 :     }
; 2013 : 
; 2014 :     _String_iterator& operator++() {
; 2015 :         _Mybase::operator++();
; 2016 :         return *this;
; 2017 :     }
; 2018 : 
; 2019 :     _String_iterator operator++(int) {
; 2020 :         _String_iterator _Tmp = *this;
; 2021 :         _Mybase::operator++();
; 2022 :         return _Tmp;
; 2023 :     }
; 2024 : 
; 2025 :     _String_iterator& operator--() {
; 2026 :         _Mybase::operator--();
; 2027 :         return *this;
; 2028 :     }
; 2029 : 
; 2030 :     _String_iterator operator--(int) {
; 2031 :         _String_iterator _Tmp = *this;
; 2032 :         _Mybase::operator--();
; 2033 :         return _Tmp;
; 2034 :     }
; 2035 : 
; 2036 :     _String_iterator& operator+=(const difference_type _Off) {
; 2037 :         _Mybase::operator+=(_Off);
; 2038 :         return *this;
; 2039 :     }
; 2040 : 
; 2041 :     _NODISCARD _String_iterator operator+(const difference_type _Off) const {
; 2042 :         _String_iterator _Tmp = *this;
; 2043 :         return _Tmp += _Off;
; 2044 :     }
; 2045 : 
; 2046 :     _String_iterator& operator-=(const difference_type _Off) {
; 2047 :         _Mybase::operator-=(_Off);
; 2048 :         return *this;
; 2049 :     }
; 2050 : 
; 2051 :     using _Mybase::operator-;
; 2052 : 
; 2053 :     _NODISCARD _String_iterator operator-(const difference_type _Off) const {
; 2054 :         _String_iterator _Tmp = *this;
; 2055 :         return _Tmp -= _Off;
; 2056 :     }
; 2057 : 
; 2058 :     _NODISCARD reference operator[](const difference_type _Off) const {
; 2059 :         return const_cast<reference>(_Mybase::operator[](_Off));
; 2060 :     }
; 2061 : 
; 2062 :     using _Prevent_inheriting_unwrap = _String_iterator;
; 2063 : 
; 2064 :     _NODISCARD value_type* _Unwrapped() const {
; 2065 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));
; 2066 :     }
; 2067 : };
; 2068 : 
; 2069 : template <class _Mystr>
; 2070 : _NODISCARD _String_iterator<_Mystr> operator+(
; 2071 :     typename _String_iterator<_Mystr>::difference_type _Off, _String_iterator<_Mystr> _Next) {
; 2072 :     return _Next += _Off;
; 2073 : }
; 2074 : 
; 2075 : #if _HAS_CXX20
; 2076 : template <class _Mystr>
; 2077 : struct pointer_traits<_String_iterator<_Mystr>> {
; 2078 :     using pointer         = _String_iterator<_Mystr>;
; 2079 :     using element_type    = typename pointer::value_type;
; 2080 :     using difference_type = typename pointer::difference_type;
; 2081 : 
; 2082 :     _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
; 2083 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 2084 :         const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
; 2085 :         if (!_Mycont) {
; 2086 :             _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
; 2087 :                                      "(e.g. reallocation occurred, or the string was destroyed)");
; 2088 :         }
; 2089 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 2090 : 
; 2091 :         const auto _Rawptr = _STD to_address(_Iter._Ptr);
; 2092 : 
; 2093 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 2094 :         if (_Mycont) {
; 2095 :             const auto _Contptr = _Mycont->_Myptr();
; 2096 :             _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
; 2097 :                 "cannot convert string iterator to pointer because it is out of range");
; 2098 :         }
; 2099 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 2100 : 
; 2101 :         return const_cast<element_type*>(_Rawptr);
; 2102 :     }
; 2103 : };
; 2104 : #endif // _HAS_CXX20
; 2105 : 
; 2106 : // basic_string TYPE WRAPPERS
; 2107 : template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
; 2108 :     class _Reference, class _Const_reference>
; 2109 : struct _String_iter_types {
; 2110 :     using value_type      = _Value_type;
; 2111 :     using size_type       = _Size_type;
; 2112 :     using difference_type = _Difference_type;
; 2113 :     using pointer         = _Pointer;
; 2114 :     using const_pointer   = _Const_pointer;
; 2115 : };
; 2116 : 
; 2117 : // CLASS TEMPLATE _String_val
; 2118 : template <class _Val_types>
; 2119 : class _String_val : public _Container_base {
; 2120 : public:
; 2121 :     using value_type      = typename _Val_types::value_type;
; 2122 :     using size_type       = typename _Val_types::size_type;
; 2123 :     using difference_type = typename _Val_types::difference_type;
; 2124 :     using pointer         = typename _Val_types::pointer;
; 2125 :     using const_pointer   = typename _Val_types::const_pointer;
; 2126 :     using reference       = value_type&;
; 2127 :     using const_reference = const value_type&;
; 2128 : 
; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}
; 2130 : 
; 2131 :     // length of internal buffer, [1, 16]:
; 2132 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2133 :     // roundup mask for allocated buffers, [0, 15]:
; 2134 :     static constexpr size_type _ALLOC_MASK =
; 2135 :         sizeof(value_type) <= 1
; 2136 :             ? 15
; 2137 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2138 : 
; 2139 :     value_type* _Myptr() noexcept {
; 2140 :         value_type* _Result = _Bx._Buf;
; 2141 :         if (_Large_string_engaged()) {
; 2142 :             _Result = _Unfancy(_Bx._Ptr);
; 2143 :         }
; 2144 : 
; 2145 :         return _Result;
; 2146 :     }
; 2147 : 
; 2148 :     const value_type* _Myptr() const noexcept {
; 2149 :         const value_type* _Result = _Bx._Buf;
; 2150 :         if (_Large_string_engaged()) {
; 2151 :             _Result = _Unfancy(_Bx._Ptr);
; 2152 :         }
; 2153 : 
; 2154 :         return _Result;
; 2155 :     }
; 2156 : 
; 2157 :     bool _Large_string_engaged() const noexcept {
; 2158 :         return _BUF_SIZE <= _Myres;
; 2159 :     }
; 2160 : 
; 2161 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2162 :         if (_Mysize < _Off) {
; 2163 :             _Xran();
; 2164 :         }
; 2165 :     }
; 2166 : 
; 2167 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2168 :         if (_Mysize <= _Off) {
; 2169 :             _Xran();
; 2170 :         }
; 2171 :     }
; 2172 : 
; 2173 :     [[noreturn]] static void _Xran() {
; 2174 :         _Xout_of_range("invalid string position");
; 2175 :     }
; 2176 : 
; 2177 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2178 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2179 :         return _Min_value(_Size, _Mysize - _Off);
; 2180 :     }
; 2181 : 
; 2182 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2183 :         _Bxty() {} // user-provided, for fancy pointers
; 2184 : 
; 2185 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2186 : 
; 2187 :         value_type _Buf[_BUF_SIZE];
; 2188 :         pointer _Ptr;
; 2189 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2190 :     } _Bx;
; 2191 : 
; 2192 :     size_type _Mysize; // current length of string
; 2193 :     size_type _Myres; // current storage reserved for string
; 2194 : };
; 2195 : 
; 2196 : // CLASS TEMPLATE basic_string
; 2197 : template <class _Ty>
; 2198 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2199 : 
; 2200 : struct _String_constructor_concat_tag {
; 2201 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2202 :     explicit _String_constructor_concat_tag() = default;
; 2203 : };
; 2204 : 
; 2205 : [[noreturn]] inline void _Xlen_string() {
; 2206 :     _Xlength_error("string too long");
; 2207 : }
; 2208 : 
; 2209 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2210 : class basic_string { // null-terminated transparent array of elements
; 2211 : private:
; 2212 :     friend _Tidy_deallocate_guard<basic_string>;
; 2213 : 
; 2214 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2215 :     using _Alty_traits = allocator_traits<_Alty>;
; 2216 : 
; 2217 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2218 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2219 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2220 : 
; 2221 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2222 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2223 : 
; 2224 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2225 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2226 :         "char_traits character type match the string's character type.");
; 2227 : 
; 2228 : public:
; 2229 :     using traits_type    = _Traits;
; 2230 :     using allocator_type = _Alloc;
; 2231 : 
; 2232 :     using value_type      = _Elem;
; 2233 :     using size_type       = typename _Alty_traits::size_type;
; 2234 :     using difference_type = typename _Alty_traits::difference_type;
; 2235 :     using pointer         = typename _Alty_traits::pointer;
; 2236 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2237 :     using reference       = value_type&;
; 2238 :     using const_reference = const value_type&;
; 2239 : 
; 2240 :     using iterator       = _String_iterator<_Scary_val>;
; 2241 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2242 : 
; 2243 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2244 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2245 : 
; 2246 : private:
; 2247 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2248 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2249 : 
; 2250 :     // When doing _String_val operations by memcpy, we are touching:
; 2251 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2252 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2253 :     //   _String_val::_Mysize   (type is size_type)
; 2254 :     //   _String_val::_Myres    (type is size_type)
; 2255 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2256 :     // We need to ask if pointer is safe to memcpy.
; 2257 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2258 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2259 :     //   they can observe traits::assign and similar.
; 2260 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2261 :     // This offset skips over the _Container_base members, if any
; 2262 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2263 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2264 : 
; 2265 :     template <class _Iter>
; 2266 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2267 : 
; 2268 : #if _HAS_CXX17
; 2269 :     template <class _StringViewIsh>
; 2270 :     using _Is_string_view_ish =
; 2271 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2272 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2273 :             int>;
; 2274 : #endif // _HAS_CXX17
; 2275 : 
; 2276 : public:
; 2277 :     basic_string(const basic_string& _Right)
; 2278 :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2279 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2280 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2281 :         _Construct_lv_contents(_Right);
; 2282 :         _Proxy._Release();
; 2283 :     }
; 2284 : 
; 2285 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2286 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2287 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2288 :         _Construct_lv_contents(_Right);
; 2289 :         _Proxy._Release();
; 2290 :     }
; 2291 : 
; 2292 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t()) {
; 2293 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2294 :         _Tidy_init();
; 2295 :     }
; 2296 : 
; 2297 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2298 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2299 :         _Tidy_init();
; 2300 :     }
; 2301 : 
; 2302 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2303 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, <end>)
; 2304 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2305 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2306 :         _Tidy_init();
; 2307 :         assign(_Right, _Roff, npos);
; 2308 :         _Proxy._Release();
; 2309 :     }
; 2310 : 
; 2311 :     basic_string(
; 2312 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2313 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2314 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2315 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2316 :         _Tidy_init();
; 2317 :         assign(_Right, _Roff, _Count);
; 2318 :         _Proxy._Release();
; 2319 :     }
; 2320 : 
; 2321 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2322 :         : _Mypair(_Zero_then_variadic_args_t()) {
; 2323 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2324 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2325 :         _Tidy_init();
; 2326 :         assign(_Ptr, _Count);
; 2327 :         _Proxy._Release();
; 2328 :     }
; 2329 : 
; 2330 :     basic_string(
; 2331 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2332 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2333 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2334 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2335 :         _Tidy_init();
; 2336 :         assign(_Ptr, _Count);
; 2337 :         _Proxy._Release();
; 2338 :     }
; 2339 : 
; 2340 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {
; 2341 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2342 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2343 :         _Tidy_init();
; 2344 :         assign(_Ptr);
; 2345 :         _Proxy._Release();
; 2346 :     }
; 2347 : 
; 2348 : #if _HAS_CXX17
; 2349 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2350 : #endif // _HAS_CXX17
; 2351 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Tidy_init();
; 2355 :         assign(_Ptr);
; 2356 :         _Proxy._Release();
; 2357 :     }
; 2358 : 
; 2359 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t()) {
; 2360 :         // construct from _Count * _Ch
; 2361 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2362 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2363 :         _Tidy_init();
; 2364 :         assign(_Count, _Ch);
; 2365 :         _Proxy._Release();
; 2366 :     }
; 2367 : 
; 2368 : #if _HAS_CXX17
; 2369 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2370 : #endif // _HAS_CXX17
; 2371 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2372 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Count * _Ch with allocator
; 2373 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2374 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2375 :         _Tidy_init();
; 2376 :         assign(_Count, _Ch);
; 2377 :         _Proxy._Release();
; 2378 :     }
; 2379 : 
; 2380 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2381 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2382 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2383 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2384 :         _Tidy_init();
; 2385 :         _Adl_verify_range(_First, _Last);
; 2386 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
; 2387 :         _Proxy._Release();
; 2388 :     }
; 2389 : 
; 2390 :     template <class _Iter>
; 2391 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2392 :         // initialize from [_First, _Last), input iterators
; 2393 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2394 :         for (; _First != _Last; ++_First) {
; 2395 :             push_back(*_First);
; 2396 :         }
; 2397 : 
; 2398 :         _Guard._Target = nullptr;
; 2399 :     }
; 2400 : 
; 2401 :     template <class _Iter>
; 2402 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2403 :         // initialize from [_First, _Last), forward iterators
; 2404 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2405 :         reserve(_Count);
; 2406 :         _Construct(_First, _Last, input_iterator_tag());
; 2407 :     }
; 2408 : 
; 2409 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2410 :         // initialize from [_First, _Last), pointers
; 2411 :         if (_First != _Last) {
; 2412 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2413 :         }
; 2414 :     }
; 2415 : 
; 2416 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2417 :         // initialize from [_First, _Last), const pointers
; 2418 :         if (_First != _Last) {
; 2419 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2420 :         }
; 2421 :     }
; 2422 : 
; 2423 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) {
; 2424 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2425 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2426 :     }
; 2427 : 
; 2428 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2429 :         _Alty_traits::is_always_equal::value) // strengthened
; 2430 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2431 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2432 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2433 :         if
; 2434 :             _CONSTEXPR_IF(!_Alty_traits::is_always_equal::value) {
; 2435 :                 if (_Getal() != _Right._Getal()) {
; 2436 :                     _Construct_lv_contents(_Right);
; 2437 :                     _Proxy._Release();
; 2438 :                     return;
; 2439 :                 }
; 2440 :             }
; 2441 : 
; 2442 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2443 :         _Proxy._Release();
; 2444 :     }
; 2445 : 
; 2446 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2447 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2448 :         : _Mypair(
; 2449 :             _One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {
; 2450 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2451 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2452 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2453 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);
; 2454 :         size_type _New_capacity = _BUF_SIZE - 1;
; 2455 :         auto& _My_data          = _Mypair._Myval2;
; 2456 :         _Elem* _Ptr             = _My_data._Bx._Buf;
; 2457 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2458 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2459 :         if (_New_capacity < _New_size) {
; 2460 :             _New_capacity           = _Calculate_growth(_New_size, _BUF_SIZE - 1, max_size());
; 2461 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws
; 2462 :             _Ptr                    = _Unfancy(_Fancyptr);
; 2463 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
; 2464 :         }
; 2465 : 
; 2466 :         _My_data._Mysize = _New_size;
; 2467 :         _My_data._Myres  = _New_capacity;
; 2468 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2469 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
; 2470 :         _Traits::assign(_Ptr[_New_size], _Elem());
; 2471 :         _Proxy._Release();
; 2472 :     }
; 2473 : 
; 2474 :     basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
; 2475 :         : _Mypair(_One_then_variadic_args_t(), _Left._Getal()) {
; 2476 :         auto& _My_data    = _Mypair._Myval2;
; 2477 :         auto& _Left_data  = _Left._Mypair._Myval2;
; 2478 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2479 :         _Left_data._Orphan_all();
; 2480 :         _Right_data._Orphan_all();
; 2481 :         const auto _Left_size  = _Left_data._Mysize;
; 2482 :         const auto _Right_size = _Right_data._Mysize;
; 2483 : 
; 2484 :         const auto _Left_capacity  = _Left_data._Myres;
; 2485 :         const auto _Right_capacity = _Right_data._Myres;
; 2486 :         // overflow is OK due to max_size() checks:
; 2487 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);
; 2488 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
; 2489 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
; 2490 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 2491 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2492 :             _Take_contents(_Left, bool_constant<_Can_memcpy_val>{});
; 2493 :             const auto _Ptr = _My_data._Myptr();
; 2494 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
; 2495 :             _My_data._Mysize = _New_size;
; 2496 :             return;
; 2497 :         }
; 2498 : 
; 2499 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
; 2500 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
; 2501 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 2502 :             // At this point, we have tested:
; 2503 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 2504 :             // therefore: (by De Morgan's Laws)
; 2505 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 2506 :             // therefore: (by the distributive property)
; 2507 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 2508 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 2509 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_string_engaged()
; 2510 :             _STL_INTERNAL_CHECK(_Right_data._Large_string_engaged());
; 2511 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2512 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2513 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
; 2514 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
; 2515 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2516 :             _My_data._Mysize = _New_size;
; 2517 :             return;
; 2518 :         }
; 2519 : 
; 2520 :         // can't use either buffer, reallocate
; 2521 :         const auto _Max = max_size();
; 2522 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK
; 2523 :             _Xlen_string();
; 2524 :         }
; 2525 : 
; 2526 :         const auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);
; 2527 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2528 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2529 :         const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws
; 2530 :         // nothrow hereafter
; 2531 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
; 2532 :         _My_data._Mysize = _New_size;
; 2533 :         _My_data._Myres  = _New_capacity;
; 2534 :         const auto _Ptr  = _Unfancy(_Fancyptr);
; 2535 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2536 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
; 2537 :         _Proxy._Release();
; 2538 :     }
; 2539 : 
; 2540 : #if _HAS_CXX17
; 2541 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2542 :     explicit basic_string(const _StringViewIsh& _Right, const _Alloc& _Al = _Alloc())
; 2543 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2544 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2545 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2546 :         _Tidy_init();
; 2547 :         assign(_Right);
; 2548 :         _Proxy._Release();
; 2549 :     }
; 2550 : 
; 2551 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2552 :     basic_string(
; 2553 :         const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2554 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count) using _Al
; 2555 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2556 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2557 :         _Tidy_init();
; 2558 :         assign(_Right, _Roff, _Count);
; 2559 :         _Proxy._Release();
; 2560 :     }
; 2561 : #endif // _HAS_CXX17
; 2562 : 
; 2563 : private:
; 2564 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {
; 2565 :         _Tidy_deallocate();
; 2566 :         _Pocma(_Getal(), _Right._Getal());
; 2567 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2568 :     }
; 2569 : 
; 2570 :     void _Move_assign(basic_string& _Right, _Propagate_allocators) noexcept {
; 2571 :         if (_Getal() == _Right._Getal()) {
; 2572 :             _Move_assign(_Right, _Equal_allocators{});
; 2573 :         } else {
; 2574 :             // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2575 :             _Mypair._Myval2._Orphan_all();
; 2576 :             _Mypair._Myval2._Reload_proxy(
; 2577 :                 _GET_PROXY_ALLOCATOR(_Alty, _Getal()), _GET_PROXY_ALLOCATOR(_Alty, _Right._Getal()));
; 2578 :             _Pocma(_Getal(), _Right._Getal());
; 2579 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2580 :         }
; 2581 :     }
; 2582 : 
; 2583 :     void _Move_assign(basic_string& _Right, _No_propagate_allocators) {
; 2584 :         if (_Getal() == _Right._Getal()) {
; 2585 :             _Move_assign(_Right, _Equal_allocators{});
; 2586 :         } else {
; 2587 :             assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2588 :         }
; 2589 :     }
; 2590 : 
; 2591 : public:
; 2592 :     basic_string& operator=(basic_string&& _Right) noexcept(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
; 2593 :         if (this != _STD addressof(_Right)) {
; 2594 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});
; 2595 :         }
; 2596 : 
; 2597 :         return *this;
; 2598 :     }
; 2599 : 
; 2600 :     basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = _STD move(_Right))) {
; 2601 :         *this = _STD move(_Right);
; 2602 :         return *this;
; 2603 :     }
; 2604 : 
; 2605 : private:
; 2606 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {
; 2607 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2608 :         const auto _My_data_mem =
; 2609 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2610 :         const auto _Right_data_mem =
; 2611 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
; 2613 :     }
; 2614 : 
; 2615 :     void _Take_contents(basic_string& _Right, true_type) noexcept {
; 2616 :         // assign by stealing _Right's buffer, memcpy optimization
; 2617 :         // pre: this != &_Right
; 2618 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2619 :         // pre: *this owns no memory, iterators orphaned (note:
; 2620 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2621 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2622 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2623 :             // take ownership of _Right's iterators along with its buffer
; 2624 :             _Swap_proxy_and_iterators(_Right);
; 2625 :         } else {
; 2626 :             _Right._Mypair._Myval2._Orphan_all();
; 2627 :         }
; 2628 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2629 : 
; 2630 :         _Memcpy_val_from(_Right);
; 2631 :         _Right._Tidy_init();
; 2632 :     }
; 2633 : 
; 2634 :     void _Take_contents(basic_string& _Right, false_type) noexcept {
; 2635 :         // assign by stealing _Right's buffer, general case
; 2636 :         // pre: this != &_Right
; 2637 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2638 :         // pre: *this owns no memory, iterators orphaned
; 2639 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2640 :         auto& _My_data    = _Mypair._Myval2;
; 2641 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2642 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 2643 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 2644 :             _Right_data._Bx._Ptr = pointer();
; 2645 :             _Swap_proxy_and_iterators(_Right);
; 2646 :         } else { // copy small string buffer
; 2647 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 2648 :             _Right_data._Orphan_all();
; 2649 :         }
; 2650 : 
; 2651 :         _My_data._Mysize = _Right_data._Mysize;
; 2652 :         _My_data._Myres  = _Right_data._Myres;
; 2653 :         _Right._Tidy_init();
; 2654 :     }
; 2655 : 
; 2656 :     void _Construct_lv_contents(const basic_string& _Right) {
; 2657 :         // assign by copying data stored in _Right
; 2658 :         // pre: this != &_Right
; 2659 :         // pre: *this owns no memory, iterators orphaned (note:
; 2660 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2661 :         auto& _Right_data             = _Right._Mypair._Myval2;
; 2662 :         const size_type _Right_size   = _Right_data._Mysize;
; 2663 :         const _Elem* const _Right_ptr = _Right_data._Myptr();
; 2664 :         auto& _My_data                = _Mypair._Myval2;
; 2665 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate
; 2666 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
; 2667 :             _My_data._Mysize = _Right_size;
; 2668 :             _My_data._Myres  = _BUF_SIZE - 1;
; 2669 :             return;
; 2670 :         }
; 2671 : 
; 2672 :         auto& _Al                     = _Getal();
; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());
; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws
; 2675 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);
; 2676 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
; 2677 :         _My_data._Mysize = _Right_size;
; 2678 :         _My_data._Myres  = _New_capacity;
; 2679 :     }
; 2680 : 
; 2681 : public:
; 2682 :     basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
; 2683 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2684 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2685 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2686 :         _Tidy_init();
; 2687 :         assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2688 :         _Proxy._Release();
; 2689 :     }
; 2690 : 
; 2691 :     basic_string& operator=(initializer_list<_Elem> _Ilist) {
; 2692 :         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2693 :     }
; 2694 : 
; 2695 :     basic_string& operator+=(initializer_list<_Elem> _Ilist) {
; 2696 :         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2697 :     }
; 2698 : 
; 2699 :     basic_string& assign(initializer_list<_Elem> _Ilist) {
; 2700 :         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2701 :     }
; 2702 : 
; 2703 :     basic_string& append(initializer_list<_Elem> _Ilist) {
; 2704 :         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2705 :     }
; 2706 : 
; 2707 :     iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) {
; 2708 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2709 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 2710 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2711 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 2712 :         insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2713 :         return begin() + static_cast<difference_type>(_Off);
; 2714 :     }
; 2715 : 
; 2716 :     basic_string& replace(
; 2717 :         const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
; 2718 :         // replace with initializer_list
; 2719 :         _Adl_verify_range(_First, _Last);
; 2720 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2721 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 2722 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2723 :         const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
; 2724 :         const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
; 2725 :         return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2726 :     }
; 2727 : 
; 2728 :     ~basic_string() noexcept {
; 2729 :         _Tidy_deallocate();
; 2730 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2731 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2732 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2733 :         _Mypair._Myval2._Myproxy = nullptr;
; 2734 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2735 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2736 :     }
; 2737 : 
; 2738 :     static constexpr auto npos{static_cast<size_type>(-1)};
; 2739 : 
; 2740 : private:
; 2741 :     void _Copy_assign_val_from_small(const basic_string& _Right) {
; 2742 :         // TRANSITION, VSO-761321; inline into only caller when that's fixed
; 2743 :         _Tidy_deallocate();
; 2744 :         if
; 2745 :             _CONSTEXPR_IF(_Can_memcpy_val) {
; 2746 :                 _Memcpy_val_from(_Right);
; 2747 :             }
; 2748 :         else {
; 2749 :             _Traits::copy(
; 2750 :                 _Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Mysize + 1);
; 2751 :             _Mypair._Myval2._Mysize = _Right._Mypair._Myval2._Mysize;
; 2752 :             _Mypair._Myval2._Myres  = _Right._Mypair._Myval2._Myres;
; 2753 :         }
; 2754 :     }
; 2755 : 
; 2756 :     void _Copy_assign(const basic_string& _Right, false_type) {
; 2757 :         _Pocca(_Getal(), _Right._Getal());
; 2758 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2759 :     }
; 2760 : 
; 2761 :     void _Copy_assign(const basic_string& _Right, true_type) {
; 2762 :         auto& _Al             = _Getal();
; 2763 :         const auto& _Right_al = _Right._Getal();
; 2764 :         if (_Al == _Right_al) {
; 2765 :             _Copy_assign(_Right, false_type{});
; 2766 :             return;
; 2767 :         }
; 2768 : 
; 2769 :         auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2770 :         auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 2771 :         _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 2772 : 
; 2773 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2774 :             const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 2775 :             const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 2776 :             auto _Right_al_non_const = _Right_al;
; 2777 :             const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity); // throws
; 2778 :             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 2779 :             _Tidy_deallocate();
; 2780 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 2781 :             _Mypair._Myval2._Mysize  = _New_size;
; 2782 :             _Mypair._Myval2._Myres   = _New_capacity;
; 2783 :         } else {
; 2784 :             _Copy_assign_val_from_small(_Right);
; 2785 :         }
; 2786 : 
; 2787 :         _Pocca(_Al, _Right_al);
; 2788 :         _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 2789 :     }
; 2790 : 
; 2791 : public:
; 2792 :     basic_string& operator=(const basic_string& _Right) {
; 2793 :         if (this != _STD addressof(_Right)) {
; 2794 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});
; 2795 :         }
; 2796 : 
; 2797 :         return *this;
; 2798 :     }
; 2799 : 
; 2800 : #if _HAS_CXX17
; 2801 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2802 :     basic_string& operator=(const _StringViewIsh& _Right) {
; 2803 :         return assign(_Right);
; 2804 :     }
; 2805 : #endif // _HAS_CXX17
; 2806 : 
; 2807 :     basic_string& operator=(_In_z_ const _Elem* const _Ptr) {
; 2808 :         return assign(_Ptr);
; 2809 :     }
; 2810 : 
; 2811 :     basic_string& operator=(const _Elem _Ch) { // assign {_Ch, _Elem()}
; 2812 :         _Mypair._Myval2._Mysize = 1;
; 2813 :         _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 2814 :         _Traits::assign(_Ptr[0], _Ch);
; 2815 :         _Traits::assign(_Ptr[1], _Elem());
; 2816 :         return *this;
; 2817 :     }
; 2818 : 
; 2819 :     basic_string& operator+=(const basic_string& _Right) {
; 2820 :         return append(_Right);
; 2821 :     }
; 2822 : 
; 2823 : #if _HAS_CXX17
; 2824 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2825 :     basic_string& operator+=(const _StringViewIsh& _Right) {
; 2826 :         return append(_Right);
; 2827 :     }
; 2828 : #endif // _HAS_CXX17
; 2829 : 
; 2830 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
; 2831 :         return append(_Ptr);
; 2832 :     }
; 2833 : 
; 2834 :     basic_string& operator+=(_Elem _Ch) {
; 2835 :         push_back(_Ch);
; 2836 :         return *this;
; 2837 :     }
; 2838 : 
; 2839 :     basic_string& append(const basic_string& _Right) {
; 2840 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2841 :     }
; 2842 : 
; 2843 :     basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 2844 :         // append _Right [_Roff, _Roff + _Count)
; 2845 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 2846 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 2847 :         return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 2848 :     }
; 2849 : 
; 2850 : #if _HAS_CXX17
; 2851 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2852 :     basic_string& append(const _StringViewIsh& _Right) {
; 2853 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2854 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2855 :     }
; 2856 : 
; 2857 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2858 :     basic_string& append(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
; 2859 :         // append _Right [_Roff, _Roff + _Count)
; 2860 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2861 :         return append(_As_view.substr(_Roff, _Count));
; 2862 :     }
; 2863 : #endif // _HAS_CXX17
; 2864 : 
; 2865 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 2866 :         // append [_Ptr, _Ptr + _Count)
; 2867 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 2870 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2871 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
; 2872 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
; 2873 :             return *this;
; 2874 :         }
; 2875 : 
; 2876 :         return _Reallocate_grow_by(
; 2877 :             _Count,
; 2878 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2879 :                 const size_type _Count) {
; 2880 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2881 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2882 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2883 :             },
; 2884 :             _Ptr, _Count);
; 2885 :     }
; 2886 : 
; 2887 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
; 2888 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 2889 :     }
; 2890 : 
; 2891 :     basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // append _Count * _Ch
; 2892 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2893 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 2894 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 2895 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2896 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
; 2897 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
; 2898 :             return *this;
; 2899 :         }
; 2900 : 
; 2901 :         return _Reallocate_grow_by(
; 2902 :             _Count,
; 2903 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2904 :                 const _Elem _Ch) {
; 2905 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2906 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2907 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2908 :             },
; 2909 :             _Count, _Ch);
; 2910 :     }
; 2911 : 
; 2912 : #if _HAS_IF_CONSTEXPR
; 2913 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2914 :     basic_string& append(const _Iter _First, const _Iter _Last) { // append [_First, _Last), input iterators
; 2915 :         _Adl_verify_range(_First, _Last);
; 2916 :         const auto _UFirst = _Get_unwrapped(_First);
; 2917 :         const auto _ULast  = _Get_unwrapped(_Last);
; 2918 :         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2919 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2920 :         } else {
; 2921 :             const basic_string _Right(_UFirst, _ULast, get_allocator());
; 2922 :             return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2923 :         }
; 2924 :     }
; 2925 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 2926 :     template <class _Iter>
; 2927 :     basic_string& _Append_range(const _Iter _UFirst, const _Iter _ULast, true_type) {
; 2928 :         return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2929 :     }
; 2930 : 
; 2931 :     template <class _Iter>
; 2932 :     basic_string& _Append_range(const _Iter _UFirst, const _Iter _ULast, false_type) {
; 2933 :         const basic_string _Right(_UFirst, _ULast, get_allocator());
; 2934 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2935 :     }
; 2936 : 
; 2937 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2938 :     basic_string& append(const _Iter _First, const _Iter _Last) { // append [_First, _Last), input iterators {
; 2939 :         _Adl_verify_range(_First, _Last);
; 2940 :         const auto _UFirst = _Get_unwrapped(_First);
; 2941 :         return _Append_range(_UFirst, _Get_unwrapped(_Last), _Is_elem_cptr<decltype(_UFirst)>{});
; 2942 :     }
; 2943 : #endif // _HAS_IF_CONSTEXPR
; 2944 : 
; 2945 :     basic_string& assign(const basic_string& _Right) {
; 2946 :         *this = _Right;
; 2947 :         return *this;
; 2948 :     }
; 2949 : 
; 2950 :     basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 2951 :         // assign _Right [_Roff, _Roff + _Count)
; 2952 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 2953 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 2954 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 2955 :     }
; 2956 : 
; 2957 : #if _HAS_CXX17
; 2958 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2959 :     basic_string& assign(const _StringViewIsh& _Right) {
; 2960 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2961 :         return assign(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2962 :     }
; 2963 : 
; 2964 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2965 :     basic_string& assign(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
; 2966 :         // assign _Right [_Roff, _Roff + _Count)
; 2967 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2968 :         return assign(_As_view.substr(_Roff, _Count));
; 2969 :     }
; 2970 : #endif // _HAS_CXX17
; 2971 : 
; 2972 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 2973 :         // assign [_Ptr, _Ptr + _Count)
; 2974 :         if (_Count <= _Mypair._Myval2._Myres) {
; 2975 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2976 :             _Mypair._Myval2._Mysize = _Count;
; 2977 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 2978 :             _Traits::assign(_Old_ptr[_Count], _Elem());
; 2979 :             return *this;
; 2980 :         }
; 2981 : 
; 2982 :         return _Reallocate_for(
; 2983 :             _Count,
; 2984 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2985 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00018	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 2987 :             },

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBEXQADI0@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T3 = 8							; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2865 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2866 :         // append [_Ptr, _Ptr + _Count)
; 2867 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0000d	8b c2		 mov	 eax, edx
  0000f	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00012	2b c1		 sub	 eax, ecx
  00014	3b d8		 cmp	 ebx, eax
  00016	77 2d		 ja	 SHORT $LN2@append

; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00018	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0001b	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2140 :         value_type* _Result = _Bx._Buf;

  0001e	8b c7		 mov	 eax, edi

; 2158 :         return _BUF_SIZE <= _Myres;

  00020	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  00023	72 02		 jb	 SHORT $LN5@append

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  00025	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:
  00027	56		 push	 esi

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00028	53		 push	 ebx
  00029	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 2870 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2871 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0002c	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 _memmove
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2872 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00038	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 2873 :             return *this;

  0003c	8b c7		 mov	 eax, edi
  0003e	5e		 pop	 esi
  0003f	5f		 pop	 edi

; 2877 :             _Count,
; 2878 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2879 :                 const size_type _Count) {
; 2880 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2881 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2882 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2883 :             },
; 2884 :             _Ptr, _Count);
; 2885 :     }

  00040	5b		 pop	 ebx
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
$LN2@append:

; 2874 :         }
; 2875 : 
; 2876 :         return _Reallocate_grow_by(

  00045	53		 push	 ebx
  00046	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00049	8b cf		 mov	 ecx, edi
  0004b	ff 75 08	 push	 DWORD PTR $T3[ebp]
  0004e	53		 push	 ebx
  0004f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
  00054	5f		 pop	 edi

; 2877 :             _Count,
; 2878 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2879 :                 const size_type _Count) {
; 2880 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2881 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2882 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2883 :             },
; 2884 :             _Ptr, _Count);
; 2885 :     }

  00055	5b		 pop	 ebx
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBEXQAD0I0I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBEXQAD0I0I@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator(), COMDAT
; _this$dead$ = ecx

; 2883 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]

; 2883 :             },

  00007	57		 push	 edi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00008	8b 7d 10	 mov	 edi, DWORD PTR __Old_size$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy

; 333  :     }
; 334  : 
; 335  :     _Pre_satisfies_(_Size_in_bytes >= _Count) static _Elem* _Copy_s(_Out_writes_all_(_Size_in_bytes)
; 336  :                                                                         _Elem* const _First1,
; 337  :         const size_t _Size_in_bytes, _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept {
; 338  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 339  :         _STL_VERIFY(_Count <= _Size_in_bytes, "invalid argument");
; 340  :         return copy(_First1, _First2, _Count);
; 341  :     }
; 342  : 
; 343  :     _NODISCARD static _CONSTEXPR17 const _Elem* find(_In_reads_(_Count) const _Elem* const _First, const size_t _Count,
; 344  :         const _Elem& _Ch) noexcept /* strengthened */ {
; 345  :         // look for _Ch in [_First, _First + _Count)
; 346  : #if _HAS_CXX17
; 347  : #ifdef __cpp_char8_t
; 348  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 349  : #if _HAS_U8_INTRINSICS
; 350  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 351  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 352  :             return _Char_traits<_Elem, _Int_type>::find(_First, _Count, _Ch);
; 353  : #endif // _HAS_U8_INTRINSICS
; 354  :         } else
; 355  : #endif // __cpp_char8_t
; 356  :         {
; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);
; 358  :         }
; 359  : #else // _HAS_CXX17
; 360  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));
; 361  : #endif // _HAS_CXX17
; 362  :     }
; 363  : 
; 364  :     static _Elem* move(_Out_writes_all_(_Count) _Elem* const _First1, _In_reads_(_Count) const _Elem* const _First2,
; 365  :         const size_t _Count) noexcept /* strengthened */ {
; 366  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));
; 368  :     }
; 369  : 
; 370  :     static _Elem* assign(_Out_writes_all_(_Count) _Elem* const _First, const size_t _Count,
; 371  :         const _Elem _Ch) noexcept /* strengthened */ {
; 372  :         // assign _Count * _Ch to [_First, ...)
; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));
; 374  :     }
; 375  : 
; 376  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {
; 377  :         _Left = _Right;
; 378  :     }
; 379  : 
; 380  :     _NODISCARD static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
; 381  :         return _Left == _Right;
; 382  :     }
; 383  : 
; 384  :     _NODISCARD static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
; 385  :         return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
; 386  :     }
; 387  : 
; 388  :     _NODISCARD static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
; 389  :         return static_cast<_Elem>(_Meta);
; 390  :     }
; 391  : 
; 392  :     _NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
; 393  :         return static_cast<unsigned char>(_Ch);
; 394  :     }
; 395  : 
; 396  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
; 397  :         return _Left == _Right;
; 398  :     }
; 399  : 
; 400  :     _NODISCARD static constexpr int_type not_eof(const int_type& _Meta) noexcept {
; 401  :         return _Meta != eof() ? _Meta : !eof();
; 402  :     }
; 403  : 
; 404  :     _NODISCARD static constexpr int_type eof() noexcept {
; 405  :         return static_cast<int_type>(EOF);
; 406  :     }
; 407  : };
; 408  : 
; 409  : #undef _HAS_U8_INTRINSICS
; 410  : 
; 411  : // STRUCT char_traits<char> (FROM <string>)
; 412  : template <>
; 413  : struct char_traits<char> : _Narrow_char_traits<char, int> {}; // properties of a string or stream char element
; 414  : 
; 415  : #ifdef __cpp_char8_t
; 416  : // STRUCT char_traits<char8_t>
; 417  : template <>
; 418  : struct char_traits<char8_t> : _Narrow_char_traits<char8_t, unsigned int> {};
; 419  : 
; 420  : #ifdef __cpp_lib_char8_t
; 421  : using u8streampos = streampos;
; 422  : #endif // __cpp_lib_char8_t
; 423  : #endif // __cpp_char8_t
; 424  : 
; 425  : template <class _Elem, class _Traits, class _SizeT>
; 426  : basic_ostream<_Elem, _Traits>& _Insert_string(
; 427  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {
; 428  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 429  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 430  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;
; 431  : 
; 432  :     _SizeT _Pad;
; 433  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
; 434  :         _Pad = 0;
; 435  :     } else {
; 436  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
; 437  :     }
; 438  : 
; 439  :     const typename _Ostr_t::sentry _Ok(_Ostr);
; 440  : 
; 441  :     if (!_Ok) {
; 442  :         _State |= _Ostr_t::badbit;
; 443  :     } else { // state okay, insert characters
; 444  :         _TRY_IO_BEGIN
; 445  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
; 446  :             for (; 0 < _Pad; --_Pad) { // pad on left
; 447  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 448  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 449  :                     break;
; 450  :                 }
; 451  :             }
; 452  :         }
; 453  : 
; 454  :         if (_State == _Ostr_t::goodbit
; 455  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
; 456  :             _State |= _Ostr_t::badbit;
; 457  :         } else {
; 458  :             for (; 0 < _Pad; --_Pad) { // pad on right
; 459  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 460  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 461  :                     break;
; 462  :                 }
; 463  :             }
; 464  :         }
; 465  : 
; 466  :         _Ostr.width(0);
; 467  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 468  :     }
; 469  : 
; 470  :     _Ostr.setstate(_State);
; 471  :     return _Ostr;
; 472  : }
; 473  : 
; 474  : // STRUCT TEMPLATE _Char_traits_eq
; 475  : template <class _Traits>
; 476  : struct _Char_traits_eq {
; 477  :     using _Elem = typename _Traits::char_type;
; 478  : 
; 479  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 480  :         return _Traits::eq(_Left, _Right);
; 481  :     }
; 482  : };
; 483  : 
; 484  : // STRUCT TEMPLATE _Char_traits_lt
; 485  : template <class _Traits>
; 486  : struct _Char_traits_lt {
; 487  :     using _Elem = typename _Traits::char_type;
; 488  : 
; 489  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 490  :         return _Traits::lt(_Left, _Right);
; 491  :     }
; 492  : };
; 493  : 
; 494  : template <class _Elem>
; 495  : struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
; 496  :     : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type { // builtin char_traits::eq behaves like equal_to<>
; 497  : };
; 498  : 
; 499  : template <class _Traits>
; 500  : using _Traits_ch_t = typename _Traits::char_type;
; 501  : 
; 502  : template <class _Traits>
; 503  : using _Traits_ptr_t = const typename _Traits::char_type*;
; 504  : 
; 505  : template <class _Traits>
; 506  : constexpr bool _Traits_equal(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 507  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
; 508  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
; 510  : }
; 511  : 
; 512  : template <class _Traits>
; 513  : constexpr int _Traits_compare(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 514  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
; 515  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 516  :     const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));
; 517  : 
; 518  :     if (_Ans != 0) {
; 519  :         return _Ans;
; 520  :     }
; 521  : 
; 522  :     if (_Left_size < _Right_size) {
; 523  :         return -1;
; 524  :     }
; 525  : 
; 526  :     if (_Left_size > _Right_size) {
; 527  :         return 1;
; 528  :     }
; 529  : 
; 530  :     return 0;
; 531  : }
; 532  : 
; 533  : template <class _Traits>
; 534  : constexpr size_t _Traits_find(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 535  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 536  :     const size_t _Needle_size) noexcept {
; 537  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 538  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
; 539  :         // xpos cannot exist, report failure
; 540  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 541  :         // 1. _Start_at <= xpos
; 542  :         // 2. xpos + _Needle_size <= _Hay_size;
; 543  :         // therefore:
; 544  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 545  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 546  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 547  :         return static_cast<size_t>(-1);
; 548  :     }
; 549  : 
; 550  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 551  :         return _Start_at;
; 552  :     }
; 553  : 
; 554  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
; 555  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 556  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
; 557  :         if (!_Match_try) { // didn't find first character; report failure
; 558  :             return static_cast<size_t>(-1);
; 559  :         }
; 560  : 
; 561  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match
; 562  :             return static_cast<size_t>(_Match_try - _Haystack);
; 563  :         }
; 564  :     }
; 565  : }
; 566  : 
; 567  : template <class _Traits>
; 568  : constexpr size_t _Traits_find_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 569  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 570  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch, at/after _Start_at
; 571  :     if (_Start_at < _Hay_size) {
; 572  :         const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
; 573  :         if (_Found_at) {
; 574  :             return static_cast<size_t>(_Found_at - _Haystack);
; 575  :         }
; 576  :     }
; 577  : 
; 578  :     return static_cast<size_t>(-1); // (npos) no match
; 579  : }
; 580  : 
; 581  : template <class _Traits>
; 582  : constexpr size_t _Traits_rfind(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 583  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 584  :     const size_t _Needle_size) noexcept {
; 585  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size) beginning before _Start_at
; 586  :     if (_Needle_size == 0) {
; 587  :         return _Min_value(_Start_at, _Hay_size); // empty string always matches
; 588  :     }
; 589  : 
; 590  :     if (_Needle_size <= _Hay_size) { // room for match, look for it
; 591  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
; 592  :             if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
; 593  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 594  :             }
; 595  : 
; 596  :             if (_Match_try == _Haystack) {
; 597  :                 break; // at beginning, no more chance for match
; 598  :             }
; 599  :         }
; 600  :     }
; 601  : 
; 602  :     return static_cast<size_t>(-1); // no match
; 603  : }
; 604  : 
; 605  : template <class _Traits>
; 606  : constexpr size_t _Traits_rfind_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 607  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 608  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
; 609  :     if (_Hay_size != 0) { // room for match, look for it
; 610  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 611  :             if (_Traits::eq(*_Match_try, _Ch)) {
; 612  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 613  :             }
; 614  : 
; 615  :             if (_Match_try == _Haystack) {
; 616  :                 break; // at beginning, no more chance for match
; 617  :             }
; 618  :         }
; 619  :     }
; 620  : 
; 621  :     return static_cast<size_t>(-1); // no match
; 622  : }
; 623  : 
; 624  : template <class _Elem, bool = _Is_character<_Elem>::value>
; 625  : class _String_bitmap { // _String_bitmap for character types
; 626  : public:
; 627  :     constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
; 628  :         // mark this bitmap such that the characters in [_First, _Last) are intended to match
; 629  :         // returns whether all inputs can be placed in the bitmap
; 630  :         for (; _First != _Last; ++_First) {
; 631  :             _Matches[static_cast<unsigned char>(*_First)] = true;
; 632  :         }
; 633  : 
; 634  :         return true;
; 635  :     }
; 636  : 
; 637  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 638  :         return _Matches[static_cast<unsigned char>(_Ch)];
; 639  :     }
; 640  : 
; 641  : private:
; 642  :     bool _Matches[256] = {};
; 643  : };
; 644  : 
; 645  : template <class _Elem>
; 646  : class _String_bitmap<_Elem, false> { // _String_bitmap for wchar_t/unsigned short/char16_t/char32_t/etc. types
; 647  : public:
; 648  :     static_assert(is_unsigned_v<_Elem>,
; 649  :         "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
; 650  :         "Visual C++ accepts other unsigned integral types as an extension.");
; 651  : 
; 652  :     constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
; 653  :         // mark this bitmap such that the characters in [_First, _Last) are intended to match
; 654  :         // returns whether all inputs can be placed in the bitmap
; 655  :         for (; _First != _Last; ++_First) {
; 656  :             const auto _Ch = *_First;
; 657  :             if (_Ch >= 256U) {
; 658  :                 return false;
; 659  :             }
; 660  : 
; 661  :             _Matches[static_cast<unsigned char>(_Ch)] = true;
; 662  :         }
; 663  : 
; 664  :         return true;
; 665  :     }
; 666  : 
; 667  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 668  :         return _Ch < 256U && _Matches[_Ch];
; 669  :     }
; 670  : 
; 671  : private:
; 672  :     bool _Matches[256] = {};
; 673  : };
; 674  : 
; 675  : template <class _Traits>
; 676  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 677  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 678  :     const size_t _Needle_size, false_type) noexcept {
; 679  :     // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 680  :     // general algorithm
; 681  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 682  :         const auto _End = _Haystack + _Hay_size;
; 683  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 684  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 685  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 686  :             }
; 687  :         }
; 688  :     }
; 689  : 
; 690  :     return static_cast<size_t>(-1); // no match
; 691  : }
; 692  : 
; 693  : template <class _Traits>
; 694  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 695  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 696  :     const size_t _Needle_size, true_type) noexcept {
; 697  :     // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 698  :     // special case for std::char_traits
; 699  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 700  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 701  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 702  :                                                                 // fall back to the serial algorithm
; 703  :             return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 704  :         }
; 705  : 
; 706  :         const auto _End = _Haystack + _Hay_size;
; 707  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 708  :             if (_Matches._Match(*_Match_try)) {
; 709  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 710  :             }
; 711  :         }
; 712  :     }
; 713  : 
; 714  :     return static_cast<size_t>(-1); // no match
; 715  : }
; 716  : 
; 717  : template <class _Traits>
; 718  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 719  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 720  :     const size_t _Needle_size, false_type) noexcept {
; 721  :     // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
; 722  :     // general algorithm
; 723  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 724  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 725  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 726  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 727  :             }
; 728  : 
; 729  :             if (_Match_try == _Haystack) {
; 730  :                 break; // at beginning, no more chance for match
; 731  :             }
; 732  :         }
; 733  :     }
; 734  : 
; 735  :     return static_cast<size_t>(-1); // no match
; 736  : }
; 737  : 
; 738  : template <class _Traits>
; 739  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 740  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 741  :     const size_t _Needle_size, true_type) noexcept {
; 742  :     // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
; 743  :     // special case for std::char_traits
; 744  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 745  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 746  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 747  :                                                                 // fall back to the serial algorithm
; 748  :             return _Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 749  :         }
; 750  : 
; 751  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 752  :             if (_Matches._Match(*_Match_try)) {
; 753  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 754  :             }
; 755  : 
; 756  :             if (_Match_try == _Haystack) {
; 757  :                 break; // at beginning, no more chance for match
; 758  :             }
; 759  :         }
; 760  :     }
; 761  : 
; 762  :     return static_cast<size_t>(-1); // no match
; 763  : }
; 764  : 
; 765  : template <class _Traits>
; 766  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 767  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 768  :     const size_t _Needle_size, false_type) noexcept {
; 769  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 770  :     // general algorithm
; 771  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 772  :         const auto _End = _Haystack + _Hay_size;
; 773  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 774  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 775  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 776  :             }
; 777  :         }
; 778  :     }
; 779  : 
; 780  :     return static_cast<size_t>(-1); // no match
; 781  : }
; 782  : 
; 783  : template <class _Traits>
; 784  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 785  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 786  :     const size_t _Needle_size, true_type) noexcept {
; 787  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 788  :     // special case for std::char_traits
; 789  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 790  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 791  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 792  :                                                                 // fall back to the serial algorithm
; 793  :             return _Traits_find_first_not_of<_Traits>(
; 794  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 795  :         }
; 796  : 
; 797  :         const auto _End = _Haystack + _Hay_size;
; 798  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 799  :             if (!_Matches._Match(*_Match_try)) {
; 800  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 801  :             }
; 802  :         }
; 803  :     }
; 804  : 
; 805  :     return static_cast<size_t>(-1); // no match
; 806  : }
; 807  : 
; 808  : template <class _Traits>
; 809  : constexpr size_t _Traits_find_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 810  :     const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 811  :     // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch, at/after _Start_at
; 812  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 813  :         const auto _End = _Haystack + _Hay_size;
; 814  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 815  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 816  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 817  :             }
; 818  :         }
; 819  :     }
; 820  : 
; 821  :     return static_cast<size_t>(-1); // no match
; 822  : }
; 823  : 
; 824  : template <class _Traits>
; 825  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 826  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 827  :     const size_t _Needle_size, false_type) noexcept {
; 828  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
; 829  :     // general algorithm
; 830  :     if (_Hay_size != 0) { // worth searching, do it
; 831  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 832  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 833  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 834  :             }
; 835  : 
; 836  :             if (_Match_try == _Haystack) {
; 837  :                 break; // at beginning, no more chance for match
; 838  :             }
; 839  :         }
; 840  :     }
; 841  : 
; 842  :     return static_cast<size_t>(-1); // no match
; 843  : }
; 844  : 
; 845  : template <class _Traits>
; 846  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 847  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 848  :     const size_t _Needle_size, true_type) noexcept {
; 849  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
; 850  :     // special case for std::char_traits
; 851  :     if (_Hay_size != 0) { // worth searching, do it
; 852  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 853  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 854  :                                                                 // fall back to the serial algorithm
; 855  :             return _Traits_find_last_not_of<_Traits>(
; 856  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 857  :         }
; 858  : 
; 859  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 860  :             if (!_Matches._Match(*_Match_try)) {
; 861  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 862  :             }
; 863  : 
; 864  :             if (_Match_try == _Haystack) {
; 865  :                 break; // at beginning, no more chance for match
; 866  :             }
; 867  :         }
; 868  :     }
; 869  : 
; 870  :     return static_cast<size_t>(-1); // no match
; 871  : }
; 872  : 
; 873  : template <class _Traits>
; 874  : constexpr size_t _Traits_rfind_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 875  :     const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 876  :     // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch before _Start_at
; 877  :     if (_Hay_size != 0) { // room for match, look for it
; 878  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 879  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 880  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 881  :             }
; 882  : 
; 883  :             if (_Match_try == _Haystack) {
; 884  :                 break; // at beginning, no more chance for match
; 885  :             }
; 886  :         }
; 887  :     }
; 888  : 
; 889  :     return static_cast<size_t>(-1); // no match
; 890  : }
; 891  : 
; 892  : 
; 893  : #if _HAS_CXX17
; 894  : // CLASS TEMPLATE _String_view_iterator
; 895  : template <class _Elem, class _Traits = char_traits<_Elem>>
; 896  : class basic_string_view;
; 897  : 
; 898  : template <class _Traits>
; 899  : class _String_view_iterator {
; 900  : public:
; 901  : #ifdef __cpp_lib_concepts
; 902  :     using iterator_concept = contiguous_iterator_tag;
; 903  : #endif // __cpp_lib_concepts
; 904  :     using iterator_category = random_access_iterator_tag;
; 905  :     using value_type        = typename _Traits::char_type;
; 906  :     using difference_type   = ptrdiff_t;
; 907  :     using pointer           = const value_type*;
; 908  :     using reference         = const value_type&;
; 909  : 
; 910  :     constexpr _String_view_iterator() noexcept = default;
; 911  : 
; 912  : private:
; 913  :     friend basic_string_view<value_type, _Traits>;
; 914  : 
; 915  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 916  :     constexpr _String_view_iterator(const pointer _Data, const size_t _Size, const size_t _Off) noexcept
; 917  :         : _Mydata(_Data), _Mysize(_Size), _Myoff(_Off) {}
; 918  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 919  :     constexpr explicit _String_view_iterator(const pointer _Ptr) noexcept : _Myptr(_Ptr) {}
; 920  : #endif // _ITERATOR_DEBUG_LEVEL
; 921  : 
; 922  : public:
; 923  :     _NODISCARD constexpr reference operator*() const noexcept {
; 924  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 925  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 926  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 927  :         return _Mydata[_Myoff];
; 928  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 929  :         return *_Myptr;
; 930  : #endif // _ITERATOR_DEBUG_LEVEL
; 931  :     }
; 932  : 
; 933  :     _NODISCARD constexpr pointer operator->() const noexcept {
; 934  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 935  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 936  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 937  :         return _Mydata + _Myoff;
; 938  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 939  :         return _Myptr;
; 940  : #endif // _ITERATOR_DEBUG_LEVEL
; 941  :     }
; 942  : 
; 943  :     constexpr _String_view_iterator& operator++() noexcept {
; 944  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 945  :         _STL_VERIFY(_Mydata, "cannot increment value-initialized string_view iterator");
; 946  :         _STL_VERIFY(_Myoff < _Mysize, "cannot increment string_view iterator past end");
; 947  :         ++_Myoff;
; 948  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 949  :         ++_Myptr;
; 950  : #endif // _ITERATOR_DEBUG_LEVEL
; 951  :         return *this;
; 952  :     }
; 953  : 
; 954  :     constexpr _String_view_iterator operator++(int) noexcept {
; 955  :         _String_view_iterator _Tmp{*this};
; 956  :         ++*this;
; 957  :         return _Tmp;
; 958  :     }
; 959  : 
; 960  :     constexpr _String_view_iterator& operator--() noexcept {
; 961  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 962  :         _STL_VERIFY(_Mydata, "cannot decrement value-initialized string_view iterator");
; 963  :         _STL_VERIFY(_Myoff != 0, "cannot decrement string_view iterator before begin");
; 964  :         --_Myoff;
; 965  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 966  :         --_Myptr;
; 967  : #endif // _ITERATOR_DEBUG_LEVEL
; 968  :         return *this;
; 969  :     }
; 970  : 
; 971  :     constexpr _String_view_iterator operator--(int) noexcept {
; 972  :         _String_view_iterator _Tmp{*this};
; 973  :         --*this;
; 974  :         return _Tmp;
; 975  :     }
; 976  : 
; 977  :     constexpr void _Verify_offset(const difference_type _Off) const noexcept {
; 978  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 979  :         if (_Off != 0) {
; 980  :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 981  :         }
; 982  : 
; 983  :         if (_Off < 0) {
; 984  : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 985  :             _STL_VERIFY(_Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 986  :         }
; 987  : 
; 988  :         if (_Off > 0) {
; 989  :             _STL_VERIFY(_Mysize - _Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 990  :         }
; 991  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 992  :         (void) _Off;
; 993  : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 994  :     }
; 995  : 
; 996  :     constexpr _String_view_iterator& operator+=(const difference_type _Off) noexcept {
; 997  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 998  :         _Verify_offset(_Off);
; 999  :         _Myoff += _Off;
; 1000 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1001 :         _Myptr += _Off;
; 1002 : #endif // _ITERATOR_DEBUG_LEVEL
; 1003 : 
; 1004 :         return *this;
; 1005 :     }
; 1006 : 
; 1007 :     _NODISCARD constexpr _String_view_iterator operator+(const difference_type _Off) const noexcept {
; 1008 :         _String_view_iterator _Tmp{*this};
; 1009 :         _Tmp += _Off;
; 1010 :         return _Tmp;
; 1011 :     }
; 1012 : 
; 1013 :     constexpr _String_view_iterator& operator-=(const difference_type _Off) noexcept {
; 1014 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1015 :         if (_Off != 0) {
; 1016 :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 1017 :         }
; 1018 : 
; 1019 :         if (_Off > 0) {
; 1020 :             _STL_VERIFY(_Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 1021 :         }
; 1022 : 
; 1023 :         if (_Off < 0) {
; 1024 : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 1025 :             _STL_VERIFY(_Mysize - _Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 1026 :         }
; 1027 : 
; 1028 :         _Myoff -= _Off;
; 1029 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1030 :         _Myptr -= _Off;
; 1031 : #endif // _ITERATOR_DEBUG_LEVEL
; 1032 : 
; 1033 :         return *this;
; 1034 :     }
; 1035 : 
; 1036 :     _NODISCARD constexpr _String_view_iterator operator-(const difference_type _Off) const noexcept {
; 1037 :         _String_view_iterator _Tmp{*this};
; 1038 :         _Tmp -= _Off;
; 1039 :         return _Tmp;
; 1040 :     }
; 1041 : 
; 1042 :     _NODISCARD constexpr difference_type operator-(const _String_view_iterator& _Right) const noexcept {
; 1043 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1044 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1045 :             "cannot subtract incompatible string_view iterators");
; 1046 :         return static_cast<difference_type>(_Myoff - _Right._Myoff);
; 1047 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1048 :         return _Myptr - _Right._Myptr;
; 1049 : #endif // _ITERATOR_DEBUG_LEVEL
; 1050 :     }
; 1051 : 
; 1052 :     _NODISCARD constexpr reference operator[](const difference_type _Off) const noexcept {
; 1053 :         return *(*this + _Off);
; 1054 :     }
; 1055 : 
; 1056 :     _NODISCARD constexpr bool operator==(const _String_view_iterator& _Right) const noexcept {
; 1057 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1058 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1059 :             "cannot compare incompatible string_view iterators for equality");
; 1060 :         return _Myoff == _Right._Myoff;
; 1061 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1062 :         return _Myptr == _Right._Myptr;
; 1063 : #endif // _ITERATOR_DEBUG_LEVEL
; 1064 :     }
; 1065 : 
; 1066 :     _NODISCARD constexpr bool operator!=(const _String_view_iterator& _Right) const noexcept {
; 1067 :         return !(*this == _Right);
; 1068 :     }
; 1069 : 
; 1070 :     _NODISCARD constexpr bool operator<(const _String_view_iterator& _Right) const noexcept {
; 1071 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1072 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1073 :             "cannot compare incompatible string_view iterators");
; 1074 :         return _Myoff < _Right._Myoff;
; 1075 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1076 :         return _Myptr < _Right._Myptr;
; 1077 : #endif // _ITERATOR_DEBUG_LEVEL
; 1078 :     }
; 1079 : 
; 1080 :     _NODISCARD constexpr bool operator>(const _String_view_iterator& _Right) const noexcept {
; 1081 :         return _Right < *this;
; 1082 :     }
; 1083 : 
; 1084 :     _NODISCARD constexpr bool operator<=(const _String_view_iterator& _Right) const noexcept {
; 1085 :         return !(_Right < *this);
; 1086 :     }
; 1087 : 
; 1088 :     _NODISCARD constexpr bool operator>=(const _String_view_iterator& _Right) const noexcept {
; 1089 :         return !(*this < _Right);
; 1090 :     }
; 1091 : 
; 1092 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1093 :     friend constexpr void _Verify_range(const _String_view_iterator& _First, const _String_view_iterator& _Last) {
; 1094 :         _STL_VERIFY(_First._Mydata == _Last._Mydata && _First._Mysize == _Last._Mysize,
; 1095 :             "string_view iterators in range are from different views");
; 1096 :         _STL_VERIFY(_First._Myoff <= _Last._Myoff, "string_view iterator range transposed");
; 1097 :     }
; 1098 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1099 : 
; 1100 :     using _Prevent_inheriting_unwrap = _String_view_iterator;
; 1101 : 
; 1102 :     _NODISCARD constexpr pointer _Unwrapped() const noexcept {
; 1103 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1104 :         return _Mydata + _Myoff;
; 1105 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1106 :         return _Myptr;
; 1107 : #endif // _ITERATOR_DEBUG_LEVEL
; 1108 :     }
; 1109 : 
; 1110 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1111 : 
; 1112 :     constexpr void _Seek_to(pointer _It) noexcept {
; 1113 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1114 :         _Myoff = static_cast<size_t>(_It - _Mydata);
; 1115 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1116 :         _Myptr = _It;
; 1117 : #endif // _ITERATOR_DEBUG_LEVEL
; 1118 :     }
; 1119 : 
; 1120 : private:
; 1121 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1122 :     pointer _Mydata = nullptr;
; 1123 :     size_t _Mysize  = 0;
; 1124 :     size_t _Myoff   = 0;
; 1125 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1126 :     pointer _Myptr = nullptr;
; 1127 : #endif // _ITERATOR_DEBUG_LEVEL
; 1128 : };
; 1129 : 
; 1130 : template <class _Traits>
; 1131 : _NODISCARD constexpr _String_view_iterator<_Traits> operator+(
; 1132 :     const typename _String_view_iterator<_Traits>::difference_type _Off,
; 1133 :     _String_view_iterator<_Traits> _Right) noexcept {
; 1134 :     _Right += _Off;
; 1135 :     return _Right;
; 1136 : }
; 1137 : 
; 1138 : #if _HAS_CXX20
; 1139 : template <class _Traits>
; 1140 : struct pointer_traits<_String_view_iterator<_Traits>> {
; 1141 :     using pointer         = _String_view_iterator<_Traits>;
; 1142 :     using element_type    = const typename pointer::value_type;
; 1143 :     using difference_type = typename pointer::difference_type;
; 1144 : 
; 1145 :     _NODISCARD static constexpr element_type* to_address(const pointer& _Iter) noexcept {
; 1146 :         return _Iter._Unwrapped();
; 1147 :     }
; 1148 : };
; 1149 : #endif // _HAS_CXX20
; 1150 : 
; 1151 : 
; 1152 : // CLASS TEMPLATE basic_string_view
; 1153 : template <class _Elem, class _Traits>
; 1154 : class basic_string_view { // wrapper for any kind of contiguous character buffer
; 1155 : public:
; 1156 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 1157 :         "Bad char_traits for basic_string_view; "
; 1158 :         "N4659 24.4.2 [string.view.template]/1 \"the type traits::char_type shall name the same type as charT.\"");
; 1159 : 
; 1160 :     using traits_type            = _Traits;
; 1161 :     using value_type             = _Elem;
; 1162 :     using pointer                = _Elem*;
; 1163 :     using const_pointer          = const _Elem*;
; 1164 :     using reference              = _Elem&;
; 1165 :     using const_reference        = const _Elem&;
; 1166 :     using const_iterator         = _String_view_iterator<_Traits>;
; 1167 :     using iterator               = const_iterator;
; 1168 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 1169 :     using reverse_iterator       = const_reverse_iterator;
; 1170 :     using size_type              = size_t;
; 1171 :     using difference_type        = ptrdiff_t;
; 1172 : 
; 1173 :     static constexpr auto npos{static_cast<size_type>(-1)};
; 1174 : 
; 1175 :     constexpr basic_string_view() noexcept : _Mydata(), _Mysize(0) {}
; 1176 : 
; 1177 :     constexpr basic_string_view(const basic_string_view&) noexcept = default;
; 1178 :     constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;
; 1179 : 
; 1180 :     /* implicit */ constexpr basic_string_view(_In_z_ const const_pointer _Ntcts) noexcept // strengthened
; 1181 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}
; 1182 : 
; 1183 :     constexpr basic_string_view(
; 1184 :         _In_reads_(_Count) const const_pointer _Cts, const size_type _Count) noexcept // strengthened
; 1185 :         : _Mydata(_Cts), _Mysize(_Count) {
; 1186 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1187 :         _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
; 1188 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1189 :     }
; 1190 : 
; 1191 :     _NODISCARD constexpr const_iterator begin() const noexcept {
; 1192 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1193 :         return const_iterator(_Mydata, _Mysize, 0);
; 1194 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1195 :         return const_iterator(_Mydata);
; 1196 : #endif // _ITERATOR_DEBUG_LEVEL
; 1197 :     }
; 1198 : 
; 1199 :     _NODISCARD constexpr const_iterator end() const noexcept {
; 1200 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1201 :         return const_iterator(_Mydata, _Mysize, _Mysize);
; 1202 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1203 :         return const_iterator(_Mydata + _Mysize);
; 1204 : #endif // _ITERATOR_DEBUG_LEVEL
; 1205 :     }
; 1206 : 
; 1207 :     _NODISCARD constexpr const_iterator cbegin() const noexcept {
; 1208 :         return begin();
; 1209 :     }
; 1210 : 
; 1211 :     _NODISCARD constexpr const_iterator cend() const noexcept {
; 1212 :         return end();
; 1213 :     }
; 1214 : 
; 1215 :     _NODISCARD constexpr const_reverse_iterator rbegin() const noexcept {
; 1216 :         return const_reverse_iterator{end()};
; 1217 :     }
; 1218 : 
; 1219 :     _NODISCARD constexpr const_reverse_iterator rend() const noexcept {
; 1220 :         return const_reverse_iterator{begin()};
; 1221 :     }
; 1222 : 
; 1223 :     _NODISCARD constexpr const_reverse_iterator crbegin() const noexcept {
; 1224 :         return rbegin();
; 1225 :     }
; 1226 : 
; 1227 :     _NODISCARD constexpr const_reverse_iterator crend() const noexcept {
; 1228 :         return rend();
; 1229 :     }
; 1230 : 
; 1231 :     constexpr const_pointer _Unchecked_begin() const noexcept {
; 1232 :         return _Mydata;
; 1233 :     }
; 1234 : 
; 1235 :     constexpr const_pointer _Unchecked_end() const noexcept {
; 1236 :         return _Mydata + _Mysize;
; 1237 :     }
; 1238 : 
; 1239 :     _NODISCARD constexpr size_type size() const noexcept {
; 1240 :         return _Mysize;
; 1241 :     }
; 1242 : 
; 1243 :     _NODISCARD constexpr size_type length() const noexcept {
; 1244 :         return _Mysize;
; 1245 :     }
; 1246 : 
; 1247 :     _NODISCARD constexpr bool empty() const noexcept {
; 1248 :         return _Mysize == 0;
; 1249 :     }
; 1250 : 
; 1251 :     _NODISCARD constexpr const_pointer data() const noexcept {
; 1252 :         return _Mydata;
; 1253 :     }
; 1254 : 
; 1255 :     _NODISCARD constexpr size_type max_size() const noexcept {
; 1256 :         // bound to PTRDIFF_MAX to make end() - begin() well defined (also makes room for npos)
; 1257 :         // bound to static_cast<size_t>(-1) / sizeof(_Elem) by address space limits
; 1258 :         return _Min_value(static_cast<size_t>(PTRDIFF_MAX), static_cast<size_t>(-1) / sizeof(_Elem));
; 1259 :     }
; 1260 : 
; 1261 :     _NODISCARD constexpr const_reference operator[](const size_type _Off) const noexcept /* strengthened */ {
; 1262 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1263 :         _STL_VERIFY(_Off < _Mysize, "string_view subscript out of range");
; 1264 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1265 :         return _Mydata[_Off];
; 1266 :     }
; 1267 : 
; 1268 :     _NODISCARD constexpr const_reference at(const size_type _Off) const {
; 1269 :         // get the character at _Off or throw if that is out of range
; 1270 :         _Check_offset_exclusive(_Off);
; 1271 :         return _Mydata[_Off];
; 1272 :     }
; 1273 : 
; 1274 :     _NODISCARD constexpr const_reference front() const noexcept /* strengthened */ {
; 1275 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1276 :         _STL_VERIFY(_Mysize != 0, "cannot call front on empty string_view");
; 1277 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1278 :         return _Mydata[0];
; 1279 :     }
; 1280 : 
; 1281 :     _NODISCARD constexpr const_reference back() const noexcept /* strengthened */ {
; 1282 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1283 :         _STL_VERIFY(_Mysize != 0, "cannot call back on empty string_view");
; 1284 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1285 :         return _Mydata[_Mysize - 1];
; 1286 :     }
; 1287 : 
; 1288 :     constexpr void remove_prefix(const size_type _Count) noexcept /* strengthened */ {
; 1289 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1290 :         _STL_VERIFY(_Mysize >= _Count, "cannot remove prefix longer than total size");
; 1291 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1292 :         _Mydata += _Count;
; 1293 :         _Mysize -= _Count;
; 1294 :     }
; 1295 : 
; 1296 :     constexpr void remove_suffix(const size_type _Count) noexcept /* strengthened */ {
; 1297 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1298 :         _STL_VERIFY(_Mysize >= _Count, "cannot remove suffix longer than total size");
; 1299 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1300 :         _Mysize -= _Count;
; 1301 :     }
; 1302 : 
; 1303 :     constexpr void swap(basic_string_view& _Other) noexcept {
; 1304 :         const basic_string_view _Tmp{_Other}; // note: std::swap is not constexpr before C++20
; 1305 :         _Other = *this;
; 1306 :         *this  = _Tmp;
; 1307 :     }
; 1308 : 
; 1309 :     constexpr size_type copy(_Out_writes_(_Count) _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
; 1310 :         // copy [_Off, _Off + Count) to [_Ptr, _Ptr + _Count)
; 1311 :         _Check_offset(_Off);
; 1312 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1313 :         _Traits::copy(_Ptr, _Mydata + _Off, _Count);
; 1314 :         return _Count;
; 1315 :     }
; 1316 : 
; 1317 :     _Pre_satisfies_(_Dest_size >= _Count) constexpr size_type _Copy_s(_Out_writes_all_(_Dest_size) _Elem* const _Dest,
; 1318 :         const size_type _Dest_size, size_type _Count, const size_type _Off = 0) const {
; 1319 :         // copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1320 :         _Check_offset(_Off);
; 1321 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1322 :         _Traits::_Copy_s(_Dest, _Dest_size, _Mydata + _Off, _Count);
; 1323 :         return _Count;
; 1324 :     }
; 1325 : 
; 1326 :     _NODISCARD constexpr basic_string_view substr(const size_type _Off = 0, size_type _Count = npos) const {
; 1327 :         // return a new basic_string_view moved forward by _Off and trimmed to _Count elements
; 1328 :         _Check_offset(_Off);
; 1329 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1330 :         return basic_string_view(_Mydata + _Off, _Count);
; 1331 :     }
; 1332 : 
; 1333 :     constexpr bool _Equal(const basic_string_view _Right) const noexcept {
; 1334 :         return _Traits_equal<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
; 1335 :     }
; 1336 : 
; 1337 :     _NODISCARD constexpr int compare(const basic_string_view _Right) const noexcept {
; 1338 :         return _Traits_compare<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
; 1339 :     }
; 1340 : 
; 1341 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right) const {
; 1342 :         // compare [_Off, _Off + _N0) with _Right
; 1343 :         return substr(_Off, _N0).compare(_Right);
; 1344 :     }
; 1345 : 
; 1346 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right,
; 1347 :         const size_type _Roff, const size_type _Count) const {
; 1348 :         // compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1349 :         return substr(_Off, _N0).compare(_Right.substr(_Roff, _Count));
; 1350 :     }
; 1351 : 
; 1352 :     _NODISCARD constexpr int compare(_In_z_ const _Elem* const _Ptr) const { // compare [0, _Mysize) with [_Ptr, <null>)
; 1353 :         return compare(basic_string_view(_Ptr));
; 1354 :     }
; 1355 : 
; 1356 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, _In_z_ const _Elem* const _Ptr) const {
; 1357 :         // compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 1358 :         return substr(_Off, _N0).compare(basic_string_view(_Ptr));
; 1359 :     }
; 1360 : 
; 1361 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0,
; 1362 :         _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) const {
; 1363 :         // compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1364 :         return substr(_Off, _N0).compare(basic_string_view(_Ptr, _Count));
; 1365 :     }
; 1366 : 
; 1367 : #if _HAS_CXX20
; 1368 :     _NODISCARD constexpr bool starts_with(const basic_string_view _Right) const noexcept {
; 1369 :         const auto _Rightsize = _Right._Mysize;
; 1370 :         if (_Mysize < _Rightsize) {
; 1371 :             return false;
; 1372 :         }
; 1373 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;
; 1374 :     }
; 1375 : 
; 1376 :     _NODISCARD constexpr bool starts_with(const _Elem _Right) const noexcept {
; 1377 :         return !empty() && _Traits::eq(front(), _Right);
; 1378 :     }
; 1379 : 
; 1380 :     _NODISCARD constexpr bool starts_with(const _Elem* const _Right) const noexcept /* strengthened */ {
; 1381 :         return starts_with(basic_string_view(_Right));
; 1382 :     }
; 1383 : 
; 1384 :     _NODISCARD constexpr bool ends_with(const basic_string_view _Right) const noexcept {
; 1385 :         const auto _Rightsize = _Right._Mysize;
; 1386 :         if (_Mysize < _Rightsize) {
; 1387 :             return false;
; 1388 :         }
; 1389 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;
; 1390 :     }
; 1391 : 
; 1392 :     _NODISCARD constexpr bool ends_with(const _Elem _Right) const noexcept {
; 1393 :         return !empty() && _Traits::eq(back(), _Right);
; 1394 :     }
; 1395 : 
; 1396 :     _NODISCARD constexpr bool ends_with(const _Elem* const _Right) const noexcept /* strengthened */ {
; 1397 :         return ends_with(basic_string_view(_Right));
; 1398 :     }
; 1399 : #endif // _HAS_CXX20
; 1400 : 
; 1401 :     _NODISCARD constexpr size_type find(const basic_string_view _Right, const size_type _Off = 0) const noexcept {
; 1402 :         // look for _Right beginning at or after _Off
; 1403 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
; 1404 :     }
; 1405 : 
; 1406 :     _NODISCARD constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1407 :         // look for _Ch at or after _Off
; 1408 :         return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1409 :     }
; 1410 : 
; 1411 :     _NODISCARD constexpr size_type find(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1412 :         const size_type _Count) const noexcept /* strengthened */ {
; 1413 :         // look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1414 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
; 1415 :     }
; 1416 : 
; 1417 :     _NODISCARD constexpr size_type find(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1418 :         noexcept /* strengthened */ {
; 1419 :         // look for [_Ptr, <null>) beginning at or after _Off
; 1420 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
; 1421 :     }
; 1422 : 
; 1423 :     _NODISCARD constexpr size_type rfind(const basic_string_view _Right, const size_type _Off = npos) const noexcept {
; 1424 :         // look for _Right beginning before _Off
; 1425 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
; 1426 :     }
; 1427 : 
; 1428 :     _NODISCARD constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1429 :         // look for _Ch before _Off
; 1430 :         return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1431 :     }
; 1432 : 
; 1433 :     _NODISCARD constexpr size_type rfind(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1434 :         const size_type _Count) const noexcept /* strengthened */ {
; 1435 :         // look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1436 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
; 1437 :     }
; 1438 : 
; 1439 :     _NODISCARD constexpr size_type rfind(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1440 :         noexcept /* strengthened */ {
; 1441 :         // look for [_Ptr, <null>) beginning before _Off
; 1442 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
; 1443 :     }
; 1444 : 
; 1445 :     _NODISCARD constexpr size_type find_first_of(const basic_string_view _Right,
; 1446 :         const size_type _Off = 0) const noexcept { // look for one of _Right at or after _Off
; 1447 :         return _Traits_find_first_of<_Traits>(
; 1448 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1449 :     }
; 1450 : 
; 1451 :     _NODISCARD constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1452 :         // look for _Ch at or after _Off
; 1453 :         return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1454 :     }
; 1455 : 
; 1456 :     _NODISCARD constexpr size_type find_first_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1457 :         const size_type _Count) const noexcept /* strengthened */ {
; 1458 :         // look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1459 :         return _Traits_find_first_of<_Traits>(
; 1460 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1461 :     }
; 1462 : 
; 1463 :     _NODISCARD constexpr size_type find_first_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1464 :         noexcept /* strengthened */ {
; 1465 :         // look for one of [_Ptr, <null>) at or after _Off
; 1466 :         return _Traits_find_first_of<_Traits>(
; 1467 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1468 :     }
; 1469 : 
; 1470 :     _NODISCARD constexpr size_type find_last_of(const basic_string_view _Right, const size_type _Off = npos) const
; 1471 :         noexcept { // look for one of _Right before _Off
; 1472 :         return _Traits_find_last_of<_Traits>(
; 1473 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1474 :     }
; 1475 : 
; 1476 :     _NODISCARD constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1477 :         // look for _Ch before _Off
; 1478 :         return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1479 :     }
; 1480 : 
; 1481 :     _NODISCARD constexpr size_type find_last_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1482 :         const size_type _Count) const noexcept /* strengthened */ {
; 1483 :         // look for one of [_Ptr, _Ptr + _Count) before _Off
; 1484 :         return _Traits_find_last_of<_Traits>(
; 1485 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1486 :     }
; 1487 : 
; 1488 :     _NODISCARD constexpr size_type find_last_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1489 :         noexcept /* strengthened */ {
; 1490 :         // look for one of [_Ptr, <null>) before _Off
; 1491 :         return _Traits_find_last_of<_Traits>(
; 1492 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1493 :     }
; 1494 : 
; 1495 :     _NODISCARD constexpr size_type find_first_not_of(const basic_string_view _Right,
; 1496 :         const size_type _Off = 0) const noexcept { // look for none of _Right at or after _Off
; 1497 :         return _Traits_find_first_not_of<_Traits>(
; 1498 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1499 :     }
; 1500 : 
; 1501 :     _NODISCARD constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1502 :         // look for any value other than _Ch at or after _Off
; 1503 :         return _Traits_find_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1504 :     }
; 1505 : 
; 1506 :     _NODISCARD constexpr size_type find_first_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1507 :         const size_type _Count) const noexcept /* strengthened */ {
; 1508 :         // look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 1509 :         return _Traits_find_first_not_of<_Traits>(
; 1510 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1511 :     }
; 1512 : 
; 1513 :     _NODISCARD constexpr size_type find_first_not_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1514 :         noexcept /* strengthened */ {
; 1515 :         // look for none of [_Ptr, <null>) at or after _Off
; 1516 :         return _Traits_find_first_not_of<_Traits>(
; 1517 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1518 :     }
; 1519 : 
; 1520 :     _NODISCARD constexpr size_type find_last_not_of(const basic_string_view _Right,
; 1521 :         const size_type _Off = npos) const noexcept { // look for none of _Right before _Off
; 1522 :         return _Traits_find_last_not_of<_Traits>(
; 1523 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1524 :     }
; 1525 : 
; 1526 :     _NODISCARD constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1527 :         // look for any value other than _Ch before _Off
; 1528 :         return _Traits_rfind_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1529 :     }
; 1530 : 
; 1531 :     _NODISCARD constexpr size_type find_last_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1532 :         const size_type _Count) const noexcept /* strengthened */ {
; 1533 :         // look for none of [_Ptr, _Ptr + _Count) before _Off
; 1534 :         return _Traits_find_last_not_of<_Traits>(
; 1535 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1536 :     }
; 1537 : 
; 1538 :     _NODISCARD constexpr size_type find_last_not_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1539 :         noexcept /* strengthened */ {
; 1540 :         // look for none of [_Ptr, <null>) before _Off
; 1541 :         return _Traits_find_last_not_of<_Traits>(
; 1542 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1543 :     }
; 1544 : 
; 1545 :     _NODISCARD constexpr bool _Starts_with(const basic_string_view _View) const noexcept {
; 1546 :         return _Mysize >= _View._Mysize && _Traits::compare(_Mydata, _View._Mydata, _View._Mysize) == 0;
; 1547 :     }
; 1548 : 
; 1549 : private:
; 1550 :     constexpr void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 1551 :         if (_Mysize < _Off) {
; 1552 :             _Xran();
; 1553 :         }
; 1554 :     }
; 1555 : 
; 1556 :     constexpr void _Check_offset_exclusive(const size_type _Off) const {
; 1557 :         // checks whether _Off is in the bounds of [0, size())
; 1558 :         if (_Mysize <= _Off) {
; 1559 :             _Xran();
; 1560 :         }
; 1561 :     }
; 1562 : 
; 1563 :     constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 1564 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 1565 :         return _Min_value(_Size, _Mysize - _Off);
; 1566 :     }
; 1567 : 
; 1568 :     [[noreturn]] static void _Xran() {
; 1569 :         _Xout_of_range("invalid string_view position");
; 1570 :     }
; 1571 : 
; 1572 :     const_pointer _Mydata;
; 1573 :     size_type _Mysize;
; 1574 : };
; 1575 : 
; 1576 : #ifdef __cpp_lib_concepts
; 1577 : namespace ranges {
; 1578 :     template <class _Elem, class _Traits>
; 1579 :     inline constexpr bool enable_view<basic_string_view<_Elem, _Traits>> = true;
; 1580 :     template <class _Elem, class _Traits>
; 1581 :     inline constexpr bool enable_borrowed_range<basic_string_view<_Elem, _Traits>> = true;
; 1582 : } // namespace ranges
; 1583 : #endif // __cpp_lib_concepts
; 1584 : 
; 1585 : // FUNCTION TEMPLATES operator== FOR basic_string_view
; 1586 : template <class _Elem, class _Traits>
; 1587 : _NODISCARD constexpr bool operator==(
; 1588 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1589 :     return _Lhs._Equal(_Rhs);
; 1590 : }
; 1591 : 
; 1592 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1593 : _NODISCARD constexpr bool operator==(
; 1594 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1595 :     return _Lhs._Equal(_Rhs);
; 1596 : }
; 1597 : 
; 1598 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1599 : _NODISCARD constexpr bool operator==(
; 1600 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1601 :     return _Lhs._Equal(_Rhs);
; 1602 : }
; 1603 : 
; 1604 : 
; 1605 : // FUNCTION TEMPLATES operator!= FOR basic_string_view
; 1606 : template <class _Elem, class _Traits>
; 1607 : _NODISCARD constexpr bool operator!=(
; 1608 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1609 :     return !_Lhs._Equal(_Rhs);
; 1610 : }
; 1611 : 
; 1612 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1613 : _NODISCARD constexpr bool operator!=(
; 1614 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1615 :     return !_Lhs._Equal(_Rhs);
; 1616 : }
; 1617 : 
; 1618 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1619 : _NODISCARD constexpr bool operator!=(
; 1620 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1621 :     return !_Lhs._Equal(_Rhs);
; 1622 : }
; 1623 : 
; 1624 : 
; 1625 : // FUNCTION TEMPLATES operator< FOR basic_string_view
; 1626 : template <class _Elem, class _Traits>
; 1627 : _NODISCARD constexpr bool operator<(
; 1628 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1629 :     return _Lhs.compare(_Rhs) < 0;
; 1630 : }
; 1631 : 
; 1632 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1633 : _NODISCARD constexpr bool operator<(
; 1634 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1635 :     return _Lhs.compare(_Rhs) < 0;
; 1636 : }
; 1637 : 
; 1638 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1639 : _NODISCARD constexpr bool operator<(
; 1640 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1641 :     return _Lhs.compare(_Rhs) < 0;
; 1642 : }
; 1643 : 
; 1644 : 
; 1645 : // FUNCTION TEMPLATES operator> FOR basic_string_view
; 1646 : template <class _Elem, class _Traits>
; 1647 : _NODISCARD constexpr bool operator>(
; 1648 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1649 :     return _Lhs.compare(_Rhs) > 0;
; 1650 : }
; 1651 : 
; 1652 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1653 : _NODISCARD constexpr bool operator>(
; 1654 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1655 :     return _Lhs.compare(_Rhs) > 0;
; 1656 : }
; 1657 : 
; 1658 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1659 : _NODISCARD constexpr bool operator>(
; 1660 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1661 :     return _Lhs.compare(_Rhs) > 0;
; 1662 : }
; 1663 : 
; 1664 : 
; 1665 : // FUNCTION TEMPLATES operator<= FOR basic_string_view
; 1666 : template <class _Elem, class _Traits>
; 1667 : _NODISCARD constexpr bool operator<=(
; 1668 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1669 :     return _Lhs.compare(_Rhs) <= 0;
; 1670 : }
; 1671 : 
; 1672 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1673 : _NODISCARD constexpr bool operator<=(
; 1674 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1675 :     return _Lhs.compare(_Rhs) <= 0;
; 1676 : }
; 1677 : 
; 1678 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1679 : _NODISCARD constexpr bool operator<=(
; 1680 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1681 :     return _Lhs.compare(_Rhs) <= 0;
; 1682 : }
; 1683 : 
; 1684 : 
; 1685 : // FUNCTION TEMPLATES operator>= FOR basic_string_view
; 1686 : template <class _Elem, class _Traits>
; 1687 : _NODISCARD constexpr bool operator>=(
; 1688 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1689 :     return _Lhs.compare(_Rhs) >= 0;
; 1690 : }
; 1691 : 
; 1692 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1693 : _NODISCARD constexpr bool operator>=(
; 1694 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1695 :     return _Lhs.compare(_Rhs) >= 0;
; 1696 : }
; 1697 : 
; 1698 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1699 : _NODISCARD constexpr bool operator>=(
; 1700 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1701 :     return _Lhs.compare(_Rhs) >= 0;
; 1702 : }
; 1703 : 
; 1704 : 
; 1705 : // TYPEDEFS FOR basic_string_view
; 1706 : using string_view = basic_string_view<char>;
; 1707 : #ifdef __cpp_lib_char8_t
; 1708 : using u8string_view = basic_string_view<char8_t>;
; 1709 : #endif // __cpp_lib_char8_t
; 1710 : using u16string_view = basic_string_view<char16_t>;
; 1711 : using u32string_view = basic_string_view<char32_t>;
; 1712 : using wstring_view   = basic_string_view<wchar_t>;
; 1713 : 
; 1714 : 
; 1715 : // STRUCT TEMPLATE SPECIALIZATION hash FOR basic_string_view
; 1716 : template <class _Elem, class _Traits>
; 1717 : struct hash<basic_string_view<_Elem, _Traits>> {
; 1718 :     _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef basic_string_view<_Elem, _Traits> _ARGUMENT_TYPE_NAME;
; 1719 :     _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t _RESULT_TYPE_NAME;
; 1720 : 
; 1721 :     _NODISCARD size_t operator()(const basic_string_view<_Elem, _Traits> _Keyval) const noexcept {
; 1722 :         return _Hash_array_representation(_Keyval.data(), _Keyval.size());
; 1723 :     }
; 1724 : };
; 1725 : 
; 1726 : template <class _Elem, class _Traits>
; 1727 : basic_ostream<_Elem, _Traits>& operator<<(
; 1728 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string_view<_Elem, _Traits> _Str) {
; 1729 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());
; 1730 : }
; 1731 : 
; 1732 : 
; 1733 : // basic_string_view LITERALS
; 1734 : inline namespace literals {
; 1735 :     inline namespace string_view_literals {
; 1736 :         _NODISCARD constexpr string_view operator"" sv(const char* _Str, size_t _Len) noexcept {
; 1737 :             return string_view(_Str, _Len);
; 1738 :         }
; 1739 : 
; 1740 :         _NODISCARD constexpr wstring_view operator"" sv(const wchar_t* _Str, size_t _Len) noexcept {
; 1741 :             return wstring_view(_Str, _Len);
; 1742 :         }
; 1743 : 
; 1744 : #ifdef __cpp_char8_t
; 1745 :         _NODISCARD constexpr basic_string_view<char8_t> operator"" sv(const char8_t* _Str, size_t _Len) noexcept {
; 1746 :             return basic_string_view<char8_t>(_Str, _Len);
; 1747 :         }
; 1748 : #endif // __cpp_char8_t
; 1749 : 
; 1750 :         _NODISCARD constexpr u16string_view operator"" sv(const char16_t* _Str, size_t _Len) noexcept {
; 1751 :             return u16string_view(_Str, _Len);
; 1752 :         }
; 1753 : 
; 1754 :         _NODISCARD constexpr u32string_view operator"" sv(const char32_t* _Str, size_t _Len) noexcept {
; 1755 :             return u32string_view(_Str, _Len);
; 1756 :         }
; 1757 :     } // namespace string_view_literals
; 1758 : } // namespace literals
; 1759 : #endif // _HAS_CXX17
; 1760 : 
; 1761 : // CLASS TEMPLATE _String_const_iterator
; 1762 : template <class _Mystr>
; 1763 : class _String_const_iterator : public _Iterator_base {
; 1764 : public:
; 1765 : #ifdef __cpp_lib_concepts
; 1766 :     using iterator_concept = contiguous_iterator_tag;
; 1767 : #endif // __cpp_lib_concepts
; 1768 :     using iterator_category = random_access_iterator_tag;
; 1769 :     using value_type        = typename _Mystr::value_type;
; 1770 :     using difference_type   = typename _Mystr::difference_type;
; 1771 :     using pointer           = typename _Mystr::const_pointer;
; 1772 :     using reference         = const value_type&;
; 1773 : 
; 1774 :     _String_const_iterator() noexcept : _Ptr() {}
; 1775 : 
; 1776 :     _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {
; 1777 :         this->_Adopt(_Pstring);
; 1778 :     }
; 1779 : 
; 1780 :     _NODISCARD reference operator*() const {
; 1781 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1782 :         _STL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1783 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1784 :         _STL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1785 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1786 :         const auto _Contptr = _Mycont->_Myptr();
; 1787 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1788 :         _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1789 :             "cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1790 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1791 : 
; 1792 :         _Analysis_assume_(_Ptr);
; 1793 :         return *_Ptr;
; 1794 :     }
; 1795 : 
; 1796 :     _NODISCARD pointer operator->() const {
; 1797 :         return pointer_traits<pointer>::pointer_to(**this);
; 1798 :     }
; 1799 : 
; 1800 :     _String_const_iterator& operator++() {
; 1801 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1802 :         _STL_VERIFY(_Ptr, "cannot increment value-initialized string iterator");
; 1803 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1804 :         _STL_VERIFY(_Mycont, "cannot increment string iterator because the iterator was"
; 1805 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1806 :         _STL_VERIFY(_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize, "cannot increment string iterator past end");
; 1807 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1808 : 
; 1809 :         ++_Ptr;
; 1810 :         return *this;
; 1811 :     }
; 1812 : 
; 1813 :     _String_const_iterator operator++(int) {
; 1814 :         _String_const_iterator _Tmp = *this;
; 1815 :         ++*this;
; 1816 :         return _Tmp;
; 1817 :     }
; 1818 : 
; 1819 :     _String_const_iterator& operator--() {
; 1820 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1821 :         _STL_VERIFY(_Ptr, "cannot decrement value-initialized string iterator");
; 1822 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1823 :         _STL_VERIFY(_Mycont, "cannot decrement string iterator because the iterator was"
; 1824 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1825 :         _STL_VERIFY(_Mycont->_Myptr() < _Unfancy(_Ptr), "cannot decrement string iterator before begin");
; 1826 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1827 : 
; 1828 :         --_Ptr;
; 1829 :         return *this;
; 1830 :     }
; 1831 : 
; 1832 :     _String_const_iterator operator--(int) {
; 1833 :         _String_const_iterator _Tmp = *this;
; 1834 :         --*this;
; 1835 :         return _Tmp;
; 1836 :     }
; 1837 : 
; 1838 :     void _Verify_offset(const difference_type _Off) const noexcept {
; 1839 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1840 :         if (_Off == 0) {
; 1841 :             return;
; 1842 :         }
; 1843 : 
; 1844 :         _STL_ASSERT(_Ptr, "cannot seek value-initialized string iterator");
; 1845 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1846 :         _STL_ASSERT(_Mycont, "cannot seek string iterator because the iterator was"
; 1847 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1848 :         const auto _Contptr = _Mycont->_Myptr();
; 1849 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1850 : 
; 1851 :         if (_Off < 0) {
; 1852 : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 1853 :             _STL_VERIFY(_Contptr - _Rawptr <= _Off, "cannot seek string iterator before begin");
; 1854 :         }
; 1855 : 
; 1856 :         if (_Off > 0) {
; 1857 :             using _Size_type = typename _Mystr::size_type;
; 1858 :             const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
; 1859 :             _STL_VERIFY(static_cast<_Size_type>(_Off) <= _Left, "cannot seek string iterator after end");
; 1860 :         }
; 1861 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1862 :         (void) _Off;
; 1863 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1864 :     }
; 1865 : 
; 1866 :     _String_const_iterator& operator+=(const difference_type _Off) {
; 1867 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1868 :         _Verify_offset(_Off);
; 1869 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1870 :         _Ptr += _Off;
; 1871 :         return *this;
; 1872 :     }
; 1873 : 
; 1874 :     _NODISCARD _String_const_iterator operator+(const difference_type _Off) const {
; 1875 :         _String_const_iterator _Tmp = *this;
; 1876 :         return _Tmp += _Off;
; 1877 :     }
; 1878 : 
; 1879 :     _String_const_iterator& operator-=(const difference_type _Off) {
; 1880 :         return *this += -_Off;
; 1881 :     }
; 1882 : 
; 1883 :     _NODISCARD _String_const_iterator operator-(const difference_type _Off) const {
; 1884 :         _String_const_iterator _Tmp = *this;
; 1885 :         return _Tmp -= _Off;
; 1886 :     }
; 1887 : 
; 1888 :     _NODISCARD difference_type operator-(const _String_const_iterator& _Right) const {
; 1889 :         _Compat(_Right);
; 1890 :         return _Ptr - _Right._Ptr;
; 1891 :     }
; 1892 : 
; 1893 :     _NODISCARD reference operator[](const difference_type _Off) const {
; 1894 :         return *(*this + _Off);
; 1895 :     }
; 1896 : 
; 1897 :     _NODISCARD bool operator==(const _String_const_iterator& _Right) const {
; 1898 :         _Compat(_Right);
; 1899 :         return _Ptr == _Right._Ptr;
; 1900 :     }
; 1901 : 
; 1902 :     _NODISCARD bool operator!=(const _String_const_iterator& _Right) const {
; 1903 :         return !(*this == _Right);
; 1904 :     }
; 1905 : 
; 1906 :     _NODISCARD bool operator<(const _String_const_iterator& _Right) const {
; 1907 :         _Compat(_Right);
; 1908 :         return _Ptr < _Right._Ptr;
; 1909 :     }
; 1910 : 
; 1911 :     _NODISCARD bool operator>(const _String_const_iterator& _Right) const {
; 1912 :         return _Right < *this;
; 1913 :     }
; 1914 : 
; 1915 :     _NODISCARD bool operator<=(const _String_const_iterator& _Right) const {
; 1916 :         return !(_Right < *this);
; 1917 :     }
; 1918 : 
; 1919 :     _NODISCARD bool operator>=(const _String_const_iterator& _Right) const {
; 1920 :         return !(*this < _Right);
; 1921 :     }
; 1922 : 
; 1923 :     void _Compat(const _String_const_iterator& _Right) const { // test for compatible iterator pair
; 1924 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1925 :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "string iterators incompatible (e.g."
; 1926 :                                                            " point to different string instances)");
; 1927 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1928 :         (void) _Right;
; 1929 : #endif // _ITERATOR_DEBUG_LEVEL
; 1930 :     }
; 1931 : 
; 1932 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1933 :     friend void _Verify_range(const _String_const_iterator& _First, const _String_const_iterator& _Last) {
; 1934 :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "string iterators in range are from different containers");
; 1935 :         _STL_VERIFY(_First._Ptr <= _Last._Ptr, "string iterator range transposed");
; 1936 :     }
; 1937 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1938 : 
; 1939 :     using _Prevent_inheriting_unwrap = _String_const_iterator;
; 1940 : 
; 1941 :     _NODISCARD const value_type* _Unwrapped() const {
; 1942 :         return _Unfancy(_Ptr);
; 1943 :     }
; 1944 : 
; 1945 :     void _Seek_to(const value_type* _It) {
; 1946 :         _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
; 1947 :     }
; 1948 : 
; 1949 :     pointer _Ptr; // pointer to element in string
; 1950 : };
; 1951 : 
; 1952 : template <class _Mystr>
; 1953 : _NODISCARD _String_const_iterator<_Mystr> operator+(
; 1954 :     typename _String_const_iterator<_Mystr>::difference_type _Off, _String_const_iterator<_Mystr> _Next) {
; 1955 :     return _Next += _Off;
; 1956 : }
; 1957 : 
; 1958 : #if _HAS_CXX20
; 1959 : template <class _Mystr>
; 1960 : struct pointer_traits<_String_const_iterator<_Mystr>> {
; 1961 :     using pointer         = _String_const_iterator<_Mystr>;
; 1962 :     using element_type    = const typename pointer::value_type;
; 1963 :     using difference_type = typename pointer::difference_type;
; 1964 : 
; 1965 :     _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
; 1966 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1967 :         const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
; 1968 :         if (!_Mycont) {
; 1969 :             _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
; 1970 :                                      "(e.g. reallocation occurred, or the string was destroyed)");
; 1971 :         }
; 1972 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1973 : 
; 1974 :         const auto _Rawptr = _STD to_address(_Iter._Ptr);
; 1975 : 
; 1976 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1977 :         if (_Mycont) {
; 1978 :             const auto _Contptr = _Mycont->_Myptr();
; 1979 :             _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
; 1980 :                 "cannot convert string iterator to pointer because it is out of range");
; 1981 :         }
; 1982 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1983 : 
; 1984 :         return _Rawptr;
; 1985 :     }
; 1986 : };
; 1987 : #endif // _HAS_CXX20
; 1988 : 
; 1989 : // CLASS TEMPLATE _String_iterator
; 1990 : template <class _Mystr>
; 1991 : class _String_iterator : public _String_const_iterator<_Mystr> {
; 1992 : public:
; 1993 :     using _Mybase = _String_const_iterator<_Mystr>;
; 1994 : 
; 1995 : #ifdef __cpp_lib_concepts
; 1996 :     using iterator_concept = contiguous_iterator_tag;
; 1997 : #endif // __cpp_lib_concepts
; 1998 :     using iterator_category = random_access_iterator_tag;
; 1999 :     using value_type        = typename _Mystr::value_type;
; 2000 :     using difference_type   = typename _Mystr::difference_type;
; 2001 :     using pointer           = typename _Mystr::pointer;
; 2002 :     using reference         = value_type&;
; 2003 : 
; 2004 :     using _Mybase::_Mybase;
; 2005 : 
; 2006 :     _NODISCARD reference operator*() const {
; 2007 :         return const_cast<reference>(_Mybase::operator*());
; 2008 :     }
; 2009 : 
; 2010 :     _NODISCARD pointer operator->() const {
; 2011 :         return pointer_traits<pointer>::pointer_to(**this);
; 2012 :     }
; 2013 : 
; 2014 :     _String_iterator& operator++() {
; 2015 :         _Mybase::operator++();
; 2016 :         return *this;
; 2017 :     }
; 2018 : 
; 2019 :     _String_iterator operator++(int) {
; 2020 :         _String_iterator _Tmp = *this;
; 2021 :         _Mybase::operator++();
; 2022 :         return _Tmp;
; 2023 :     }
; 2024 : 
; 2025 :     _String_iterator& operator--() {
; 2026 :         _Mybase::operator--();
; 2027 :         return *this;
; 2028 :     }
; 2029 : 
; 2030 :     _String_iterator operator--(int) {
; 2031 :         _String_iterator _Tmp = *this;
; 2032 :         _Mybase::operator--();
; 2033 :         return _Tmp;
; 2034 :     }
; 2035 : 
; 2036 :     _String_iterator& operator+=(const difference_type _Off) {
; 2037 :         _Mybase::operator+=(_Off);
; 2038 :         return *this;
; 2039 :     }
; 2040 : 
; 2041 :     _NODISCARD _String_iterator operator+(const difference_type _Off) const {
; 2042 :         _String_iterator _Tmp = *this;
; 2043 :         return _Tmp += _Off;
; 2044 :     }
; 2045 : 
; 2046 :     _String_iterator& operator-=(const difference_type _Off) {
; 2047 :         _Mybase::operator-=(_Off);
; 2048 :         return *this;
; 2049 :     }
; 2050 : 
; 2051 :     using _Mybase::operator-;
; 2052 : 
; 2053 :     _NODISCARD _String_iterator operator-(const difference_type _Off) const {
; 2054 :         _String_iterator _Tmp = *this;
; 2055 :         return _Tmp -= _Off;
; 2056 :     }
; 2057 : 
; 2058 :     _NODISCARD reference operator[](const difference_type _Off) const {
; 2059 :         return const_cast<reference>(_Mybase::operator[](_Off));
; 2060 :     }
; 2061 : 
; 2062 :     using _Prevent_inheriting_unwrap = _String_iterator;
; 2063 : 
; 2064 :     _NODISCARD value_type* _Unwrapped() const {
; 2065 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));
; 2066 :     }
; 2067 : };
; 2068 : 
; 2069 : template <class _Mystr>
; 2070 : _NODISCARD _String_iterator<_Mystr> operator+(
; 2071 :     typename _String_iterator<_Mystr>::difference_type _Off, _String_iterator<_Mystr> _Next) {
; 2072 :     return _Next += _Off;
; 2073 : }
; 2074 : 
; 2075 : #if _HAS_CXX20
; 2076 : template <class _Mystr>
; 2077 : struct pointer_traits<_String_iterator<_Mystr>> {
; 2078 :     using pointer         = _String_iterator<_Mystr>;
; 2079 :     using element_type    = typename pointer::value_type;
; 2080 :     using difference_type = typename pointer::difference_type;
; 2081 : 
; 2082 :     _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
; 2083 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 2084 :         const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
; 2085 :         if (!_Mycont) {
; 2086 :             _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
; 2087 :                                      "(e.g. reallocation occurred, or the string was destroyed)");
; 2088 :         }
; 2089 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 2090 : 
; 2091 :         const auto _Rawptr = _STD to_address(_Iter._Ptr);
; 2092 : 
; 2093 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 2094 :         if (_Mycont) {
; 2095 :             const auto _Contptr = _Mycont->_Myptr();
; 2096 :             _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
; 2097 :                 "cannot convert string iterator to pointer because it is out of range");
; 2098 :         }
; 2099 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 2100 : 
; 2101 :         return const_cast<element_type*>(_Rawptr);
; 2102 :     }
; 2103 : };
; 2104 : #endif // _HAS_CXX20
; 2105 : 
; 2106 : // basic_string TYPE WRAPPERS
; 2107 : template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
; 2108 :     class _Reference, class _Const_reference>
; 2109 : struct _String_iter_types {
; 2110 :     using value_type      = _Value_type;
; 2111 :     using size_type       = _Size_type;
; 2112 :     using difference_type = _Difference_type;
; 2113 :     using pointer         = _Pointer;
; 2114 :     using const_pointer   = _Const_pointer;
; 2115 : };
; 2116 : 
; 2117 : // CLASS TEMPLATE _String_val
; 2118 : template <class _Val_types>
; 2119 : class _String_val : public _Container_base {
; 2120 : public:
; 2121 :     using value_type      = typename _Val_types::value_type;
; 2122 :     using size_type       = typename _Val_types::size_type;
; 2123 :     using difference_type = typename _Val_types::difference_type;
; 2124 :     using pointer         = typename _Val_types::pointer;
; 2125 :     using const_pointer   = typename _Val_types::const_pointer;
; 2126 :     using reference       = value_type&;
; 2127 :     using const_reference = const value_type&;
; 2128 : 
; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}
; 2130 : 
; 2131 :     // length of internal buffer, [1, 16]:
; 2132 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2133 :     // roundup mask for allocated buffers, [0, 15]:
; 2134 :     static constexpr size_type _ALLOC_MASK =
; 2135 :         sizeof(value_type) <= 1
; 2136 :             ? 15
; 2137 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2138 : 
; 2139 :     value_type* _Myptr() noexcept {
; 2140 :         value_type* _Result = _Bx._Buf;
; 2141 :         if (_Large_string_engaged()) {
; 2142 :             _Result = _Unfancy(_Bx._Ptr);
; 2143 :         }
; 2144 : 
; 2145 :         return _Result;
; 2146 :     }
; 2147 : 
; 2148 :     const value_type* _Myptr() const noexcept {
; 2149 :         const value_type* _Result = _Bx._Buf;
; 2150 :         if (_Large_string_engaged()) {
; 2151 :             _Result = _Unfancy(_Bx._Ptr);
; 2152 :         }
; 2153 : 
; 2154 :         return _Result;
; 2155 :     }
; 2156 : 
; 2157 :     bool _Large_string_engaged() const noexcept {
; 2158 :         return _BUF_SIZE <= _Myres;
; 2159 :     }
; 2160 : 
; 2161 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2162 :         if (_Mysize < _Off) {
; 2163 :             _Xran();
; 2164 :         }
; 2165 :     }
; 2166 : 
; 2167 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2168 :         if (_Mysize <= _Off) {
; 2169 :             _Xran();
; 2170 :         }
; 2171 :     }
; 2172 : 
; 2173 :     [[noreturn]] static void _Xran() {
; 2174 :         _Xout_of_range("invalid string position");
; 2175 :     }
; 2176 : 
; 2177 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2178 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2179 :         return _Min_value(_Size, _Mysize - _Off);
; 2180 :     }
; 2181 : 
; 2182 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2183 :         _Bxty() {} // user-provided, for fancy pointers
; 2184 : 
; 2185 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2186 : 
; 2187 :         value_type _Buf[_BUF_SIZE];
; 2188 :         pointer _Ptr;
; 2189 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2190 :     } _Bx;
; 2191 : 
; 2192 :     size_type _Mysize; // current length of string
; 2193 :     size_type _Myres; // current storage reserved for string
; 2194 : };
; 2195 : 
; 2196 : // CLASS TEMPLATE basic_string
; 2197 : template <class _Ty>
; 2198 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2199 : 
; 2200 : struct _String_constructor_concat_tag {
; 2201 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2202 :     explicit _String_constructor_concat_tag() = default;
; 2203 : };
; 2204 : 
; 2205 : [[noreturn]] inline void _Xlen_string() {
; 2206 :     _Xlength_error("string too long");
; 2207 : }
; 2208 : 
; 2209 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2210 : class basic_string { // null-terminated transparent array of elements
; 2211 : private:
; 2212 :     friend _Tidy_deallocate_guard<basic_string>;
; 2213 : 
; 2214 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2215 :     using _Alty_traits = allocator_traits<_Alty>;
; 2216 : 
; 2217 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2218 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2219 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2220 : 
; 2221 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2222 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2223 : 
; 2224 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2225 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2226 :         "char_traits character type match the string's character type.");
; 2227 : 
; 2228 : public:
; 2229 :     using traits_type    = _Traits;
; 2230 :     using allocator_type = _Alloc;
; 2231 : 
; 2232 :     using value_type      = _Elem;
; 2233 :     using size_type       = typename _Alty_traits::size_type;
; 2234 :     using difference_type = typename _Alty_traits::difference_type;
; 2235 :     using pointer         = typename _Alty_traits::pointer;
; 2236 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2237 :     using reference       = value_type&;
; 2238 :     using const_reference = const value_type&;
; 2239 : 
; 2240 :     using iterator       = _String_iterator<_Scary_val>;
; 2241 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2242 : 
; 2243 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2244 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2245 : 
; 2246 : private:
; 2247 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2248 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2249 : 
; 2250 :     // When doing _String_val operations by memcpy, we are touching:
; 2251 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2252 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2253 :     //   _String_val::_Mysize   (type is size_type)
; 2254 :     //   _String_val::_Myres    (type is size_type)
; 2255 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2256 :     // We need to ask if pointer is safe to memcpy.
; 2257 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2258 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2259 :     //   they can observe traits::assign and similar.
; 2260 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2261 :     // This offset skips over the _Container_base members, if any
; 2262 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2263 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2264 : 
; 2265 :     template <class _Iter>
; 2266 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2267 : 
; 2268 : #if _HAS_CXX17
; 2269 :     template <class _StringViewIsh>
; 2270 :     using _Is_string_view_ish =
; 2271 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2272 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2273 :             int>;
; 2274 : #endif // _HAS_CXX17
; 2275 : 
; 2276 : public:
; 2277 :     basic_string(const basic_string& _Right)
; 2278 :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2279 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2280 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2281 :         _Construct_lv_contents(_Right);
; 2282 :         _Proxy._Release();
; 2283 :     }
; 2284 : 
; 2285 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2286 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2287 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2288 :         _Construct_lv_contents(_Right);
; 2289 :         _Proxy._Release();
; 2290 :     }
; 2291 : 
; 2292 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t()) {
; 2293 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2294 :         _Tidy_init();
; 2295 :     }
; 2296 : 
; 2297 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2298 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2299 :         _Tidy_init();
; 2300 :     }
; 2301 : 
; 2302 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2303 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, <end>)
; 2304 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2305 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2306 :         _Tidy_init();
; 2307 :         assign(_Right, _Roff, npos);
; 2308 :         _Proxy._Release();
; 2309 :     }
; 2310 : 
; 2311 :     basic_string(
; 2312 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2313 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2314 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2315 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2316 :         _Tidy_init();
; 2317 :         assign(_Right, _Roff, _Count);
; 2318 :         _Proxy._Release();
; 2319 :     }
; 2320 : 
; 2321 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2322 :         : _Mypair(_Zero_then_variadic_args_t()) {
; 2323 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2324 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2325 :         _Tidy_init();
; 2326 :         assign(_Ptr, _Count);
; 2327 :         _Proxy._Release();
; 2328 :     }
; 2329 : 
; 2330 :     basic_string(
; 2331 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2332 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2333 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2334 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2335 :         _Tidy_init();
; 2336 :         assign(_Ptr, _Count);
; 2337 :         _Proxy._Release();
; 2338 :     }
; 2339 : 
; 2340 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {
; 2341 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2342 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2343 :         _Tidy_init();
; 2344 :         assign(_Ptr);
; 2345 :         _Proxy._Release();
; 2346 :     }
; 2347 : 
; 2348 : #if _HAS_CXX17
; 2349 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2350 : #endif // _HAS_CXX17
; 2351 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Tidy_init();
; 2355 :         assign(_Ptr);
; 2356 :         _Proxy._Release();
; 2357 :     }
; 2358 : 
; 2359 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t()) {
; 2360 :         // construct from _Count * _Ch
; 2361 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2362 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2363 :         _Tidy_init();
; 2364 :         assign(_Count, _Ch);
; 2365 :         _Proxy._Release();
; 2366 :     }
; 2367 : 
; 2368 : #if _HAS_CXX17
; 2369 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2370 : #endif // _HAS_CXX17
; 2371 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2372 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Count * _Ch with allocator
; 2373 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2374 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2375 :         _Tidy_init();
; 2376 :         assign(_Count, _Ch);
; 2377 :         _Proxy._Release();
; 2378 :     }
; 2379 : 
; 2380 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2381 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2382 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2383 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2384 :         _Tidy_init();
; 2385 :         _Adl_verify_range(_First, _Last);
; 2386 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
; 2387 :         _Proxy._Release();
; 2388 :     }
; 2389 : 
; 2390 :     template <class _Iter>
; 2391 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2392 :         // initialize from [_First, _Last), input iterators
; 2393 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2394 :         for (; _First != _Last; ++_First) {
; 2395 :             push_back(*_First);
; 2396 :         }
; 2397 : 
; 2398 :         _Guard._Target = nullptr;
; 2399 :     }
; 2400 : 
; 2401 :     template <class _Iter>
; 2402 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2403 :         // initialize from [_First, _Last), forward iterators
; 2404 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2405 :         reserve(_Count);
; 2406 :         _Construct(_First, _Last, input_iterator_tag());
; 2407 :     }
; 2408 : 
; 2409 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2410 :         // initialize from [_First, _Last), pointers
; 2411 :         if (_First != _Last) {
; 2412 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2413 :         }
; 2414 :     }
; 2415 : 
; 2416 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2417 :         // initialize from [_First, _Last), const pointers
; 2418 :         if (_First != _Last) {
; 2419 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2420 :         }
; 2421 :     }
; 2422 : 
; 2423 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) {
; 2424 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2425 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2426 :     }
; 2427 : 
; 2428 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2429 :         _Alty_traits::is_always_equal::value) // strengthened
; 2430 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2431 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2432 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2433 :         if
; 2434 :             _CONSTEXPR_IF(!_Alty_traits::is_always_equal::value) {
; 2435 :                 if (_Getal() != _Right._Getal()) {
; 2436 :                     _Construct_lv_contents(_Right);
; 2437 :                     _Proxy._Release();
; 2438 :                     return;
; 2439 :                 }
; 2440 :             }
; 2441 : 
; 2442 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2443 :         _Proxy._Release();
; 2444 :     }
; 2445 : 
; 2446 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2447 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2448 :         : _Mypair(
; 2449 :             _One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {
; 2450 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2451 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2452 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2453 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);
; 2454 :         size_type _New_capacity = _BUF_SIZE - 1;
; 2455 :         auto& _My_data          = _Mypair._Myval2;
; 2456 :         _Elem* _Ptr             = _My_data._Bx._Buf;
; 2457 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2458 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2459 :         if (_New_capacity < _New_size) {
; 2460 :             _New_capacity           = _Calculate_growth(_New_size, _BUF_SIZE - 1, max_size());
; 2461 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws
; 2462 :             _Ptr                    = _Unfancy(_Fancyptr);
; 2463 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
; 2464 :         }
; 2465 : 
; 2466 :         _My_data._Mysize = _New_size;
; 2467 :         _My_data._Myres  = _New_capacity;
; 2468 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2469 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
; 2470 :         _Traits::assign(_Ptr[_New_size], _Elem());
; 2471 :         _Proxy._Release();
; 2472 :     }
; 2473 : 
; 2474 :     basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
; 2475 :         : _Mypair(_One_then_variadic_args_t(), _Left._Getal()) {
; 2476 :         auto& _My_data    = _Mypair._Myval2;
; 2477 :         auto& _Left_data  = _Left._Mypair._Myval2;
; 2478 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2479 :         _Left_data._Orphan_all();
; 2480 :         _Right_data._Orphan_all();
; 2481 :         const auto _Left_size  = _Left_data._Mysize;
; 2482 :         const auto _Right_size = _Right_data._Mysize;
; 2483 : 
; 2484 :         const auto _Left_capacity  = _Left_data._Myres;
; 2485 :         const auto _Right_capacity = _Right_data._Myres;
; 2486 :         // overflow is OK due to max_size() checks:
; 2487 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);
; 2488 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
; 2489 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
; 2490 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 2491 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2492 :             _Take_contents(_Left, bool_constant<_Can_memcpy_val>{});
; 2493 :             const auto _Ptr = _My_data._Myptr();
; 2494 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
; 2495 :             _My_data._Mysize = _New_size;
; 2496 :             return;
; 2497 :         }
; 2498 : 
; 2499 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
; 2500 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
; 2501 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 2502 :             // At this point, we have tested:
; 2503 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 2504 :             // therefore: (by De Morgan's Laws)
; 2505 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 2506 :             // therefore: (by the distributive property)
; 2507 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 2508 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 2509 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_string_engaged()
; 2510 :             _STL_INTERNAL_CHECK(_Right_data._Large_string_engaged());
; 2511 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2512 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2513 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
; 2514 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
; 2515 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2516 :             _My_data._Mysize = _New_size;
; 2517 :             return;
; 2518 :         }
; 2519 : 
; 2520 :         // can't use either buffer, reallocate
; 2521 :         const auto _Max = max_size();
; 2522 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK
; 2523 :             _Xlen_string();
; 2524 :         }
; 2525 : 
; 2526 :         const auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);
; 2527 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2528 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2529 :         const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws
; 2530 :         // nothrow hereafter
; 2531 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
; 2532 :         _My_data._Mysize = _New_size;
; 2533 :         _My_data._Myres  = _New_capacity;
; 2534 :         const auto _Ptr  = _Unfancy(_Fancyptr);
; 2535 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2536 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
; 2537 :         _Proxy._Release();
; 2538 :     }
; 2539 : 
; 2540 : #if _HAS_CXX17
; 2541 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2542 :     explicit basic_string(const _StringViewIsh& _Right, const _Alloc& _Al = _Alloc())
; 2543 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2544 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2545 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2546 :         _Tidy_init();
; 2547 :         assign(_Right);
; 2548 :         _Proxy._Release();
; 2549 :     }
; 2550 : 
; 2551 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2552 :     basic_string(
; 2553 :         const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2554 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count) using _Al
; 2555 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2556 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2557 :         _Tidy_init();
; 2558 :         assign(_Right, _Roff, _Count);
; 2559 :         _Proxy._Release();
; 2560 :     }
; 2561 : #endif // _HAS_CXX17
; 2562 : 
; 2563 : private:
; 2564 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {
; 2565 :         _Tidy_deallocate();
; 2566 :         _Pocma(_Getal(), _Right._Getal());
; 2567 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2568 :     }
; 2569 : 
; 2570 :     void _Move_assign(basic_string& _Right, _Propagate_allocators) noexcept {
; 2571 :         if (_Getal() == _Right._Getal()) {
; 2572 :             _Move_assign(_Right, _Equal_allocators{});
; 2573 :         } else {
; 2574 :             // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2575 :             _Mypair._Myval2._Orphan_all();
; 2576 :             _Mypair._Myval2._Reload_proxy(
; 2577 :                 _GET_PROXY_ALLOCATOR(_Alty, _Getal()), _GET_PROXY_ALLOCATOR(_Alty, _Right._Getal()));
; 2578 :             _Pocma(_Getal(), _Right._Getal());
; 2579 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2580 :         }
; 2581 :     }
; 2582 : 
; 2583 :     void _Move_assign(basic_string& _Right, _No_propagate_allocators) {
; 2584 :         if (_Getal() == _Right._Getal()) {
; 2585 :             _Move_assign(_Right, _Equal_allocators{});
; 2586 :         } else {
; 2587 :             assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2588 :         }
; 2589 :     }
; 2590 : 
; 2591 : public:
; 2592 :     basic_string& operator=(basic_string&& _Right) noexcept(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
; 2593 :         if (this != _STD addressof(_Right)) {
; 2594 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});
; 2595 :         }
; 2596 : 
; 2597 :         return *this;
; 2598 :     }
; 2599 : 
; 2600 :     basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = _STD move(_Right))) {
; 2601 :         *this = _STD move(_Right);
; 2602 :         return *this;
; 2603 :     }
; 2604 : 
; 2605 : private:
; 2606 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {
; 2607 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2608 :         const auto _My_data_mem =
; 2609 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2610 :         const auto _Right_data_mem =
; 2611 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
; 2613 :     }
; 2614 : 
; 2615 :     void _Take_contents(basic_string& _Right, true_type) noexcept {
; 2616 :         // assign by stealing _Right's buffer, memcpy optimization
; 2617 :         // pre: this != &_Right
; 2618 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2619 :         // pre: *this owns no memory, iterators orphaned (note:
; 2620 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2621 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2622 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2623 :             // take ownership of _Right's iterators along with its buffer
; 2624 :             _Swap_proxy_and_iterators(_Right);
; 2625 :         } else {
; 2626 :             _Right._Mypair._Myval2._Orphan_all();
; 2627 :         }
; 2628 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2629 : 
; 2630 :         _Memcpy_val_from(_Right);
; 2631 :         _Right._Tidy_init();
; 2632 :     }
; 2633 : 
; 2634 :     void _Take_contents(basic_string& _Right, false_type) noexcept {
; 2635 :         // assign by stealing _Right's buffer, general case
; 2636 :         // pre: this != &_Right
; 2637 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2638 :         // pre: *this owns no memory, iterators orphaned
; 2639 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2640 :         auto& _My_data    = _Mypair._Myval2;
; 2641 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2642 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 2643 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 2644 :             _Right_data._Bx._Ptr = pointer();
; 2645 :             _Swap_proxy_and_iterators(_Right);
; 2646 :         } else { // copy small string buffer
; 2647 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 2648 :             _Right_data._Orphan_all();
; 2649 :         }
; 2650 : 
; 2651 :         _My_data._Mysize = _Right_data._Mysize;
; 2652 :         _My_data._Myres  = _Right_data._Myres;
; 2653 :         _Right._Tidy_init();
; 2654 :     }
; 2655 : 
; 2656 :     void _Construct_lv_contents(const basic_string& _Right) {
; 2657 :         // assign by copying data stored in _Right
; 2658 :         // pre: this != &_Right
; 2659 :         // pre: *this owns no memory, iterators orphaned (note:
; 2660 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2661 :         auto& _Right_data             = _Right._Mypair._Myval2;
; 2662 :         const size_type _Right_size   = _Right_data._Mysize;
; 2663 :         const _Elem* const _Right_ptr = _Right_data._Myptr();
; 2664 :         auto& _My_data                = _Mypair._Myval2;
; 2665 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate
; 2666 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
; 2667 :             _My_data._Mysize = _Right_size;
; 2668 :             _My_data._Myres  = _BUF_SIZE - 1;
; 2669 :             return;
; 2670 :         }
; 2671 : 
; 2672 :         auto& _Al                     = _Getal();
; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());
; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws
; 2675 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);
; 2676 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
; 2677 :         _My_data._Mysize = _Right_size;
; 2678 :         _My_data._Myres  = _New_capacity;
; 2679 :     }
; 2680 : 
; 2681 : public:
; 2682 :     basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
; 2683 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2684 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2685 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2686 :         _Tidy_init();
; 2687 :         assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2688 :         _Proxy._Release();
; 2689 :     }
; 2690 : 
; 2691 :     basic_string& operator=(initializer_list<_Elem> _Ilist) {
; 2692 :         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2693 :     }
; 2694 : 
; 2695 :     basic_string& operator+=(initializer_list<_Elem> _Ilist) {
; 2696 :         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2697 :     }
; 2698 : 
; 2699 :     basic_string& assign(initializer_list<_Elem> _Ilist) {
; 2700 :         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2701 :     }
; 2702 : 
; 2703 :     basic_string& append(initializer_list<_Elem> _Ilist) {
; 2704 :         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2705 :     }
; 2706 : 
; 2707 :     iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) {
; 2708 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2709 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 2710 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2711 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 2712 :         insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2713 :         return begin() + static_cast<difference_type>(_Off);
; 2714 :     }
; 2715 : 
; 2716 :     basic_string& replace(
; 2717 :         const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
; 2718 :         // replace with initializer_list
; 2719 :         _Adl_verify_range(_First, _Last);
; 2720 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2721 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 2722 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2723 :         const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
; 2724 :         const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
; 2725 :         return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2726 :     }
; 2727 : 
; 2728 :     ~basic_string() noexcept {
; 2729 :         _Tidy_deallocate();
; 2730 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2731 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2732 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2733 :         _Mypair._Myval2._Myproxy = nullptr;
; 2734 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2735 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2736 :     }
; 2737 : 
; 2738 :     static constexpr auto npos{static_cast<size_type>(-1)};
; 2739 : 
; 2740 : private:
; 2741 :     void _Copy_assign_val_from_small(const basic_string& _Right) {
; 2742 :         // TRANSITION, VSO-761321; inline into only caller when that's fixed
; 2743 :         _Tidy_deallocate();
; 2744 :         if
; 2745 :             _CONSTEXPR_IF(_Can_memcpy_val) {
; 2746 :                 _Memcpy_val_from(_Right);
; 2747 :             }
; 2748 :         else {
; 2749 :             _Traits::copy(
; 2750 :                 _Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Mysize + 1);
; 2751 :             _Mypair._Myval2._Mysize = _Right._Mypair._Myval2._Mysize;
; 2752 :             _Mypair._Myval2._Myres  = _Right._Mypair._Myval2._Myres;
; 2753 :         }
; 2754 :     }
; 2755 : 
; 2756 :     void _Copy_assign(const basic_string& _Right, false_type) {
; 2757 :         _Pocca(_Getal(), _Right._Getal());
; 2758 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2759 :     }
; 2760 : 
; 2761 :     void _Copy_assign(const basic_string& _Right, true_type) {
; 2762 :         auto& _Al             = _Getal();
; 2763 :         const auto& _Right_al = _Right._Getal();
; 2764 :         if (_Al == _Right_al) {
; 2765 :             _Copy_assign(_Right, false_type{});
; 2766 :             return;
; 2767 :         }
; 2768 : 
; 2769 :         auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2770 :         auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 2771 :         _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 2772 : 
; 2773 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2774 :             const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 2775 :             const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 2776 :             auto _Right_al_non_const = _Right_al;
; 2777 :             const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity); // throws
; 2778 :             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 2779 :             _Tidy_deallocate();
; 2780 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 2781 :             _Mypair._Myval2._Mysize  = _New_size;
; 2782 :             _Mypair._Myval2._Myres   = _New_capacity;
; 2783 :         } else {
; 2784 :             _Copy_assign_val_from_small(_Right);
; 2785 :         }
; 2786 : 
; 2787 :         _Pocca(_Al, _Right_al);
; 2788 :         _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 2789 :     }
; 2790 : 
; 2791 : public:
; 2792 :     basic_string& operator=(const basic_string& _Right) {
; 2793 :         if (this != _STD addressof(_Right)) {
; 2794 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});
; 2795 :         }
; 2796 : 
; 2797 :         return *this;
; 2798 :     }
; 2799 : 
; 2800 : #if _HAS_CXX17
; 2801 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2802 :     basic_string& operator=(const _StringViewIsh& _Right) {
; 2803 :         return assign(_Right);
; 2804 :     }
; 2805 : #endif // _HAS_CXX17
; 2806 : 
; 2807 :     basic_string& operator=(_In_z_ const _Elem* const _Ptr) {
; 2808 :         return assign(_Ptr);
; 2809 :     }
; 2810 : 
; 2811 :     basic_string& operator=(const _Elem _Ch) { // assign {_Ch, _Elem()}
; 2812 :         _Mypair._Myval2._Mysize = 1;
; 2813 :         _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 2814 :         _Traits::assign(_Ptr[0], _Ch);
; 2815 :         _Traits::assign(_Ptr[1], _Elem());
; 2816 :         return *this;
; 2817 :     }
; 2818 : 
; 2819 :     basic_string& operator+=(const basic_string& _Right) {
; 2820 :         return append(_Right);
; 2821 :     }
; 2822 : 
; 2823 : #if _HAS_CXX17
; 2824 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2825 :     basic_string& operator+=(const _StringViewIsh& _Right) {
; 2826 :         return append(_Right);
; 2827 :     }
; 2828 : #endif // _HAS_CXX17
; 2829 : 
; 2830 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
; 2831 :         return append(_Ptr);
; 2832 :     }
; 2833 : 
; 2834 :     basic_string& operator+=(_Elem _Ch) {
; 2835 :         push_back(_Ch);
; 2836 :         return *this;
; 2837 :     }
; 2838 : 
; 2839 :     basic_string& append(const basic_string& _Right) {
; 2840 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2841 :     }
; 2842 : 
; 2843 :     basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 2844 :         // append _Right [_Roff, _Roff + _Count)
; 2845 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 2846 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 2847 :         return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 2848 :     }
; 2849 : 
; 2850 : #if _HAS_CXX17
; 2851 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2852 :     basic_string& append(const _StringViewIsh& _Right) {
; 2853 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2854 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2855 :     }
; 2856 : 
; 2857 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2858 :     basic_string& append(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
; 2859 :         // append _Right [_Roff, _Roff + _Count)
; 2860 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2861 :         return append(_As_view.substr(_Roff, _Count));
; 2862 :     }
; 2863 : #endif // _HAS_CXX17
; 2864 : 
; 2865 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 2866 :         // append [_Ptr, _Ptr + _Count)
; 2867 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 2870 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2871 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
; 2872 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
; 2873 :             return *this;
; 2874 :         }
; 2875 : 
; 2876 :         return _Reallocate_grow_by(
; 2877 :             _Count,
; 2878 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2879 :                 const size_type _Count) {
; 2880 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2881 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00015	03 fe		 add	 edi, esi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00017	8b 75 18	 mov	 esi, DWORD PTR __Count$[ebp]
  0001a	56		 push	 esi
  0001b	ff 75 14	 push	 DWORD PTR __Ptr$[ebp]
  0001e	57		 push	 edi
  0001f	e8 00 00 00 00	 call	 _memcpy
  00024	83 c4 18	 add	 esp, 24			; 00000018H

; 2882 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00027	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi

; 2883 :             },

  0002d	5d		 pop	 ebp
  0002e	c2 14 00	 ret	 20			; 00000014H
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBEXQAD0I0I@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 2615 :     void _Take_contents(basic_string& _Right, true_type) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00009	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0000c	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00011	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00016	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0001d	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00024	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2616 :         // assign by stealing _Right's buffer, memcpy optimization
; 2617 :         // pre: this != &_Right
; 2618 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2619 :         // pre: *this owns no memory, iterators orphaned (note:
; 2620 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2621 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2622 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2623 :             // take ownership of _Right's iterators along with its buffer
; 2624 :             _Swap_proxy_and_iterators(_Right);
; 2625 :         } else {
; 2626 :             _Right._Mypair._Myval2._Orphan_all();
; 2627 :         }
; 2628 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2629 : 
; 2630 :         _Memcpy_val_from(_Right);
; 2631 :         _Right._Tidy_init();
; 2632 :     }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2185 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	c2 00 00	 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2149 :         const value_type* _Result = _Bx._Buf;
; 2150 :         if (_Large_string_engaged()) {

  00004	72 03		 jb	 SHORT $LN6@Myptr

; 2151 :             _Result = _Unfancy(_Bx._Ptr);
; 2152 :         }
; 2153 : 
; 2154 :         return _Result;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2155 :     }

  00008	c3		 ret	 0
$LN6@Myptr:

; 2151 :             _Result = _Unfancy(_Bx._Ptr);
; 2152 :         }
; 2153 : 
; 2154 :         return _Result;

  00009	8b c1		 mov	 eax, ecx

; 2155 :     }

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2140 :         value_type* _Result = _Bx._Buf;
; 2141 :         if (_Large_string_engaged()) {

  00004	72 03		 jb	 SHORT $LN6@Myptr

; 2142 :             _Result = _Unfancy(_Bx._Ptr);
; 2143 :         }
; 2144 : 
; 2145 :         return _Result;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2146 :     }

  00008	c3		 ret	 0
$LN6@Myptr:

; 2142 :             _Result = _Unfancy(_Bx._Ptr);
; 2143 :         }
; 2144 : 
; 2145 :         return _Result;

  00009	8b c1		 mov	 eax, ecx

; 2146 :     }

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 405  :         return static_cast<int_type>(EOF);

  00000	83 c8 ff	 or	 eax, -1

; 406  :     }

  00003	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?not_eof@?$_Narrow_char_traits@DH@std@@SAHABH@Z
_TEXT	SEGMENT
?not_eof@?$_Narrow_char_traits@DH@std@@SAHABH@Z PROC	; std::_Narrow_char_traits<char,int>::not_eof, COMDAT
; __Meta$ = ecx

; 400  :     _NODISCARD static constexpr int_type not_eof(const int_type& _Meta) noexcept {

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 401  :         return _Meta != eof() ? _Meta : !eof();

  00002	33 c9		 xor	 ecx, ecx
  00004	83 f8 ff	 cmp	 eax, -1
  00007	0f 44 c1	 cmove	 eax, ecx

; 402  :     }

  0000a	c3		 ret	 0
?not_eof@?$_Narrow_char_traits@DH@std@@SAHABH@Z ENDP	; std::_Narrow_char_traits<char,int>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 396  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 397  :         return _Left == _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000d	0f 94 c0	 sete	 al

; 398  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHABD@Z PROC ; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT

; 392  :     _NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 393  :         return static_cast<unsigned char>(_Ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 394  :     }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHABD@Z ENDP ; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Narrow_char_traits<char,int>::copy, COMDAT

; 330  :         const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 333  :     }

  00003	5d		 pop	 ebp

; 331  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Narrow_char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT
; __First$ = ecx

; 310  :         // find length of null-terminated string
; 311  : #if _HAS_CXX17
; 312  : #ifdef __cpp_char8_t
; 313  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 314  : #if _HAS_U8_INTRINSICS
; 315  :             return __builtin_u8strlen(_First);
; 316  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 317  :             return _Char_traits<_Elem, _Int_type>::length(_First);
; 318  : #endif // _HAS_U8_INTRINSICS
; 319  :         } else
; 320  : #endif // __cpp_char8_t
; 321  :         {
; 322  :             return __builtin_strlen(_First);

  00000	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL3@length:
  00003	8a 01		 mov	 al, BYTE PTR [ecx]
  00005	41		 inc	 ecx
  00006	84 c0		 test	 al, al
  00008	75 f9		 jne	 SHORT $LL3@length
  0000a	2b ca		 sub	 ecx, edx
  0000c	8b c1		 mov	 eax, ecx

; 323  :         }
; 324  : #else // _HAS_CXX17
; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 326  : #endif // _HAS_CXX17
; 327  :     }

  0000e	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xlocale
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
$T1 = -32						; size = 8
__Nr$4 = -28						; size = 4
__Pn$5 = -24						; size = 4
__Pb$6 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$dead$ = 12					; size = 4
__Prot$dead$ = 16					; size = 4
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 275  :     basic_filebuf* open(const char* _Filename, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f1		 mov	 esi, ecx

; 276  :         // _Prot is an extension
; 277  :         if (_Myfile) {

  0002c	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00030	8b 45 08	 mov	 eax, DWORD PTR __Filename$[ebp]
  00033	0f 85 e0 00 00
	00		 jne	 $LN32@open

; 278  :             return nullptr;
; 279  :         }
; 280  : 
; 281  :         const auto _File = _Fiopen(_Filename, _Mode, _Prot);

  00039	6a 40		 push	 64			; 00000040H
  0003b	6a 02		 push	 2
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z
  00044	8b f8		 mov	 edi, eax
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 282  :         if (!_File) {

  00049	85 ff		 test	 edi, edi
  0004b	0f 84 c8 00 00
	00		 je	 $LN32@open

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

  00051	8b ce		 mov	 ecx, esi
  00053	c6 46 48 01	 mov	 BYTE PTR [esi+72], 1
  00057	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 712  :             ::_get_stream_buffer_pointers(

  00061	8d 45 e4	 lea	 eax, DWORD PTR __Nr$4[ebp]
  00064	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Pb$6[ebp], 0
  0006b	50		 push	 eax
  0006c	8d 45 e8	 lea	 eax, DWORD PTR __Pn$5[ebp]
  0006f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Pn$5[ebp], 0
  00076	50		 push	 eax
  00077	8d 45 ec	 lea	 eax, DWORD PTR __Pb$6[ebp]
  0007a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Nr$4[ebp], 0
  00081	50		 push	 eax
  00082	57		 push	 edi
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___get_stream_buffer_pointers
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 276  :         _IGfirst = _Gf;

  00089	8b 45 ec	 mov	 eax, DWORD PTR __Pb$6[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 712  :             ::_get_stream_buffer_pointers(

  0008c	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 276  :         _IGfirst = _Gf;

  0008f	89 46 0c	 mov	 DWORD PTR [esi+12], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

  00092	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 277  :         _IPfirst = _Pf;

  00094	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 278  :         _IGnext  = _Gn;

  00097	8b 45 e8	 mov	 eax, DWORD PTR __Pn$5[ebp]
  0009a	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 279  :         _IPnext  = _Pn;

  0009d	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 280  :         _IGcount = _Gc;

  000a0	8b 45 e4	 mov	 eax, DWORD PTR __Nr$4[ebp]
  000a3	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 281  :         _IPcount = _Pc;

  000a6	89 46 30	 mov	 DWORD PTR [esi+48], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 720  :         _State  = _Stinit;

  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  000ae	89 46 40	 mov	 DWORD PTR [esi+64], eax
  000b1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000b6	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

  000b9	8d 45 e0	 lea	 eax, DWORD PTR $T1[ebp]
  000bc	50		 push	 eax

; 719  :         _Myfile = _File;

  000bd	89 7e 4c	 mov	 DWORD PTR [esi+76], edi

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

  000c0	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
  000cd	8b c8		 mov	 ecx, eax
  000cf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d6	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  000db	8b f8		 mov	 edi, eax

; 761  :         if (_Newcvt.always_noconv()) {

  000dd	8b cf		 mov	 ecx, edi
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
  000e5	84 c0		 test	 al, al
  000e7	74 09		 je	 SHORT $LN18@open

; 762  :             _Pcvt = nullptr; // nothing to do

  000e9	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 763  :         } else { // set up for nontrivial codecvt facet

  000f0	eb 0b		 jmp	 SHORT $LN19@open
$LN18@open:

; 764  :             _Pcvt = _STD addressof(_Newcvt);
; 765  :             _Mysb::_Init(); // reset any buffering

  000f2	8b ce		 mov	 ecx, esi
  000f4	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
$LN19@open:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xlocale

; 352  :         if (_Ptr) {

  000fd	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp+4]
  00100	85 c9		 test	 ecx, ecx
  00102	74 11		 je	 SHORT $LN30@open

; 353  :             delete _Ptr->_Decref();

  00104	8b 01		 mov	 eax, DWORD PTR [ecx]
  00106	ff 50 08	 call	 DWORD PTR [eax+8]
  00109	85 c0		 test	 eax, eax
  0010b	74 08		 je	 SHORT $LN30@open
  0010d	8b 10		 mov	 edx, DWORD PTR [eax]
  0010f	8b c8		 mov	 ecx, eax
  00111	6a 01		 push	 1
  00113	ff 12		 call	 DWORD PTR [edx]
$LN30@open:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream

; 288  :         return this; // open succeeded

  00115	8b c6		 mov	 eax, esi
  00117	eb 02		 jmp	 SHORT $LN1@open
$LN32@open:

; 283  :             return nullptr; // open failed

  00119	33 c0		 xor	 eax, eax
$LN1@open:

; 289  :     }

  0011b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00125	59		 pop	 ecx
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012b	33 cd		 xor	 ecx, ebp
  0012d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR $T1[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\fstream
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$GSCopy$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 162  :     basic_filebuf() : _Mysb() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	89 75 ec	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  :         _Mysb::_Init(); // initialize stream buffer base object

  0003b	8b ce		 mov	 ecx, esi

; 162  :     basic_filebuf() : _Mysb() {

  0003d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 702  :         _Closef    = _Which == _Openfl;

  00043	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0

; 703  :         _Wrotesome = false;

  00047	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0

; 704  : 
; 705  :         _Mysb::_Init(); // initialize stream buffer base object

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 706  : 
; 707  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 708  :             _Elem** _Pb = nullptr;
; 709  :             _Elem** _Pn = nullptr;
; 710  :             int* _Nr    = nullptr;
; 711  : 
; 712  :             ::_get_stream_buffer_pointers(
; 713  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 714  :             int* _Nw = _Nr;
; 715  : 
; 716  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 717  :         }
; 718  : 
; 719  :         _Myfile = _File;
; 720  :         _State  = _Stinit;

  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 163  :         _Init(nullptr, _Newfl);
; 164  :     }

  00057	8b c6		 mov	 eax, esi

; 720  :         _State  = _Stinit;

  00059	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  0005c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  00062	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  00069	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 721  :         _Pcvt   = nullptr; // pointer to codecvt facet

  0006c	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 163  :         _Init(nullptr, _Newfl);
; 164  :     }

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 37   :     return _Left < _Right ? _Right : _Left;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 02		 cmp	 eax, DWORD PTR [edx]
  00004	0f 42 ca	 cmovb	 ecx, edx
  00007	8b c1		 mov	 eax, ecx

; 38   : }

  00009	c3		 ret	 0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1337 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 3698 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3699 :         const size_type _Storage_max = // can always store small string
; 3700 :             _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3701 :         return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 3702 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3703 :         );
; 3704 :     }

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 2606 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2607 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2608 :         const auto _My_data_mem =
; 2609 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2610 :         const auto _Right_data_mem =
; 2611 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00009	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0000c	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00011	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 2613 :     }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2177 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2178 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2179 :         return _Min_value(_Size, _Mysize - _Off);

  00003	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00006	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Size$[ebp]
  0000c	3b c8		 cmp	 ecx, eax
  0000e	0f 42 c1	 cmovb	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2180 :     }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2161 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2162 :         if (_Mysize < _Off) {

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN6@Check_offs

; 2164 :         }
; 2165 :     }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN6@Check_offs:

; 2163 :             _Xran();

  0000f	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN4@Check_offs:
  00014	cc		 int	 3
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	0f 93 c0	 setae	 al

; 2159 :     }

  00007	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 377  :         _Left = _Right;

  00000	8a 02		 mov	 al, BYTE PTR [edx]
  00002	88 01		 mov	 BYTE PTR [ecx], al

; 378  :     }

  00004	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Narrow_char_traits<char,int>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 365  :         const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 366  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00003	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00006	52		 push	 edx
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memmove
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 368  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Narrow_char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$dead$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 29		 jb	 SHORT $LN4@allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0000d	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

  00010	3b c8		 cmp	 ecx, eax
  00012	76 39		 jbe	 SHORT $LN26@allocate

; 51   :         return ::operator new(_Bytes);

  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001a	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  0001c	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001f	85 c9		 test	 ecx, ecx
  00021	74 0d		 je	 SHORT $LN13@allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00023	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00026	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00029	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
$LN13@allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@allocate:

; 179  :     if (_Bytes != 0) {

  00036	85 c0		 test	 eax, eax
  00038	74 0d		 je	 SHORT $LN5@allocate

; 51   :         return ::operator new(_Bytes);

  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00040	83 c4 04	 add	 esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@allocate:

; 183  :     return nullptr;

  00047	33 c0		 xor	 eax, eax

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN26@allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

  0004d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN24@allocate:
  00052	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00009	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000f	72 12		 jb	 SHORT $LN15@deallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00011	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00014	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	77 10		 ja	 SHORT $LN12@deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00021	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00023	51		 push	 ecx
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8

; 781  :     }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
$LN12@deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  00037	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2174 :         _Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN3@Xran:
  0000b	cc		 int	 3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	83 c8 ff	 or	 eax, -1

; 681  :     }

  00003	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z
_TEXT	SEGMENT
$T6 = -4						; size = 1
___$ReturnUdt$ = -4					; size = 4
__Right$dead$ = 8					; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 4468 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi
  00006	8b fa		 mov	 edi, edx
  00008	8b d9		 mov	 ebx, ecx
  0000a	89 5d fc	 mov	 DWORD PTR ___$ReturnUdt$[ebp], ebx

; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  0000d	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00010	8b c2		 mov	 eax, edx
  00012	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00015	2b c1		 sub	 eax, ecx
  00017	83 f8 19	 cmp	 eax, 25			; 00000019H
  0001a	72 2a		 jb	 SHORT $LN10@operator

; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0001c	8d 41 19	 lea	 eax, DWORD PTR [ecx+25]
  0001f	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2140 :         value_type* _Result = _Bx._Buf;

  00022	8b c7		 mov	 eax, edi

; 2158 :         return _BUF_SIZE <= _Myres;

  00024	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  00027	72 02		 jb	 SHORT $LN13@operator

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  00029	8b 07		 mov	 eax, DWORD PTR [edi]
$LN13@operator:
  0002b	56		 push	 esi

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0002c	6a 19		 push	 25			; 00000019H

; 2871 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0002e	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MOPMIHII@?2Documents?2otc_latest?4txt@
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _memmove
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2872 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0003f	c6 46 19 00	 mov	 BYTE PTR [esi+25], 0
  00043	5e		 pop	 esi

; 2873 :             return *this;

  00044	eb 15		 jmp	 SHORT $LN9@operator
$LN10@operator:

; 2874 :         }
; 2875 : 
; 2876 :         return _Reallocate_grow_by(

  00046	6a 19		 push	 25			; 00000019H
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MOPMIHII@?2Documents?2otc_latest?4txt@
  0004d	ff 75 fc	 push	 DWORD PTR $T6[ebp]
  00050	8b cf		 mov	 ecx, edi
  00052	6a 19		 push	 25			; 00000019H
  00054	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
  00059	8b f8		 mov	 edi, eax
$LN9@operator:

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  0005b	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 4469 :     return _STD move(_Left.append(_Right));

  00062	8b c3		 mov	 eax, ebx

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00064	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0006b	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  0006e	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  00071	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  00076	66 0f d6 43 10	 movq	 QWORD PTR [ebx+16], xmm0

; 4301 :         _Mypair._Myval2._Mysize = 0;

  0007b	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00082	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00089	c6 07 00	 mov	 BYTE PTR [edi], 0

; 4469 :     return _STD move(_Left.append(_Right));

  0008c	5f		 pop	 edi
  0008d	5b		 pop	 ebx

; 4470 : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -44						; size = 8
__Pad$ = -44						; size = 8
__State$ = -36						; size = 4
__Val$1$ = -32						; size = 4
tv699 = -28						; size = 4
__Ostr$ = -24						; size = 4
__Count$2$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 735  :     const char* _Val) { // insert NTBS into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b c2		 mov	 eax, edx
  0002d	89 45 e0	 mov	 DWORD PTR __Val$1$[ebp], eax
  00030	8b d9		 mov	 ebx, ecx
  00032	89 5d e8	 mov	 DWORD PTR __Ostr$[ebp], ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 322  :             return __builtin_strlen(_First);

  00035	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 739  :     ios_base::iostate _State = ios_base::goodbit;

  00037	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 322  :             return __builtin_strlen(_First);

  0003e	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL92@operator:
  00041	8a 01		 mov	 al, BYTE PTR [ecx]
  00043	41		 inc	 ecx
  00044	84 c0		 test	 al, al
  00046	75 f9		 jne	 SHORT $LL92@operator
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 741  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00048	8b 13		 mov	 edx, DWORD PTR [ebx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 322  :             return __builtin_strlen(_First);

  0004a	2b ce		 sub	 ecx, esi
  0004c	89 4d ec	 mov	 DWORD PTR __Count$2$[ebp], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase

; 367  :         return _Wide;

  0004f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00052	03 c3		 add	 eax, ebx
  00054	89 45 e4	 mov	 DWORD PTR tv699[ebp], eax
  00057	8b 78 24	 mov	 edi, DWORD PTR [eax+36]
  0005a	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 741  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  0005d	85 ff		 test	 edi, edi
  0005f	7c 17		 jl	 SHORT $LN17@operator
  00061	7f 0e		 jg	 SHORT $LN94@operator
  00063	85 f6		 test	 esi, esi
  00065	74 11		 je	 SHORT $LN17@operator
  00067	85 ff		 test	 edi, edi
  00069	7c 0d		 jl	 SHORT $LN17@operator
  0006b	7f 04		 jg	 SHORT $LN94@operator
  0006d	3b f1		 cmp	 esi, ecx
  0006f	76 07		 jbe	 SHORT $LN17@operator
$LN94@operator:
  00071	2b f1		 sub	 esi, ecx
  00073	83 df 00	 sbb	 edi, 0
  00076	eb 0e		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00078	0f 57 c0	 xorps	 xmm0, xmm0
  0007b	66 0f 13 45 d4	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  00080	8b 7d d8	 mov	 edi, DWORD PTR __Pad$[ebp+4]
  00083	8b 75 d4	 mov	 esi, DWORD PTR __Pad$[ebp]
$LN18@operator:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios

; 80   :         return _Mystrbuf;

  00086	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00089	8b ca		 mov	 ecx, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  0008b	89 5d d4	 mov	 DWORD PTR __Ok$[ebp], ebx

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();
; 73   :             if (_Rdbuf) {

  0008e	85 c0		 test	 eax, eax
  00090	74 0f		 je	 SHORT $LN39@operator

; 74   :                 _Rdbuf->_Lock();

  00092	8b 4d e4	 mov	 ecx, DWORD PTR tv699[ebp]
  00095	8b 00		 mov	 eax, DWORD PTR [eax]
  00097	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
  0009a	ff 50 04	 call	 DWORD PTR [eax+4]
  0009d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0009f	8b ca		 mov	 ecx, edx
$LN39@operator:

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  000a1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase

; 280  :         return _Mystate;

  000a8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ab	03 c3		 add	 eax, ebx

; 299  :         return rdstate() == ios_base::goodbit;

  000ad	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 93   :             if (!_Ostr.good()) {

  000b1	74 04		 je	 SHORT $LN33@operator

; 94   :                 _Ok = false;

  000b3	32 c0		 xor	 al, al

; 95   :                 return;

  000b5	eb 26		 jmp	 SHORT $LN107@operator
$LN33@operator:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios

; 70   :         return _Tiestr;

  000b7	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  000ba	85 c0		 test	 eax, eax
  000bc	74 1d		 je	 SHORT $LN35@operator
  000be	3b c3		 cmp	 eax, ebx
  000c0	74 19		 je	 SHORT $LN35@operator

; 101  :                 return;
; 102  :             }
; 103  : 
; 104  : 
; 105  :             _Tied->flush();

  000c2	8b c8		 mov	 ecx, eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000ca	8b 13		 mov	 edx, DWORD PTR [ebx]
  000cc	8b ca		 mov	 ecx, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase

; 280  :         return _Mystate;

  000ce	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 299  :         return rdstate() == ios_base::goodbit;

  000d1	83 7c 18 0c 00	 cmp	 DWORD PTR [eax+ebx+12], 0
  000d6	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000d9	eb 02		 jmp	 SHORT $LN107@operator
$LN35@operator:

; 100  :                 _Ok = true;

  000db	b0 01		 mov	 al, 1
$LN107@operator:

; 742  :     const typename _Myos::sentry _Ok(_Ostr);

  000dd	88 45 d8	 mov	 BYTE PTR __Ok$[ebp+4], al
  000e0	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 743  : 
; 744  :     if (!_Ok) {

  000e7	84 c0		 test	 al, al
  000e9	75 0a		 jne	 SHORT $LN8@operator

; 745  :         _State |= ios_base::badbit;

  000eb	ba 04 00 00 00	 mov	 edx, 4

; 746  :     } else { // state okay, insert

  000f0	e9 dd 00 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 747  :         _TRY_IO_BEGIN

  000f5	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase

; 330  :         return _Fmtfl;

  000f9	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000fc	8b 44 18 14	 mov	 eax, DWORD PTR [eax+ebx+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 748  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  00100	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00105	83 f8 40	 cmp	 eax, 64			; 00000040H
  00108	74 38		 je	 SHORT $LN87@operator
  0010a	66 0f 1f 44 00
	00		 npad	 6
$LL4@operator:

; 749  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00110	85 ff		 test	 edi, edi
  00112	7c 2c		 jl	 SHORT $LN89@operator
  00114	7f 04		 jg	 SHORT $LN95@operator
  00116	85 f6		 test	 esi, esi
  00118	74 26		 je	 SHORT $LN89@operator
$LN95@operator:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios

; 80   :         return _Mystrbuf;

  0011a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0011c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011f	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]

; 101  :         return _Fillch;

  00123	8a 44 18 40	 mov	 al, BYTE PTR [eax+ebx+64]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 750  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00127	50		 push	 eax
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0012e	83 f8 ff	 cmp	 eax, -1
  00131	75 05		 jne	 SHORT $LN2@operator

; 751  :                     _State |= ios_base::badbit; // insertion failed, quit

  00133	8d 50 05	 lea	 edx, DWORD PTR [eax+5]

; 752  :                     break;

  00136	eb 5c		 jmp	 SHORT $LN6@operator
$LN2@operator:

; 749  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00138	83 c6 ff	 add	 esi, -1
  0013b	83 d7 ff	 adc	 edi, -1
  0013e	eb d0		 jmp	 SHORT $LL4@operator
$LN89@operator:

; 757  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00140	8b 0b		 mov	 ecx, DWORD PTR [ebx]
$LN87@operator:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios

; 80   :         return _Mystrbuf;

  00142	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 757  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00145	6a 00		 push	 0
  00147	ff 75 ec	 push	 DWORD PTR __Count$2$[ebp]
  0014a	ff 75 e0	 push	 DWORD PTR __Val$1$[ebp]
  0014d	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  00157	3b 45 ec	 cmp	 eax, DWORD PTR __Count$2$[ebp]
  0015a	75 27		 jne	 SHORT $LN96@operator
  0015c	85 d2		 test	 edx, edx
  0015e	75 23		 jne	 SHORT $LN96@operator
$LL98@operator:

; 758  :             _State |= ios_base::badbit;
; 759  :         }
; 760  : 
; 761  :         if (_State == ios_base::goodbit) {
; 762  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00160	85 ff		 test	 edi, edi
  00162	7c 2e		 jl	 SHORT $LN102@operator
  00164	7f 04		 jg	 SHORT $LN97@operator
  00166	85 f6		 test	 esi, esi
  00168	74 28		 je	 SHORT $LN102@operator
$LN97@operator:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios

; 80   :         return _Mystrbuf;

  0016a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016f	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]

; 101  :         return _Fillch;

  00173	8a 44 18 40	 mov	 al, BYTE PTR [eax+ebx+64]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 763  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00177	50		 push	 eax
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0017e	83 f8 ff	 cmp	 eax, -1
  00181	75 07		 jne	 SHORT $LN5@operator
$LN96@operator:

; 764  :                     _State |= ios_base::badbit; // insertion failed, quit
; 765  :                     break;
; 766  :                 }
; 767  :             }
; 768  :         }
; 769  : 
; 770  :         _Ostr.width(0);

  00183	ba 04 00 00 00	 mov	 edx, 4
  00188	eb 0a		 jmp	 SHORT $LN6@operator
$LN5@operator:

; 758  :             _State |= ios_base::badbit;
; 759  :         }
; 760  : 
; 761  :         if (_State == ios_base::goodbit) {
; 762  :             for (; 0 < _Pad; --_Pad) { // pad on right

  0018a	83 c6 ff	 add	 esi, -1
  0018d	83 d7 ff	 adc	 edi, -1
  00190	eb ce		 jmp	 SHORT $LL98@operator
$LN102@operator:

; 764  :                     _State |= ios_base::badbit; // insertion failed, quit
; 765  :                     break;
; 766  :                 }
; 767  :             }
; 768  :         }
; 769  : 
; 770  :         _Ostr.width(0);

  00192	33 d2		 xor	 edx, edx
$LN6@operator:
  00194	8b 03		 mov	 eax, DWORD PTR [ebx]
  00196	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase

; 372  :         _Wide                      = _Newwidth;

  00199	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  001a1	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
  001a9	eb 20		 jmp	 SHORT $LN108@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 771  :         _CATCH_IO_(ios_base, _Ostr)

  001ab	8b 55 e8	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001ae	6a 01		 push	 1
  001b0	6a 04		 push	 4
  001b2	8b 02		 mov	 eax, DWORD PTR [edx]
  001b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001b7	03 ca		 add	 ecx, edx
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001bf	b8 00 00 00 00	 mov	 eax, $LN23@operator
  001c4	c3		 ret	 0
$LN23@operator:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
  001c5	8b 5d e8	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  001c8	8b 55 dc	 mov	 edx, DWORD PTR __State$[ebp]
$LN108@operator:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 772  :     }
; 773  : 
; 774  :     _Ostr.setstate(_State);

  001cb	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
  001d2	8b 03		 mov	 eax, DWORD PTR [ebx]
  001d4	6a 00		 push	 0
  001d6	52		 push	 edx
  001d7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001da	03 cb		 add	 ecx, ebx
  001dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 110  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  001e2	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 111  : #if !_HAS_EXCEPTIONS
; 112  :             const bool _Zero_uncaught_exceptions = true;
; 113  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 114  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909
; 115  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 116  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 117  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 118  : 
; 119  :             if (_Zero_uncaught_exceptions) {

  001ef	8b 75 d4	 mov	 esi, DWORD PTR __Ok$[ebp]
  001f2	85 c0		 test	 eax, eax
  001f4	75 08		 jne	 SHORT $LN72@operator

; 120  :                 this->_Myostr._Osfx();

  001f6	8b ce		 mov	 ecx, esi
  001f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN72@operator:

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  001fe	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios

; 80   :         return _Mystrbuf;

  00202	8b 06		 mov	 eax, DWORD PTR [esi]
  00204	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00207	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 80   :             if (_Rdbuf) {

  0020b	85 c9		 test	 ecx, ecx
  0020d	74 05		 je	 SHORT $LN99@operator

; 81   :                 _Rdbuf->_Unlock();

  0020f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00211	ff 50 08	 call	 DWORD PTR [eax+8]
$LN99@operator:

; 775  :     return _Ostr;
; 776  : }

  00214	8b c3		 mov	 eax, ebx
  00216	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00219	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00220	59		 pop	 ecx
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	5b		 pop	 ebx
  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 981  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 982  :     _Ostr.put(_Ostr.widen('\n'));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  00007	6a 0a		 push	 10			; 0000000aH
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	03 ce		 add	 ecx, esi
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00016	0f b6 c8	 movzx	 ecx, al
  00019	51		 push	 ecx
  0001a	8b ce		 mov	 ecx, esi
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 983  :     _Ostr.flush();

  00022	8b ce		 mov	 ecx, esi
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 984  :     return _Ostr;

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi

; 985  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xlocale
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$8 = -28						; size = 4
__Psave_guard$9 = -24					; size = 4
__Lock$10 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT
; __Loc$ = ecx

; 427  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx

; 428  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  0002d	6a 00		 push	 0
  0002f	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$10[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 429  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave

; 430  : 
; 431  :     const size_t _Id         = _Facet::id;

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
  0004a	89 45 e4	 mov	 DWORD PTR __Psave$8[ebp], eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00053	8b f8		 mov	 edi, eax

; 375  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00055	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00058	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0005b	73 0c		 jae	 SHORT $LN15@use_facet
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	8b 34 b9	 mov	 esi, DWORD PTR [ecx+edi*4]

; 376  :         if (_Facptr || !_Ptr->_Xparent) {

  00063	85 f6		 test	 esi, esi
  00065	75 5c		 jne	 SHORT $LN32@use_facet
  00067	eb 02		 jmp	 SHORT $LN34@use_facet
$LN15@use_facet:

; 375  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00069	33 f6		 xor	 esi, esi
$LN34@use_facet:

; 376  :         if (_Facptr || !_Ptr->_Xparent) {

  0006b	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  0006f	74 11		 je	 SHORT $LN10@use_facet

; 377  :             return _Facptr; // found facet or not transparent
; 378  :         }
; 379  : 
; 380  :         // look in current locale
; 381  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 382  :         if (_Id < _Ptr0->_Facetcount) {

  00077	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0007a	73 0a		 jae	 SHORT $LN35@use_facet

; 383  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  0007c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007f	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN10@use_facet:

; 432  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 433  : 
; 434  :     if (!_Pf) {

  00082	85 f6		 test	 esi, esi
  00084	75 3d		 jne	 SHORT $LN32@use_facet
$LN35@use_facet:

; 435  :         if (_Psave) {

  00086	8b 75 e4	 mov	 esi, DWORD PTR __Psave$8[ebp]
  00089	85 f6		 test	 esi, esi
  0008b	75 36		 jne	 SHORT $LN32@use_facet

; 436  :             _Pf = _Psave; // lazy facet already allocated
; 437  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  0008d	8d 45 e4	 lea	 eax, DWORD PTR __Psave$8[ebp]
  00090	53		 push	 ebx
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00098	83 c4 08	 add	 esp, 8
  0009b	83 f8 ff	 cmp	 eax, -1
  0009e	74 4a		 je	 SHORT $LN40@use_facet

; 440  : #else // _HAS_EXCEPTIONS
; 441  :             _CSTD abort(); // lazy disallowed
; 442  : #endif // _HAS_EXCEPTIONS
; 443  :         } else { // queue up lazy facet for destruction
; 444  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  000a0	8b 75 e4	 mov	 esi, DWORD PTR __Psave$8[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000a3	89 75 e8	 mov	 DWORD PTR __Psave_guard$9[ebp], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xlocale

; 450  :             _Facet_Register(_Pfmod);

  000a6	56		 push	 esi
  000a7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ab	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 451  : #endif // defined(_M_CEE)
; 452  : 
; 453  :             _Pfmod->_Incref();

  000b0	8b 06		 mov	 eax, DWORD PTR [esi]
  000b2	83 c4 04	 add	 esp, 4
  000b5	8b ce		 mov	 ecx, esi
  000b7	ff 50 04	 call	 DWORD PTR [eax+4]

; 454  :             _Facetptr<_Facet>::_Psave = _Psave;

  000ba	8b 75 e4	 mov	 esi, DWORD PTR __Psave$8[ebp]
  000bd	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
$LN32@use_facet:

; 455  :             _Pf                       = _Psave;
; 456  : 
; 457  :             (void) _Psave_guard.release();
; 458  :         }
; 459  :     }
; 460  : 
; 461  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  000c3	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$10[ebp]
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000cc	8b c6		 mov	 eax, esi

; 462  :     _END_LOCK()
; 463  : } // end of use_facet body

  000ce	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d8	59		 pop	 ecx
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	33 cd		 xor	 ecx, ebp
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
$LN40@use_facet:

; 438  : #if _HAS_EXCEPTIONS
; 439  :             _Throw_bad_cast(); // lazy disallowed

  000ea	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast
$LN37@use_facet:
  000ef	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$10[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$1:
  00009	8d 4d e8	 lea	 ecx, DWORD PTR __Psave_guard$9[ebp]
  0000c	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
__ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z:
  00016	90		 npad	 1
  00017	90		 npad	 1
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; __Arg$ = ecx

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1468 : }

  00002	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT
; __Arg$ = ecx

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1468 : }

  00002	c3		 ret	 0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00007	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00010	c2 08 00	 ret	 8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00007	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z PROC ; std::addressof<std::codecvt<char,char,_Mbstatet> const >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z ENDP ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT
; __Obj$dead$ = ecx

; 242  :     _Obj.~_Ty();
; 243  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z
_TEXT	SEGMENT
$T12 = -8						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$dead$ = 8				; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>, COMDAT
; _this$ = ecx

; 4252 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 4253 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4254 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4255 :         auto& _My_data            = _Mypair._Myval2;
; 4256 :         const size_type _Old_size = _My_data._Mysize;
; 4257 :         if (max_size() - _Old_size < _Size_increase) {

  00009	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  0000e	8b c1		 mov	 eax, ecx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00015	2b c2		 sub	 eax, edx
  00017	89 55 fc	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  0001a	83 f8 01	 cmp	 eax, 1
  0001d	0f 82 0c 01 00
	00		 jb	 $LN65@Reallocate

; 4259 :         }
; 4260 : 
; 4261 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4262 :         const size_type _Old_capacity = _My_data._Myres;

  00023	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]
  00026	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00029	83 cf 0f	 or	 edi, 15			; 0000000fH

; 4259 :         }
; 4260 : 
; 4261 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4262 :         const size_type _Old_capacity = _My_data._Myres;

  0002c	89 75 f8	 mov	 DWORD PTR $T12[ebp], esi

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0002f	3b f9		 cmp	 edi, ecx

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00031	76 04		 jbe	 SHORT $LN9@Reallocate

; 4211 :             return _Max;

  00033	8b f9		 mov	 edi, ecx
  00035	eb 18		 jmp	 SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00037	8b c6		 mov	 eax, esi
  00039	d1 e8		 shr	 eax, 1
  0003b	2b c8		 sub	 ecx, eax
  0003d	3b f1		 cmp	 esi, ecx
  0003f	76 07		 jbe	 SHORT $LN10@Reallocate

; 4215 :             return _Max;

  00041	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  00046	eb 07		 jmp	 SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4216 :         }
; 4217 : 
; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  00048	03 c6		 add	 eax, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  0004a	3b f8		 cmp	 edi, eax
  0004c	0f 42 f8	 cmovb	 edi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4265 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004f	33 c9		 xor	 ecx, ecx
  00051	8b c7		 mov	 eax, edi
  00053	83 c0 01	 add	 eax, 1
  00056	0f 92 c1	 setb	 cl
  00059	f7 d9		 neg	 ecx
  0005b	0b c8		 or	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0005d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00063	72 2a		 jb	 SHORT $LN17@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  00065	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 90   :     if (_Block_size <= _Bytes) {

  00068	3b c1		 cmp	 eax, ecx
  0006a	0f 86 c4 00 00
	00		 jbe	 $LN66@Reallocate

; 51   :         return ::operator new(_Bytes);

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00076	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00079	85 c0		 test	 eax, eax
  0007b	0f 84 83 00 00
	00		 je	 $LN53@Reallocate

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00081	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00084	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00087	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0008a	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0008d	eb 16		 jmp	 SHORT $LN16@Reallocate
$LN17@Reallocate:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

  0008f	85 c9		 test	 ecx, ecx
  00091	74 10		 je	 SHORT $LN18@Reallocate

; 51   :         return ::operator new(_Bytes);

  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 180  :         return _Traits::_Allocate(_Bytes);

  00099	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 51   :         return ::operator new(_Bytes);

  0009c	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  0009f	8b f0		 mov	 esi, eax
  000a1	eb 02		 jmp	 SHORT $LN16@Reallocate
$LN18@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  000a3	33 f6		 xor	 esi, esi
$LN16@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4270 :         if (_BUF_SIZE <= _Old_capacity) {

  000a5	83 7d f8 10	 cmp	 DWORD PTR $T12[ebp], 16	; 00000010H
  000a9	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  000ac	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000af	89 7b 14	 mov	 DWORD PTR [ebx+20], edi
  000b2	52		 push	 edx
  000b3	72 55		 jb	 SHORT $LN3@Reallocate

; 4271 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000b5	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000b7	57		 push	 edi
  000b8	56		 push	 esi
  000b9	e8 00 00 00 00	 call	 _memcpy

; 3629 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  000be	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4272 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4273 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000c4	8b 4d f8	 mov	 ecx, DWORD PTR $T12[ebp]

; 3629 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  000c7	8a 45 10	 mov	 al, BYTE PTR _<_Args_0>$[ebp]

; 4272 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4273 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ca	41		 inc	 ecx

; 3629 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  000cb	88 04 16	 mov	 BYTE PTR [esi+edx], al

; 3630 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  000ce	c6 44 16 01 00	 mov	 BYTE PTR [esi+edx+1], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000d3	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000d9	72 12		 jb	 SHORT $LN56@Reallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000db	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  000de	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000e1	2b fa		 sub	 edi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000e3	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  000e6	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000e9	77 19		 ja	 SHORT $LN53@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000eb	8b fa		 mov	 edi, edx
$LN56@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  000ed	51		 push	 ecx
  000ee	57		 push	 edi
  000ef	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000f4	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4280 :         return *this;

  000f7	89 33		 mov	 DWORD PTR [ebx], esi
  000f9	8b c3		 mov	 eax, ebx
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 4281 :     }

  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 0c 00	 ret	 12			; 0000000cH
$LN53@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0010a	53		 push	 ebx
  0010b	56		 push	 esi
  0010c	e8 00 00 00 00	 call	 _memcpy

; 3629 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  00111	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00114	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3629 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  00117	8a 4d 10	 mov	 cl, BYTE PTR _<_Args_0>$[ebp]

; 4280 :         return *this;

  0011a	8b c3		 mov	 eax, ebx

; 3629 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0011c	88 0c 16	 mov	 BYTE PTR [esi+edx], cl

; 3630 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  0011f	c6 44 16 01 00	 mov	 BYTE PTR [esi+edx+1], 0

; 4280 :         return *this;

  00124	5f		 pop	 edi
  00125	89 33		 mov	 DWORD PTR [ebx], esi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx

; 4281 :     }

  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c2 0c 00	 ret	 12			; 0000000cH
$LN65@Reallocate:

; 4258 :             _Xlen_string(); // result too long

  0012f	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN66@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00134	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN63@Reallocate:
  00139	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z
_TEXT	SEGMENT
$T11 = -8						; size = 4
_<_Args_0>$GSCopy$1$ = -4				; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>, COMDAT
; _this$ = ecx

; 4226 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00009	53		 push	 ebx
  0000a	89 45 fc	 mov	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp], eax
  0000d	8b d9		 mov	 ebx, ecx

; 4227 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4228 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4229 :         if (_New_size > max_size()) {

  0000f	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00012	57		 push	 edi
  00013	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00018	0f 87 e4 00 00
	00		 ja	 $LN61@Reallocate

; 4231 :         }
; 4232 : 
; 4233 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001e	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00021	56		 push	 esi

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00022	8b f0		 mov	 esi, eax

; 4231 :         }
; 4232 : 
; 4233 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  00024	89 4d f8	 mov	 DWORD PTR $T11[ebp], ecx

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00027	83 ce 0f	 or	 esi, 15			; 0000000fH
  0002a	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00030	76 07		 jbe	 SHORT $LN9@Reallocate

; 4211 :             return _Max;

  00032	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00037	eb 1e		 jmp	 SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00039	8b d1		 mov	 edx, ecx
  0003b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00040	d1 ea		 shr	 edx, 1
  00042	2b c2		 sub	 eax, edx
  00044	3b c8		 cmp	 ecx, eax
  00046	76 07		 jbe	 SHORT $LN10@Reallocate

; 4215 :             return _Max;

  00048	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0004d	eb 08		 jmp	 SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4216 :         }
; 4217 : 
; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  0004f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  00052	3b f0		 cmp	 esi, eax
  00054	0f 42 f0	 cmovb	 esi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4236 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00057	33 c9		 xor	 ecx, ecx
  00059	8b c6		 mov	 eax, esi
  0005b	83 c0 01	 add	 eax, 1
  0005e	0f 92 c1	 setb	 cl
  00061	f7 d9		 neg	 ecx
  00063	0b c8		 or	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00065	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0006b	72 23		 jb	 SHORT $LN17@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0006d	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 90   :     if (_Block_size <= _Bytes) {

  00070	3b c1		 cmp	 eax, ecx
  00072	0f 86 8f 00 00
	00		 jbe	 $LN62@Reallocate

; 51   :         return ::operator new(_Bytes);

  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007e	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00081	85 c0		 test	 eax, eax
  00083	74 77		 je	 SHORT $LN53@Reallocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00085	8d 78 23	 lea	 edi, DWORD PTR [eax+35]
  00088	83 e7 e0	 and	 edi, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0008b	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0008e	eb 13		 jmp	 SHORT $LN16@Reallocate
$LN17@Reallocate:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

  00090	85 c9		 test	 ecx, ecx
  00092	74 0d		 je	 SHORT $LN18@Reallocate

; 51   :         return ::operator new(_Bytes);

  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009a	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  0009d	8b f8		 mov	 edi, eax
  0009f	eb 02		 jmp	 SHORT $LN16@Reallocate
$LN18@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  000a1	33 ff		 xor	 edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4238 :         _Mypair._Myval2._Mysize = _New_size;

  000a3	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000a6	50		 push	 eax
  000a7	ff 75 fc	 push	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp]

; 4238 :         _Mypair._Myval2._Mysize = _New_size;

  000aa	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000ad	57		 push	 edi

; 4239 :         _Mypair._Myval2._Myres  = _New_capacity;

  000ae	89 73 14	 mov	 DWORD PTR [ebx+20], esi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000b1	e8 00 00 00 00	 call	 _memcpy

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000b6	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4240 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4241 :         if (_BUF_SIZE <= _Old_capacity) {

  000bc	8b 4d f8	 mov	 ecx, DWORD PTR $T11[ebp]

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000bf	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0

; 4240 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4241 :         if (_BUF_SIZE <= _Old_capacity) {

  000c3	5e		 pop	 esi
  000c4	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000c7	72 27		 jb	 SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c9	8b 03		 mov	 eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4242 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000cb	41		 inc	 ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000cc	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000d2	72 12		 jb	 SHORT $LN56@Reallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000d4	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000d7	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000da	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000dc	83 c0 fc	 add	 eax, -4			; fffffffcH
  000df	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000e2	77 18		 ja	 SHORT $LN53@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000e4	8b c2		 mov	 eax, edx
$LN56@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  000e6	51		 push	 ecx
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ed	83 c4 08	 add	 esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4248 :         return *this;

  000f0	89 3b		 mov	 DWORD PTR [ebx], edi
  000f2	8b c3		 mov	 eax, ebx
  000f4	5f		 pop	 edi
  000f5	5b		 pop	 ebx

; 4249 :     }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
$LN53@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN61@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4230 :             _Xlen_string(); // result too long

  00102	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN62@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00107	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN59@Reallocate:
  0010c	cc		 int	 3
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z
_TEXT	SEGMENT
_<_Args_0>$GSCopy$1$ = -16				; size = 4
$T12 = -12						; size = 4
__Old_size$1$ = -8					; size = 4
tv468 = -4						; size = 4
__New_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4252 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	89 45 f0	 mov	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp], eax

; 4253 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4254 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4255 :         auto& _My_data            = _Mypair._Myval2;
; 4256 :         const size_type _Old_size = _My_data._Mysize;
; 4257 :         if (max_size() - _Old_size < _Size_increase) {

  0000f	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00014	8b c1		 mov	 eax, ecx
  00016	56		 push	 esi
  00017	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  0001a	2b c2		 sub	 eax, edx
  0001c	8b 75 08	 mov	 esi, DWORD PTR __Size_increase$[ebp]
  0001f	89 55 f8	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  00022	57		 push	 edi
  00023	3b c6		 cmp	 eax, esi
  00025	0f 82 29 01 00
	00		 jb	 $LN69@Reallocate

; 4262 :         const size_type _Old_capacity = _My_data._Myres;

  0002b	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
  0002e	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00031	8b f0		 mov	 esi, eax

; 4259 :         }
; 4260 : 
; 4261 :         const size_type _New_size     = _Old_size + _Size_increase;

  00033	89 45 fc	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00036	83 ce 0f	 or	 esi, 15			; 0000000fH

; 4262 :         const size_type _Old_capacity = _My_data._Myres;

  00039	89 7d f4	 mov	 DWORD PTR $T12[ebp], edi

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0003c	3b f1		 cmp	 esi, ecx

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0003e	76 04		 jbe	 SHORT $LN9@Reallocate

; 4211 :             return _Max;

  00040	8b f1		 mov	 esi, ecx
  00042	eb 18		 jmp	 SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00044	8b c7		 mov	 eax, edi
  00046	d1 e8		 shr	 eax, 1
  00048	2b c8		 sub	 ecx, eax
  0004a	3b f9		 cmp	 edi, ecx
  0004c	76 07		 jbe	 SHORT $LN10@Reallocate

; 4215 :             return _Max;

  0004e	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00053	eb 07		 jmp	 SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4216 :         }
; 4217 : 
; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  00055	03 c7		 add	 eax, edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  00057	3b f0		 cmp	 esi, eax
  00059	0f 42 f0	 cmovb	 esi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4265 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0005c	33 c9		 xor	 ecx, ecx
  0005e	8b c6		 mov	 eax, esi
  00060	83 c0 01	 add	 eax, 1
  00063	0f 92 c1	 setb	 cl
  00066	f7 d9		 neg	 ecx
  00068	0b c8		 or	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0006a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00070	72 2a		 jb	 SHORT $LN17@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  00072	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 90   :     if (_Block_size <= _Bytes) {

  00075	3b c1		 cmp	 eax, ecx
  00077	0f 86 dc 00 00
	00		 jbe	 $LN70@Reallocate

; 51   :         return ::operator new(_Bytes);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00083	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00086	85 c0		 test	 eax, eax
  00088	0f 84 97 00 00
	00		 je	 $LN55@Reallocate

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0008e	8b 55 f8	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00091	8d 78 23	 lea	 edi, DWORD PTR [eax+35]
  00094	83 e7 e0	 and	 edi, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00097	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0009a	eb 16		 jmp	 SHORT $LN16@Reallocate
$LN17@Reallocate:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

  0009c	85 c9		 test	 ecx, ecx
  0009e	74 10		 je	 SHORT $LN18@Reallocate

; 51   :         return ::operator new(_Bytes);

  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 180  :         return _Traits::_Allocate(_Bytes);

  000a6	8b 55 f8	 mov	 edx, DWORD PTR __Old_size$1$[ebp]

; 51   :         return ::operator new(_Bytes);

  000a9	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  000ac	8b f8		 mov	 edi, eax
  000ae	eb 02		 jmp	 SHORT $LN16@Reallocate
$LN18@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  000b0	33 ff		 xor	 edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4267 :         _My_data._Mysize      = _New_size;

  000b2	8b 45 fc	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  000b5	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 4268 :         _My_data._Myres       = _New_capacity;
; 4269 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000b8	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  000bb	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000be	8d 34 17	 lea	 esi, DWORD PTR [edi+edx]
  000c1	03 c6		 add	 eax, esi

; 4270 :         if (_BUF_SIZE <= _Old_capacity) {

  000c3	83 7d f4 10	 cmp	 DWORD PTR $T12[ebp], 16	; 00000010H
  000c7	89 45 fc	 mov	 DWORD PTR tv468[ebp], eax
  000ca	52		 push	 edx
  000cb	72 5e		 jb	 SHORT $LN3@Reallocate

; 4271 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000cd	8b 33		 mov	 esi, DWORD PTR [ebx]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000cf	56		 push	 esi
  000d0	57		 push	 edi
  000d1	e8 00 00 00 00	 call	 _memcpy
  000d6	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000d9	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$1$[ebp]
  000dc	ff 75 f0	 push	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp]
  000df	03 c7		 add	 eax, edi
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _memcpy

; 2882 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000e7	8b 45 fc	 mov	 eax, DWORD PTR tv468[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000ea	83 c4 18	 add	 esp, 24			; 00000018H

; 4272 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4273 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ed	8b 4d f4	 mov	 ecx, DWORD PTR $T12[ebp]
  000f0	41		 inc	 ecx

; 2882 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000f1	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000f4	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000fa	72 12		 jb	 SHORT $LN58@Reallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000fc	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000ff	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00102	2b f2		 sub	 esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00104	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00107	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0010a	77 19		 ja	 SHORT $LN55@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0010c	8b f2		 mov	 esi, edx
$LN58@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0010e	51		 push	 ecx
  0010f	56		 push	 esi
  00110	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00115	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4280 :         return *this;

  00118	89 3b		 mov	 DWORD PTR [ebx], edi
  0011a	8b c3		 mov	 eax, ebx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx

; 4281 :     }

  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c2 10 00	 ret	 16			; 00000010H
$LN55@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  0012b	53		 push	 ebx
  0012c	57		 push	 edi
  0012d	e8 00 00 00 00	 call	 _memcpy
  00132	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00135	ff 75 f0	 push	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp]
  00138	56		 push	 esi
  00139	e8 00 00 00 00	 call	 _memcpy

; 2882 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0013e	8b 45 fc	 mov	 eax, DWORD PTR tv468[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00141	83 c4 18	 add	 esp, 24			; 00000018H

; 2882 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00144	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4280 :         return *this;

  00147	8b c3		 mov	 eax, ebx
  00149	89 3b		 mov	 DWORD PTR [ebx], edi
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi
  0014d	5b		 pop	 ebx

; 4281 :     }

  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c2 10 00	 ret	 16			; 00000010H
$LN69@Reallocate:

; 4258 :             _Xlen_string(); // result too long

  00154	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN70@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00159	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Reallocate:
  0015e	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

  00004	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT
; __Ptr$ = ecx

; 289  :     return _Ptr;

  00000	8b c1		 mov	 eax, ecx

; 290  : }

  00002	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT
; __Count$ = ecx

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {
; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  00000	8b c1		 mov	 eax, ecx

; 40   : }

  00002	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	c2 04 00	 ret	 4
?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 126  :             return _Ok;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 127  :         }

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 110  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 111  : #if !_HAS_EXCEPTIONS
; 112  :             const bool _Zero_uncaught_exceptions = true;
; 113  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 114  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909
; 115  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 116  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 117  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 118  : 
; 119  :             if (_Zero_uncaught_exceptions) {

  0002b	85 c0		 test	 eax, eax
  0002d	75 08		 jne	 SHORT $LN2@sentry

; 120  :                 this->_Myostr._Osfx();

  0002f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  0003e	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios

; 80   :         return _Mystrbuf;

  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 80   :             if (_Rdbuf) {

  00049	85 c9		 test	 ecx, ecx
  0004b	74 05		 je	 SHORT $LN5@sentry

; 81   :                 _Rdbuf->_Unlock();

  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@sentry:

; 121  :             }
; 122  :         }

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
  00066	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	8b 7d 08	 mov	 edi, DWORD PTR __Ostr$[ebp]

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  0002d	89 3e		 mov	 DWORD PTR [esi], edi

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

  0002f	8b 17		 mov	 edx, DWORD PTR [edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios

; 80   :         return _Mystrbuf;

  00031	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00034	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 73   :             if (_Rdbuf) {

  00038	85 c9		 test	 ecx, ecx
  0003a	74 07		 je	 SHORT $LN8@sentry

; 74   :                 _Rdbuf->_Lock();

  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
  00041	8b 17		 mov	 edx, DWORD PTR [edi]
$LN8@sentry:

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase

; 280  :         return _Mystate;

  0004a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 299  :         return rdstate() == ios_base::goodbit;

  0004d	83 7c 38 0c 00	 cmp	 DWORD PTR [eax+edi+12], 0

; 280  :         return _Mystate;

  00052	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 93   :             if (!_Ostr.good()) {

  00055	74 04		 je	 SHORT $LN2@sentry

; 94   :                 _Ok = false;

  00057	32 c0		 xor	 al, al

; 95   :                 return;

  00059	eb 22		 jmp	 SHORT $LN23@sentry
$LN2@sentry:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios

; 70   :         return _Tiestr;

  0005b	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  0005e	85 c9		 test	 ecx, ecx
  00060	74 19		 je	 SHORT $LN4@sentry
  00062	3b cf		 cmp	 ecx, edi
  00064	74 15		 je	 SHORT $LN4@sentry

; 101  :                 return;
; 102  :             }
; 103  : 
; 104  : 
; 105  :             _Tied->flush();

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xiosbase

; 299  :         return rdstate() == ios_base::goodbit;

  0006c	8b 07		 mov	 eax, DWORD PTR [edi]
  0006e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00071	83 7c 38 0c 00	 cmp	 DWORD PTR [eax+edi+12], 0
  00076	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

  00079	eb 02		 jmp	 SHORT $LN23@sentry
$LN4@sentry:

; 100  :                 _Ok = true;

  0007b	b0 01		 mov	 al, 1
$LN23@sentry:

; 107  :         }

  0007d	88 46 04	 mov	 BYTE PTR [esi+4], al
  00080	8b c6		 mov	 eax, esi
  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\memory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\memory

; 1907 :     }

  00008	c3		 ret	 0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 1876 :         if (_Mypair._Myval2) {

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 06		 je	 SHORT $LN6@unique_ptr

; 1762 :         delete _Ptr;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	6a 01		 push	 1
  0000a	ff 10		 call	 DWORD PTR [eax]
$LN6@unique_ptr:

; 1877 :             _Mypair._Get_first()(_Mypair._Myval2);
; 1878 :         }
; 1879 :     }

  0000c	c3		 ret	 0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4221 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00006	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0000b	83 ca 0f	 or	 edx, 15			; 0000000fH

; 4221 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  0000e	56		 push	 esi

; 4222 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0000f	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00012	3b d0		 cmp	 edx, eax

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00014	77 1d		 ja	 SHORT $LN3@Calculate_

; 4211 :             return _Max;
; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00016	8b ce		 mov	 ecx, esi
  00018	d1 e9		 shr	 ecx, 1
  0001a	2b c1		 sub	 eax, ecx
  0001c	3b f0		 cmp	 esi, eax
  0001e	76 0a		 jbe	 SHORT $LN5@Calculate_

; 4222 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00020	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00025	5e		 pop	 esi

; 4223 :     }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN5@Calculate_:

; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  0002a	03 ce		 add	 ecx, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  0002c	3b d1		 cmp	 edx, ecx
  0002e	0f 42 d1	 cmovb	 edx, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4222 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00031	8b c2		 mov	 eax, edx
$LN3@Calculate_:
  00033	5e		 pop	 esi

; 4223 :     }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios

; 80   :         return _Mystrbuf;

  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 80   :             if (_Rdbuf) {

  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 82   :             }
; 83   :         }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ios

; 80   :         return _Mystrbuf;

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\ostream

; 73   :             if (_Rdbuf) {

  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN6@Sentry_bas

; 74   :                 _Rdbuf->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN6@Sentry_bas:

; 75   :             }
; 76   :         }

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1337 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT
; _this$dead$ = ecx

; 1760 :     void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1761 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1762 :         delete _Ptr;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0c		 je	 SHORT $LN3@operator
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	c7 45 08 01 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 1

; 1763 :     }

  00013	5d		 pop	 ebp

; 1761 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1762 :         delete _Ptr;

  00014	ff 20		 jmp	 DWORD PTR [eax]
$LN3@operator:

; 1763 :     }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
__Max$ = 8						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; __Requested$ = ecx
; __Old$ = edx

; 4208 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Max$[ebp]
  00008	83 c9 0f	 or	 ecx, 15			; 0000000fH
  0000b	3b cf		 cmp	 ecx, edi

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000d	77 1a		 ja	 SHORT $LN7@Calculate_

; 4211 :             return _Max;
; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0000f	8b f2		 mov	 esi, edx
  00011	8b c7		 mov	 eax, edi
  00013	d1 ee		 shr	 esi, 1
  00015	2b c6		 sub	 eax, esi
  00017	3b d0		 cmp	 edx, eax
  00019	77 0e		 ja	 SHORT $LN7@Calculate_

; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  0001b	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  0001e	3b c8		 cmp	 ecx, eax
  00020	5f		 pop	 edi
  00021	0f 42 c8	 cmovb	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  00024	8b c1		 mov	 eax, ecx

; 4219 :     }

  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN7@Calculate_:

; 4215 :             return _Max;

  00029	8b c7		 mov	 eax, edi
  0002b	5f		 pop	 edi

; 4219 :     }

  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2183 :         _Bxty() {} // user-provided, for fancy pointers

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\memory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; _this$ = ecx

; 1815 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\memory

; 1815 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr) {}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$exchange@PAV_Facet_base@std@@PAV12@@std@@YAPAV_Facet_base@0@AAPAV10@$$QAPAV10@@Z
_TEXT	SEGMENT
??$exchange@PAV_Facet_base@std@@PAV12@@std@@YAPAV_Facet_base@0@AAPAV10@$$QAPAV10@@Z PROC ; std::exchange<std::_Facet_base *,std::_Facet_base *>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 572  :     // assign _New_val to _Val, return previous _Val
; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	8b 12		 mov	 edx, DWORD PTR [edx]
  00004	89 11		 mov	 DWORD PTR [ecx], edx

; 575  :     return _Old_val;
; 576  : }

  00006	c3		 ret	 0
??$exchange@PAV_Facet_base@std@@PAV12@@std@@YAPAV_Facet_base@0@AAPAV10@$$QAPAV10@@Z ENDP ; std::exchange<std::_Facet_base *,std::_Facet_base *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT
; _this$ = ecx

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _<_Val2_0>$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b c1		 mov	 eax, ecx
  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z
_TEXT	SEGMENT
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
END
