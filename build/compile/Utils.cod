; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	c:\users\neonik\desktop\csgo cheat sources\otc-source\otc\cpp\utils\utils.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@	; `string'
PUBLIC	??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP@				; `string'
PUBLIC	??_C@_0M@CPNHGEPL@Signature?3?5@		; `string'
PUBLIC	??_C@_0BJ@CGAJGCJE@Can?8t?5unpack?5signature?4?5@ ; `string'
PUBLIC	??_C@_1IK@NJBBFKEK@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@ ; `string'
PUBLIC	??_C@_1JO@BMHPCMGB@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@ ; `string'
PUBLIC	??_C@_1JO@IOMHEKPF@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@ ; `string'
PUBLIC	??_C@_1JO@NONGKCIC@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@ ; `string'
PUBLIC	??_C@_1NA@MEIAJFDE@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_1NA@PBKLKMMF@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_1NA@CKCHEBNC@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@ ; `string'
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__strtol:PROC
EXTRN	__imp__K32GetModuleInformation@16:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetVersionExW@4:PROC
EXTRN	__imp_?_Xinvalid_argument@std@@YAXPBD@Z:PROC
EXTRN	__imp__RegOpenKeyExW@20:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
;	COMDAT ??_C@_1NA@CKCHEBNC@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@
CONST	SEGMENT
??_C@_1NA@CKCHEBNC@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@ DB 'I'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'e', 00H, 'r', 00H, '\', 00H, 'D', 00H, 'e', 00H, 'p', 00H, 'e'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'i', 00H
	DB	'e', 00H, 's', 00H, '\', 00H, 'V', 00H, 'C', 00H, ',', 00H, 'r'
	DB	00H, 'e', 00H, 'd', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H
	DB	'x', 00H, '8', 00H, '6', 00H, ',', 00H, 'x', 00H, '8', 00H, '6'
	DB	00H, ',', 00H, '1', 00H, '4', 00H, '.', 00H, '2', 00H, '2', 00H
	DB	',', 00H, 'b', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'e'
	DB	00H, '\', 00H, 'D', 00H, 'e', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'd', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, '{'
	DB	00H, '5', 00H, 'b', 00H, 'f', 00H, 'c', 00H, '1', 00H, '3', 00H
	DB	'8', 00H, '0', 00H, '-', 00H, 'f', 00H, 'd', 00H, '3', 00H, '5'
	DB	00H, '-', 00H, '4', 00H, 'b', 00H, '8', 00H, '5', 00H, '-', 00H
	DB	'9', 00H, '7', 00H, '1', 00H, '5', 00H, '-', 00H, '7', 00H, '3'
	DB	00H, '5', 00H, '1', 00H, '5', 00H, '3', 00H, '5', 00H, 'd', 00H
	DB	'0', 00H, '7', 00H, '7', 00H, 'e', 00H, '}', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NA@PBKLKMMF@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@
CONST	SEGMENT
??_C@_1NA@PBKLKMMF@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@ DB 'I'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'e', 00H, 'r', 00H, '\', 00H, 'D', 00H, 'e', 00H, 'p', 00H, 'e'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'i', 00H
	DB	'e', 00H, 's', 00H, '\', 00H, 'V', 00H, 'C', 00H, ',', 00H, 'r'
	DB	00H, 'e', 00H, 'd', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H
	DB	'x', 00H, '8', 00H, '6', 00H, ',', 00H, 'x', 00H, '8', 00H, '6'
	DB	00H, ',', 00H, '1', 00H, '4', 00H, '.', 00H, '2', 00H, '1', 00H
	DB	',', 00H, 'b', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'e'
	DB	00H, '\', 00H, 'D', 00H, 'e', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'd', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, '{'
	DB	00H, '4', 00H, '9', 00H, '6', 00H, '9', 00H, '7', 00H, '8', 00H
	DB	'6', 00H, '9', 00H, '-', 00H, 'b', 00H, 'e', 00H, '8', 00H, 'e'
	DB	00H, '-', 00H, '4', 00H, '2', 00H, '7', 00H, 'd', 00H, '-', 00H
	DB	'8', 00H, '1', 00H, 'a', 00H, '0', 00H, '-', 00H, 'c', 00H, '3'
	DB	00H, '3', 00H, '4', 00H, 'd', 00H, '1', 00H, 'd', 00H, '1', 00H
	DB	'4', 00H, '9', 00H, '5', 00H, '0', 00H, '}', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NA@MEIAJFDE@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@
CONST	SEGMENT
??_C@_1NA@MEIAJFDE@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@ DB 'I'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'e', 00H, 'r', 00H, '\', 00H, 'D', 00H, 'e', 00H, 'p', 00H, 'e'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'i', 00H
	DB	'e', 00H, 's', 00H, '\', 00H, 'V', 00H, 'C', 00H, ',', 00H, 'r'
	DB	00H, 'e', 00H, 'd', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H
	DB	'x', 00H, '8', 00H, '6', 00H, ',', 00H, 'x', 00H, '8', 00H, '6'
	DB	00H, ',', 00H, '1', 00H, '4', 00H, '.', 00H, '1', 00H, '6', 00H
	DB	',', 00H, 'b', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'e'
	DB	00H, '\', 00H, 'D', 00H, 'e', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'd', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, '{'
	DB	00H, '6', 00H, '7', 00H, 'f', 00H, '6', 00H, '7', 00H, '5', 00H
	DB	'4', 00H, '7', 00H, '-', 00H, '9', 00H, '6', 00H, '9', 00H, '3'
	DB	00H, '-', 00H, '4', 00H, '9', 00H, '3', 00H, '7', 00H, '-', 00H
	DB	'a', 00H, 'a', 00H, '1', 00H, '3', 00H, '-', 00H, '5', 00H, '6'
	DB	00H, 'e', 00H, '2', 00H, '9', 00H, '6', 00H, 'b', 00H, 'd', 00H
	DB	'4', 00H, '0', 00H, 'f', 00H, '6', 00H, '}', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@NONGKCIC@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@
CONST	SEGMENT
??_C@_1JO@NONGKCIC@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@ DB 'S'
	DB	00H, 'O', 00H, 'F', 00H, 'T', 00H, 'W', 00H, 'A', 00H, 'R', 00H
	DB	'E', 00H, '\', 00H, 'C', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'I', 00H, 'n', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 'D', 00H, 'e', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'i', 00H, 'e', 00H, 's', 00H, '\'
	DB	00H, '{', 00H, 'e', 00H, '2', 00H, '8', 00H, '0', 00H, '3', 00H
	DB	'1', 00H, '1', 00H, '0', 00H, '-', 00H, '7', 00H, '8', 00H, 'b'
	DB	00H, '3', 00H, '-', 00H, '4', 00H, '6', 00H, '6', 00H, '4', 00H
	DB	'-', 00H, 'a', 00H, '4', 00H, '7', 00H, '9', 00H, '-', 00H, '3'
	DB	00H, '6', 00H, '1', 00H, '1', 00H, 'a', 00H, '3', 00H, '8', 00H
	DB	'1', 00H, '6', 00H, '5', 00H, '6', 00H, 'a', 00H, '}', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@IOMHEKPF@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@
CONST	SEGMENT
??_C@_1JO@IOMHEKPF@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@ DB 'S'
	DB	00H, 'O', 00H, 'F', 00H, 'T', 00H, 'W', 00H, 'A', 00H, 'R', 00H
	DB	'E', 00H, '\', 00H, 'C', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'I', 00H, 'n', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 'D', 00H, 'e', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'i', 00H, 'e', 00H, 's', 00H, '\'
	DB	00H, '{', 00H, 'f', 00H, '6', 00H, '5', 00H, 'd', 00H, 'b', 00H
	DB	'0', 00H, '2', 00H, '7', 00H, '-', 00H, 'a', 00H, 'f', 00H, 'f'
	DB	00H, '3', 00H, '-', 00H, '4', 00H, '0', 00H, '7', 00H, '0', 00H
	DB	'-', 00H, '8', 00H, '8', 00H, '6', 00H, 'a', 00H, '-', 00H, '0'
	DB	00H, 'd', 00H, '8', 00H, '7', 00H, '0', 00H, '6', 00H, '4', 00H
	DB	'a', 00H, 'a', 00H, 'b', 00H, 'b', 00H, '1', 00H, '}', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@BMHPCMGB@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@
CONST	SEGMENT
??_C@_1JO@BMHPCMGB@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@ DB 'S'
	DB	00H, 'O', 00H, 'F', 00H, 'T', 00H, 'W', 00H, 'A', 00H, 'R', 00H
	DB	'E', 00H, '\', 00H, 'C', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'I', 00H, 'n', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 'D', 00H, 'e', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'i', 00H, 'e', 00H, 's', 00H, '\'
	DB	00H, '{', 00H, '3', 00H, '3', 00H, 'd', 00H, '1', 00H, 'f', 00H
	DB	'd', 00H, '9', 00H, '0', 00H, '-', 00H, '4', 00H, '2', 00H, '7'
	DB	00H, '4', 00H, '-', 00H, '4', 00H, '8', 00H, 'a', 00H, '1', 00H
	DB	'-', 00H, '9', 00H, 'b', 00H, 'c', 00H, '1', 00H, '-', 00H, '9'
	DB	00H, '7', 00H, 'e', 00H, '3', 00H, '3', 00H, 'd', 00H, '9', 00H
	DB	'c', 00H, '2', 00H, 'd', 00H, '6', 00H, 'f', 00H, '}', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1IK@NJBBFKEK@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@
CONST	SEGMENT
??_C@_1IK@NJBBFKEK@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@ DB 'S'
	DB	00H, 'O', 00H, 'F', 00H, 'T', 00H, 'W', 00H, 'A', 00H, 'R', 00H
	DB	'E', 00H, '\', 00H, 'C', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'I', 00H, 'n', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 'P', 00H, 'r', 00H, 'o', 00H, 'd', 00H, 'u', 00H, 'c', 00H
	DB	't', 00H, 's', 00H, '\', 00H, '6', 00H, '7', 00H, 'D', 00H, '6'
	DB	00H, 'E', 00H, 'C', 00H, 'F', 00H, '5', 00H, 'C', 00H, 'D', 00H
	DB	'5', 00H, 'F', 00H, 'B', 00H, 'A', 00H, '7', 00H, '3', 00H, '2'
	DB	00H, 'B', 00H, '8', 00H, 'B', 00H, '2', 00H, '2', 00H, 'B', 00H
	DB	'A', 00H, 'C', 00H, '8', 00H, 'D', 00H, 'E', 00H, '1', 00H, 'B'
	DB	00H, '4', 00H, 'D', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CGAJGCJE@Can?8t?5unpack?5signature?4?5@
CONST	SEGMENT
??_C@_0BJ@CGAJGCJE@Can?8t?5unpack?5signature?4?5@ DB 'Can''t unpack signa'
	DB	'ture. ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CPNHGEPL@Signature?3?5@
CONST	SEGMENT
??_C@_0M@CPNHGEPL@Signature?3?5@ DB 'Signature: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
CONST	SEGMENT
??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ DB 'stoi argument out '
	DB	'of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
CONST	SEGMENT
??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@ DB 'invalid stoi argument', 00H ; `string'
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * &>
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
PUBLIC	?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABU01@@Z ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > const >
PUBLIC	??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * &>
PUBLIC	??$construct@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::construct<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
PUBLIC	??$_Lower_bound_duplicate@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABQAUHKEY__@@@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Lower_bound_duplicate<HKEY__ *>
PUBLIC	??$_Find_lower_bound@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@ABQAUHKEY__@@@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Find_lower_bound<HKEY__ *>
PUBLIC	??$_Kfn@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@SAABQAUHKEY__@@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0>::_Kfn<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Max
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@PAUHKEY__@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@PAUHKEY__@@@2@XZ ; std::_Compressed_pair<std::less<HKEY__ *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>,1>::_Get_first
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Allocate
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@PAUHKEY__@@@2@XZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Getcomp
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Get_scary
PUBLIC	??R?$less@PAUHKEY__@@@std@@QBE_NABQAUHKEY__@@0@Z ; std::less<HKEY__ *>::operator()
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator--
PUBLIC	??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2
PUBLIC	??_G?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAXI@Z ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::`scalar deleting destructor'
PUBLIC	??$_Get_unwrapped@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABQAV10@@Z ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>
PUBLIC	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::nullptr_t>
PUBLIC	??$destroy@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::destroy<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??$addressof@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAPAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@AAU10@@Z ; std::addressof<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??$forward@ABQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@ABQAU10@@Z ; std::forward<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * const &>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *>
PUBLIC	??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z		; std::forward<wchar_t * const &>
PUBLIC	??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z		; std::addressof<wchar_t *>
PUBLIC	??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > ><std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
PUBLIC	??$forward@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@ABU10@@Z ; std::forward<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
PUBLIC	??$_Find_hint@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_hint_result@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABQAUHKEY__@@@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Find_hint<HKEY__ *>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::max_size
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::max_size
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Rrotate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
PUBLIC	?find@?$_Narrow_char_traits@DH@std@@SAPBDQBDIABD@Z ; std::_Narrow_char_traits<char,int>::find
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::deallocate
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Check_grow_by_1
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Insert_node
PUBLIC	?_Extract@?$_In_place_key_extract_map@PAUHKEY__@@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAABQAUHKEY__@@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z ; std::_In_place_key_extract_map<HKEY__ *,std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Extract
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Release
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z ; std::_Traits_equal<std::char_traits<char> >
PUBLIC	??$_Get_size_of_n@$01@std@@YAII@Z		; std::_Get_size_of_n<2>
PUBLIC	??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z	; std::_Unfancy_maybe_null<unsigned char>
PUBLIC	??$_Get_size_of_n@$0CM@@std@@YAII@Z		; std::_Get_size_of_n<44>
PUBLIC	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * const &>
PUBLIC	??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
PUBLIC	??$forward@ABU?$less@PAUHKEY__@@@std@@@std@@YAABU?$less@PAUHKEY__@@@0@ABU10@@Z ; std::forward<std::less<HKEY__ *> const &>
PUBLIC	??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Emplace_hint<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
PUBLIC	??$_Adl_verify_range@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PBU12@@std@@YAXABQBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@0@Z ; std::_Adl_verify_range<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const *,std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const *>
PUBLIC	??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ; std::forward<std::allocator<wchar_t> >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
PUBLIC	??$forward@AAY0GI@$$CB_W@std@@YAAAY0GI@$$CB_WAAY0GI@$$CB_W@Z ; std::forward<wchar_t const (&)[104]>
PUBLIC	??$forward@AAY0EP@$$CB_W@std@@YAAAY0EP@$$CB_WAAY0EP@$$CB_W@Z ; std::forward<wchar_t const (&)[79]>
PUBLIC	??$forward@AAY0EF@$$CB_W@std@@YAAAY0EF@$$CB_WAAY0EF@$$CB_W@Z ; std::forward<wchar_t const (&)[69]>
PUBLIC	??$forward@PAUHKEY__@@@std@@YA$$QAPAUHKEY__@@AAPAU1@@Z ; std::forward<HKEY__ *>
PUBLIC	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1><>
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?compare@?$_Narrow_char_traits@DH@std@@SAHQBD0I@Z ; std::_Narrow_char_traits<char,int>::compare
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	??0?$allocator@_W@std@@QAE@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
PUBLIC	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
PUBLIC	?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$allocator@E@std@@QAE@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::data
PUBLIC	?_Umove@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove
PUBLIC	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >::allocate
PUBLIC	??$_Get_unwrapped@ABQAE@std@@YAPAEABQAE@Z	; std::_Get_unwrapped<unsigned char * const &>
PUBLIC	??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
PUBLIC	??$_Unfancy@_W@std@@YAPA_WPA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV34@QB_WI@Z@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QB_WI@Z@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>,wchar_t const *>
PUBLIC	??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$?0ABU?$less@PAUHKEY__@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PAUHKEY__@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PAUHKEY__@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<HKEY__ *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>,1>::_Compressed_pair<std::less<HKEY__ *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>,1><std::less<HKEY__ *> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$_Get_unwrapped@AAPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@AAPBU10@@Z ; std::_Get_unwrapped<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const * &>
PUBLIC	??$insert@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAEXPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@0@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::insert<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const *>
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??reserve@01@QAEXI@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
PUBLIC	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
PUBLIC	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QAEPAEQAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
PUBLIC	??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE$$QAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
PUBLIC	??$_Unfancy@E@std@@YAPAEPAE@Z			; std::_Unfancy<unsigned char>
PUBLIC	??$forward@E@std@@YA$$QAEAAE@Z			; std::forward<unsigned char>
PUBLIC	??$move@AAE@std@@YA$$QAEAAE@Z			; std::move<unsigned char &>
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
PUBLIC	??$?0PAUHKEY__@@AAY0GI@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0GI@$$CB_W@Z ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > ><HKEY__ *,wchar_t const (&)[104],0>
PUBLIC	??$?0PAUHKEY__@@AAY0EP@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0EP@$$CB_W@Z ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > ><HKEY__ *,wchar_t const (&)[79],0>
PUBLIC	??$?0PAUHKEY__@@AAY0EF@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0EF@$$CB_W@Z ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > ><HKEY__ *,wchar_t const (&)[69],0>
PUBLIC	??$_Emplace_reallocate@AAK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKAAK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long &>
PUBLIC	??$construct@KAAK@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@QAKAAK@Z ; std::_Default_allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>
PUBLIC	??$forward@AAK@std@@YAAAKAAK@Z			; std::forward<unsigned long &>
PUBLIC	??$data@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAEAAV?$vector@EV?$allocator@E@std@@@0@@Z ; std::data<std::vector<unsigned char,std::allocator<unsigned char> > >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ; split<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?length@?$_WChar_traits@_W@std@@SAIPB_W@Z	; std::_WChar_traits<wchar_t>::length
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
PUBLIC	?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept1
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?move@?$_WChar_traits@_W@std@@SAPA_WQA_WQB_WI@Z	; std::_WChar_traits<wchar_t>::move
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z	; std::_WChar_traits<wchar_t>::assign
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
PUBLIC	?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
PUBLIC	?deallocate@?$allocator@E@std@@QAEXQAEI@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	?allocate@?$allocator@E@std@@QAEPAEI@Z		; std::allocator<unsigned char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept
PUBLIC	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Min
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>::_Get_first
PUBLIC	?begin@?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ ; std::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::begin
PUBLIC	?end@?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ ; std::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::end
PUBLIC	?copy@?$_WChar_traits@_W@std@@SAPA_WQA_WQB_WI@Z	; std::_WChar_traits<wchar_t>::copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??R<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV23@QB_WI@Z@QBEXQA_WI0@Z ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>::operator()
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	?_Reallocate_exactly@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate_exactly
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
PUBLIC	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	??0?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAUHKEY__@@@1@@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAEXV?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::insert
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Get_scary
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>
PUBLIC	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator++
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
PUBLIC	??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z@QBEXQADQBDI@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1>::operator()
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??$_Emplace_back_with_unused_capacity@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char>
PUBLIC	??$emplace_back@E@?$vector@EV?$allocator@E@std@@@std@@QAEAAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::emplace_back<unsigned char>
PUBLIC	?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
PUBLIC	?reserve@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::reserve
PUBLIC	?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear
PUBLIC	??1?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::~_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >
PUBLIC	?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QBE?AU_Default_sentinel@2@XZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Unchecked_end
PUBLIC	??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z ; std::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
PUBLIC	??0?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@0@Z ; std::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator!=
PUBLIC	??D?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@XZ ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::operator*
PUBLIC	??E?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::operator++
PUBLIC	?__autoclassinit2@?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAEXI@Z ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAEXI@Z ; std::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::__autoclassinit2
PUBLIC	??1?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@XZ ; std::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::~map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
PUBLIC	??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::~pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	?IsRedistPackagePresent@Utils@@SA_NXZ		; Utils::IsRedistPackagePresent
PUBLIC	?IsWinServBuild@Utils@@SA_NXZ			; Utils::IsWinServBuild
PUBLIC	?IsWinXPOrLater@Utils@@SA_NXZ			; Utils::IsWinXPOrLater
PUBLIC	?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2
PUBLIC	??$_Emplace_back_with_unused_capacity@AAK@?$vector@KV?$allocator@K@std@@@std@@AAEAAKAAK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_back_with_unused_capacity<unsigned long &>
PUBLIC	??$emplace_back@AAK@?$vector@KV?$allocator@K@std@@@std@@QAEAAKAAK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long &>
PUBLIC	?SearchSignature@@YAKKKPBD0@Z			; SearchSignature
PUBLIC	?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2
PUBLIC	?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; UnpackSignature
PUBLIC	?GetModuleInfo@Utils@@SA?AU_MODULEINFO@@PBD@Z	; Utils::GetModuleInfo
PUBLIC	?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
PUBLIC	_wmemmove
PUBLIC	_wmemcpy
PUBLIC	?GetFunction@Utils@@SAKPBD0@Z			; Utils::GetFunction
PUBLIC	?UpdateInstructionCharArgument@Utils@@SAXKQADHHHHHHH@Z ; Utils::UpdateInstructionCharArgument
PUBLIC	?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z ; Utils::FindOffsetsToVec
PUBLIC	?GetModule@Utils@@SAPAUHINSTANCE__@@PBD@Z	; Utils::GetModule
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?IsRedistPackagePresent@Utils@@SA_NXZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?IsRedistPackagePresent@Utils@@SA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?IsRedistPackagePresent@Utils@@SA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$7
	DD	06H
	DD	FLAT:__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$16
	DD	06H
	DD	FLAT:__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z$0
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ?GetModule@Utils@@SAPAUHINSTANCE__@@PBD@Z
_TEXT	SEGMENT
?GetModule@Utils@@SAPAUHINSTANCE__@@PBD@Z PROC		; Utils::GetModule, COMDAT
; _module$ = ecx

; 3    : HMODULE Utils::GetModule (const char* module) {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4    : 
; 5    :    HMODULE hModule = GetModuleHandleA (module);

  00003	56		 push	 esi
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4

; 6    : 
; 7    :    if (!hModule) {

  0000a	85 c0		 test	 eax, eax
  0000c	75 07		 jne	 SHORT $LN2@GetModule

; 8    :        hModule = LoadLibraryA (module);

  0000e	56		 push	 esi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
$LN2@GetModule:

; 9    :    }
; 10   : 
; 11   :    return hModule;
; 12   : }

  00015	5e		 pop	 esi
  00016	c3		 ret	 0
?GetModule@Utils@@SAPAUHINSTANCE__@@PBD@Z ENDP		; Utils::GetModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z
_TEXT	SEGMENT
$T6 = -280						; size = 24
$T1 = -268						; size = 12
_<end>$L0$1$ = -256					; size = 4
$T25 = -252						; size = 4
tv1035 = -248						; size = 4
_vector$GSCopy$1$ = -244				; size = 4
__Ptr$1$ = -240						; size = 4
__Ptr$1$ = -236						; size = 4
_stream$26 = -232					; size = 176
_mask$ = -56						; size = 24
_pattern$ = -32						; size = 12
__Result$2$ = -20					; size = 4
_offset$27 = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_signatures$ = 8					; size = 12
_isPanic$ = 20						; size = 1
?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z PROC ; Utils::FindOffsetsToVec, COMDAT
; _module$ = ecx
; _vector$ = edx

; 94   : void Utils::FindOffsetsToVec (const char* module, std::vector<const char*> signatures, std::vector<DWORD>& vector, bool isPanic) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b da		 mov	 ebx, edx
  00030	89 9d 0c ff ff
	ff		 mov	 DWORD PTR _vector$GSCopy$1$[ebp], ebx
  00036	8b f9		 mov	 edi, ecx
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	0f 57 c0	 xorps	 xmm0, xmm0

; 5    :    HMODULE hModule = GetModuleHandleA (module);

  00042	57		 push	 edi

; 16   :     MODULEINFO modinfo = { 0 };

  00043	66 0f d6 85 f4
	fe ff ff	 movq	 QWORD PTR $T1[ebp], xmm0
  0004b	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp+8], 0

; 5    :    HMODULE hModule = GetModuleHandleA (module);

  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  0005b	8b f0		 mov	 esi, eax

; 6    : 
; 7    :    if (!hModule) {

  0005d	85 f6		 test	 esi, esi
  0005f	75 09		 jne	 SHORT $LN16@FindOffset

; 8    :        hModule = LoadLibraryA (module);

  00061	57		 push	 edi
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  00068	8b f0		 mov	 esi, eax
$LN16@FindOffset:

; 18   :     GetModuleInformation (GetCurrentProcess (), GetModule(module), &modinfo, sizeof (MODULEINFO));

  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00070	6a 0c		 push	 12			; 0000000cH
  00072	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00078	51		 push	 ecx
  00079	56		 push	 esi
  0007a	50		 push	 eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__K32GetModuleInformation@16
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00081	33 f6		 xor	 esi, esi
  00083	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pattern$[ebp+8], 0
  0008a	0f 57 c0	 xorps	 xmm0, xmm0
  0008d	89 75 e8	 mov	 DWORD PTR _pattern$[ebp+8], esi
  00090	66 0f d6 45 e0	 movq	 QWORD PTR _pattern$[ebp], xmm0
  00095	89 75 e0	 mov	 DWORD PTR _pattern$[ebp], esi
  00098	89 75 e4	 mov	 DWORD PTR _pattern$[ebp+4], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4301 :         _Mypair._Myval2._Mysize = 0;

  0009b	89 75 d8	 mov	 DWORD PTR _mask$[ebp+16], esi

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0009e	c7 45 dc 0f 00
	00 00		 mov	 DWORD PTR _mask$[ebp+20], 15 ; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  000a5	c6 45 c8 00	 mov	 BYTE PTR _mask$[ebp], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 99   :     std::string mask;

  000a9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 101  :     for (const auto& signature : signatures) {

  000ad	8b 7d 08	 mov	 edi, DWORD PTR _signatures$[ebp]
  000b0	8b 45 0c	 mov	 eax, DWORD PTR _signatures$[ebp+4]
  000b3	89 bd 10 ff ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], edi
  000b9	89 85 00 ff ff
	ff		 mov	 DWORD PTR _<end>$L0$1$[ebp], eax
  000bf	3b f8		 cmp	 edi, eax
  000c1	0f 84 5a 01 00
	00		 je	 $LN114@FindOffset
$LL4@FindOffset:

; 102  : 
; 103  :         if (!UnpackSignature (signature, pattern, mask)) {

  000c7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c9	8d 45 c8	 lea	 eax, DWORD PTR _mask$[ebp]
  000cc	50		 push	 eax
  000cd	8d 55 e0	 lea	 edx, DWORD PTR _pattern$[ebp]
  000d0	e8 00 00 00 00	 call	 ?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; UnpackSignature
  000d5	83 c4 04	 add	 esp, 4
  000d8	84 c0		 test	 al, al
  000da	75 09		 jne	 SHORT $LN64@FindOffset

; 104  :             if (isPanic) {

  000dc	38 45 14	 cmp	 BYTE PTR _isPanic$[ebp], al
  000df	0f 85 d0 01 00
	00		 jne	 $LN181@FindOffset
$LN64@FindOffset:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  000e5	83 7d dc 10	 cmp	 DWORD PTR _mask$[ebp+20], 16 ; 00000010H

; 2149 :         const value_type* _Result = _Bx._Buf;

  000e9	8d 55 c8	 lea	 edx, DWORD PTR _mask$[ebp]

; 2150 :         if (_Large_string_engaged()) {

  000ec	0f 43 55 c8	 cmovae	 edx, DWORD PTR _mask$[ebp]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 73   :     DWORD patternLength = strlen (mask);

  000f0	8b f2		 mov	 esi, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2150 :         if (_Large_string_engaged()) {

  000f2	89 55 ec	 mov	 DWORD PTR __Result$2$[ebp], edx
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 73   :     DWORD patternLength = strlen (mask);

  000f5	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL192@FindOffset:
  000f8	8a 06		 mov	 al, BYTE PTR [esi]
  000fa	46		 inc	 esi
  000fb	84 c0		 test	 al, al
  000fd	75 f9		 jne	 SHORT $LL192@FindOffset
  000ff	2b f1		 sub	 esi, ecx

; 74   : 
; 75   :     if (patternLength > moduleSize) return NULL;

  00101	8b 4d e0	 mov	 ecx, DWORD PTR _pattern$[ebp]
  00104	89 8d 14 ff ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], ecx
  0010a	3b b5 f8 fe ff
	ff		 cmp	 esi, DWORD PTR $T1[ebp+4]
  00110	77 72		 ja	 SHORT $LN196@FindOffset

; 76   :     if (baseAddress == 0) return NULL;

  00112	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00118	85 c0		 test	 eax, eax
  0011a	74 68		 je	 SHORT $LN196@FindOffset

; 77   : 
; 78   :     for (DWORD offset = 0; offset < baseAddress - patternLength; offset++) {

  0011c	33 ff		 xor	 edi, edi
  0011e	2b c6		 sub	 eax, esi
  00120	89 85 04 ff ff
	ff		 mov	 DWORD PTR $T25[ebp], eax
  00126	74 56		 je	 SHORT $LN77@FindOffset
$LL78@FindOffset:

; 79   : 
; 80   :         bool isFound = true;

  00128	33 c0		 xor	 eax, eax
  0012a	b3 01		 mov	 bl, 1

; 81   : 
; 82   :         for (DWORD charIterator = 0; charIterator < patternLength; charIterator++) {

  0012c	85 f6		 test	 esi, esi
  0012e	74 69		 je	 SHORT $LN180@FindOffset

; 79   : 
; 80   :         bool isFound = true;

  00130	2b d1		 sub	 edx, ecx
  00132	89 95 08 ff ff
	ff		 mov	 DWORD PTR tv1035[ebp], edx
$LL81@FindOffset:

; 83   :             isFound &= mask [charIterator] == '?' || pattern [charIterator] == * reinterpret_cast<const char*> (baseAddress + offset + charIterator);

  00138	03 c8		 add	 ecx, eax
  0013a	80 3c 11 3f	 cmp	 BYTE PTR [ecx+edx], 63	; 0000003fH
  0013e	74 13		 je	 SHORT $LN86@FindOffset
  00140	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00146	8a 09		 mov	 cl, BYTE PTR [ecx]
  00148	03 d0		 add	 edx, eax
  0014a	3a 0c 3a	 cmp	 cl, BYTE PTR [edx+edi]
  0014d	74 04		 je	 SHORT $LN86@FindOffset
  0014f	32 c9		 xor	 cl, cl
  00151	eb 02		 jmp	 SHORT $LN87@FindOffset
$LN86@FindOffset:
  00153	b1 01		 mov	 cl, 1
$LN87@FindOffset:

; 81   : 
; 82   :         for (DWORD charIterator = 0; charIterator < patternLength; charIterator++) {

  00155	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR tv1035[ebp]

; 83   :             isFound &= mask [charIterator] == '?' || pattern [charIterator] == * reinterpret_cast<const char*> (baseAddress + offset + charIterator);

  0015b	22 d9		 and	 bl, cl
  0015d	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00163	40		 inc	 eax
  00164	3b c6		 cmp	 eax, esi
  00166	72 d0		 jb	 SHORT $LL81@FindOffset

; 84   :         }
; 85   : 
; 86   :         if (isFound) {

  00168	84 db		 test	 bl, bl
  0016a	75 2d		 jne	 SHORT $LN180@FindOffset

; 77   : 
; 78   :     for (DWORD offset = 0; offset < baseAddress - patternLength; offset++) {

  0016c	8b 55 ec	 mov	 edx, DWORD PTR __Result$2$[ebp]
  0016f	47		 inc	 edi
  00170	3b bd 04 ff ff
	ff		 cmp	 edi, DWORD PTR $T25[ebp]
  00176	72 b0		 jb	 SHORT $LL78@FindOffset

; 104  :             if (isPanic) {

  00178	8b 9d 0c ff ff
	ff		 mov	 ebx, DWORD PTR _vector$GSCopy$1$[ebp]
$LN77@FindOffset:
  0017e	8b bd 10 ff ff
	ff		 mov	 edi, DWORD PTR __Ptr$1$[ebp]
$LN196@FindOffset:

; 111  :         DWORD offset = SearchSignature (reinterpret_cast<DWORD> (moduleInfo.lpBaseOfDll), moduleInfo.SizeOfImage, reinterpret_cast<const char*> (std::data(pattern)), mask.c_str());

  00184	33 c0		 xor	 eax, eax
$LN75@FindOffset:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00186	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 111  :         DWORD offset = SearchSignature (reinterpret_cast<DWORD> (moduleInfo.lpBaseOfDll), moduleInfo.SizeOfImage, reinterpret_cast<const char*> (std::data(pattern)), mask.c_str());

  00189	89 45 ec	 mov	 DWORD PTR _offset$27[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0018c	3b 4b 08	 cmp	 ecx, DWORD PTR [ebx+8]
  0018f	74 1e		 je	 SHORT $LN89@FindOffset

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00191	89 01		 mov	 DWORD PTR [ecx], eax

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  00193	83 43 04 04	 add	 DWORD PTR [ebx+4], 4

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00197	eb 22		 jmp	 SHORT $LN88@FindOffset
$LN180@FindOffset:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 87   :             return baseAddress + offset;

  00199	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  0019f	8b 9d 0c ff ff
	ff		 mov	 ebx, DWORD PTR _vector$GSCopy$1$[ebp]
  001a5	03 c7		 add	 eax, edi
  001a7	8b bd 10 ff ff
	ff		 mov	 edi, DWORD PTR __Ptr$1$[ebp]
  001ad	eb d7		 jmp	 SHORT $LN75@FindOffset
$LN89@FindOffset:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  001af	8d 45 ec	 lea	 eax, DWORD PTR _offset$27[ebp]
  001b2	50		 push	 eax
  001b3	51		 push	 ecx
  001b4	8b cb		 mov	 ecx, ebx
  001b6	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AAK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKAAK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long &>
$LN88@FindOffset:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  001bb	83 7d dc 10	 cmp	 DWORD PTR _mask$[ebp+20], 16 ; 00000010H

; 2140 :         value_type* _Result = _Bx._Buf;

  001bf	8d 45 c8	 lea	 eax, DWORD PTR _mask$[ebp]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 115  :         pattern.clear ();

  001c2	8b b5 14 ff ff
	ff		 mov	 esi, DWORD PTR __Ptr$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2141 :         if (_Large_string_engaged()) {

  001c8	0f 43 45 c8	 cmovae	 eax, DWORD PTR _mask$[ebp]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 101  :     for (const auto& signature : signatures) {

  001cc	83 c7 04	 add	 edi, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4297 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  001cf	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _mask$[ebp+16], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 115  :         pattern.clear ();

  001d6	89 75 e4	 mov	 DWORD PTR _pattern$[ebp+4], esi
  001d9	89 bd 10 ff ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4297 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  001df	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 101  :     for (const auto& signature : signatures) {

  001e2	3b bd 00 ff ff
	ff		 cmp	 edi, DWORD PTR _<end>$L0$1$[ebp]
  001e8	0f 85 d9 fe ff
	ff		 jne	 $LL4@FindOffset
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  001ee	8b 55 dc	 mov	 edx, DWORD PTR _mask$[ebp+20]
  001f1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001f4	72 28		 jb	 SHORT $LN193@FindOffset
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001f6	8b 4d c8	 mov	 ecx, DWORD PTR _mask$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001f9	42		 inc	 edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001fa	8b c1		 mov	 eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001fc	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00202	72 10		 jb	 SHORT $LN124@FindOffset

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00204	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00207	83 c2 23	 add	 edx, 35			; 00000023H
  0020a	2b c1		 sub	 eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0020c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0020f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00212	77 75		 ja	 SHORT $LN169@FindOffset
$LN124@FindOffset:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00214	52		 push	 edx
  00215	51		 push	 ecx
  00216	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0021b	83 c4 08	 add	 esp, 8
$LN193@FindOffset:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4317 :         _Mypair._Myval2._Mysize = 0;

  0021e	8b 7d 08	 mov	 edi, DWORD PTR _signatures$[ebp]
$LN114@FindOffset:
  00221	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _mask$[ebp+16], 0

; 4318 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00228	c7 45 dc 0f 00
	00 00		 mov	 DWORD PTR _mask$[ebp+20], 15 ; 0000000fH

; 4319 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4320 :         // write can alias this
; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0022f	c6 45 c8 00	 mov	 BYTE PTR _mask$[ebp], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00233	85 f6		 test	 esi, esi
  00235	74 2c		 je	 SHORT $LN132@FindOffset

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00237	8b 4d e8	 mov	 ecx, DWORD PTR _pattern$[ebp+8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0023a	8b c6		 mov	 eax, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0023c	2b ce		 sub	 ecx, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0023e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00244	72 10		 jb	 SHORT $LN148@FindOffset

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00246	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  00249	83 c1 23	 add	 ecx, 35			; 00000023H
  0024c	2b c6		 sub	 eax, esi

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0024e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00251	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00254	77 33		 ja	 SHORT $LN169@FindOffset
$LN148@FindOffset:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00256	51		 push	 ecx
  00257	56		 push	 esi
  00258	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0025d	8b 7d 08	 mov	 edi, DWORD PTR _signatures$[ebp]
  00260	83 c4 08	 add	 esp, 8
$LN132@FindOffset:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00263	85 ff		 test	 edi, edi
  00265	74 32		 je	 SHORT $LN156@FindOffset

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00267	8b 4d 10	 mov	 ecx, DWORD PTR _signatures$[ebp+8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0026a	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0026c	2b cf		 sub	 ecx, edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0026e	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00271	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00277	72 16		 jb	 SHORT $LN172@FindOffset

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00279	8b 7f fc	 mov	 edi, DWORD PTR [edi-4]
  0027c	83 c1 23	 add	 ecx, 35			; 00000023H
  0027f	2b c7		 sub	 eax, edi

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00281	83 c0 fc	 add	 eax, -4			; fffffffcH
  00284	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00287	76 06		 jbe	 SHORT $LN172@FindOffset
$LN169@FindOffset:
  00289	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN172@FindOffset:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0028f	51		 push	 ecx
  00290	57		 push	 edi
  00291	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00296	83 c4 08	 add	 esp, 8
$LN156@FindOffset:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 119  : }

  00299	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0029c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002a3	59		 pop	 ecx
  002a4	5f		 pop	 edi
  002a5	5e		 pop	 esi
  002a6	5b		 pop	 ebx
  002a7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002aa	33 cd		 xor	 ecx, ebp
  002ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b1	8b e5		 mov	 esp, ebp
  002b3	5d		 pop	 ebp
  002b4	c3		 ret	 0
$LN181@FindOffset:

; 105  :                 std::stringstream stream;

  002b5	51		 push	 ecx
  002b6	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _stream$26[ebp]
  002bc	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
  002c1	51		 push	 ecx
  002c2	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _stream$26[ebp]
  002c8	e8 00 00 00 00	 call	 ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >

; 106  :                 stream << "Can't unpack signature. " << "Signature: " << signature;

  002cd	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BJ@CGAJGCJE@Can?8t?5unpack?5signature?4?5@
  002d2	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  002d6	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _stream$26[ebp+16]
  002dc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002e1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@CPNHGEPL@Signature?3?5@
  002e6	8b c8		 mov	 ecx, eax
  002e8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002ed	8b 17		 mov	 edx, DWORD PTR [edi]
  002ef	8b c8		 mov	 ecx, eax
  002f1	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 107  :                 PanicUtils::Release (PanicUtils::Layers::ROUTINE, stream.str().c_str());

  002f6	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  002fc	50		 push	 eax
  002fd	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _stream$26[ebp]
  00303	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  00308	8b c8		 mov	 ecx, eax
  0030a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0030e	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00313	8b d0		 mov	 edx, eax
  00315	b9 01 00 00 00	 mov	 ecx, 1
  0031a	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN195@FindOffset:
  0031f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _signatures$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@PBDV?$allocator@PBD@std@@@std@@QAE@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
__unwindfunclet$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z$1:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR _pattern$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__unwindfunclet$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z$2:
  00010	8d 4d c8	 lea	 ecx, DWORD PTR _mask$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z$3:
  00018	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _stream$26[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z$4:
  00023	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002e	cc		 int	 3
  0002f	cc		 int	 3
  00030	cc		 int	 3
  00031	cc		 int	 3
  00032	cc		 int	 3
__ehhandler$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z:
  00033	90		 npad	 1
  00034	90		 npad	 1
  00035	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00039	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003c	8b 8a e4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-284]
  00042	33 c8		 xor	 ecx, eax
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0004c	33 c8		 xor	 ecx, eax
  0004e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00053	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z
  00058	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FindOffsetsToVec@Utils@@SAXPBDV?$vector@PBDV?$allocator@PBD@std@@@std@@AAV?$vector@KV?$allocator@K@std@@@3@_N@Z ENDP ; Utils::FindOffsetsToVec
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ?UpdateInstructionCharArgument@Utils@@SAXKQADHHHHHHH@Z
_TEXT	SEGMENT
_offsetToInstructions$ = 8				; size = 4
_instructionIteratorBase$dead$ = 12			; size = 4
_instructionCount$ = 16					; size = 4
_iterationCycleUpdate$dead$ = 20			; size = 4
_instructionCharMoveCount$dead$ = 24			; size = 4
_arrayCharIteratorBase$dead$ = 28			; size = 4
_arrayCharCycleUpdate$dead$ = 32			; size = 4
?UpdateInstructionCharArgument@Utils@@SAXKQADHHHHHHH@Z PROC ; Utils::UpdateInstructionCharArgument, COMDAT
; _base$ = ecx
; _compressedArray$ = edx

; 121  : void Utils::UpdateInstructionCharArgument (DWORD base, char compressedArray[], int offsetToInstructions, int instructionIteratorBase, int instructionCount, int iterationCycleUpdate, int instructionCharMoveCount, int arrayCharIteratorBase, int arrayCharCycleUpdate) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 124  : 
; 125  :     for (int instructionsIterator = instructionIteratorBase; instructionsIterator < instructionCount; instructionsIterator += iterationCycleUpdate) {

  00004	8b 7d 10	 mov	 edi, DWORD PTR _instructionCount$[ebp]
  00007	33 c0		 xor	 eax, eax
  00009	85 ff		 test	 edi, edi
  0000b	7e 16		 jle	 SHORT $LN3@UpdateInst

; 122  : 
; 123  :     int segmentedCharIterator = arrayCharIteratorBase;

  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _offsetToInstructions$[ebp]
  00011	03 f1		 add	 esi, ecx
$LL4@UpdateInst:

; 126  :         std::memcpy (reinterpret_cast <DWORD*> (base + offsetToInstructions + instructionsIterator), compressedArray + segmentedCharIterator, instructionCharMoveCount);

  00013	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 127  :         segmentedCharIterator += arrayCharCycleUpdate;

  00015	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  00018	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  0001b	83 c0 07	 add	 eax, 7
  0001e	3b c7		 cmp	 eax, edi
  00020	7c f1		 jl	 SHORT $LL4@UpdateInst
  00022	5e		 pop	 esi
$LN3@UpdateInst:
  00023	5f		 pop	 edi

; 128  :     }
; 129  : 
; 130  : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?UpdateInstructionCharArgument@Utils@@SAXKQADHHHHHHH@Z ENDP ; Utils::UpdateInstructionCharArgument
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ?GetFunction@Utils@@SAKPBD0@Z
_TEXT	SEGMENT
?GetFunction@Utils@@SAKPBD0@Z PROC			; Utils::GetFunction, COMDAT
; _module$ = ecx
; _function$ = edx

; 23   : DWORD Utils::GetFunction (const char* module, const char* function) {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx
  00004	8b fa		 mov	 edi, edx

; 5    :    HMODULE hModule = GetModuleHandleA (module);

  00006	56		 push	 esi
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4

; 6    : 
; 7    :    if (!hModule) {

  0000d	85 c0		 test	 eax, eax
  0000f	75 07		 jne	 SHORT $LN4@GetFunctio

; 8    :        hModule = LoadLibraryA (module);

  00011	56		 push	 esi
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
$LN4@GetFunctio:

; 24   :    return reinterpret_cast<DWORD> (GetProcAddress(GetModule(module), function));

  00018	57		 push	 edi
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 25   : }

  00022	c3		 ret	 0
?GetFunction@Utils@@SAKPBD0@Z ENDP			; Utils::GetFunction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__N$ = 8						; size = 4
_wmemcpy PROC						; COMDAT
; __S1$ = ecx
; __S2$ = edx

; 230  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 231  :         #pragma warning(push)
; 232  :         #pragma warning(disable : 4995 4996 6386)
; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 08	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memcpy
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 234  :         #pragma warning(pop)
; 235  :     }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__N$ = 8						; size = 4
_wmemmove PROC						; COMDAT
; __S1$ = ecx
; __S2$ = edx

; 243  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  :         #pragma warning(push)
; 245  :         #pragma warning(disable : 4996 6386)
; 246  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 08	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memmove
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 247  :         #pragma warning(pop)
; 248  :     }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string
;	COMDAT ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z
_TEXT	SEGMENT
__Eptr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Base$dead$ = 8					; size = 4
?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z PROC ; std::stoi, COMDAT
; __Str$ = ecx
; __Idx$dead$ = edx

; 89   : inline int stoi(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b f1		 mov	 esi, ecx

; 91   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  0001a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string

; 91   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

  0001e	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2150 :         if (_Large_string_engaged()) {

  00020	72 02		 jb	 SHORT $LN10@stoi

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00022	8b 36		 mov	 esi, DWORD PTR [esi]
$LN10@stoi:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string

; 95   :     const long _Ans = _CSTD strtol(_Ptr, &_Eptr, _Base);

  00024	6a 10		 push	 16			; 00000010H
  00026	8d 45 f8	 lea	 eax, DWORD PTR __Eptr$[ebp]
  00029	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0002f	50		 push	 eax
  00030	56		 push	 esi
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 96   : 
; 97   :     if (_Ptr == _Eptr) {

  0003a	3b 75 f8	 cmp	 esi, DWORD PTR __Eptr$[ebp]
  0003d	75 0b		 jne	 SHORT $LN2@stoi

; 98   :         _Xinvalid_argument("invalid stoi argument");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xinvalid_argument@std@@YAXPBD@Z
$LN2@stoi:

; 99   :     }
; 100  : 
; 101  :     if (_Errno_ref == ERANGE || _Ans < INT_MIN || INT_MAX < _Ans) {

  0004a	83 3f 22	 cmp	 DWORD PTR [edi], 34	; 00000022H
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	75 0b		 jne	 SHORT $LN6@stoi

; 102  :         _Xout_of_range("stoi argument out of range");

  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN6@stoi:

; 103  :     }
; 104  : 
; 105  :     if (_Idx) {
; 106  :         *_Idx = static_cast<size_t>(_Eptr - _Ptr);
; 107  :     }
; 108  : 
; 109  :     return static_cast<int>(_Ans);
; 110  : }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN15@stoi:
?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ENDP ; std::stoi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ?GetModuleInfo@Utils@@SA?AU_MODULEINFO@@PBD@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
?GetModuleInfo@Utils@@SA?AU_MODULEINFO@@PBD@Z PROC	; Utils::GetModuleInfo, COMDAT
; _module$ = ecx

; 14   : MODULEINFO Utils::GetModuleInfo (const char* module) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 15   : 
; 16   :     MODULEINFO modinfo = { 0 };

  00005	8b 75 08	 mov	 esi, DWORD PTR $T1[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	0f 57 c0	 xorps	 xmm0, xmm0

; 5    :    HMODULE hModule = GetModuleHandleA (module);

  0000e	53		 push	 ebx

; 15   : 
; 16   :     MODULEINFO modinfo = { 0 };

  0000f	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00013	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 5    :    HMODULE hModule = GetModuleHandleA (module);

  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00020	8b f8		 mov	 edi, eax

; 6    : 
; 7    :    if (!hModule) {

  00022	85 ff		 test	 edi, edi
  00024	75 09		 jne	 SHORT $LN4@GetModuleI

; 8    :        hModule = LoadLibraryA (module);

  00026	53		 push	 ebx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0002d	8b f8		 mov	 edi, eax
$LN4@GetModuleI:

; 17   : 
; 18   :     GetModuleInformation (GetCurrentProcess (), GetModule(module), &modinfo, sizeof (MODULEINFO));

  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00035	6a 0c		 push	 12			; 0000000cH
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	50		 push	 eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__K32GetModuleInformation@16

; 19   : 
; 20   :     return modinfo;

  00040	5f		 pop	 edi
  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 21   : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?GetModuleInfo@Utils@@SA?AU_MODULEINFO@@PBD@Z ENDP	; Utils::GetModuleInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T2 = -96						; size = 24
$T7 = -72						; size = 24
__Errno_ref$1$ = -48					; size = 4
__Result$1$ = -44					; size = 4
_<end>$L0$1$ = -40					; size = 4
$T44 = -40						; size = 1
$T39 = -33						; size = 1
$T30 = -33						; size = 1
__Eptr$48 = -32						; size = 4
_tokens$ = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_mask$ = 8						; size = 4
?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; UnpackSignature, COMDAT
; _packedSignature$ = ecx
; _pattern$ = edx

; 45   : bool UnpackSignature (const char* packedSignature, std::vector <unsigned char>& pattern, std::string& mask) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b da		 mov	 ebx, edx
  0002d	8b f1		 mov	 esi, ecx
  0002f	8b 7d 08	 mov	 edi, DWORD PTR _mask$[ebp]
  00032	0f 57 c0	 xorps	 xmm0, xmm0
  00035	66 0f d6 45 e4	 movq	 QWORD PTR _tokens$[ebp], xmm0
  0003a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _tokens$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00041	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _tokens$[ebp], 0
  00048	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _tokens$[ebp+4], 0
  0004f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _tokens$[ebp+8], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 47   :     std::vector <std::string> tokens;

  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2992 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0005d	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  00060	6a 01		 push	 1
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00067	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0006e	c7 45 b4 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00075	c6 45 a0 00	 mov	 BYTE PTR $T2[ebp], 0

; 2992 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00079	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 322  :             return __builtin_strlen(_First);

  0007e	8b ce		 mov	 ecx, esi
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 49   :     size_t count = split <std::string> (std::string (packedSignature), " ", tokens);

  00080	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00084	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T7[ebp+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0008b	c7 45 cc 0f 00
	00 00		 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00092	c6 45 b8 00	 mov	 BYTE PTR $T7[ebp], 0

; 322  :             return __builtin_strlen(_First);

  00096	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00099	0f 1f 80 00 00
	00 00		 npad	 7
$LL244@UnpackSign:
  000a0	8a 01		 mov	 al, BYTE PTR [ecx]
  000a2	41		 inc	 ecx
  000a3	84 c0		 test	 al, al
  000a5	75 f9		 jne	 SHORT $LL244@UnpackSign
  000a7	2b ca		 sub	 ecx, edx

; 2992 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000a9	51		 push	 ecx
  000aa	56		 push	 esi
  000ab	8d 4d b8	 lea	 ecx, DWORD PTR $T7[ebp]
  000ae	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 49   :     size_t count = split <std::string> (std::string (packedSignature), " ", tokens);

  000b3	8d 45 e4	 lea	 eax, DWORD PTR _tokens$[ebp]
  000b6	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000ba	50		 push	 eax
  000bb	8d 55 a0	 lea	 edx, DWORD PTR $T2[ebp]
  000be	8d 4d b8	 lea	 ecx, DWORD PTR $T7[ebp]
  000c1	e8 00 00 00 00	 call	 ??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ; split<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  000c6	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ca	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000cd	8b 55 cc	 mov	 edx, DWORD PTR $T7[ebp+20]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 49   :     size_t count = split <std::string> (std::string (packedSignature), " ", tokens);

  000d0	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000d2	83 fa 10	 cmp	 edx, 16			; 00000010H
  000d5	72 28		 jb	 SHORT $LN57@UnpackSign
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000d7	8b 4d b8	 mov	 ecx, DWORD PTR $T7[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000da	42		 inc	 edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000db	8b c1		 mov	 eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000dd	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000e3	72 10		 jb	 SHORT $LN67@UnpackSign

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000e5	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000e8	83 c2 23	 add	 edx, 35			; 00000023H
  000eb	2b c1		 sub	 eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ed	83 c0 fc	 add	 eax, -4			; fffffffcH
  000f0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f3	77 46		 ja	 SHORT $LN92@UnpackSign
$LN67@UnpackSign:

; 195  :     ::operator delete(_Ptr, _Bytes);

  000f5	52		 push	 edx
  000f6	51		 push	 ecx
  000f7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000fc	83 c4 08	 add	 esp, 8
$LN57@UnpackSign:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 49   :     size_t count = split <std::string> (std::string (packedSignature), " ", tokens);

  000ff	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00103	8b 55 b4	 mov	 edx, DWORD PTR $T2[ebp+20]

; 4317 :         _Mypair._Myval2._Mysize = 0;

  00106	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T7[ebp+16], 0

; 4318 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0010d	c7 45 cc 0f 00
	00 00		 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH

; 4319 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4320 :         // write can alias this
; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00114	c6 45 b8 00	 mov	 BYTE PTR $T7[ebp], 0

; 2158 :         return _BUF_SIZE <= _Myres;

  00118	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0011b	72 2e		 jb	 SHORT $LN85@UnpackSign
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0011d	8b 4d a0	 mov	 ecx, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00120	42		 inc	 edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00121	8b c1		 mov	 eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00123	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00129	72 16		 jb	 SHORT $LN95@UnpackSign

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0012b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0012e	83 c2 23	 add	 edx, 35			; 00000023H
  00131	2b c1		 sub	 eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00133	83 c0 fc	 add	 eax, -4			; fffffffcH
  00136	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00139	76 06		 jbe	 SHORT $LN95@UnpackSign
$LN92@UnpackSign:
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN95@UnpackSign:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00141	52		 push	 edx
  00142	51		 push	 ecx
  00143	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00148	83 c4 08	 add	 esp, 8
$LN85@UnpackSign:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 50   :     if (!count) return false;

  0014b	85 f6		 test	 esi, esi
  0014d	75 0a		 jne	 SHORT $LN5@UnpackSign
  0014f	8b 75 e4	 mov	 esi, DWORD PTR _tokens$[ebp]
  00152	32 db		 xor	 bl, bl
  00154	e9 62 01 00 00	 jmp	 $LN12@UnpackSign
$LN5@UnpackSign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00159	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0015c	2b 03		 sub	 eax, DWORD PTR [ebx]

; 1306 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  0015e	3b f0		 cmp	 esi, eax
  00160	76 14		 jbe	 SHORT $LN127@UnpackSign

; 1307 :             if (_Newcapacity > max_size()) {

  00162	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00168	0f 87 dc 01 00
	00		 ja	 $LN251@UnpackSign

; 1309 :             }
; 1310 : 
; 1311 :             _Reallocate_exactly(_Newcapacity);

  0016e	56		 push	 esi
  0016f	8b cb		 mov	 ecx, ebx
  00171	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate_exactly
$LN127@UnpackSign:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 53   :     mask.reserve (count);

  00176	56		 push	 esi
  00177	8b cf		 mov	 ecx, edi
  00179	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 55   :     for (const auto& token : tokens) {

  0017e	8b 45 e8	 mov	 eax, DWORD PTR _tokens$[ebp+4]
  00181	8b 75 e4	 mov	 esi, DWORD PTR _tokens$[ebp]
  00184	89 45 d8	 mov	 DWORD PTR _<end>$L0$1$[ebp], eax
  00187	3b f0		 cmp	 esi, eax
  00189	0f 84 2a 01 00
	00		 je	 $LN3@UnpackSign
  0018f	90		 npad	 1
$LL4@UnpackSign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00190	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2149 :         const value_type* _Result = _Bx._Buf;

  00194	8b c6		 mov	 eax, esi

; 2150 :         if (_Large_string_engaged()) {

  00196	72 02		 jb	 SHORT $LN243@UnpackSign

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00198	8b 06		 mov	 eax, DWORD PTR [esi]
$LN243@UnpackSign:

; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  0019a	83 7e 10 01	 cmp	 DWORD PTR [esi+16], 1
  0019e	75 68		 jne	 SHORT $LN6@UnpackSign

; 302  :             return __builtin_memcmp(_First1, _First2, _Count);

  001a0	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  001a3	3c 3f		 cmp	 al, 63			; 0000003fH
  001a5	75 04		 jne	 SHORT $LN245@UnpackSign
  001a7	33 c0		 xor	 eax, eax
  001a9	eb 05		 jmp	 SHORT $LN246@UnpackSign
$LN245@UnpackSign:
  001ab	1b c0		 sbb	 eax, eax
  001ad	83 c8 01	 or	 eax, 1
$LN246@UnpackSign:

; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  001b0	85 c0		 test	 eax, eax
  001b2	75 54		 jne	 SHORT $LN6@UnpackSign
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 58   :             pattern.push_back (0x00);

  001b4	88 45 df	 mov	 BYTE PTR $T30[ebp], al
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  001b7	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  001ba	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  001bd	74 08		 je	 SHORT $LN152@UnpackSign

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  001bf	c6 00 00	 mov	 BYTE PTR [eax], 0

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  001c2	ff 43 04	 inc	 DWORD PTR [ebx+4]

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  001c5	eb 0c		 jmp	 SHORT $LN151@UnpackSign
$LN152@UnpackSign:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  001c7	8d 4d df	 lea	 ecx, DWORD PTR $T30[ebp]
  001ca	51		 push	 ecx
  001cb	50		 push	 eax
  001cc	8b cb		 mov	 ecx, ebx
  001ce	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QAEPAEQAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
$LN151@UnpackSign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  001d3	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  001d6	8b c2		 mov	 eax, edx
  001d8	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  001db	2b c1		 sub	 eax, ecx
  001dd	83 f8 01	 cmp	 eax, 1
  001e0	72 1a		 jb	 SHORT $LN163@UnpackSign

; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  001e2	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  001e5	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2140 :         value_type* _Result = _Bx._Buf;

  001e8	8b c7		 mov	 eax, edi

; 2158 :         return _BUF_SIZE <= _Myres;

  001ea	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  001ed	72 02		 jb	 SHORT $LN166@UnpackSign

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  001ef	8b 07		 mov	 eax, DWORD PTR [edi]
$LN166@UnpackSign:

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  001f1	66 c7 04 08 3f
	00		 mov	 WORD PTR [eax+ecx], 63	; 0000003fH

; 2873 :             return *this;

  001f7	e9 ae 00 00 00	 jmp	 $LN2@UnpackSign
$LN163@UnpackSign:

; 2874 :         }
; 2875 : 
; 2876 :         return _Reallocate_grow_by(

  001fc	6a 01		 push	 1
  001fe	68 00 00 00 00	 push	 OFFSET ??_C@_01OGPIMHDM@?$DP@
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 60   :         }

  00203	e9 96 00 00 00	 jmp	 $LN249@UnpackSign
$LN6@UnpackSign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string

; 91   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

  00208	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  0020e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string

; 91   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

  00212	8b c8		 mov	 ecx, eax
  00214	89 4d d0	 mov	 DWORD PTR __Errno_ref$1$[ebp], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2149 :         const value_type* _Result = _Bx._Buf;

  00217	8b c6		 mov	 eax, esi
  00219	89 75 d4	 mov	 DWORD PTR __Result$1$[ebp], esi

; 2150 :         if (_Large_string_engaged()) {

  0021c	72 05		 jb	 SHORT $LN181@UnpackSign

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  0021e	8b 06		 mov	 eax, DWORD PTR [esi]
  00220	89 45 d4	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN181@UnpackSign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string

; 94   :     _Errno_ref      = 0;

  00223	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 95   :     const long _Ans = _CSTD strtol(_Ptr, &_Eptr, _Base);

  00229	8d 4d e0	 lea	 ecx, DWORD PTR __Eptr$48[ebp]
  0022c	6a 10		 push	 16			; 00000010H
  0022e	51		 push	 ecx
  0022f	50		 push	 eax
  00230	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol

; 96   : 
; 97   :     if (_Ptr == _Eptr) {

  00236	8b 4d d4	 mov	 ecx, DWORD PTR __Result$1$[ebp]
  00239	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023c	8b d0		 mov	 edx, eax
  0023e	3b 4d e0	 cmp	 ecx, DWORD PTR __Eptr$48[ebp]
  00241	0f 84 d0 00 00
	00		 je	 $LN235@UnpackSign

; 101  :     if (_Errno_ref == ERANGE || _Ans < INT_MIN || INT_MAX < _Ans) {

  00247	8b 45 d0	 mov	 eax, DWORD PTR __Errno_ref$1$[ebp]
  0024a	83 38 22	 cmp	 DWORD PTR [eax], 34	; 00000022H
  0024d	0f 84 b9 00 00
	00		 je	 $LN236@UnpackSign
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00253	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 62   :             pattern.push_back (static_cast <unsigned char> (std::stoi (token, nullptr, 16)));

  00256	88 55 df	 mov	 BYTE PTR $T39[ebp], dl
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00259	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  0025c	74 07		 je	 SHORT $LN188@UnpackSign

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0025e	88 10		 mov	 BYTE PTR [eax], dl

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  00260	ff 43 04	 inc	 DWORD PTR [ebx+4]

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00263	eb 0c		 jmp	 SHORT $LN187@UnpackSign
$LN188@UnpackSign:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00265	8d 4d df	 lea	 ecx, DWORD PTR $T39[ebp]
  00268	51		 push	 ecx
  00269	50		 push	 eax
  0026a	8b cb		 mov	 ecx, ebx
  0026c	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QAEPAEQAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
$LN187@UnpackSign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00271	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00274	8b c2		 mov	 eax, edx
  00276	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00279	2b c1		 sub	 eax, ecx
  0027b	83 f8 01	 cmp	 eax, 1
  0027e	72 17		 jb	 SHORT $LN199@UnpackSign

; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00280	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00283	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2140 :         value_type* _Result = _Bx._Buf;

  00286	8b c7		 mov	 eax, edi

; 2158 :         return _BUF_SIZE <= _Myres;

  00288	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  0028b	72 02		 jb	 SHORT $LN202@UnpackSign

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  0028d	8b 07		 mov	 eax, DWORD PTR [edi]
$LN202@UnpackSign:

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0028f	66 c7 04 08 2e
	00		 mov	 WORD PTR [eax+ecx], 46	; 0000002eH

; 2873 :             return *this;

  00295	eb 13		 jmp	 SHORT $LN2@UnpackSign
$LN199@UnpackSign:

; 2874 :         }
; 2875 : 
; 2876 :         return _Reallocate_grow_by(

  00297	6a 01		 push	 1
  00299	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4@
$LN249@UnpackSign:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 55   :     for (const auto& token : tokens) {

  0029e	ff 75 d8	 push	 DWORD PTR $T44[ebp]
  002a1	8b cf		 mov	 ecx, edi
  002a3	6a 01		 push	 1
  002a5	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
$LN2@UnpackSign:
  002aa	83 c6 18	 add	 esi, 24			; 00000018H
  002ad	3b 75 d8	 cmp	 esi, DWORD PTR _<end>$L0$1$[ebp]
  002b0	0f 85 da fe ff
	ff		 jne	 $LL4@UnpackSign
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string

; 101  :     if (_Errno_ref == ERANGE || _Ans < INT_MIN || INT_MAX < _Ans) {

  002b6	8b 75 e4	 mov	 esi, DWORD PTR _tokens$[ebp]
$LN3@UnpackSign:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 68   :     return true;

  002b9	b3 01		 mov	 bl, 1
$LN12@UnpackSign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  002bb	85 f6		 test	 esi, esi
  002bd	74 6d		 je	 SHORT $LN211@UnpackSign

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  002bf	8b 55 e8	 mov	 edx, DWORD PTR _tokens$[ebp+4]
  002c2	51		 push	 ecx
  002c3	8b ce		 mov	 ecx, esi
  002c5	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  002ca	8b 4d ec	 mov	 ecx, DWORD PTR _tokens$[ebp+8]
  002cd	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  002d2	8b 75 e4	 mov	 esi, DWORD PTR _tokens$[ebp]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  002d5	83 c4 04	 add	 esp, 4

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  002d8	2b ce		 sub	 ecx, esi
  002da	f7 e9		 imul	 ecx
  002dc	c1 fa 02	 sar	 edx, 2
  002df	8b c2		 mov	 eax, edx
  002e1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002e4	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002e6	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  002e9	8b c6		 mov	 eax, esi
  002eb	c1 e1 03	 shl	 ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  002ee	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  002f4	72 2c		 jb	 SHORT $LN229@UnpackSign

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002f6	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  002f9	83 c1 23	 add	 ecx, 35			; 00000023H
  002fc	2b c6		 sub	 eax, esi

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002fe	83 c0 fc	 add	 eax, -4			; fffffffcH
  00301	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00304	76 1c		 jbe	 SHORT $LN229@UnpackSign
  00306	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN236@UnpackSign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\string

; 102  :         _Xout_of_range("stoi argument out of range");

  0030c	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
  00311	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN235@UnpackSign:

; 98   :         _Xinvalid_argument("invalid stoi argument");

  00317	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
  0031c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xinvalid_argument@std@@YAXPBD@Z
$LN229@UnpackSign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00322	51		 push	 ecx
  00323	56		 push	 esi
  00324	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00329	83 c4 08	 add	 esp, 8
$LN211@UnpackSign:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 68   :     return true;

  0032c	8a c3		 mov	 al, bl

; 69   : }

  0032e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00331	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00338	59		 pop	 ecx
  00339	5f		 pop	 edi
  0033a	5e		 pop	 esi
  0033b	5b		 pop	 ebx
  0033c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033f	33 cd		 xor	 ecx, ebp
  00341	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00346	8b e5		 mov	 esp, ebp
  00348	5d		 pop	 ebp
  00349	c3		 ret	 0
$LN251@UnpackSign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1308 :                 _Xlength();

  0034a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN248@UnpackSign:
  0034f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _tokens$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1:
  00008	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2:
  00010	8d 4d b8	 lea	 ecx, DWORD PTR $T7[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?UnpackSignature@@YA_NPBDAAV?$vector@EV?$allocator@E@std@@@std@@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; UnpackSignature
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00007	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0000e	c2 04 00	 ret	 4
?__autoclassinit2@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ?SearchSignature@@YAKKKPBD0@Z
_TEXT	SEGMENT
tv283 = -16						; size = 4
tv281 = -12						; size = 4
_patternLength$1$ = -8					; size = 4
_baseAddress$1$ = -4					; size = 4
_pattern$ = 8						; size = 4
_mask$ = 12						; size = 4
?SearchSignature@@YAKKKPBD0@Z PROC			; SearchSignature, COMDAT
; _baseAddress$ = ecx
; _moduleSize$ = edx

; 71   : DWORD SearchSignature (DWORD baseAddress, DWORD moduleSize, const char* pattern, const char* mask) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 72   : 
; 73   :     DWORD patternLength = strlen (mask);

  00008	8b 75 0c	 mov	 esi, DWORD PTR _mask$[ebp]
  0000b	57		 push	 edi
  0000c	89 4d fc	 mov	 DWORD PTR _baseAddress$1$[ebp], ecx
  0000f	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
$LL23@SearchSign:
  00012	8a 06		 mov	 al, BYTE PTR [esi]
  00014	46		 inc	 esi
  00015	84 c0		 test	 al, al
  00017	75 f9		 jne	 SHORT $LL23@SearchSign
  00019	2b f7		 sub	 esi, edi
  0001b	89 75 f8	 mov	 DWORD PTR _patternLength$1$[ebp], esi

; 74   : 
; 75   :     if (patternLength > moduleSize) return NULL;

  0001e	3b f2		 cmp	 esi, edx
  00020	77 57		 ja	 SHORT $LN3@SearchSign

; 76   :     if (baseAddress == 0) return NULL;

  00022	85 c9		 test	 ecx, ecx
  00024	74 53		 je	 SHORT $LN3@SearchSign

; 77   : 
; 78   :     for (DWORD offset = 0; offset < baseAddress - patternLength; offset++) {

  00026	8b c1		 mov	 eax, ecx
  00028	33 ff		 xor	 edi, edi
  0002a	2b c6		 sub	 eax, esi
  0002c	89 45 f0	 mov	 DWORD PTR tv283[ebp], eax
  0002f	74 48		 je	 SHORT $LN3@SearchSign
$LL4@SearchSign:

; 79   : 
; 80   :         bool isFound = true;

  00031	33 c0		 xor	 eax, eax
  00033	b3 01		 mov	 bl, 1

; 81   : 
; 82   :         for (DWORD charIterator = 0; charIterator < patternLength; charIterator++) {

  00035	85 f6		 test	 esi, esi
  00037	74 49		 je	 SHORT $LN16@SearchSign

; 79   : 
; 80   :         bool isFound = true;

  00039	8b 55 0c	 mov	 edx, DWORD PTR _mask$[ebp]
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _pattern$[ebp]
  0003f	2b d1		 sub	 edx, ecx
  00041	89 55 f4	 mov	 DWORD PTR tv281[ebp], edx
$LL7@SearchSign:

; 83   :             isFound &= mask [charIterator] == '?' || pattern [charIterator] == * reinterpret_cast<const char*> (baseAddress + offset + charIterator);

  00044	03 c8		 add	 ecx, eax
  00046	80 3c 0a 3f	 cmp	 BYTE PTR [edx+ecx], 63	; 0000003fH
  0004a	74 14		 je	 SHORT $LN12@SearchSign
  0004c	8b 75 fc	 mov	 esi, DWORD PTR _baseAddress$1$[ebp]
  0004f	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  00052	8a 09		 mov	 cl, BYTE PTR [ecx]
  00054	3a 0c 32	 cmp	 cl, BYTE PTR [edx+esi]
  00057	8b 75 f8	 mov	 esi, DWORD PTR _patternLength$1$[ebp]
  0005a	74 04		 je	 SHORT $LN12@SearchSign
  0005c	32 c9		 xor	 cl, cl
  0005e	eb 02		 jmp	 SHORT $LN13@SearchSign
$LN12@SearchSign:
  00060	b1 01		 mov	 cl, 1
$LN13@SearchSign:

; 81   : 
; 82   :         for (DWORD charIterator = 0; charIterator < patternLength; charIterator++) {

  00062	8b 55 f4	 mov	 edx, DWORD PTR tv281[ebp]

; 83   :             isFound &= mask [charIterator] == '?' || pattern [charIterator] == * reinterpret_cast<const char*> (baseAddress + offset + charIterator);

  00065	22 d9		 and	 bl, cl
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _pattern$[ebp]
  0006a	40		 inc	 eax
  0006b	3b c6		 cmp	 eax, esi
  0006d	72 d5		 jb	 SHORT $LL7@SearchSign

; 84   :         }
; 85   : 
; 86   :         if (isFound) {

  0006f	84 db		 test	 bl, bl
  00071	75 0f		 jne	 SHORT $LN16@SearchSign

; 77   : 
; 78   :     for (DWORD offset = 0; offset < baseAddress - patternLength; offset++) {

  00073	47		 inc	 edi
  00074	3b 7d f0	 cmp	 edi, DWORD PTR tv283[ebp]
  00077	72 b8		 jb	 SHORT $LL4@SearchSign
$LN3@SearchSign:
  00079	5f		 pop	 edi

; 88   :         }
; 89   :     }
; 90   : 
; 91   :     return NULL;
; 92   : }

  0007a	5e		 pop	 esi
  0007b	33 c0		 xor	 eax, eax
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
$LN16@SearchSign:

; 87   :             return baseAddress + offset;

  00082	8b 45 fc	 mov	 eax, DWORD PTR _baseAddress$1$[ebp]
  00085	03 c7		 add	 eax, edi
  00087	5f		 pop	 edi

; 88   :         }
; 89   :     }
; 90   : 
; 91   :     return NULL;
; 92   : }

  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?SearchSignature@@YAKKKPBD0@Z ENDP			; SearchSignature
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$emplace_back@AAK@?$vector@KV?$allocator@K@std@@@std@@QAEAAKAAK@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@AAK@?$vector@KV?$allocator@K@std@@@std@@QAEAAKAAK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;
; 703  :         pointer& _Mylast = _My_data._Mylast;
; 704  :         if (_Mylast != _My_data._Myend) {

  00005	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00008	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0000b	74 14		 je	 SHORT $LN2@emplace_ba

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
  00012	89 01		 mov	 DWORD PTR [ecx], eax

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;

  00014	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 690  :         ++_Mylast;

  00017	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0001a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN2@emplace_ba:

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00021	ff 75 08	 push	 DWORD PTR _<_Val_0>$[ebp]
  00024	51		 push	 ecx
  00025	8b ca		 mov	 ecx, edx
  00027	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AAK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKAAK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long &>

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??$emplace_back@AAK@?$vector@KV?$allocator@K@std@@@std@@QAEAAKAAK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AAK@?$vector@KV?$allocator@K@std@@@std@@AAEAAKAAK@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@AAK@?$vector@KV?$allocator@K@std@@@std@@AAEAAKAAK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_back_with_unused_capacity<unsigned long &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;
; 685  :         pointer& _Mylast = _My_data._Mylast;
; 686  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	89 02		 mov	 DWORD PTR [edx], eax

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;

  0000d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 690  :         ++_Mylast;

  00010	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00013	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@AAK@?$vector@KV?$allocator@K@std@@@std@@AAEAAKAAK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_back_with_unused_capacity<unsigned long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00007	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0000e	c2 04 00	 ret	 4
?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ?IsWinXPOrLater@Utils@@SA_NXZ
_TEXT	SEGMENT
_osVersionInfo$ = -280					; size = 276
__$ArrayPad$ = -4					; size = 4
?IsWinXPOrLater@Utils@@SA_NXZ PROC			; Utils::IsWinXPOrLater, COMDAT

; 132  : bool Utils::IsWinXPOrLater () {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 133  : 
; 134  :     //Source: https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversionexa.
; 135  : 
; 136  :     OSVERSIONINFO osVersionInfo;
; 137  :     ZeroMemory (&osVersionInfo, sizeof (OSVERSIONINFO));

  00013	68 14 01 00 00	 push	 276			; 00000114H
  00018	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$[ebp]
  0001e	6a 00		 push	 0
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _memset
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 138  : 
; 139  :     //This causes a little confused. 
; 140  :     //
; 141  :     //If we were unable to fill the structure, then we return true, because the function expects false, 
; 142  :     //this will lead to the fact that the initialization of the loader simply stops, and through the debugger you can see what is wrong. 
; 143  :     if (GetVersionEx (&osVersionInfo)) return true;

  00029	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$[ebp]
  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExW@4
  00036	85 c0		 test	 eax, eax
  00038	75 26		 jne	 SHORT $LN5@IsWinXPOrL

; 144  : 
; 145  :     return ((osVersionInfo.dwMajorVersion > 5) || ((osVersionInfo.dwMajorVersion == 5) && (osVersionInfo.dwMinorVersion >= 1)));

  0003a	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _osVersionInfo$[ebp+4]
  00040	83 f8 05	 cmp	 eax, 5
  00043	77 1b		 ja	 SHORT $LN5@IsWinXPOrL
  00045	75 09		 jne	 SHORT $LN4@IsWinXPOrL
  00047	83 bd f0 fe ff
	ff 01		 cmp	 DWORD PTR _osVersionInfo$[ebp+8], 1
  0004e	73 10		 jae	 SHORT $LN5@IsWinXPOrL
$LN4@IsWinXPOrL:
  00050	32 c0		 xor	 al, al

; 146  : 
; 147  : }

  00052	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00055	33 cd		 xor	 ecx, ebp
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN5@IsWinXPOrL:
  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	b0 01		 mov	 al, 1
  00065	33 cd		 xor	 ecx, ebp
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?IsWinXPOrLater@Utils@@SA_NXZ ENDP			; Utils::IsWinXPOrLater
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ?IsWinServBuild@Utils@@SA_NXZ
_TEXT	SEGMENT
_osVersionInfo$ = -288					; size = 284
__$ArrayPad$ = -4					; size = 4
?IsWinServBuild@Utils@@SA_NXZ PROC			; Utils::IsWinServBuild, COMDAT

; 149  : bool Utils::IsWinServBuild () {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 150  : 
; 151  :     OSVERSIONINFOEX osVersionInfo;
; 152  :     ZeroMemory (&osVersionInfo, sizeof(OSVERSIONINFO));

  00013	68 14 01 00 00	 push	 276			; 00000114H
  00018	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$[ebp]
  0001e	6a 00		 push	 0
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _memset
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 153  : 
; 154  :     //This causes a little confused. 
; 155  :     //
; 156  :     //If we were unable to fill the structure, then we return true, because the function expects false, 
; 157  :     //this will lead to the fact that the initialization of the loader simply stops, and through the debugger you can see what is wrong.
; 158  :     if (GetVersionEx ((LPOSVERSIONINFO) &osVersionInfo)) return true;

  00029	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _osVersionInfo$[ebp]
  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExW@4
  00036	85 c0		 test	 eax, eax
  00038	74 10		 je	 SHORT $LN2@IsWinServB
  0003a	b0 01		 mov	 al, 1

; 161  : 
; 162  : }

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003f	33 cd		 xor	 ecx, ebp
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN2@IsWinServB:

; 159  : 
; 160  :     return osVersionInfo.wProductType == VER_NT_WORKSTATION;

  0004a	80 7d fa 01	 cmp	 BYTE PTR _osVersionInfo$[ebp+282], 1

; 161  : 
; 162  : }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00051	0f 94 c0	 sete	 al
  00054	33 cd		 xor	 ecx, ebp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?IsWinServBuild@Utils@@SA_NXZ ENDP			; Utils::IsWinServBuild
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ?IsRedistPackagePresent@Utils@@SA_NXZ
_TEXT	SEGMENT
$T2 = -220						; size = 196
_regSubKeys$ = -24					; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?IsRedistPackagePresent@Utils@@SA_NXZ PROC		; Utils::IsRedistPackagePresent, COMDAT

; 164  : bool Utils::IsRedistPackagePresent () {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?IsRedistPackagePresent@Utils@@SA_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 152  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00031	c7 85 24 ff ff
	ff 02 00 00 80	 mov	 DWORD PTR $T2[ebp], -2147483646 ; 80000002H
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_1IK@NJBBFKEK@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@
  00040	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp+4]
  00046	66 0f 13 45 e8	 movlpd	 QWORD PTR _regSubKeys$[ebp], xmm0
  0004b	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 169  :     std::map <HKEY, std::wstring> regSubKeys = {

  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 152  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00057	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp+32]
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_1JO@BMHPCMGB@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@
  00062	c7 85 40 ff ff
	ff 02 00 00 80	 mov	 DWORD PTR $T2[ebp+28], -2147483646 ; 80000002H
  0006c	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 169  :     std::map <HKEY, std::wstring> regSubKeys = {

  00071	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 152  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00075	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp+60]
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_1JO@IOMHEKPF@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@
  00080	c7 85 5c ff ff
	ff 02 00 00 80	 mov	 DWORD PTR $T2[ebp+56], -2147483646 ; 80000002H
  0008a	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 169  :     std::map <HKEY, std::wstring> regSubKeys = {

  0008f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 152  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00093	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp+88]
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_1JO@NONGKCIC@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@
  0009e	c7 85 78 ff ff
	ff 02 00 00 80	 mov	 DWORD PTR $T2[ebp+84], -2147483646 ; 80000002H
  000a8	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 169  :     std::map <HKEY, std::wstring> regSubKeys = {

  000ad	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 152  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000b1	8d 4d 98	 lea	 ecx, DWORD PTR $T2[ebp+116]
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MEIAJFDE@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@
  000b9	c7 45 94 00 00
	00 80		 mov	 DWORD PTR $T2[ebp+112], -2147483648 ; 80000000H
  000c0	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 169  :     std::map <HKEY, std::wstring> regSubKeys = {

  000c5	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 152  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000c9	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp+144]
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@PBKLKMMF@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@
  000d1	c7 45 b0 00 00
	00 80		 mov	 DWORD PTR $T2[ebp+140], -2147483648 ; 80000000H
  000d8	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 169  :     std::map <HKEY, std::wstring> regSubKeys = {

  000dd	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 152  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000e1	8d 4d d0	 lea	 ecx, DWORD PTR $T2[ebp+172]
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CKCHEBNC@?$AAI?$AAn?$AAs?$AAt?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?2?$AAD?$AAe?$AAp?$AAe?$AAn@
  000e9	c7 45 cc 00 00
	00 80		 mov	 DWORD PTR $T2[ebp+168], -2147483648 ; 80000000H
  000f0	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 169  :     std::map <HKEY, std::wstring> regSubKeys = {

  000f5	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  000fc	8d b5 24 ff ff
	ff		 lea	 esi, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00102	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00104	8d 5d e8	 lea	 ebx, DWORD PTR $T2[ebp+196]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00107	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _regSubKeys$[ebp], 0
  0010e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _regSubKeys$[ebp+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00115	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  0011a	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0011c	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0011f	89 3f		 mov	 DWORD PTR [edi], edi

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00121	89 7f 04	 mov	 DWORD PTR [edi+4], edi

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00124	89 7f 08	 mov	 DWORD PTR [edi+8], edi

; 347  :         _Pnode->_Color = _Black;

  00127	66 c7 47 0c 01
	01		 mov	 WORD PTR [edi+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0012d	89 7d e8	 mov	 DWORD PTR _regSubKeys$[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map

; 301  :     map(initializer_list<value_type> _Ilist) : _Mybase(key_compare()) {

  00130	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1373 :         for (; _UFirst != _ULast; ++_UFirst) {

  00134	3b f3		 cmp	 esi, ebx
  00136	74 11		 je	 SHORT $LN88@IsRedistPa
$LL89@IsRedistPa:

; 1374 :             _Emplace_hint(_Myhead, *_UFirst);

  00138	56		 push	 esi
  00139	57		 push	 edi
  0013a	8d 4d e8	 lea	 ecx, DWORD PTR _regSubKeys$[ebp]
  0013d	e8 00 00 00 00	 call	 ??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Emplace_hint<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
  00142	83 c6 1c	 add	 esi, 28			; 0000001cH
  00145	3b f3		 cmp	 esi, ebx
  00147	75 ef		 jne	 SHORT $LL89@IsRedistPa
$LN88@IsRedistPa:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 169  :     std::map <HKEY, std::wstring> regSubKeys = {

  00149	68 00 00 00 00	 push	 OFFSET ??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
  0014e	6a 07		 push	 7
  00150	6a 1c		 push	 28			; 0000001cH
  00152	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00158	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00162	8b 75 e8	 mov	 esi, DWORD PTR _regSubKeys$[ebp]
  00165	8b 36		 mov	 esi, DWORD PTR [esi]

; 111  :         return !_Ptr->_Isnil;

  00167	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 185  :     for (const auto& key : regSubKeys) {

  0016b	75 6a		 jne	 SHORT $LN3@IsRedistPa
  0016d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__RegOpenKeyExW@20
$LL253@IsRedistPa:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00173	83 7e 28 08	 cmp	 DWORD PTR [esi+40], 8

; 3676 :         return _Mypair._Myval2._Myptr();

  00177	8d 46 14	 lea	 eax, DWORD PTR [esi+20]

; 2150 :         if (_Large_string_engaged()) {

  0017a	72 02		 jb	 SHORT $LN268@IsRedistPa

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  0017c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN268@IsRedistPa:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 186  :         if (RegOpenKeyExW (key.first, key.second.c_str(), 0, KEY_READ, nullptr)) {

  0017e	6a 00		 push	 0
  00180	68 19 00 02 00	 push	 131097			; 00020019H
  00185	6a 00		 push	 0
  00187	50		 push	 eax
  00188	ff 76 10	 push	 DWORD PTR [esi+16]
  0018b	ff d7		 call	 edi
  0018d	85 c0		 test	 eax, eax
  0018f	0f 85 80 00 00
	00		 jne	 $LN306@IsRedistPa
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00195	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00198	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0019c	74 1d		 je	 SHORT $LN252@IsRedistPa

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0019e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001a1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001a5	75 10		 jne	 SHORT $LN251@IsRedistPa
$LL250@IsRedistPa:
  001a7	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  001aa	75 0b		 jne	 SHORT $LN251@IsRedistPa

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  001ac	8b f0		 mov	 esi, eax
  001ae	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001b5	74 f0		 je	 SHORT $LL250@IsRedistPa
$LN251@IsRedistPa:

; 56   :             }
; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())

  001b7	8b f0		 mov	 esi, eax

; 59   :         } else {

  001b9	eb 16		 jmp	 SHORT $LN310@IsRedistPa
$LN252@IsRedistPa:

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  001bb	8b f0		 mov	 esi, eax

; 451  :         while (!_Pnode->_Left->_Isnil) {

  001bd	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001bf	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001c3	75 0c		 jne	 SHORT $LN310@IsRedistPa
$LL256@IsRedistPa:
  001c5	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  001c7	8b f1		 mov	 esi, ecx
  001c9	8b c8		 mov	 ecx, eax
  001cb	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001cf	74 f4		 je	 SHORT $LL256@IsRedistPa
$LN310@IsRedistPa:

; 111  :         return !_Ptr->_Isnil;

  001d1	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 185  :     for (const auto& key : regSubKeys) {

  001d5	74 9c		 je	 SHORT $LL253@IsRedistPa
$LN3@IsRedistPa:

; 192  :     return false;

  001d7	32 db		 xor	 bl, bl
$LN16@IsRedistPa:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  001d9	8b 45 e8	 mov	 eax, DWORD PTR _regSubKeys$[ebp]
  001dc	ff 70 04	 push	 DWORD PTR [eax+4]
  001df	8d 45 e8	 lea	 eax, DWORD PTR _regSubKeys$[ebp]
  001e2	50		 push	 eax
  001e3	8b c8		 mov	 ecx, eax
  001e5	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  001ea	6a 2c		 push	 44			; 0000002cH
  001ec	ff 75 e8	 push	 DWORD PTR _regSubKeys$[ebp]
  001ef	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001f4	83 c4 08	 add	 esp, 8
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 192  :     return false;

  001f7	8a c3		 mov	 al, bl

; 193  : 
; 194  : }

  001f9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001fc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00203	59		 pop	 ecx
  00204	5f		 pop	 edi
  00205	5e		 pop	 esi
  00206	5b		 pop	 ebx
  00207	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020a	33 cd		 xor	 ecx, ebp
  0020c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c3		 ret	 0
$LN306@IsRedistPa:

; 187  :             RegCloseKey (key.first);

  00215	ff 76 10	 push	 DWORD PTR [esi+16]
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  0021e	b3 01		 mov	 bl, 1
  00220	eb b7		 jmp	 SHORT $LN16@IsRedistPa
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$0:
  00000	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$1:
  0000b	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp+28]
  00011	e9 00 00 00 00	 jmp	 ??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$2:
  00016	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp+56]
  0001c	e9 00 00 00 00	 jmp	 ??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$3:
  00021	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp+84]
  00027	e9 00 00 00 00	 jmp	 ??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$4:
  0002c	8d 4d 94	 lea	 ecx, DWORD PTR $T2[ebp+112]
  0002f	e9 00 00 00 00	 jmp	 ??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$5:
  00034	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp+140]
  00037	e9 00 00 00 00	 jmp	 ??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$7:
  0003c	68 00 00 00 00	 push	 OFFSET ??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
  00041	6a 07		 push	 7
  00043	6a 1c		 push	 28			; 0000001cH
  00045	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00051	c3		 ret	 0
__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$16:
  00052	8d 4d e8	 lea	 ecx, DWORD PTR _regSubKeys$[ebp]
  00055	e9 00 00 00 00	 jmp	 ??1?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::~_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >
__unwindfunclet$?IsRedistPackagePresent@Utils@@SA_NXZ$8:
  0005a	8d 4d e8	 lea	 ecx, DWORD PTR _regSubKeys$[ebp]
  0005d	e9 00 00 00 00	 jmp	 ??1?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@XZ
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
  00066	cc		 int	 3
__ehhandler$?IsRedistPackagePresent@Utils@@SA_NXZ:
  00067	90		 npad	 1
  00068	90		 npad	 1
  00069	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0006d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00070	8b 8a 20 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-224]
  00076	33 c8		 xor	 ecx, eax
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00080	33 c8		 xor	 ecx, eax
  00082	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00087	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?IsRedistPackagePresent@Utils@@SA_NXZ
  0008c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?IsRedistPackagePresent@Utils@@SA_NXZ ENDP		; Utils::IsRedistPackagePresent
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ PROC ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::~pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00006	83 f9 08	 cmp	 ecx, 8

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 2e		 jb	 SHORT $LN15@pair
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000e	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001b	72 12		 jb	 SHORT $LN25@pair

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00020	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00023	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00025	83 c0 fc	 add	 eax, -4			; fffffffcH
  00028	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002b	77 22		 ja	 SHORT $LN22@pair

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002d	8b c2		 mov	 eax, edx
$LN25@pair:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002f	51		 push	 ecx
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	83 c4 08	 add	 esp, 8
$LN15@pair:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00039	33 c0		 xor	 eax, eax
  0003b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00042	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00049	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  0004d	5e		 pop	 esi
  0004e	c3		 ret	 0
$LN22@pair:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN31@pair:
  00055	cc		 int	 3
??1?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ ENDP ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::~pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@XZ PROC ; std::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::~map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0000e	6a 2c		 push	 44			; 0000002cH
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??1?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::~map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAEXI@Z PROC ; std::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00007	c2 04 00	 ret	 4
?__autoclassinit2@?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAEXI@Z ENDP ; std::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	c2 04 00	 ret	 4
?__autoclassinit2@?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??E?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::operator++, COMDAT
; _this$ = ecx

; 140  :     _Tree_unchecked_iterator& operator++() {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00004	8b 16		 mov	 edx, DWORD PTR [esi]
  00006	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  00009	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0000d	74 22		 je	 SHORT $LN6@operator

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0000f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00012	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00016	75 12		 jne	 SHORT $LN21@operator
$LL4@operator:
  00018	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0001b	75 0d		 jne	 SHORT $LN21@operator

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	8b d0		 mov	 edx, eax
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 ee		 je	 SHORT $LL4@operator
$LN21@operator:

; 141  :         _Mybase::operator++();
; 142  :         return *this;

  0002a	89 06		 mov	 DWORD PTR [esi], eax

; 143  :     }

  0002c	8b c6		 mov	 eax, esi
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	c3		 ret	 0
$LN6@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00031	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00033	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00037	75 13		 jne	 SHORT $LN11@operator
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@operator:
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00042	8b f9		 mov	 edi, ecx
  00044	8b c8		 mov	 ecx, eax
  00046	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004a	74 f4		 je	 SHORT $LL10@operator
$LN11@operator:

; 141  :         _Mybase::operator++();
; 142  :         return *this;

  0004c	89 3e		 mov	 DWORD PTR [esi], edi

; 143  :     }

  0004e	8b c6		 mov	 eax, esi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	c3		 ret	 0
??E?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??D?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@XZ PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::operator*, COMDAT
; _this$ = ecx

; 44   :         return _Ptr->_Myval;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 133  :         return const_cast<reference>(_Mybase::operator*());
; 134  :     }

  00005	c3		 ret	 0
??D?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@XZ ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator!=, COMDAT
; _this$ = ecx

; 111  :         return !_Ptr->_Isnil;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00006	0f 94 c0	 sete	 al

; 112  :     }

  00009	c2 04 00	 ret	 4
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ??0?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@0@Z PROC ; std::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@0@Z ENDP ; std::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
;	COMDAT ??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -24					; size = 4
_this$ = -20						; size = 4
tv850 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ilist$ = 8						; size = 8
??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z PROC ; std::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >, COMDAT
; _this$ = ecx

; 301  :     map(initializer_list<value_type> _Ilist) : _Mybase(key_compare()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	8b 45 0c	 mov	 eax, DWORD PTR __Ilist$[ebp+4]
  00030	8b 75 08	 mov	 esi, DWORD PTR __Ilist$[ebp]
  00033	89 7d e8	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00036	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map

; 301  :     map(initializer_list<value_type> _Ilist) : _Mybase(key_compare()) {

  00038	89 45 f0	 mov	 DWORD PTR tv850[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0003b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00041	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00048	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  0004d	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0004f	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00052	89 1b		 mov	 DWORD PTR [ebx], ebx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00054	89 5b 04	 mov	 DWORD PTR [ebx+4], ebx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00057	89 5b 08	 mov	 DWORD PTR [ebx+8], ebx

; 347  :         _Pnode->_Color = _Black;

  0005a	66 c7 43 0c 01
	01		 mov	 WORD PTR [ebx+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00060	89 1f		 mov	 DWORD PTR [edi], ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map

; 301  :     map(initializer_list<value_type> _Ilist) : _Mybase(key_compare()) {

  00062	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1373 :         for (; _UFirst != _ULast; ++_UFirst) {

  00069	3b 75 f0	 cmp	 esi, DWORD PTR tv850[ebp]
  0006c	74 13		 je	 SHORT $LN199@map
  0006e	66 90		 npad	 2
$LL48@map:

; 1374 :             _Emplace_hint(_Myhead, *_UFirst);

  00070	56		 push	 esi
  00071	53		 push	 ebx
  00072	8b cf		 mov	 ecx, edi
  00074	e8 00 00 00 00	 call	 ??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Emplace_hint<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
  00079	83 c6 1c	 add	 esi, 28			; 0000001cH
  0007c	3b 75 f0	 cmp	 esi, DWORD PTR tv850[ebp]
  0007f	75 ef		 jne	 SHORT $LL48@map
$LN199@map:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map

; 303  :     }

  00081	8b c7		 mov	 eax, edi
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z$0:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::~_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$map@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@@std@@QAE@V?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@1@@Z ENDP ; std::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::map<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Unchecked_end@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QBE?AU_Default_sentinel@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QBE?AU_Default_sentinel@2@XZ PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Unchecked_end, COMDAT
; _this$dead$ = ecx

; 1264 :     _Default_sentinel _Unchecked_end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1265 :         return {};

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1266 :     }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Unchecked_end@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QBE?AU_Default_sentinel@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1256 :     _Unchecked_iterator _Unchecked_begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1257 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1258 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::~_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >, COMDAT
; _this$ = ecx

; 1187 :     ~_Tree() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0000e	6a 2c		 push	 44			; 0000002cH
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1194 :     }

  0001b	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::~_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::clear, COMDAT
; _this$ = ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);
; 1390 :         _Mylast = _Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1391 :     }

  00005	c3		 ret	 0
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?reserve@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::reserve, COMDAT
; _this$ = ecx

; 1304 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1305 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1306 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00008	8b 55 08	 mov	 edx, DWORD PTR __Newcapacity$[ebp]
  0000b	3b d0		 cmp	 edx, eax
  0000d	76 11		 jbe	 SHORT $LN2@reserve

; 1307 :             if (_Newcapacity > max_size()) {

  0000f	81 fa ff ff ff
	7f		 cmp	 edx, 2147483647		; 7fffffffH
  00015	77 0d		 ja	 SHORT $LN10@reserve

; 1309 :             }
; 1310 : 
; 1311 :             _Reallocate_exactly(_Newcapacity);

  00017	89 55 08	 mov	 DWORD PTR __Newcapacity$[ebp], edx

; 1312 :         }
; 1313 :     }

  0001a	5d		 pop	 ebp

; 1309 :             }
; 1310 : 
; 1311 :             _Reallocate_exactly(_Newcapacity);

  0001b	e9 00 00 00 00	 jmp	 ?_Reallocate_exactly@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate_exactly
$LN2@reserve:

; 1312 :         }
; 1313 :     }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN10@reserve:

; 1308 :                 _Xlength();

  00024	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN8@reserve:
  00029	cc		 int	 3
?reserve@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back, COMDAT
; _this$ = ecx

; 720  :     void push_back(_Ty&& _Val) { // insert by moving into element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 704  :         if (_Mylast != _My_data._Myend) {

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00009	74 0e		 je	 SHORT $LN4@push_back

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	8a 00		 mov	 al, BYTE PTR [eax]
  00010	88 02		 mov	 BYTE PTR [edx], al

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  00012	ff 41 04	 inc	 DWORD PTR [ecx+4]

; 721  :         emplace_back(_STD move(_Val));
; 722  :     }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN4@push_back:

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00019	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QAEPAEQAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>

; 721  :         emplace_back(_STD move(_Val));
; 722  :     }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$emplace_back@E@?$vector@EV?$allocator@E@std@@@std@@QAEAAE$$QAE@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@E@?$vector@EV?$allocator@E@std@@@std@@QAEAAE$$QAE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::emplace_back<unsigned char>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;
; 703  :         pointer& _Mylast = _My_data._Mylast;
; 704  :         if (_Mylast != _My_data._Myend) {

  00005	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00008	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0000b	74 14		 je	 SHORT $LN2@emplace_ba

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00010	8a 00		 mov	 al, BYTE PTR [eax]
  00012	88 01		 mov	 BYTE PTR [ecx], al

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;

  00014	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 690  :         ++_Mylast;

  00017	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0001a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN2@emplace_ba:

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00021	ff 75 08	 push	 DWORD PTR _<_Val_0>$[ebp]
  00024	51		 push	 ecx
  00025	8b ca		 mov	 ecx, edx
  00027	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QAEPAEQAE$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??$emplace_back@E@?$vector@EV?$allocator@E@std@@@std@@QAEAAE$$QAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::emplace_back<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;
; 685  :         pointer& _Mylast = _My_data._Mylast;
; 686  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	8a 00		 mov	 al, BYTE PTR [eax]
  0000b	88 02		 mov	 BYTE PTR [edx], al

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;

  0000d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 690  :         ++_Mylast;

  00010	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00013	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@E@?$vector@EV?$allocator@E@std@@@std@@AAEAAE$$QAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 3d		 je	 SHORT $LN4@vector

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN20@vector

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 22		 ja	 SHORT $LN17@vector

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN20@vector:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00035	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  00038	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  0003f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00046	5e		 pop	 esi

; 678  :     }

  00047	c3		 ret	 0
$LN17@vector:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN25@vector:
  0004e	cc		 int	 3
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 445  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 446  :     }

  00006	8b c1		 mov	 eax, ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 445  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 446  :     }

  00016	c3		 ret	 0
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1470 :         return _Mypair._Myval2._Mylast;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1471 :     }

  00003	c3		 ret	 0
?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1462 :         return _Mypair._Myval2._Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1463 :     }

  00002	c3		 ret	 0
?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 64		 je	 SHORT $LN4@vector

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00009	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0000c	56		 push	 esi
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00013	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00016	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001b	8b 37		 mov	 esi, DWORD PTR [edi]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0001d	83 c4 04	 add	 esp, 4

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00020	2b ce		 sub	 ecx, esi
  00022	f7 e9		 imul	 ecx
  00024	c1 fa 02	 sar	 edx, 2
  00027	8b c2		 mov	 eax, edx
  00029	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002c	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002e	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00031	c1 e1 03	 shl	 ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00034	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003a	72 12		 jb	 SHORT $LN22@vector

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003c	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  0003f	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00042	2b f2		 sub	 esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00044	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00047	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004a	77 23		 ja	 SHORT $LN19@vector

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004c	8b f2		 mov	 esi, edx
$LN22@vector:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0004e	51		 push	 ecx
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00055	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00058	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1698 :             _Mylast  = pointer();

  0005e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1699 :             _Myend   = pointer();

  00065	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  0006c	5e		 pop	 esi
$LN4@vector:
  0006d	5f		 pop	 edi

; 678  :     }

  0006e	c3		 ret	 0
$LN19@vector:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@vector:
  00075	cc		 int	 3
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 445  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 446  :     }

  00006	8b c1		 mov	 eax, ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 445  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 446  :     }

  00016	c3		 ret	 0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8

; 2150 :         if (_Large_string_engaged()) {

  00004	72 03		 jb	 SHORT $LN8@c_str

; 3676 :         return _Mypair._Myval2._Myptr();

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3677 :     }

  00008	c3		 ret	 0
$LN8@c_str:

; 3676 :         return _Mypair._Myval2._Myptr();

  00009	8b c1		 mov	 eax, ecx

; 3677 :     }

  0000b	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2728 :     ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 08	 cmp	 ecx, 8

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 2d		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN22@basic_stri

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 21		 ja	 SHORT $LN19@basic_stri

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN22@basic_stri:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00038	33 c0		 xor	 eax, eax
  0003a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	66 89 06	 mov	 WORD PTR [esi], ax
  0004b	5e		 pop	 esi

; 2736 :     }

  0004c	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
  00053	cc		 int	 3
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T11 = -8						; size = 4
__Old_size$1$ = -4					; size = 4
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 3721 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap) { // determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 3722 :         if (_Mypair._Myval2._Myres >= _Newcap) { // requested capacity is not larger than current capacity, ignore

  00008	8b 75 08	 mov	 esi, DWORD PTR __Newcap$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
  00011	89 5d f8	 mov	 DWORD PTR $T11[ebp], ebx
  00014	3b de		 cmp	 ebx, esi
  00016	0f 83 fc 00 00
	00		 jae	 $LN1@reserve

; 3723 :             return; // nothing to do
; 3724 :         }
; 3725 : 
; 3726 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0001c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 3727 :         _Reallocate_grow_by(

  0001f	8b ce		 mov	 ecx, esi
  00021	2b c8		 sub	 ecx, eax
  00023	89 45 fc	 mov	 DWORD PTR __Old_size$1$[ebp], eax

; 4257 :         if (max_size() - _Old_size < _Size_increase) {

  00026	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  0002b	8b c2		 mov	 eax, edx
  0002d	2b 45 fc	 sub	 eax, DWORD PTR __Old_size$1$[ebp]
  00030	3b c1		 cmp	 eax, ecx
  00032	0f 82 e9 00 00
	00		 jb	 $LN69@reserve

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00038	83 ce 0f	 or	 esi, 15			; 0000000fH
  0003b	3b f2		 cmp	 esi, edx

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0003d	76 04		 jbe	 SHORT $LN12@reserve

; 4211 :             return _Max;

  0003f	8b f2		 mov	 esi, edx
  00041	eb 18		 jmp	 SHORT $LN11@reserve
$LN12@reserve:

; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00043	8b c3		 mov	 eax, ebx
  00045	d1 e8		 shr	 eax, 1
  00047	2b d0		 sub	 edx, eax
  00049	3b da		 cmp	 ebx, edx
  0004b	76 07		 jbe	 SHORT $LN13@reserve

; 4215 :             return _Max;

  0004d	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00052	eb 07		 jmp	 SHORT $LN11@reserve
$LN13@reserve:

; 4216 :         }
; 4217 : 
; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  00054	03 c3		 add	 eax, ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  00056	3b f0		 cmp	 esi, eax
  00058	0f 42 f0	 cmovb	 esi, eax
$LN11@reserve:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4265 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0005b	33 c9		 xor	 ecx, ecx
  0005d	8b c6		 mov	 eax, esi
  0005f	83 c0 01	 add	 eax, 1
  00062	0f 92 c1	 setb	 cl
  00065	f7 d9		 neg	 ecx
  00067	0b c8		 or	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00069	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0006f	72 23		 jb	 SHORT $LN20@reserve

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  00071	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 90   :     if (_Block_size <= _Bytes) {

  00074	3b c1		 cmp	 eax, ecx
  00076	0f 86 aa 00 00
	00		 jbe	 $LN70@reserve

; 51   :         return ::operator new(_Bytes);

  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00082	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00085	85 c0		 test	 eax, eax
  00087	74 77		 je	 SHORT $LN56@reserve

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00089	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  0008c	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0008f	89 43 fc	 mov	 DWORD PTR [ebx-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00092	eb 13		 jmp	 SHORT $LN19@reserve
$LN20@reserve:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

  00094	85 c9		 test	 ecx, ecx
  00096	74 0d		 je	 SHORT $LN21@reserve

; 51   :         return ::operator new(_Bytes);

  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009e	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  000a1	8b d8		 mov	 ebx, eax
  000a3	eb 02		 jmp	 SHORT $LN19@reserve
$LN21@reserve:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  000a5	33 db		 xor	 ebx, ebx
$LN19@reserve:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4267 :         _My_data._Mysize      = _New_size;

  000a7	8b 45 08	 mov	 eax, DWORD PTR __Newcap$[ebp]
  000aa	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 4268 :         _My_data._Myres       = _New_capacity;
; 4269 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000ad	8b 45 fc	 mov	 eax, DWORD PTR __Old_size$1$[ebp]
  000b0	40		 inc	 eax
  000b1	89 77 14	 mov	 DWORD PTR [edi+20], esi

; 4270 :         if (_BUF_SIZE <= _Old_capacity) {

  000b4	83 7d f8 10	 cmp	 DWORD PTR $T11[ebp], 16	; 00000010H
  000b8	50		 push	 eax
  000b9	72 4b		 jb	 SHORT $LN6@reserve

; 4271 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000bb	8b 37		 mov	 esi, DWORD PTR [edi]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000bd	56		 push	 esi
  000be	53		 push	 ebx
  000bf	e8 00 00 00 00	 call	 _memcpy

; 4273 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000c4	8b 4d f8	 mov	 ecx, DWORD PTR $T11[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4273 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ca	41		 inc	 ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000cb	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000d1	72 12		 jb	 SHORT $LN59@reserve

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000d3	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000d6	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000d9	2b f2		 sub	 esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000db	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  000de	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000e1	77 1d		 ja	 SHORT $LN56@reserve

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000e3	8b f2		 mov	 esi, edx
$LN59@reserve:

; 195  :     ::operator delete(_Ptr, _Bytes);

  000e5	51		 push	 ecx
  000e6	56		 push	 esi
  000e7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 3732 :         _Mypair._Myval2._Mysize = _Old_size;

  000ec	8b 45 fc	 mov	 eax, DWORD PTR __Old_size$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  000ef	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 3732 :         _Mypair._Myval2._Mysize = _Old_size;

  000f2	89 1f		 mov	 DWORD PTR [edi], ebx
  000f4	89 47 10	 mov	 DWORD PTR [edi+16], eax
  000f7	5f		 pop	 edi

; 3733 :     }

  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
$LN56@reserve:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@reserve:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00106	57		 push	 edi
  00107	53		 push	 ebx
  00108	e8 00 00 00 00	 call	 _memcpy

; 3732 :         _Mypair._Myval2._Mysize = _Old_size;

  0010d	8b 45 fc	 mov	 eax, DWORD PTR __Old_size$1$[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00110	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3732 :         _Mypair._Myval2._Mysize = _Old_size;

  00113	89 1f		 mov	 DWORD PTR [edi], ebx
  00115	89 47 10	 mov	 DWORD PTR [edi+16], eax
$LN1@reserve:

; 3733 :     }

  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c2 04 00	 ret	 4
$LN69@reserve:

; 4258 :             _Xlen_string(); // result too long

  00121	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN70@reserve:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00126	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@reserve:
  0012b	cc		 int	 3
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z@QBEXQADQBDI@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z@QBEXQADQBDI@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1>::operator(), COMDAT
; _this$dead$ = ecx

; 3730 :             });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 333  :     }
; 334  : 
; 335  :     _Pre_satisfies_(_Size_in_bytes >= _Count) static _Elem* _Copy_s(_Out_writes_all_(_Size_in_bytes)
; 336  :                                                                         _Elem* const _First1,
; 337  :         const size_t _Size_in_bytes, _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept {
; 338  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 339  :         _STL_VERIFY(_Count <= _Size_in_bytes, "invalid argument");
; 340  :         return copy(_First1, _First2, _Count);
; 341  :     }
; 342  : 
; 343  :     _NODISCARD static _CONSTEXPR17 const _Elem* find(_In_reads_(_Count) const _Elem* const _First, const size_t _Count,
; 344  :         const _Elem& _Ch) noexcept /* strengthened */ {
; 345  :         // look for _Ch in [_First, _First + _Count)
; 346  : #if _HAS_CXX17
; 347  : #ifdef __cpp_char8_t
; 348  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 349  : #if _HAS_U8_INTRINSICS
; 350  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 351  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 352  :             return _Char_traits<_Elem, _Int_type>::find(_First, _Count, _Ch);
; 353  : #endif // _HAS_U8_INTRINSICS
; 354  :         } else
; 355  : #endif // __cpp_char8_t
; 356  :         {
; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);
; 358  :         }
; 359  : #else // _HAS_CXX17
; 360  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));
; 361  : #endif // _HAS_CXX17
; 362  :     }
; 363  : 
; 364  :     static _Elem* move(_Out_writes_all_(_Count) _Elem* const _First1, _In_reads_(_Count) const _Elem* const _First2,
; 365  :         const size_t _Count) noexcept /* strengthened */ {
; 366  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));
; 368  :     }
; 369  : 
; 370  :     static _Elem* assign(_Out_writes_all_(_Count) _Elem* const _First, const size_t _Count,
; 371  :         const _Elem _Ch) noexcept /* strengthened */ {
; 372  :         // assign _Count * _Ch to [_First, ...)
; 373  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));
; 374  :     }
; 375  : 
; 376  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {
; 377  :         _Left = _Right;
; 378  :     }
; 379  : 
; 380  :     _NODISCARD static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
; 381  :         return _Left == _Right;
; 382  :     }
; 383  : 
; 384  :     _NODISCARD static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
; 385  :         return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
; 386  :     }
; 387  : 
; 388  :     _NODISCARD static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
; 389  :         return static_cast<_Elem>(_Meta);
; 390  :     }
; 391  : 
; 392  :     _NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
; 393  :         return static_cast<unsigned char>(_Ch);
; 394  :     }
; 395  : 
; 396  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
; 397  :         return _Left == _Right;
; 398  :     }
; 399  : 
; 400  :     _NODISCARD static constexpr int_type not_eof(const int_type& _Meta) noexcept {
; 401  :         return _Meta != eof() ? _Meta : !eof();
; 402  :     }
; 403  : 
; 404  :     _NODISCARD static constexpr int_type eof() noexcept {
; 405  :         return static_cast<int_type>(EOF);
; 406  :     }
; 407  : };
; 408  : 
; 409  : #undef _HAS_U8_INTRINSICS
; 410  : 
; 411  : // STRUCT char_traits<char> (FROM <string>)
; 412  : template <>
; 413  : struct char_traits<char> : _Narrow_char_traits<char, int> {}; // properties of a string or stream char element
; 414  : 
; 415  : #ifdef __cpp_char8_t
; 416  : // STRUCT char_traits<char8_t>
; 417  : template <>
; 418  : struct char_traits<char8_t> : _Narrow_char_traits<char8_t, unsigned int> {};
; 419  : 
; 420  : #ifdef __cpp_lib_char8_t
; 421  : using u8streampos = streampos;
; 422  : #endif // __cpp_lib_char8_t
; 423  : #endif // __cpp_char8_t
; 424  : 
; 425  : template <class _Elem, class _Traits, class _SizeT>
; 426  : basic_ostream<_Elem, _Traits>& _Insert_string(
; 427  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {
; 428  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 429  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 430  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;
; 431  : 
; 432  :     _SizeT _Pad;
; 433  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
; 434  :         _Pad = 0;
; 435  :     } else {
; 436  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
; 437  :     }
; 438  : 
; 439  :     const typename _Ostr_t::sentry _Ok(_Ostr);
; 440  : 
; 441  :     if (!_Ok) {
; 442  :         _State |= _Ostr_t::badbit;
; 443  :     } else { // state okay, insert characters
; 444  :         _TRY_IO_BEGIN
; 445  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
; 446  :             for (; 0 < _Pad; --_Pad) { // pad on left
; 447  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 448  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 449  :                     break;
; 450  :                 }
; 451  :             }
; 452  :         }
; 453  : 
; 454  :         if (_State == _Ostr_t::goodbit
; 455  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
; 456  :             _State |= _Ostr_t::badbit;
; 457  :         } else {
; 458  :             for (; 0 < _Pad; --_Pad) { // pad on right
; 459  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 460  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 461  :                     break;
; 462  :                 }
; 463  :             }
; 464  :         }
; 465  : 
; 466  :         _Ostr.width(0);
; 467  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 468  :     }
; 469  : 
; 470  :     _Ostr.setstate(_State);
; 471  :     return _Ostr;
; 472  : }
; 473  : 
; 474  : // STRUCT TEMPLATE _Char_traits_eq
; 475  : template <class _Traits>
; 476  : struct _Char_traits_eq {
; 477  :     using _Elem = typename _Traits::char_type;
; 478  : 
; 479  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 480  :         return _Traits::eq(_Left, _Right);
; 481  :     }
; 482  : };
; 483  : 
; 484  : // STRUCT TEMPLATE _Char_traits_lt
; 485  : template <class _Traits>
; 486  : struct _Char_traits_lt {
; 487  :     using _Elem = typename _Traits::char_type;
; 488  : 
; 489  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 490  :         return _Traits::lt(_Left, _Right);
; 491  :     }
; 492  : };
; 493  : 
; 494  : template <class _Elem>
; 495  : struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
; 496  :     : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type { // builtin char_traits::eq behaves like equal_to<>
; 497  : };
; 498  : 
; 499  : template <class _Traits>
; 500  : using _Traits_ch_t = typename _Traits::char_type;
; 501  : 
; 502  : template <class _Traits>
; 503  : using _Traits_ptr_t = const typename _Traits::char_type*;
; 504  : 
; 505  : template <class _Traits>
; 506  : constexpr bool _Traits_equal(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 507  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
; 508  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
; 510  : }
; 511  : 
; 512  : template <class _Traits>
; 513  : constexpr int _Traits_compare(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 514  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
; 515  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 516  :     const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));
; 517  : 
; 518  :     if (_Ans != 0) {
; 519  :         return _Ans;
; 520  :     }
; 521  : 
; 522  :     if (_Left_size < _Right_size) {
; 523  :         return -1;
; 524  :     }
; 525  : 
; 526  :     if (_Left_size > _Right_size) {
; 527  :         return 1;
; 528  :     }
; 529  : 
; 530  :     return 0;
; 531  : }
; 532  : 
; 533  : template <class _Traits>
; 534  : constexpr size_t _Traits_find(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 535  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 536  :     const size_t _Needle_size) noexcept {
; 537  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 538  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
; 539  :         // xpos cannot exist, report failure
; 540  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 541  :         // 1. _Start_at <= xpos
; 542  :         // 2. xpos + _Needle_size <= _Hay_size;
; 543  :         // therefore:
; 544  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 545  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 546  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 547  :         return static_cast<size_t>(-1);
; 548  :     }
; 549  : 
; 550  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 551  :         return _Start_at;
; 552  :     }
; 553  : 
; 554  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
; 555  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 556  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
; 557  :         if (!_Match_try) { // didn't find first character; report failure
; 558  :             return static_cast<size_t>(-1);
; 559  :         }
; 560  : 
; 561  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match
; 562  :             return static_cast<size_t>(_Match_try - _Haystack);
; 563  :         }
; 564  :     }
; 565  : }
; 566  : 
; 567  : template <class _Traits>
; 568  : constexpr size_t _Traits_find_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 569  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 570  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch, at/after _Start_at
; 571  :     if (_Start_at < _Hay_size) {
; 572  :         const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
; 573  :         if (_Found_at) {
; 574  :             return static_cast<size_t>(_Found_at - _Haystack);
; 575  :         }
; 576  :     }
; 577  : 
; 578  :     return static_cast<size_t>(-1); // (npos) no match
; 579  : }
; 580  : 
; 581  : template <class _Traits>
; 582  : constexpr size_t _Traits_rfind(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 583  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 584  :     const size_t _Needle_size) noexcept {
; 585  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size) beginning before _Start_at
; 586  :     if (_Needle_size == 0) {
; 587  :         return _Min_value(_Start_at, _Hay_size); // empty string always matches
; 588  :     }
; 589  : 
; 590  :     if (_Needle_size <= _Hay_size) { // room for match, look for it
; 591  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
; 592  :             if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
; 593  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 594  :             }
; 595  : 
; 596  :             if (_Match_try == _Haystack) {
; 597  :                 break; // at beginning, no more chance for match
; 598  :             }
; 599  :         }
; 600  :     }
; 601  : 
; 602  :     return static_cast<size_t>(-1); // no match
; 603  : }
; 604  : 
; 605  : template <class _Traits>
; 606  : constexpr size_t _Traits_rfind_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 607  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 608  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
; 609  :     if (_Hay_size != 0) { // room for match, look for it
; 610  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 611  :             if (_Traits::eq(*_Match_try, _Ch)) {
; 612  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 613  :             }
; 614  : 
; 615  :             if (_Match_try == _Haystack) {
; 616  :                 break; // at beginning, no more chance for match
; 617  :             }
; 618  :         }
; 619  :     }
; 620  : 
; 621  :     return static_cast<size_t>(-1); // no match
; 622  : }
; 623  : 
; 624  : template <class _Elem, bool = _Is_character<_Elem>::value>
; 625  : class _String_bitmap { // _String_bitmap for character types
; 626  : public:
; 627  :     constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
; 628  :         // mark this bitmap such that the characters in [_First, _Last) are intended to match
; 629  :         // returns whether all inputs can be placed in the bitmap
; 630  :         for (; _First != _Last; ++_First) {
; 631  :             _Matches[static_cast<unsigned char>(*_First)] = true;
; 632  :         }
; 633  : 
; 634  :         return true;
; 635  :     }
; 636  : 
; 637  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 638  :         return _Matches[static_cast<unsigned char>(_Ch)];
; 639  :     }
; 640  : 
; 641  : private:
; 642  :     bool _Matches[256] = {};
; 643  : };
; 644  : 
; 645  : template <class _Elem>
; 646  : class _String_bitmap<_Elem, false> { // _String_bitmap for wchar_t/unsigned short/char16_t/char32_t/etc. types
; 647  : public:
; 648  :     static_assert(is_unsigned_v<_Elem>,
; 649  :         "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
; 650  :         "Visual C++ accepts other unsigned integral types as an extension.");
; 651  : 
; 652  :     constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
; 653  :         // mark this bitmap such that the characters in [_First, _Last) are intended to match
; 654  :         // returns whether all inputs can be placed in the bitmap
; 655  :         for (; _First != _Last; ++_First) {
; 656  :             const auto _Ch = *_First;
; 657  :             if (_Ch >= 256U) {
; 658  :                 return false;
; 659  :             }
; 660  : 
; 661  :             _Matches[static_cast<unsigned char>(_Ch)] = true;
; 662  :         }
; 663  : 
; 664  :         return true;
; 665  :     }
; 666  : 
; 667  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 668  :         return _Ch < 256U && _Matches[_Ch];
; 669  :     }
; 670  : 
; 671  : private:
; 672  :     bool _Matches[256] = {};
; 673  : };
; 674  : 
; 675  : template <class _Traits>
; 676  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 677  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 678  :     const size_t _Needle_size, false_type) noexcept {
; 679  :     // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 680  :     // general algorithm
; 681  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 682  :         const auto _End = _Haystack + _Hay_size;
; 683  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 684  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 685  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 686  :             }
; 687  :         }
; 688  :     }
; 689  : 
; 690  :     return static_cast<size_t>(-1); // no match
; 691  : }
; 692  : 
; 693  : template <class _Traits>
; 694  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 695  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 696  :     const size_t _Needle_size, true_type) noexcept {
; 697  :     // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 698  :     // special case for std::char_traits
; 699  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 700  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 701  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 702  :                                                                 // fall back to the serial algorithm
; 703  :             return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 704  :         }
; 705  : 
; 706  :         const auto _End = _Haystack + _Hay_size;
; 707  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 708  :             if (_Matches._Match(*_Match_try)) {
; 709  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 710  :             }
; 711  :         }
; 712  :     }
; 713  : 
; 714  :     return static_cast<size_t>(-1); // no match
; 715  : }
; 716  : 
; 717  : template <class _Traits>
; 718  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 719  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 720  :     const size_t _Needle_size, false_type) noexcept {
; 721  :     // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
; 722  :     // general algorithm
; 723  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 724  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 725  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 726  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 727  :             }
; 728  : 
; 729  :             if (_Match_try == _Haystack) {
; 730  :                 break; // at beginning, no more chance for match
; 731  :             }
; 732  :         }
; 733  :     }
; 734  : 
; 735  :     return static_cast<size_t>(-1); // no match
; 736  : }
; 737  : 
; 738  : template <class _Traits>
; 739  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 740  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 741  :     const size_t _Needle_size, true_type) noexcept {
; 742  :     // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
; 743  :     // special case for std::char_traits
; 744  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 745  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 746  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 747  :                                                                 // fall back to the serial algorithm
; 748  :             return _Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 749  :         }
; 750  : 
; 751  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 752  :             if (_Matches._Match(*_Match_try)) {
; 753  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 754  :             }
; 755  : 
; 756  :             if (_Match_try == _Haystack) {
; 757  :                 break; // at beginning, no more chance for match
; 758  :             }
; 759  :         }
; 760  :     }
; 761  : 
; 762  :     return static_cast<size_t>(-1); // no match
; 763  : }
; 764  : 
; 765  : template <class _Traits>
; 766  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 767  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 768  :     const size_t _Needle_size, false_type) noexcept {
; 769  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 770  :     // general algorithm
; 771  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 772  :         const auto _End = _Haystack + _Hay_size;
; 773  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 774  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 775  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 776  :             }
; 777  :         }
; 778  :     }
; 779  : 
; 780  :     return static_cast<size_t>(-1); // no match
; 781  : }
; 782  : 
; 783  : template <class _Traits>
; 784  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 785  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 786  :     const size_t _Needle_size, true_type) noexcept {
; 787  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 788  :     // special case for std::char_traits
; 789  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 790  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 791  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 792  :                                                                 // fall back to the serial algorithm
; 793  :             return _Traits_find_first_not_of<_Traits>(
; 794  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 795  :         }
; 796  : 
; 797  :         const auto _End = _Haystack + _Hay_size;
; 798  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 799  :             if (!_Matches._Match(*_Match_try)) {
; 800  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 801  :             }
; 802  :         }
; 803  :     }
; 804  : 
; 805  :     return static_cast<size_t>(-1); // no match
; 806  : }
; 807  : 
; 808  : template <class _Traits>
; 809  : constexpr size_t _Traits_find_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 810  :     const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 811  :     // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch, at/after _Start_at
; 812  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 813  :         const auto _End = _Haystack + _Hay_size;
; 814  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 815  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 816  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 817  :             }
; 818  :         }
; 819  :     }
; 820  : 
; 821  :     return static_cast<size_t>(-1); // no match
; 822  : }
; 823  : 
; 824  : template <class _Traits>
; 825  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 826  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 827  :     const size_t _Needle_size, false_type) noexcept {
; 828  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
; 829  :     // general algorithm
; 830  :     if (_Hay_size != 0) { // worth searching, do it
; 831  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 832  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 833  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 834  :             }
; 835  : 
; 836  :             if (_Match_try == _Haystack) {
; 837  :                 break; // at beginning, no more chance for match
; 838  :             }
; 839  :         }
; 840  :     }
; 841  : 
; 842  :     return static_cast<size_t>(-1); // no match
; 843  : }
; 844  : 
; 845  : template <class _Traits>
; 846  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 847  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 848  :     const size_t _Needle_size, true_type) noexcept {
; 849  :     // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
; 850  :     // special case for std::char_traits
; 851  :     if (_Hay_size != 0) { // worth searching, do it
; 852  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 853  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 854  :                                                                 // fall back to the serial algorithm
; 855  :             return _Traits_find_last_not_of<_Traits>(
; 856  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 857  :         }
; 858  : 
; 859  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 860  :             if (!_Matches._Match(*_Match_try)) {
; 861  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 862  :             }
; 863  : 
; 864  :             if (_Match_try == _Haystack) {
; 865  :                 break; // at beginning, no more chance for match
; 866  :             }
; 867  :         }
; 868  :     }
; 869  : 
; 870  :     return static_cast<size_t>(-1); // no match
; 871  : }
; 872  : 
; 873  : template <class _Traits>
; 874  : constexpr size_t _Traits_rfind_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 875  :     const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
; 876  :     // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch before _Start_at
; 877  :     if (_Hay_size != 0) { // room for match, look for it
; 878  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 879  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 880  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 881  :             }
; 882  : 
; 883  :             if (_Match_try == _Haystack) {
; 884  :                 break; // at beginning, no more chance for match
; 885  :             }
; 886  :         }
; 887  :     }
; 888  : 
; 889  :     return static_cast<size_t>(-1); // no match
; 890  : }
; 891  : 
; 892  : 
; 893  : #if _HAS_CXX17
; 894  : // CLASS TEMPLATE _String_view_iterator
; 895  : template <class _Elem, class _Traits = char_traits<_Elem>>
; 896  : class basic_string_view;
; 897  : 
; 898  : template <class _Traits>
; 899  : class _String_view_iterator {
; 900  : public:
; 901  : #ifdef __cpp_lib_concepts
; 902  :     using iterator_concept = contiguous_iterator_tag;
; 903  : #endif // __cpp_lib_concepts
; 904  :     using iterator_category = random_access_iterator_tag;
; 905  :     using value_type        = typename _Traits::char_type;
; 906  :     using difference_type   = ptrdiff_t;
; 907  :     using pointer           = const value_type*;
; 908  :     using reference         = const value_type&;
; 909  : 
; 910  :     constexpr _String_view_iterator() noexcept = default;
; 911  : 
; 912  : private:
; 913  :     friend basic_string_view<value_type, _Traits>;
; 914  : 
; 915  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 916  :     constexpr _String_view_iterator(const pointer _Data, const size_t _Size, const size_t _Off) noexcept
; 917  :         : _Mydata(_Data), _Mysize(_Size), _Myoff(_Off) {}
; 918  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 919  :     constexpr explicit _String_view_iterator(const pointer _Ptr) noexcept : _Myptr(_Ptr) {}
; 920  : #endif // _ITERATOR_DEBUG_LEVEL
; 921  : 
; 922  : public:
; 923  :     _NODISCARD constexpr reference operator*() const noexcept {
; 924  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 925  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 926  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 927  :         return _Mydata[_Myoff];
; 928  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 929  :         return *_Myptr;
; 930  : #endif // _ITERATOR_DEBUG_LEVEL
; 931  :     }
; 932  : 
; 933  :     _NODISCARD constexpr pointer operator->() const noexcept {
; 934  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 935  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 936  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 937  :         return _Mydata + _Myoff;
; 938  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 939  :         return _Myptr;
; 940  : #endif // _ITERATOR_DEBUG_LEVEL
; 941  :     }
; 942  : 
; 943  :     constexpr _String_view_iterator& operator++() noexcept {
; 944  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 945  :         _STL_VERIFY(_Mydata, "cannot increment value-initialized string_view iterator");
; 946  :         _STL_VERIFY(_Myoff < _Mysize, "cannot increment string_view iterator past end");
; 947  :         ++_Myoff;
; 948  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 949  :         ++_Myptr;
; 950  : #endif // _ITERATOR_DEBUG_LEVEL
; 951  :         return *this;
; 952  :     }
; 953  : 
; 954  :     constexpr _String_view_iterator operator++(int) noexcept {
; 955  :         _String_view_iterator _Tmp{*this};
; 956  :         ++*this;
; 957  :         return _Tmp;
; 958  :     }
; 959  : 
; 960  :     constexpr _String_view_iterator& operator--() noexcept {
; 961  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 962  :         _STL_VERIFY(_Mydata, "cannot decrement value-initialized string_view iterator");
; 963  :         _STL_VERIFY(_Myoff != 0, "cannot decrement string_view iterator before begin");
; 964  :         --_Myoff;
; 965  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 966  :         --_Myptr;
; 967  : #endif // _ITERATOR_DEBUG_LEVEL
; 968  :         return *this;
; 969  :     }
; 970  : 
; 971  :     constexpr _String_view_iterator operator--(int) noexcept {
; 972  :         _String_view_iterator _Tmp{*this};
; 973  :         --*this;
; 974  :         return _Tmp;
; 975  :     }
; 976  : 
; 977  :     constexpr void _Verify_offset(const difference_type _Off) const noexcept {
; 978  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 979  :         if (_Off != 0) {
; 980  :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 981  :         }
; 982  : 
; 983  :         if (_Off < 0) {
; 984  : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 985  :             _STL_VERIFY(_Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 986  :         }
; 987  : 
; 988  :         if (_Off > 0) {
; 989  :             _STL_VERIFY(_Mysize - _Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 990  :         }
; 991  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 992  :         (void) _Off;
; 993  : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 994  :     }
; 995  : 
; 996  :     constexpr _String_view_iterator& operator+=(const difference_type _Off) noexcept {
; 997  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 998  :         _Verify_offset(_Off);
; 999  :         _Myoff += _Off;
; 1000 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1001 :         _Myptr += _Off;
; 1002 : #endif // _ITERATOR_DEBUG_LEVEL
; 1003 : 
; 1004 :         return *this;
; 1005 :     }
; 1006 : 
; 1007 :     _NODISCARD constexpr _String_view_iterator operator+(const difference_type _Off) const noexcept {
; 1008 :         _String_view_iterator _Tmp{*this};
; 1009 :         _Tmp += _Off;
; 1010 :         return _Tmp;
; 1011 :     }
; 1012 : 
; 1013 :     constexpr _String_view_iterator& operator-=(const difference_type _Off) noexcept {
; 1014 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1015 :         if (_Off != 0) {
; 1016 :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 1017 :         }
; 1018 : 
; 1019 :         if (_Off > 0) {
; 1020 :             _STL_VERIFY(_Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 1021 :         }
; 1022 : 
; 1023 :         if (_Off < 0) {
; 1024 : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 1025 :             _STL_VERIFY(_Mysize - _Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 1026 :         }
; 1027 : 
; 1028 :         _Myoff -= _Off;
; 1029 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1030 :         _Myptr -= _Off;
; 1031 : #endif // _ITERATOR_DEBUG_LEVEL
; 1032 : 
; 1033 :         return *this;
; 1034 :     }
; 1035 : 
; 1036 :     _NODISCARD constexpr _String_view_iterator operator-(const difference_type _Off) const noexcept {
; 1037 :         _String_view_iterator _Tmp{*this};
; 1038 :         _Tmp -= _Off;
; 1039 :         return _Tmp;
; 1040 :     }
; 1041 : 
; 1042 :     _NODISCARD constexpr difference_type operator-(const _String_view_iterator& _Right) const noexcept {
; 1043 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1044 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1045 :             "cannot subtract incompatible string_view iterators");
; 1046 :         return static_cast<difference_type>(_Myoff - _Right._Myoff);
; 1047 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1048 :         return _Myptr - _Right._Myptr;
; 1049 : #endif // _ITERATOR_DEBUG_LEVEL
; 1050 :     }
; 1051 : 
; 1052 :     _NODISCARD constexpr reference operator[](const difference_type _Off) const noexcept {
; 1053 :         return *(*this + _Off);
; 1054 :     }
; 1055 : 
; 1056 :     _NODISCARD constexpr bool operator==(const _String_view_iterator& _Right) const noexcept {
; 1057 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1058 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1059 :             "cannot compare incompatible string_view iterators for equality");
; 1060 :         return _Myoff == _Right._Myoff;
; 1061 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1062 :         return _Myptr == _Right._Myptr;
; 1063 : #endif // _ITERATOR_DEBUG_LEVEL
; 1064 :     }
; 1065 : 
; 1066 :     _NODISCARD constexpr bool operator!=(const _String_view_iterator& _Right) const noexcept {
; 1067 :         return !(*this == _Right);
; 1068 :     }
; 1069 : 
; 1070 :     _NODISCARD constexpr bool operator<(const _String_view_iterator& _Right) const noexcept {
; 1071 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1072 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1073 :             "cannot compare incompatible string_view iterators");
; 1074 :         return _Myoff < _Right._Myoff;
; 1075 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1076 :         return _Myptr < _Right._Myptr;
; 1077 : #endif // _ITERATOR_DEBUG_LEVEL
; 1078 :     }
; 1079 : 
; 1080 :     _NODISCARD constexpr bool operator>(const _String_view_iterator& _Right) const noexcept {
; 1081 :         return _Right < *this;
; 1082 :     }
; 1083 : 
; 1084 :     _NODISCARD constexpr bool operator<=(const _String_view_iterator& _Right) const noexcept {
; 1085 :         return !(_Right < *this);
; 1086 :     }
; 1087 : 
; 1088 :     _NODISCARD constexpr bool operator>=(const _String_view_iterator& _Right) const noexcept {
; 1089 :         return !(*this < _Right);
; 1090 :     }
; 1091 : 
; 1092 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1093 :     friend constexpr void _Verify_range(const _String_view_iterator& _First, const _String_view_iterator& _Last) {
; 1094 :         _STL_VERIFY(_First._Mydata == _Last._Mydata && _First._Mysize == _Last._Mysize,
; 1095 :             "string_view iterators in range are from different views");
; 1096 :         _STL_VERIFY(_First._Myoff <= _Last._Myoff, "string_view iterator range transposed");
; 1097 :     }
; 1098 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1099 : 
; 1100 :     using _Prevent_inheriting_unwrap = _String_view_iterator;
; 1101 : 
; 1102 :     _NODISCARD constexpr pointer _Unwrapped() const noexcept {
; 1103 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1104 :         return _Mydata + _Myoff;
; 1105 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1106 :         return _Myptr;
; 1107 : #endif // _ITERATOR_DEBUG_LEVEL
; 1108 :     }
; 1109 : 
; 1110 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1111 : 
; 1112 :     constexpr void _Seek_to(pointer _It) noexcept {
; 1113 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1114 :         _Myoff = static_cast<size_t>(_It - _Mydata);
; 1115 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1116 :         _Myptr = _It;
; 1117 : #endif // _ITERATOR_DEBUG_LEVEL
; 1118 :     }
; 1119 : 
; 1120 : private:
; 1121 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1122 :     pointer _Mydata = nullptr;
; 1123 :     size_t _Mysize  = 0;
; 1124 :     size_t _Myoff   = 0;
; 1125 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1126 :     pointer _Myptr = nullptr;
; 1127 : #endif // _ITERATOR_DEBUG_LEVEL
; 1128 : };
; 1129 : 
; 1130 : template <class _Traits>
; 1131 : _NODISCARD constexpr _String_view_iterator<_Traits> operator+(
; 1132 :     const typename _String_view_iterator<_Traits>::difference_type _Off,
; 1133 :     _String_view_iterator<_Traits> _Right) noexcept {
; 1134 :     _Right += _Off;
; 1135 :     return _Right;
; 1136 : }
; 1137 : 
; 1138 : #if _HAS_CXX20
; 1139 : template <class _Traits>
; 1140 : struct pointer_traits<_String_view_iterator<_Traits>> {
; 1141 :     using pointer         = _String_view_iterator<_Traits>;
; 1142 :     using element_type    = const typename pointer::value_type;
; 1143 :     using difference_type = typename pointer::difference_type;
; 1144 : 
; 1145 :     _NODISCARD static constexpr element_type* to_address(const pointer& _Iter) noexcept {
; 1146 :         return _Iter._Unwrapped();
; 1147 :     }
; 1148 : };
; 1149 : #endif // _HAS_CXX20
; 1150 : 
; 1151 : 
; 1152 : // CLASS TEMPLATE basic_string_view
; 1153 : template <class _Elem, class _Traits>
; 1154 : class basic_string_view { // wrapper for any kind of contiguous character buffer
; 1155 : public:
; 1156 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 1157 :         "Bad char_traits for basic_string_view; "
; 1158 :         "N4659 24.4.2 [string.view.template]/1 \"the type traits::char_type shall name the same type as charT.\"");
; 1159 : 
; 1160 :     using traits_type            = _Traits;
; 1161 :     using value_type             = _Elem;
; 1162 :     using pointer                = _Elem*;
; 1163 :     using const_pointer          = const _Elem*;
; 1164 :     using reference              = _Elem&;
; 1165 :     using const_reference        = const _Elem&;
; 1166 :     using const_iterator         = _String_view_iterator<_Traits>;
; 1167 :     using iterator               = const_iterator;
; 1168 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 1169 :     using reverse_iterator       = const_reverse_iterator;
; 1170 :     using size_type              = size_t;
; 1171 :     using difference_type        = ptrdiff_t;
; 1172 : 
; 1173 :     static constexpr auto npos{static_cast<size_type>(-1)};
; 1174 : 
; 1175 :     constexpr basic_string_view() noexcept : _Mydata(), _Mysize(0) {}
; 1176 : 
; 1177 :     constexpr basic_string_view(const basic_string_view&) noexcept = default;
; 1178 :     constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;
; 1179 : 
; 1180 :     /* implicit */ constexpr basic_string_view(_In_z_ const const_pointer _Ntcts) noexcept // strengthened
; 1181 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}
; 1182 : 
; 1183 :     constexpr basic_string_view(
; 1184 :         _In_reads_(_Count) const const_pointer _Cts, const size_type _Count) noexcept // strengthened
; 1185 :         : _Mydata(_Cts), _Mysize(_Count) {
; 1186 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1187 :         _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
; 1188 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1189 :     }
; 1190 : 
; 1191 :     _NODISCARD constexpr const_iterator begin() const noexcept {
; 1192 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1193 :         return const_iterator(_Mydata, _Mysize, 0);
; 1194 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1195 :         return const_iterator(_Mydata);
; 1196 : #endif // _ITERATOR_DEBUG_LEVEL
; 1197 :     }
; 1198 : 
; 1199 :     _NODISCARD constexpr const_iterator end() const noexcept {
; 1200 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1201 :         return const_iterator(_Mydata, _Mysize, _Mysize);
; 1202 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1203 :         return const_iterator(_Mydata + _Mysize);
; 1204 : #endif // _ITERATOR_DEBUG_LEVEL
; 1205 :     }
; 1206 : 
; 1207 :     _NODISCARD constexpr const_iterator cbegin() const noexcept {
; 1208 :         return begin();
; 1209 :     }
; 1210 : 
; 1211 :     _NODISCARD constexpr const_iterator cend() const noexcept {
; 1212 :         return end();
; 1213 :     }
; 1214 : 
; 1215 :     _NODISCARD constexpr const_reverse_iterator rbegin() const noexcept {
; 1216 :         return const_reverse_iterator{end()};
; 1217 :     }
; 1218 : 
; 1219 :     _NODISCARD constexpr const_reverse_iterator rend() const noexcept {
; 1220 :         return const_reverse_iterator{begin()};
; 1221 :     }
; 1222 : 
; 1223 :     _NODISCARD constexpr const_reverse_iterator crbegin() const noexcept {
; 1224 :         return rbegin();
; 1225 :     }
; 1226 : 
; 1227 :     _NODISCARD constexpr const_reverse_iterator crend() const noexcept {
; 1228 :         return rend();
; 1229 :     }
; 1230 : 
; 1231 :     constexpr const_pointer _Unchecked_begin() const noexcept {
; 1232 :         return _Mydata;
; 1233 :     }
; 1234 : 
; 1235 :     constexpr const_pointer _Unchecked_end() const noexcept {
; 1236 :         return _Mydata + _Mysize;
; 1237 :     }
; 1238 : 
; 1239 :     _NODISCARD constexpr size_type size() const noexcept {
; 1240 :         return _Mysize;
; 1241 :     }
; 1242 : 
; 1243 :     _NODISCARD constexpr size_type length() const noexcept {
; 1244 :         return _Mysize;
; 1245 :     }
; 1246 : 
; 1247 :     _NODISCARD constexpr bool empty() const noexcept {
; 1248 :         return _Mysize == 0;
; 1249 :     }
; 1250 : 
; 1251 :     _NODISCARD constexpr const_pointer data() const noexcept {
; 1252 :         return _Mydata;
; 1253 :     }
; 1254 : 
; 1255 :     _NODISCARD constexpr size_type max_size() const noexcept {
; 1256 :         // bound to PTRDIFF_MAX to make end() - begin() well defined (also makes room for npos)
; 1257 :         // bound to static_cast<size_t>(-1) / sizeof(_Elem) by address space limits
; 1258 :         return _Min_value(static_cast<size_t>(PTRDIFF_MAX), static_cast<size_t>(-1) / sizeof(_Elem));
; 1259 :     }
; 1260 : 
; 1261 :     _NODISCARD constexpr const_reference operator[](const size_type _Off) const noexcept /* strengthened */ {
; 1262 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1263 :         _STL_VERIFY(_Off < _Mysize, "string_view subscript out of range");
; 1264 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1265 :         return _Mydata[_Off];
; 1266 :     }
; 1267 : 
; 1268 :     _NODISCARD constexpr const_reference at(const size_type _Off) const {
; 1269 :         // get the character at _Off or throw if that is out of range
; 1270 :         _Check_offset_exclusive(_Off);
; 1271 :         return _Mydata[_Off];
; 1272 :     }
; 1273 : 
; 1274 :     _NODISCARD constexpr const_reference front() const noexcept /* strengthened */ {
; 1275 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1276 :         _STL_VERIFY(_Mysize != 0, "cannot call front on empty string_view");
; 1277 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1278 :         return _Mydata[0];
; 1279 :     }
; 1280 : 
; 1281 :     _NODISCARD constexpr const_reference back() const noexcept /* strengthened */ {
; 1282 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1283 :         _STL_VERIFY(_Mysize != 0, "cannot call back on empty string_view");
; 1284 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1285 :         return _Mydata[_Mysize - 1];
; 1286 :     }
; 1287 : 
; 1288 :     constexpr void remove_prefix(const size_type _Count) noexcept /* strengthened */ {
; 1289 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1290 :         _STL_VERIFY(_Mysize >= _Count, "cannot remove prefix longer than total size");
; 1291 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1292 :         _Mydata += _Count;
; 1293 :         _Mysize -= _Count;
; 1294 :     }
; 1295 : 
; 1296 :     constexpr void remove_suffix(const size_type _Count) noexcept /* strengthened */ {
; 1297 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1298 :         _STL_VERIFY(_Mysize >= _Count, "cannot remove suffix longer than total size");
; 1299 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1300 :         _Mysize -= _Count;
; 1301 :     }
; 1302 : 
; 1303 :     constexpr void swap(basic_string_view& _Other) noexcept {
; 1304 :         const basic_string_view _Tmp{_Other}; // note: std::swap is not constexpr before C++20
; 1305 :         _Other = *this;
; 1306 :         *this  = _Tmp;
; 1307 :     }
; 1308 : 
; 1309 :     constexpr size_type copy(_Out_writes_(_Count) _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
; 1310 :         // copy [_Off, _Off + Count) to [_Ptr, _Ptr + _Count)
; 1311 :         _Check_offset(_Off);
; 1312 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1313 :         _Traits::copy(_Ptr, _Mydata + _Off, _Count);
; 1314 :         return _Count;
; 1315 :     }
; 1316 : 
; 1317 :     _Pre_satisfies_(_Dest_size >= _Count) constexpr size_type _Copy_s(_Out_writes_all_(_Dest_size) _Elem* const _Dest,
; 1318 :         const size_type _Dest_size, size_type _Count, const size_type _Off = 0) const {
; 1319 :         // copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1320 :         _Check_offset(_Off);
; 1321 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1322 :         _Traits::_Copy_s(_Dest, _Dest_size, _Mydata + _Off, _Count);
; 1323 :         return _Count;
; 1324 :     }
; 1325 : 
; 1326 :     _NODISCARD constexpr basic_string_view substr(const size_type _Off = 0, size_type _Count = npos) const {
; 1327 :         // return a new basic_string_view moved forward by _Off and trimmed to _Count elements
; 1328 :         _Check_offset(_Off);
; 1329 :         _Count = _Clamp_suffix_size(_Off, _Count);
; 1330 :         return basic_string_view(_Mydata + _Off, _Count);
; 1331 :     }
; 1332 : 
; 1333 :     constexpr bool _Equal(const basic_string_view _Right) const noexcept {
; 1334 :         return _Traits_equal<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
; 1335 :     }
; 1336 : 
; 1337 :     _NODISCARD constexpr int compare(const basic_string_view _Right) const noexcept {
; 1338 :         return _Traits_compare<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
; 1339 :     }
; 1340 : 
; 1341 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right) const {
; 1342 :         // compare [_Off, _Off + _N0) with _Right
; 1343 :         return substr(_Off, _N0).compare(_Right);
; 1344 :     }
; 1345 : 
; 1346 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right,
; 1347 :         const size_type _Roff, const size_type _Count) const {
; 1348 :         // compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1349 :         return substr(_Off, _N0).compare(_Right.substr(_Roff, _Count));
; 1350 :     }
; 1351 : 
; 1352 :     _NODISCARD constexpr int compare(_In_z_ const _Elem* const _Ptr) const { // compare [0, _Mysize) with [_Ptr, <null>)
; 1353 :         return compare(basic_string_view(_Ptr));
; 1354 :     }
; 1355 : 
; 1356 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0, _In_z_ const _Elem* const _Ptr) const {
; 1357 :         // compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 1358 :         return substr(_Off, _N0).compare(basic_string_view(_Ptr));
; 1359 :     }
; 1360 : 
; 1361 :     _NODISCARD constexpr int compare(const size_type _Off, const size_type _N0,
; 1362 :         _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) const {
; 1363 :         // compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1364 :         return substr(_Off, _N0).compare(basic_string_view(_Ptr, _Count));
; 1365 :     }
; 1366 : 
; 1367 : #if _HAS_CXX20
; 1368 :     _NODISCARD constexpr bool starts_with(const basic_string_view _Right) const noexcept {
; 1369 :         const auto _Rightsize = _Right._Mysize;
; 1370 :         if (_Mysize < _Rightsize) {
; 1371 :             return false;
; 1372 :         }
; 1373 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;
; 1374 :     }
; 1375 : 
; 1376 :     _NODISCARD constexpr bool starts_with(const _Elem _Right) const noexcept {
; 1377 :         return !empty() && _Traits::eq(front(), _Right);
; 1378 :     }
; 1379 : 
; 1380 :     _NODISCARD constexpr bool starts_with(const _Elem* const _Right) const noexcept /* strengthened */ {
; 1381 :         return starts_with(basic_string_view(_Right));
; 1382 :     }
; 1383 : 
; 1384 :     _NODISCARD constexpr bool ends_with(const basic_string_view _Right) const noexcept {
; 1385 :         const auto _Rightsize = _Right._Mysize;
; 1386 :         if (_Mysize < _Rightsize) {
; 1387 :             return false;
; 1388 :         }
; 1389 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;
; 1390 :     }
; 1391 : 
; 1392 :     _NODISCARD constexpr bool ends_with(const _Elem _Right) const noexcept {
; 1393 :         return !empty() && _Traits::eq(back(), _Right);
; 1394 :     }
; 1395 : 
; 1396 :     _NODISCARD constexpr bool ends_with(const _Elem* const _Right) const noexcept /* strengthened */ {
; 1397 :         return ends_with(basic_string_view(_Right));
; 1398 :     }
; 1399 : #endif // _HAS_CXX20
; 1400 : 
; 1401 :     _NODISCARD constexpr size_type find(const basic_string_view _Right, const size_type _Off = 0) const noexcept {
; 1402 :         // look for _Right beginning at or after _Off
; 1403 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
; 1404 :     }
; 1405 : 
; 1406 :     _NODISCARD constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1407 :         // look for _Ch at or after _Off
; 1408 :         return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1409 :     }
; 1410 : 
; 1411 :     _NODISCARD constexpr size_type find(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1412 :         const size_type _Count) const noexcept /* strengthened */ {
; 1413 :         // look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1414 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
; 1415 :     }
; 1416 : 
; 1417 :     _NODISCARD constexpr size_type find(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1418 :         noexcept /* strengthened */ {
; 1419 :         // look for [_Ptr, <null>) beginning at or after _Off
; 1420 :         return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
; 1421 :     }
; 1422 : 
; 1423 :     _NODISCARD constexpr size_type rfind(const basic_string_view _Right, const size_type _Off = npos) const noexcept {
; 1424 :         // look for _Right beginning before _Off
; 1425 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
; 1426 :     }
; 1427 : 
; 1428 :     _NODISCARD constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1429 :         // look for _Ch before _Off
; 1430 :         return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1431 :     }
; 1432 : 
; 1433 :     _NODISCARD constexpr size_type rfind(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1434 :         const size_type _Count) const noexcept /* strengthened */ {
; 1435 :         // look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1436 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
; 1437 :     }
; 1438 : 
; 1439 :     _NODISCARD constexpr size_type rfind(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1440 :         noexcept /* strengthened */ {
; 1441 :         // look for [_Ptr, <null>) beginning before _Off
; 1442 :         return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
; 1443 :     }
; 1444 : 
; 1445 :     _NODISCARD constexpr size_type find_first_of(const basic_string_view _Right,
; 1446 :         const size_type _Off = 0) const noexcept { // look for one of _Right at or after _Off
; 1447 :         return _Traits_find_first_of<_Traits>(
; 1448 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1449 :     }
; 1450 : 
; 1451 :     _NODISCARD constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1452 :         // look for _Ch at or after _Off
; 1453 :         return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1454 :     }
; 1455 : 
; 1456 :     _NODISCARD constexpr size_type find_first_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1457 :         const size_type _Count) const noexcept /* strengthened */ {
; 1458 :         // look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1459 :         return _Traits_find_first_of<_Traits>(
; 1460 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1461 :     }
; 1462 : 
; 1463 :     _NODISCARD constexpr size_type find_first_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1464 :         noexcept /* strengthened */ {
; 1465 :         // look for one of [_Ptr, <null>) at or after _Off
; 1466 :         return _Traits_find_first_of<_Traits>(
; 1467 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1468 :     }
; 1469 : 
; 1470 :     _NODISCARD constexpr size_type find_last_of(const basic_string_view _Right, const size_type _Off = npos) const
; 1471 :         noexcept { // look for one of _Right before _Off
; 1472 :         return _Traits_find_last_of<_Traits>(
; 1473 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1474 :     }
; 1475 : 
; 1476 :     _NODISCARD constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1477 :         // look for _Ch before _Off
; 1478 :         return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1479 :     }
; 1480 : 
; 1481 :     _NODISCARD constexpr size_type find_last_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1482 :         const size_type _Count) const noexcept /* strengthened */ {
; 1483 :         // look for one of [_Ptr, _Ptr + _Count) before _Off
; 1484 :         return _Traits_find_last_of<_Traits>(
; 1485 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1486 :     }
; 1487 : 
; 1488 :     _NODISCARD constexpr size_type find_last_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1489 :         noexcept /* strengthened */ {
; 1490 :         // look for one of [_Ptr, <null>) before _Off
; 1491 :         return _Traits_find_last_of<_Traits>(
; 1492 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1493 :     }
; 1494 : 
; 1495 :     _NODISCARD constexpr size_type find_first_not_of(const basic_string_view _Right,
; 1496 :         const size_type _Off = 0) const noexcept { // look for none of _Right at or after _Off
; 1497 :         return _Traits_find_first_not_of<_Traits>(
; 1498 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1499 :     }
; 1500 : 
; 1501 :     _NODISCARD constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
; 1502 :         // look for any value other than _Ch at or after _Off
; 1503 :         return _Traits_find_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1504 :     }
; 1505 : 
; 1506 :     _NODISCARD constexpr size_type find_first_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1507 :         const size_type _Count) const noexcept /* strengthened */ {
; 1508 :         // look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 1509 :         return _Traits_find_first_not_of<_Traits>(
; 1510 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1511 :     }
; 1512 : 
; 1513 :     _NODISCARD constexpr size_type find_first_not_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const
; 1514 :         noexcept /* strengthened */ {
; 1515 :         // look for none of [_Ptr, <null>) at or after _Off
; 1516 :         return _Traits_find_first_not_of<_Traits>(
; 1517 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1518 :     }
; 1519 : 
; 1520 :     _NODISCARD constexpr size_type find_last_not_of(const basic_string_view _Right,
; 1521 :         const size_type _Off = npos) const noexcept { // look for none of _Right before _Off
; 1522 :         return _Traits_find_last_not_of<_Traits>(
; 1523 :             _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
; 1524 :     }
; 1525 : 
; 1526 :     _NODISCARD constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
; 1527 :         // look for any value other than _Ch before _Off
; 1528 :         return _Traits_rfind_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
; 1529 :     }
; 1530 : 
; 1531 :     _NODISCARD constexpr size_type find_last_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
; 1532 :         const size_type _Count) const noexcept /* strengthened */ {
; 1533 :         // look for none of [_Ptr, _Ptr + _Count) before _Off
; 1534 :         return _Traits_find_last_not_of<_Traits>(
; 1535 :             _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
; 1536 :     }
; 1537 : 
; 1538 :     _NODISCARD constexpr size_type find_last_not_of(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const
; 1539 :         noexcept /* strengthened */ {
; 1540 :         // look for none of [_Ptr, <null>) before _Off
; 1541 :         return _Traits_find_last_not_of<_Traits>(
; 1542 :             _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
; 1543 :     }
; 1544 : 
; 1545 :     _NODISCARD constexpr bool _Starts_with(const basic_string_view _View) const noexcept {
; 1546 :         return _Mysize >= _View._Mysize && _Traits::compare(_Mydata, _View._Mydata, _View._Mysize) == 0;
; 1547 :     }
; 1548 : 
; 1549 : private:
; 1550 :     constexpr void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 1551 :         if (_Mysize < _Off) {
; 1552 :             _Xran();
; 1553 :         }
; 1554 :     }
; 1555 : 
; 1556 :     constexpr void _Check_offset_exclusive(const size_type _Off) const {
; 1557 :         // checks whether _Off is in the bounds of [0, size())
; 1558 :         if (_Mysize <= _Off) {
; 1559 :             _Xran();
; 1560 :         }
; 1561 :     }
; 1562 : 
; 1563 :     constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 1564 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 1565 :         return _Min_value(_Size, _Mysize - _Off);
; 1566 :     }
; 1567 : 
; 1568 :     [[noreturn]] static void _Xran() {
; 1569 :         _Xout_of_range("invalid string_view position");
; 1570 :     }
; 1571 : 
; 1572 :     const_pointer _Mydata;
; 1573 :     size_type _Mysize;
; 1574 : };
; 1575 : 
; 1576 : #ifdef __cpp_lib_concepts
; 1577 : namespace ranges {
; 1578 :     template <class _Elem, class _Traits>
; 1579 :     inline constexpr bool enable_view<basic_string_view<_Elem, _Traits>> = true;
; 1580 :     template <class _Elem, class _Traits>
; 1581 :     inline constexpr bool enable_borrowed_range<basic_string_view<_Elem, _Traits>> = true;
; 1582 : } // namespace ranges
; 1583 : #endif // __cpp_lib_concepts
; 1584 : 
; 1585 : // FUNCTION TEMPLATES operator== FOR basic_string_view
; 1586 : template <class _Elem, class _Traits>
; 1587 : _NODISCARD constexpr bool operator==(
; 1588 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1589 :     return _Lhs._Equal(_Rhs);
; 1590 : }
; 1591 : 
; 1592 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1593 : _NODISCARD constexpr bool operator==(
; 1594 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1595 :     return _Lhs._Equal(_Rhs);
; 1596 : }
; 1597 : 
; 1598 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1599 : _NODISCARD constexpr bool operator==(
; 1600 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1601 :     return _Lhs._Equal(_Rhs);
; 1602 : }
; 1603 : 
; 1604 : 
; 1605 : // FUNCTION TEMPLATES operator!= FOR basic_string_view
; 1606 : template <class _Elem, class _Traits>
; 1607 : _NODISCARD constexpr bool operator!=(
; 1608 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1609 :     return !_Lhs._Equal(_Rhs);
; 1610 : }
; 1611 : 
; 1612 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1613 : _NODISCARD constexpr bool operator!=(
; 1614 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1615 :     return !_Lhs._Equal(_Rhs);
; 1616 : }
; 1617 : 
; 1618 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1619 : _NODISCARD constexpr bool operator!=(
; 1620 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1621 :     return !_Lhs._Equal(_Rhs);
; 1622 : }
; 1623 : 
; 1624 : 
; 1625 : // FUNCTION TEMPLATES operator< FOR basic_string_view
; 1626 : template <class _Elem, class _Traits>
; 1627 : _NODISCARD constexpr bool operator<(
; 1628 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1629 :     return _Lhs.compare(_Rhs) < 0;
; 1630 : }
; 1631 : 
; 1632 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1633 : _NODISCARD constexpr bool operator<(
; 1634 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1635 :     return _Lhs.compare(_Rhs) < 0;
; 1636 : }
; 1637 : 
; 1638 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1639 : _NODISCARD constexpr bool operator<(
; 1640 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1641 :     return _Lhs.compare(_Rhs) < 0;
; 1642 : }
; 1643 : 
; 1644 : 
; 1645 : // FUNCTION TEMPLATES operator> FOR basic_string_view
; 1646 : template <class _Elem, class _Traits>
; 1647 : _NODISCARD constexpr bool operator>(
; 1648 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1649 :     return _Lhs.compare(_Rhs) > 0;
; 1650 : }
; 1651 : 
; 1652 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1653 : _NODISCARD constexpr bool operator>(
; 1654 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1655 :     return _Lhs.compare(_Rhs) > 0;
; 1656 : }
; 1657 : 
; 1658 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1659 : _NODISCARD constexpr bool operator>(
; 1660 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1661 :     return _Lhs.compare(_Rhs) > 0;
; 1662 : }
; 1663 : 
; 1664 : 
; 1665 : // FUNCTION TEMPLATES operator<= FOR basic_string_view
; 1666 : template <class _Elem, class _Traits>
; 1667 : _NODISCARD constexpr bool operator<=(
; 1668 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1669 :     return _Lhs.compare(_Rhs) <= 0;
; 1670 : }
; 1671 : 
; 1672 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1673 : _NODISCARD constexpr bool operator<=(
; 1674 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1675 :     return _Lhs.compare(_Rhs) <= 0;
; 1676 : }
; 1677 : 
; 1678 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1679 : _NODISCARD constexpr bool operator<=(
; 1680 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1681 :     return _Lhs.compare(_Rhs) <= 0;
; 1682 : }
; 1683 : 
; 1684 : 
; 1685 : // FUNCTION TEMPLATES operator>= FOR basic_string_view
; 1686 : template <class _Elem, class _Traits>
; 1687 : _NODISCARD constexpr bool operator>=(
; 1688 :     const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1689 :     return _Lhs.compare(_Rhs) >= 0;
; 1690 : }
; 1691 : 
; 1692 : template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
; 1693 : _NODISCARD constexpr bool operator>=(
; 1694 :     const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
; 1695 :     return _Lhs.compare(_Rhs) >= 0;
; 1696 : }
; 1697 : 
; 1698 : template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
; 1699 : _NODISCARD constexpr bool operator>=(
; 1700 :     const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
; 1701 :     return _Lhs.compare(_Rhs) >= 0;
; 1702 : }
; 1703 : 
; 1704 : 
; 1705 : // TYPEDEFS FOR basic_string_view
; 1706 : using string_view = basic_string_view<char>;
; 1707 : #ifdef __cpp_lib_char8_t
; 1708 : using u8string_view = basic_string_view<char8_t>;
; 1709 : #endif // __cpp_lib_char8_t
; 1710 : using u16string_view = basic_string_view<char16_t>;
; 1711 : using u32string_view = basic_string_view<char32_t>;
; 1712 : using wstring_view   = basic_string_view<wchar_t>;
; 1713 : 
; 1714 : 
; 1715 : // STRUCT TEMPLATE SPECIALIZATION hash FOR basic_string_view
; 1716 : template <class _Elem, class _Traits>
; 1717 : struct hash<basic_string_view<_Elem, _Traits>> {
; 1718 :     _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef basic_string_view<_Elem, _Traits> _ARGUMENT_TYPE_NAME;
; 1719 :     _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t _RESULT_TYPE_NAME;
; 1720 : 
; 1721 :     _NODISCARD size_t operator()(const basic_string_view<_Elem, _Traits> _Keyval) const noexcept {
; 1722 :         return _Hash_array_representation(_Keyval.data(), _Keyval.size());
; 1723 :     }
; 1724 : };
; 1725 : 
; 1726 : template <class _Elem, class _Traits>
; 1727 : basic_ostream<_Elem, _Traits>& operator<<(
; 1728 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string_view<_Elem, _Traits> _Str) {
; 1729 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());
; 1730 : }
; 1731 : 
; 1732 : 
; 1733 : // basic_string_view LITERALS
; 1734 : inline namespace literals {
; 1735 :     inline namespace string_view_literals {
; 1736 :         _NODISCARD constexpr string_view operator"" sv(const char* _Str, size_t _Len) noexcept {
; 1737 :             return string_view(_Str, _Len);
; 1738 :         }
; 1739 : 
; 1740 :         _NODISCARD constexpr wstring_view operator"" sv(const wchar_t* _Str, size_t _Len) noexcept {
; 1741 :             return wstring_view(_Str, _Len);
; 1742 :         }
; 1743 : 
; 1744 : #ifdef __cpp_char8_t
; 1745 :         _NODISCARD constexpr basic_string_view<char8_t> operator"" sv(const char8_t* _Str, size_t _Len) noexcept {
; 1746 :             return basic_string_view<char8_t>(_Str, _Len);
; 1747 :         }
; 1748 : #endif // __cpp_char8_t
; 1749 : 
; 1750 :         _NODISCARD constexpr u16string_view operator"" sv(const char16_t* _Str, size_t _Len) noexcept {
; 1751 :             return u16string_view(_Str, _Len);
; 1752 :         }
; 1753 : 
; 1754 :         _NODISCARD constexpr u32string_view operator"" sv(const char32_t* _Str, size_t _Len) noexcept {
; 1755 :             return u32string_view(_Str, _Len);
; 1756 :         }
; 1757 :     } // namespace string_view_literals
; 1758 : } // namespace literals
; 1759 : #endif // _HAS_CXX17
; 1760 : 
; 1761 : // CLASS TEMPLATE _String_const_iterator
; 1762 : template <class _Mystr>
; 1763 : class _String_const_iterator : public _Iterator_base {
; 1764 : public:
; 1765 : #ifdef __cpp_lib_concepts
; 1766 :     using iterator_concept = contiguous_iterator_tag;
; 1767 : #endif // __cpp_lib_concepts
; 1768 :     using iterator_category = random_access_iterator_tag;
; 1769 :     using value_type        = typename _Mystr::value_type;
; 1770 :     using difference_type   = typename _Mystr::difference_type;
; 1771 :     using pointer           = typename _Mystr::const_pointer;
; 1772 :     using reference         = const value_type&;
; 1773 : 
; 1774 :     _String_const_iterator() noexcept : _Ptr() {}
; 1775 : 
; 1776 :     _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {
; 1777 :         this->_Adopt(_Pstring);
; 1778 :     }
; 1779 : 
; 1780 :     _NODISCARD reference operator*() const {
; 1781 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1782 :         _STL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1783 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1784 :         _STL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1785 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1786 :         const auto _Contptr = _Mycont->_Myptr();
; 1787 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1788 :         _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1789 :             "cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1790 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1791 : 
; 1792 :         _Analysis_assume_(_Ptr);
; 1793 :         return *_Ptr;
; 1794 :     }
; 1795 : 
; 1796 :     _NODISCARD pointer operator->() const {
; 1797 :         return pointer_traits<pointer>::pointer_to(**this);
; 1798 :     }
; 1799 : 
; 1800 :     _String_const_iterator& operator++() {
; 1801 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1802 :         _STL_VERIFY(_Ptr, "cannot increment value-initialized string iterator");
; 1803 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1804 :         _STL_VERIFY(_Mycont, "cannot increment string iterator because the iterator was"
; 1805 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1806 :         _STL_VERIFY(_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize, "cannot increment string iterator past end");
; 1807 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1808 : 
; 1809 :         ++_Ptr;
; 1810 :         return *this;
; 1811 :     }
; 1812 : 
; 1813 :     _String_const_iterator operator++(int) {
; 1814 :         _String_const_iterator _Tmp = *this;
; 1815 :         ++*this;
; 1816 :         return _Tmp;
; 1817 :     }
; 1818 : 
; 1819 :     _String_const_iterator& operator--() {
; 1820 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1821 :         _STL_VERIFY(_Ptr, "cannot decrement value-initialized string iterator");
; 1822 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1823 :         _STL_VERIFY(_Mycont, "cannot decrement string iterator because the iterator was"
; 1824 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1825 :         _STL_VERIFY(_Mycont->_Myptr() < _Unfancy(_Ptr), "cannot decrement string iterator before begin");
; 1826 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1827 : 
; 1828 :         --_Ptr;
; 1829 :         return *this;
; 1830 :     }
; 1831 : 
; 1832 :     _String_const_iterator operator--(int) {
; 1833 :         _String_const_iterator _Tmp = *this;
; 1834 :         --*this;
; 1835 :         return _Tmp;
; 1836 :     }
; 1837 : 
; 1838 :     void _Verify_offset(const difference_type _Off) const noexcept {
; 1839 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1840 :         if (_Off == 0) {
; 1841 :             return;
; 1842 :         }
; 1843 : 
; 1844 :         _STL_ASSERT(_Ptr, "cannot seek value-initialized string iterator");
; 1845 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1846 :         _STL_ASSERT(_Mycont, "cannot seek string iterator because the iterator was"
; 1847 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1848 :         const auto _Contptr = _Mycont->_Myptr();
; 1849 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1850 : 
; 1851 :         if (_Off < 0) {
; 1852 : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 1853 :             _STL_VERIFY(_Contptr - _Rawptr <= _Off, "cannot seek string iterator before begin");
; 1854 :         }
; 1855 : 
; 1856 :         if (_Off > 0) {
; 1857 :             using _Size_type = typename _Mystr::size_type;
; 1858 :             const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
; 1859 :             _STL_VERIFY(static_cast<_Size_type>(_Off) <= _Left, "cannot seek string iterator after end");
; 1860 :         }
; 1861 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1862 :         (void) _Off;
; 1863 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1864 :     }
; 1865 : 
; 1866 :     _String_const_iterator& operator+=(const difference_type _Off) {
; 1867 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1868 :         _Verify_offset(_Off);
; 1869 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1870 :         _Ptr += _Off;
; 1871 :         return *this;
; 1872 :     }
; 1873 : 
; 1874 :     _NODISCARD _String_const_iterator operator+(const difference_type _Off) const {
; 1875 :         _String_const_iterator _Tmp = *this;
; 1876 :         return _Tmp += _Off;
; 1877 :     }
; 1878 : 
; 1879 :     _String_const_iterator& operator-=(const difference_type _Off) {
; 1880 :         return *this += -_Off;
; 1881 :     }
; 1882 : 
; 1883 :     _NODISCARD _String_const_iterator operator-(const difference_type _Off) const {
; 1884 :         _String_const_iterator _Tmp = *this;
; 1885 :         return _Tmp -= _Off;
; 1886 :     }
; 1887 : 
; 1888 :     _NODISCARD difference_type operator-(const _String_const_iterator& _Right) const {
; 1889 :         _Compat(_Right);
; 1890 :         return _Ptr - _Right._Ptr;
; 1891 :     }
; 1892 : 
; 1893 :     _NODISCARD reference operator[](const difference_type _Off) const {
; 1894 :         return *(*this + _Off);
; 1895 :     }
; 1896 : 
; 1897 :     _NODISCARD bool operator==(const _String_const_iterator& _Right) const {
; 1898 :         _Compat(_Right);
; 1899 :         return _Ptr == _Right._Ptr;
; 1900 :     }
; 1901 : 
; 1902 :     _NODISCARD bool operator!=(const _String_const_iterator& _Right) const {
; 1903 :         return !(*this == _Right);
; 1904 :     }
; 1905 : 
; 1906 :     _NODISCARD bool operator<(const _String_const_iterator& _Right) const {
; 1907 :         _Compat(_Right);
; 1908 :         return _Ptr < _Right._Ptr;
; 1909 :     }
; 1910 : 
; 1911 :     _NODISCARD bool operator>(const _String_const_iterator& _Right) const {
; 1912 :         return _Right < *this;
; 1913 :     }
; 1914 : 
; 1915 :     _NODISCARD bool operator<=(const _String_const_iterator& _Right) const {
; 1916 :         return !(_Right < *this);
; 1917 :     }
; 1918 : 
; 1919 :     _NODISCARD bool operator>=(const _String_const_iterator& _Right) const {
; 1920 :         return !(*this < _Right);
; 1921 :     }
; 1922 : 
; 1923 :     void _Compat(const _String_const_iterator& _Right) const { // test for compatible iterator pair
; 1924 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1925 :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "string iterators incompatible (e.g."
; 1926 :                                                            " point to different string instances)");
; 1927 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1928 :         (void) _Right;
; 1929 : #endif // _ITERATOR_DEBUG_LEVEL
; 1930 :     }
; 1931 : 
; 1932 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1933 :     friend void _Verify_range(const _String_const_iterator& _First, const _String_const_iterator& _Last) {
; 1934 :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "string iterators in range are from different containers");
; 1935 :         _STL_VERIFY(_First._Ptr <= _Last._Ptr, "string iterator range transposed");
; 1936 :     }
; 1937 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1938 : 
; 1939 :     using _Prevent_inheriting_unwrap = _String_const_iterator;
; 1940 : 
; 1941 :     _NODISCARD const value_type* _Unwrapped() const {
; 1942 :         return _Unfancy(_Ptr);
; 1943 :     }
; 1944 : 
; 1945 :     void _Seek_to(const value_type* _It) {
; 1946 :         _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
; 1947 :     }
; 1948 : 
; 1949 :     pointer _Ptr; // pointer to element in string
; 1950 : };
; 1951 : 
; 1952 : template <class _Mystr>
; 1953 : _NODISCARD _String_const_iterator<_Mystr> operator+(
; 1954 :     typename _String_const_iterator<_Mystr>::difference_type _Off, _String_const_iterator<_Mystr> _Next) {
; 1955 :     return _Next += _Off;
; 1956 : }
; 1957 : 
; 1958 : #if _HAS_CXX20
; 1959 : template <class _Mystr>
; 1960 : struct pointer_traits<_String_const_iterator<_Mystr>> {
; 1961 :     using pointer         = _String_const_iterator<_Mystr>;
; 1962 :     using element_type    = const typename pointer::value_type;
; 1963 :     using difference_type = typename pointer::difference_type;
; 1964 : 
; 1965 :     _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
; 1966 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1967 :         const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
; 1968 :         if (!_Mycont) {
; 1969 :             _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
; 1970 :                                      "(e.g. reallocation occurred, or the string was destroyed)");
; 1971 :         }
; 1972 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1973 : 
; 1974 :         const auto _Rawptr = _STD to_address(_Iter._Ptr);
; 1975 : 
; 1976 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1977 :         if (_Mycont) {
; 1978 :             const auto _Contptr = _Mycont->_Myptr();
; 1979 :             _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
; 1980 :                 "cannot convert string iterator to pointer because it is out of range");
; 1981 :         }
; 1982 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1983 : 
; 1984 :         return _Rawptr;
; 1985 :     }
; 1986 : };
; 1987 : #endif // _HAS_CXX20
; 1988 : 
; 1989 : // CLASS TEMPLATE _String_iterator
; 1990 : template <class _Mystr>
; 1991 : class _String_iterator : public _String_const_iterator<_Mystr> {
; 1992 : public:
; 1993 :     using _Mybase = _String_const_iterator<_Mystr>;
; 1994 : 
; 1995 : #ifdef __cpp_lib_concepts
; 1996 :     using iterator_concept = contiguous_iterator_tag;
; 1997 : #endif // __cpp_lib_concepts
; 1998 :     using iterator_category = random_access_iterator_tag;
; 1999 :     using value_type        = typename _Mystr::value_type;
; 2000 :     using difference_type   = typename _Mystr::difference_type;
; 2001 :     using pointer           = typename _Mystr::pointer;
; 2002 :     using reference         = value_type&;
; 2003 : 
; 2004 :     using _Mybase::_Mybase;
; 2005 : 
; 2006 :     _NODISCARD reference operator*() const {
; 2007 :         return const_cast<reference>(_Mybase::operator*());
; 2008 :     }
; 2009 : 
; 2010 :     _NODISCARD pointer operator->() const {
; 2011 :         return pointer_traits<pointer>::pointer_to(**this);
; 2012 :     }
; 2013 : 
; 2014 :     _String_iterator& operator++() {
; 2015 :         _Mybase::operator++();
; 2016 :         return *this;
; 2017 :     }
; 2018 : 
; 2019 :     _String_iterator operator++(int) {
; 2020 :         _String_iterator _Tmp = *this;
; 2021 :         _Mybase::operator++();
; 2022 :         return _Tmp;
; 2023 :     }
; 2024 : 
; 2025 :     _String_iterator& operator--() {
; 2026 :         _Mybase::operator--();
; 2027 :         return *this;
; 2028 :     }
; 2029 : 
; 2030 :     _String_iterator operator--(int) {
; 2031 :         _String_iterator _Tmp = *this;
; 2032 :         _Mybase::operator--();
; 2033 :         return _Tmp;
; 2034 :     }
; 2035 : 
; 2036 :     _String_iterator& operator+=(const difference_type _Off) {
; 2037 :         _Mybase::operator+=(_Off);
; 2038 :         return *this;
; 2039 :     }
; 2040 : 
; 2041 :     _NODISCARD _String_iterator operator+(const difference_type _Off) const {
; 2042 :         _String_iterator _Tmp = *this;
; 2043 :         return _Tmp += _Off;
; 2044 :     }
; 2045 : 
; 2046 :     _String_iterator& operator-=(const difference_type _Off) {
; 2047 :         _Mybase::operator-=(_Off);
; 2048 :         return *this;
; 2049 :     }
; 2050 : 
; 2051 :     using _Mybase::operator-;
; 2052 : 
; 2053 :     _NODISCARD _String_iterator operator-(const difference_type _Off) const {
; 2054 :         _String_iterator _Tmp = *this;
; 2055 :         return _Tmp -= _Off;
; 2056 :     }
; 2057 : 
; 2058 :     _NODISCARD reference operator[](const difference_type _Off) const {
; 2059 :         return const_cast<reference>(_Mybase::operator[](_Off));
; 2060 :     }
; 2061 : 
; 2062 :     using _Prevent_inheriting_unwrap = _String_iterator;
; 2063 : 
; 2064 :     _NODISCARD value_type* _Unwrapped() const {
; 2065 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));
; 2066 :     }
; 2067 : };
; 2068 : 
; 2069 : template <class _Mystr>
; 2070 : _NODISCARD _String_iterator<_Mystr> operator+(
; 2071 :     typename _String_iterator<_Mystr>::difference_type _Off, _String_iterator<_Mystr> _Next) {
; 2072 :     return _Next += _Off;
; 2073 : }
; 2074 : 
; 2075 : #if _HAS_CXX20
; 2076 : template <class _Mystr>
; 2077 : struct pointer_traits<_String_iterator<_Mystr>> {
; 2078 :     using pointer         = _String_iterator<_Mystr>;
; 2079 :     using element_type    = typename pointer::value_type;
; 2080 :     using difference_type = typename pointer::difference_type;
; 2081 : 
; 2082 :     _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
; 2083 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 2084 :         const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
; 2085 :         if (!_Mycont) {
; 2086 :             _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
; 2087 :                                      "(e.g. reallocation occurred, or the string was destroyed)");
; 2088 :         }
; 2089 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 2090 : 
; 2091 :         const auto _Rawptr = _STD to_address(_Iter._Ptr);
; 2092 : 
; 2093 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 2094 :         if (_Mycont) {
; 2095 :             const auto _Contptr = _Mycont->_Myptr();
; 2096 :             _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
; 2097 :                 "cannot convert string iterator to pointer because it is out of range");
; 2098 :         }
; 2099 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 2100 : 
; 2101 :         return const_cast<element_type*>(_Rawptr);
; 2102 :     }
; 2103 : };
; 2104 : #endif // _HAS_CXX20
; 2105 : 
; 2106 : // basic_string TYPE WRAPPERS
; 2107 : template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
; 2108 :     class _Reference, class _Const_reference>
; 2109 : struct _String_iter_types {
; 2110 :     using value_type      = _Value_type;
; 2111 :     using size_type       = _Size_type;
; 2112 :     using difference_type = _Difference_type;
; 2113 :     using pointer         = _Pointer;
; 2114 :     using const_pointer   = _Const_pointer;
; 2115 : };
; 2116 : 
; 2117 : // CLASS TEMPLATE _String_val
; 2118 : template <class _Val_types>
; 2119 : class _String_val : public _Container_base {
; 2120 : public:
; 2121 :     using value_type      = typename _Val_types::value_type;
; 2122 :     using size_type       = typename _Val_types::size_type;
; 2123 :     using difference_type = typename _Val_types::difference_type;
; 2124 :     using pointer         = typename _Val_types::pointer;
; 2125 :     using const_pointer   = typename _Val_types::const_pointer;
; 2126 :     using reference       = value_type&;
; 2127 :     using const_reference = const value_type&;
; 2128 : 
; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}
; 2130 : 
; 2131 :     // length of internal buffer, [1, 16]:
; 2132 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2133 :     // roundup mask for allocated buffers, [0, 15]:
; 2134 :     static constexpr size_type _ALLOC_MASK =
; 2135 :         sizeof(value_type) <= 1
; 2136 :             ? 15
; 2137 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2138 : 
; 2139 :     value_type* _Myptr() noexcept {
; 2140 :         value_type* _Result = _Bx._Buf;
; 2141 :         if (_Large_string_engaged()) {
; 2142 :             _Result = _Unfancy(_Bx._Ptr);
; 2143 :         }
; 2144 : 
; 2145 :         return _Result;
; 2146 :     }
; 2147 : 
; 2148 :     const value_type* _Myptr() const noexcept {
; 2149 :         const value_type* _Result = _Bx._Buf;
; 2150 :         if (_Large_string_engaged()) {
; 2151 :             _Result = _Unfancy(_Bx._Ptr);
; 2152 :         }
; 2153 : 
; 2154 :         return _Result;
; 2155 :     }
; 2156 : 
; 2157 :     bool _Large_string_engaged() const noexcept {
; 2158 :         return _BUF_SIZE <= _Myres;
; 2159 :     }
; 2160 : 
; 2161 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2162 :         if (_Mysize < _Off) {
; 2163 :             _Xran();
; 2164 :         }
; 2165 :     }
; 2166 : 
; 2167 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2168 :         if (_Mysize <= _Off) {
; 2169 :             _Xran();
; 2170 :         }
; 2171 :     }
; 2172 : 
; 2173 :     [[noreturn]] static void _Xran() {
; 2174 :         _Xout_of_range("invalid string position");
; 2175 :     }
; 2176 : 
; 2177 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2178 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2179 :         return _Min_value(_Size, _Mysize - _Off);
; 2180 :     }
; 2181 : 
; 2182 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2183 :         _Bxty() {} // user-provided, for fancy pointers
; 2184 : 
; 2185 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2186 : 
; 2187 :         value_type _Buf[_BUF_SIZE];
; 2188 :         pointer _Ptr;
; 2189 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2190 :     } _Bx;
; 2191 : 
; 2192 :     size_type _Mysize; // current length of string
; 2193 :     size_type _Myres; // current storage reserved for string
; 2194 : };
; 2195 : 
; 2196 : // CLASS TEMPLATE basic_string
; 2197 : template <class _Ty>
; 2198 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2199 : 
; 2200 : struct _String_constructor_concat_tag {
; 2201 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2202 :     explicit _String_constructor_concat_tag() = default;
; 2203 : };
; 2204 : 
; 2205 : [[noreturn]] inline void _Xlen_string() {
; 2206 :     _Xlength_error("string too long");
; 2207 : }
; 2208 : 
; 2209 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2210 : class basic_string { // null-terminated transparent array of elements
; 2211 : private:
; 2212 :     friend _Tidy_deallocate_guard<basic_string>;
; 2213 : 
; 2214 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2215 :     using _Alty_traits = allocator_traits<_Alty>;
; 2216 : 
; 2217 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2218 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2219 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2220 : 
; 2221 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2222 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2223 : 
; 2224 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2225 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2226 :         "char_traits character type match the string's character type.");
; 2227 : 
; 2228 : public:
; 2229 :     using traits_type    = _Traits;
; 2230 :     using allocator_type = _Alloc;
; 2231 : 
; 2232 :     using value_type      = _Elem;
; 2233 :     using size_type       = typename _Alty_traits::size_type;
; 2234 :     using difference_type = typename _Alty_traits::difference_type;
; 2235 :     using pointer         = typename _Alty_traits::pointer;
; 2236 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2237 :     using reference       = value_type&;
; 2238 :     using const_reference = const value_type&;
; 2239 : 
; 2240 :     using iterator       = _String_iterator<_Scary_val>;
; 2241 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2242 : 
; 2243 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2244 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2245 : 
; 2246 : private:
; 2247 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2248 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2249 : 
; 2250 :     // When doing _String_val operations by memcpy, we are touching:
; 2251 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2252 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2253 :     //   _String_val::_Mysize   (type is size_type)
; 2254 :     //   _String_val::_Myres    (type is size_type)
; 2255 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2256 :     // We need to ask if pointer is safe to memcpy.
; 2257 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2258 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2259 :     //   they can observe traits::assign and similar.
; 2260 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2261 :     // This offset skips over the _Container_base members, if any
; 2262 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2263 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2264 : 
; 2265 :     template <class _Iter>
; 2266 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2267 : 
; 2268 : #if _HAS_CXX17
; 2269 :     template <class _StringViewIsh>
; 2270 :     using _Is_string_view_ish =
; 2271 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2272 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2273 :             int>;
; 2274 : #endif // _HAS_CXX17
; 2275 : 
; 2276 : public:
; 2277 :     basic_string(const basic_string& _Right)
; 2278 :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2279 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2280 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2281 :         _Construct_lv_contents(_Right);
; 2282 :         _Proxy._Release();
; 2283 :     }
; 2284 : 
; 2285 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2286 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2287 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2288 :         _Construct_lv_contents(_Right);
; 2289 :         _Proxy._Release();
; 2290 :     }
; 2291 : 
; 2292 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t()) {
; 2293 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2294 :         _Tidy_init();
; 2295 :     }
; 2296 : 
; 2297 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2298 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2299 :         _Tidy_init();
; 2300 :     }
; 2301 : 
; 2302 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2303 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, <end>)
; 2304 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2305 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2306 :         _Tidy_init();
; 2307 :         assign(_Right, _Roff, npos);
; 2308 :         _Proxy._Release();
; 2309 :     }
; 2310 : 
; 2311 :     basic_string(
; 2312 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2313 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2314 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2315 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2316 :         _Tidy_init();
; 2317 :         assign(_Right, _Roff, _Count);
; 2318 :         _Proxy._Release();
; 2319 :     }
; 2320 : 
; 2321 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2322 :         : _Mypair(_Zero_then_variadic_args_t()) {
; 2323 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2324 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2325 :         _Tidy_init();
; 2326 :         assign(_Ptr, _Count);
; 2327 :         _Proxy._Release();
; 2328 :     }
; 2329 : 
; 2330 :     basic_string(
; 2331 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2332 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2333 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2334 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2335 :         _Tidy_init();
; 2336 :         assign(_Ptr, _Count);
; 2337 :         _Proxy._Release();
; 2338 :     }
; 2339 : 
; 2340 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {
; 2341 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2342 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2343 :         _Tidy_init();
; 2344 :         assign(_Ptr);
; 2345 :         _Proxy._Release();
; 2346 :     }
; 2347 : 
; 2348 : #if _HAS_CXX17
; 2349 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2350 : #endif // _HAS_CXX17
; 2351 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Tidy_init();
; 2355 :         assign(_Ptr);
; 2356 :         _Proxy._Release();
; 2357 :     }
; 2358 : 
; 2359 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t()) {
; 2360 :         // construct from _Count * _Ch
; 2361 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2362 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2363 :         _Tidy_init();
; 2364 :         assign(_Count, _Ch);
; 2365 :         _Proxy._Release();
; 2366 :     }
; 2367 : 
; 2368 : #if _HAS_CXX17
; 2369 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2370 : #endif // _HAS_CXX17
; 2371 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2372 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Count * _Ch with allocator
; 2373 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2374 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2375 :         _Tidy_init();
; 2376 :         assign(_Count, _Ch);
; 2377 :         _Proxy._Release();
; 2378 :     }
; 2379 : 
; 2380 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2381 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2382 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2383 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2384 :         _Tidy_init();
; 2385 :         _Adl_verify_range(_First, _Last);
; 2386 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
; 2387 :         _Proxy._Release();
; 2388 :     }
; 2389 : 
; 2390 :     template <class _Iter>
; 2391 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2392 :         // initialize from [_First, _Last), input iterators
; 2393 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2394 :         for (; _First != _Last; ++_First) {
; 2395 :             push_back(*_First);
; 2396 :         }
; 2397 : 
; 2398 :         _Guard._Target = nullptr;
; 2399 :     }
; 2400 : 
; 2401 :     template <class _Iter>
; 2402 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2403 :         // initialize from [_First, _Last), forward iterators
; 2404 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2405 :         reserve(_Count);
; 2406 :         _Construct(_First, _Last, input_iterator_tag());
; 2407 :     }
; 2408 : 
; 2409 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2410 :         // initialize from [_First, _Last), pointers
; 2411 :         if (_First != _Last) {
; 2412 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2413 :         }
; 2414 :     }
; 2415 : 
; 2416 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2417 :         // initialize from [_First, _Last), const pointers
; 2418 :         if (_First != _Last) {
; 2419 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2420 :         }
; 2421 :     }
; 2422 : 
; 2423 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) {
; 2424 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2425 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2426 :     }
; 2427 : 
; 2428 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2429 :         _Alty_traits::is_always_equal::value) // strengthened
; 2430 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2431 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2432 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2433 :         if
; 2434 :             _CONSTEXPR_IF(!_Alty_traits::is_always_equal::value) {
; 2435 :                 if (_Getal() != _Right._Getal()) {
; 2436 :                     _Construct_lv_contents(_Right);
; 2437 :                     _Proxy._Release();
; 2438 :                     return;
; 2439 :                 }
; 2440 :             }
; 2441 : 
; 2442 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2443 :         _Proxy._Release();
; 2444 :     }
; 2445 : 
; 2446 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2447 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2448 :         : _Mypair(
; 2449 :             _One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {
; 2450 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2451 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2452 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2453 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);
; 2454 :         size_type _New_capacity = _BUF_SIZE - 1;
; 2455 :         auto& _My_data          = _Mypair._Myval2;
; 2456 :         _Elem* _Ptr             = _My_data._Bx._Buf;
; 2457 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2458 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2459 :         if (_New_capacity < _New_size) {
; 2460 :             _New_capacity           = _Calculate_growth(_New_size, _BUF_SIZE - 1, max_size());
; 2461 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws
; 2462 :             _Ptr                    = _Unfancy(_Fancyptr);
; 2463 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
; 2464 :         }
; 2465 : 
; 2466 :         _My_data._Mysize = _New_size;
; 2467 :         _My_data._Myres  = _New_capacity;
; 2468 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2469 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
; 2470 :         _Traits::assign(_Ptr[_New_size], _Elem());
; 2471 :         _Proxy._Release();
; 2472 :     }
; 2473 : 
; 2474 :     basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
; 2475 :         : _Mypair(_One_then_variadic_args_t(), _Left._Getal()) {
; 2476 :         auto& _My_data    = _Mypair._Myval2;
; 2477 :         auto& _Left_data  = _Left._Mypair._Myval2;
; 2478 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2479 :         _Left_data._Orphan_all();
; 2480 :         _Right_data._Orphan_all();
; 2481 :         const auto _Left_size  = _Left_data._Mysize;
; 2482 :         const auto _Right_size = _Right_data._Mysize;
; 2483 : 
; 2484 :         const auto _Left_capacity  = _Left_data._Myres;
; 2485 :         const auto _Right_capacity = _Right_data._Myres;
; 2486 :         // overflow is OK due to max_size() checks:
; 2487 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);
; 2488 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
; 2489 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
; 2490 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 2491 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2492 :             _Take_contents(_Left, bool_constant<_Can_memcpy_val>{});
; 2493 :             const auto _Ptr = _My_data._Myptr();
; 2494 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
; 2495 :             _My_data._Mysize = _New_size;
; 2496 :             return;
; 2497 :         }
; 2498 : 
; 2499 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
; 2500 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
; 2501 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 2502 :             // At this point, we have tested:
; 2503 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 2504 :             // therefore: (by De Morgan's Laws)
; 2505 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 2506 :             // therefore: (by the distributive property)
; 2507 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 2508 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 2509 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_string_engaged()
; 2510 :             _STL_INTERNAL_CHECK(_Right_data._Large_string_engaged());
; 2511 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2512 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2513 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
; 2514 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
; 2515 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2516 :             _My_data._Mysize = _New_size;
; 2517 :             return;
; 2518 :         }
; 2519 : 
; 2520 :         // can't use either buffer, reallocate
; 2521 :         const auto _Max = max_size();
; 2522 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK
; 2523 :             _Xlen_string();
; 2524 :         }
; 2525 : 
; 2526 :         const auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);
; 2527 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2528 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2529 :         const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws
; 2530 :         // nothrow hereafter
; 2531 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
; 2532 :         _My_data._Mysize = _New_size;
; 2533 :         _My_data._Myres  = _New_capacity;
; 2534 :         const auto _Ptr  = _Unfancy(_Fancyptr);
; 2535 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2536 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
; 2537 :         _Proxy._Release();
; 2538 :     }
; 2539 : 
; 2540 : #if _HAS_CXX17
; 2541 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2542 :     explicit basic_string(const _StringViewIsh& _Right, const _Alloc& _Al = _Alloc())
; 2543 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2544 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2545 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2546 :         _Tidy_init();
; 2547 :         assign(_Right);
; 2548 :         _Proxy._Release();
; 2549 :     }
; 2550 : 
; 2551 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2552 :     basic_string(
; 2553 :         const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2554 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count) using _Al
; 2555 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2556 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2557 :         _Tidy_init();
; 2558 :         assign(_Right, _Roff, _Count);
; 2559 :         _Proxy._Release();
; 2560 :     }
; 2561 : #endif // _HAS_CXX17
; 2562 : 
; 2563 : private:
; 2564 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {
; 2565 :         _Tidy_deallocate();
; 2566 :         _Pocma(_Getal(), _Right._Getal());
; 2567 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2568 :     }
; 2569 : 
; 2570 :     void _Move_assign(basic_string& _Right, _Propagate_allocators) noexcept {
; 2571 :         if (_Getal() == _Right._Getal()) {
; 2572 :             _Move_assign(_Right, _Equal_allocators{});
; 2573 :         } else {
; 2574 :             // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2575 :             _Mypair._Myval2._Orphan_all();
; 2576 :             _Mypair._Myval2._Reload_proxy(
; 2577 :                 _GET_PROXY_ALLOCATOR(_Alty, _Getal()), _GET_PROXY_ALLOCATOR(_Alty, _Right._Getal()));
; 2578 :             _Pocma(_Getal(), _Right._Getal());
; 2579 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2580 :         }
; 2581 :     }
; 2582 : 
; 2583 :     void _Move_assign(basic_string& _Right, _No_propagate_allocators) {
; 2584 :         if (_Getal() == _Right._Getal()) {
; 2585 :             _Move_assign(_Right, _Equal_allocators{});
; 2586 :         } else {
; 2587 :             assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2588 :         }
; 2589 :     }
; 2590 : 
; 2591 : public:
; 2592 :     basic_string& operator=(basic_string&& _Right) noexcept(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
; 2593 :         if (this != _STD addressof(_Right)) {
; 2594 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});
; 2595 :         }
; 2596 : 
; 2597 :         return *this;
; 2598 :     }
; 2599 : 
; 2600 :     basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = _STD move(_Right))) {
; 2601 :         *this = _STD move(_Right);
; 2602 :         return *this;
; 2603 :     }
; 2604 : 
; 2605 : private:
; 2606 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {
; 2607 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2608 :         const auto _My_data_mem =
; 2609 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2610 :         const auto _Right_data_mem =
; 2611 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
; 2613 :     }
; 2614 : 
; 2615 :     void _Take_contents(basic_string& _Right, true_type) noexcept {
; 2616 :         // assign by stealing _Right's buffer, memcpy optimization
; 2617 :         // pre: this != &_Right
; 2618 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2619 :         // pre: *this owns no memory, iterators orphaned (note:
; 2620 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2621 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2622 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2623 :             // take ownership of _Right's iterators along with its buffer
; 2624 :             _Swap_proxy_and_iterators(_Right);
; 2625 :         } else {
; 2626 :             _Right._Mypair._Myval2._Orphan_all();
; 2627 :         }
; 2628 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2629 : 
; 2630 :         _Memcpy_val_from(_Right);
; 2631 :         _Right._Tidy_init();
; 2632 :     }
; 2633 : 
; 2634 :     void _Take_contents(basic_string& _Right, false_type) noexcept {
; 2635 :         // assign by stealing _Right's buffer, general case
; 2636 :         // pre: this != &_Right
; 2637 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2638 :         // pre: *this owns no memory, iterators orphaned
; 2639 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2640 :         auto& _My_data    = _Mypair._Myval2;
; 2641 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2642 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 2643 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 2644 :             _Right_data._Bx._Ptr = pointer();
; 2645 :             _Swap_proxy_and_iterators(_Right);
; 2646 :         } else { // copy small string buffer
; 2647 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 2648 :             _Right_data._Orphan_all();
; 2649 :         }
; 2650 : 
; 2651 :         _My_data._Mysize = _Right_data._Mysize;
; 2652 :         _My_data._Myres  = _Right_data._Myres;
; 2653 :         _Right._Tidy_init();
; 2654 :     }
; 2655 : 
; 2656 :     void _Construct_lv_contents(const basic_string& _Right) {
; 2657 :         // assign by copying data stored in _Right
; 2658 :         // pre: this != &_Right
; 2659 :         // pre: *this owns no memory, iterators orphaned (note:
; 2660 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2661 :         auto& _Right_data             = _Right._Mypair._Myval2;
; 2662 :         const size_type _Right_size   = _Right_data._Mysize;
; 2663 :         const _Elem* const _Right_ptr = _Right_data._Myptr();
; 2664 :         auto& _My_data                = _Mypair._Myval2;
; 2665 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate
; 2666 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
; 2667 :             _My_data._Mysize = _Right_size;
; 2668 :             _My_data._Myres  = _BUF_SIZE - 1;
; 2669 :             return;
; 2670 :         }
; 2671 : 
; 2672 :         auto& _Al                     = _Getal();
; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());
; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws
; 2675 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);
; 2676 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
; 2677 :         _My_data._Mysize = _Right_size;
; 2678 :         _My_data._Myres  = _New_capacity;
; 2679 :     }
; 2680 : 
; 2681 : public:
; 2682 :     basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
; 2683 :         : _Mypair(_One_then_variadic_args_t(), _Al) {
; 2684 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2685 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2686 :         _Tidy_init();
; 2687 :         assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2688 :         _Proxy._Release();
; 2689 :     }
; 2690 : 
; 2691 :     basic_string& operator=(initializer_list<_Elem> _Ilist) {
; 2692 :         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2693 :     }
; 2694 : 
; 2695 :     basic_string& operator+=(initializer_list<_Elem> _Ilist) {
; 2696 :         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2697 :     }
; 2698 : 
; 2699 :     basic_string& assign(initializer_list<_Elem> _Ilist) {
; 2700 :         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2701 :     }
; 2702 : 
; 2703 :     basic_string& append(initializer_list<_Elem> _Ilist) {
; 2704 :         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2705 :     }
; 2706 : 
; 2707 :     iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) {
; 2708 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2709 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 2710 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2711 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 2712 :         insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2713 :         return begin() + static_cast<difference_type>(_Off);
; 2714 :     }
; 2715 : 
; 2716 :     basic_string& replace(
; 2717 :         const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
; 2718 :         // replace with initializer_list
; 2719 :         _Adl_verify_range(_First, _Last);
; 2720 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2721 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 2722 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2723 :         const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
; 2724 :         const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
; 2725 :         return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
; 2726 :     }
; 2727 : 
; 2728 :     ~basic_string() noexcept {
; 2729 :         _Tidy_deallocate();
; 2730 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2731 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2732 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2733 :         _Mypair._Myval2._Myproxy = nullptr;
; 2734 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2735 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2736 :     }
; 2737 : 
; 2738 :     static constexpr auto npos{static_cast<size_type>(-1)};
; 2739 : 
; 2740 : private:
; 2741 :     void _Copy_assign_val_from_small(const basic_string& _Right) {
; 2742 :         // TRANSITION, VSO-761321; inline into only caller when that's fixed
; 2743 :         _Tidy_deallocate();
; 2744 :         if
; 2745 :             _CONSTEXPR_IF(_Can_memcpy_val) {
; 2746 :                 _Memcpy_val_from(_Right);
; 2747 :             }
; 2748 :         else {
; 2749 :             _Traits::copy(
; 2750 :                 _Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Mysize + 1);
; 2751 :             _Mypair._Myval2._Mysize = _Right._Mypair._Myval2._Mysize;
; 2752 :             _Mypair._Myval2._Myres  = _Right._Mypair._Myval2._Myres;
; 2753 :         }
; 2754 :     }
; 2755 : 
; 2756 :     void _Copy_assign(const basic_string& _Right, false_type) {
; 2757 :         _Pocca(_Getal(), _Right._Getal());
; 2758 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2759 :     }
; 2760 : 
; 2761 :     void _Copy_assign(const basic_string& _Right, true_type) {
; 2762 :         auto& _Al             = _Getal();
; 2763 :         const auto& _Right_al = _Right._Getal();
; 2764 :         if (_Al == _Right_al) {
; 2765 :             _Copy_assign(_Right, false_type{});
; 2766 :             return;
; 2767 :         }
; 2768 : 
; 2769 :         auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2770 :         auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 2771 :         _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 2772 : 
; 2773 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2774 :             const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 2775 :             const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 2776 :             auto _Right_al_non_const = _Right_al;
; 2777 :             const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity); // throws
; 2778 :             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 2779 :             _Tidy_deallocate();
; 2780 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 2781 :             _Mypair._Myval2._Mysize  = _New_size;
; 2782 :             _Mypair._Myval2._Myres   = _New_capacity;
; 2783 :         } else {
; 2784 :             _Copy_assign_val_from_small(_Right);
; 2785 :         }
; 2786 : 
; 2787 :         _Pocca(_Al, _Right_al);
; 2788 :         _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 2789 :     }
; 2790 : 
; 2791 : public:
; 2792 :     basic_string& operator=(const basic_string& _Right) {
; 2793 :         if (this != _STD addressof(_Right)) {
; 2794 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});
; 2795 :         }
; 2796 : 
; 2797 :         return *this;
; 2798 :     }
; 2799 : 
; 2800 : #if _HAS_CXX17
; 2801 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2802 :     basic_string& operator=(const _StringViewIsh& _Right) {
; 2803 :         return assign(_Right);
; 2804 :     }
; 2805 : #endif // _HAS_CXX17
; 2806 : 
; 2807 :     basic_string& operator=(_In_z_ const _Elem* const _Ptr) {
; 2808 :         return assign(_Ptr);
; 2809 :     }
; 2810 : 
; 2811 :     basic_string& operator=(const _Elem _Ch) { // assign {_Ch, _Elem()}
; 2812 :         _Mypair._Myval2._Mysize = 1;
; 2813 :         _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 2814 :         _Traits::assign(_Ptr[0], _Ch);
; 2815 :         _Traits::assign(_Ptr[1], _Elem());
; 2816 :         return *this;
; 2817 :     }
; 2818 : 
; 2819 :     basic_string& operator+=(const basic_string& _Right) {
; 2820 :         return append(_Right);
; 2821 :     }
; 2822 : 
; 2823 : #if _HAS_CXX17
; 2824 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2825 :     basic_string& operator+=(const _StringViewIsh& _Right) {
; 2826 :         return append(_Right);
; 2827 :     }
; 2828 : #endif // _HAS_CXX17
; 2829 : 
; 2830 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
; 2831 :         return append(_Ptr);
; 2832 :     }
; 2833 : 
; 2834 :     basic_string& operator+=(_Elem _Ch) {
; 2835 :         push_back(_Ch);
; 2836 :         return *this;
; 2837 :     }
; 2838 : 
; 2839 :     basic_string& append(const basic_string& _Right) {
; 2840 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2841 :     }
; 2842 : 
; 2843 :     basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 2844 :         // append _Right [_Roff, _Roff + _Count)
; 2845 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 2846 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 2847 :         return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 2848 :     }
; 2849 : 
; 2850 : #if _HAS_CXX17
; 2851 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2852 :     basic_string& append(const _StringViewIsh& _Right) {
; 2853 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2854 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2855 :     }
; 2856 : 
; 2857 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2858 :     basic_string& append(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
; 2859 :         // append _Right [_Roff, _Roff + _Count)
; 2860 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2861 :         return append(_As_view.substr(_Roff, _Count));
; 2862 :     }
; 2863 : #endif // _HAS_CXX17
; 2864 : 
; 2865 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 2866 :         // append [_Ptr, _Ptr + _Count)
; 2867 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 2870 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2871 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
; 2872 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
; 2873 :             return *this;
; 2874 :         }
; 2875 : 
; 2876 :         return _Reallocate_grow_by(
; 2877 :             _Count,
; 2878 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2879 :                 const size_type _Count) {
; 2880 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2881 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2882 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2883 :             },
; 2884 :             _Ptr, _Count);
; 2885 :     }
; 2886 : 
; 2887 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
; 2888 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 2889 :     }
; 2890 : 
; 2891 :     basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // append _Count * _Ch
; 2892 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2893 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 2894 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 2895 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2896 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
; 2897 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
; 2898 :             return *this;
; 2899 :         }
; 2900 : 
; 2901 :         return _Reallocate_grow_by(
; 2902 :             _Count,
; 2903 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2904 :                 const _Elem _Ch) {
; 2905 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2906 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2907 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2908 :             },
; 2909 :             _Count, _Ch);
; 2910 :     }
; 2911 : 
; 2912 : #if _HAS_IF_CONSTEXPR
; 2913 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2914 :     basic_string& append(const _Iter _First, const _Iter _Last) { // append [_First, _Last), input iterators
; 2915 :         _Adl_verify_range(_First, _Last);
; 2916 :         const auto _UFirst = _Get_unwrapped(_First);
; 2917 :         const auto _ULast  = _Get_unwrapped(_Last);
; 2918 :         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2919 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2920 :         } else {
; 2921 :             const basic_string _Right(_UFirst, _ULast, get_allocator());
; 2922 :             return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2923 :         }
; 2924 :     }
; 2925 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 2926 :     template <class _Iter>
; 2927 :     basic_string& _Append_range(const _Iter _UFirst, const _Iter _ULast, true_type) {
; 2928 :         return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2929 :     }
; 2930 : 
; 2931 :     template <class _Iter>
; 2932 :     basic_string& _Append_range(const _Iter _UFirst, const _Iter _ULast, false_type) {
; 2933 :         const basic_string _Right(_UFirst, _ULast, get_allocator());
; 2934 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2935 :     }
; 2936 : 
; 2937 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2938 :     basic_string& append(const _Iter _First, const _Iter _Last) { // append [_First, _Last), input iterators {
; 2939 :         _Adl_verify_range(_First, _Last);
; 2940 :         const auto _UFirst = _Get_unwrapped(_First);
; 2941 :         return _Append_range(_UFirst, _Get_unwrapped(_Last), _Is_elem_cptr<decltype(_UFirst)>{});
; 2942 :     }
; 2943 : #endif // _HAS_IF_CONSTEXPR
; 2944 : 
; 2945 :     basic_string& assign(const basic_string& _Right) {
; 2946 :         *this = _Right;
; 2947 :         return *this;
; 2948 :     }
; 2949 : 
; 2950 :     basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 2951 :         // assign _Right [_Roff, _Roff + _Count)
; 2952 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 2953 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 2954 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 2955 :     }
; 2956 : 
; 2957 : #if _HAS_CXX17
; 2958 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2959 :     basic_string& assign(const _StringViewIsh& _Right) {
; 2960 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2961 :         return assign(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 2962 :     }
; 2963 : 
; 2964 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 2965 :     basic_string& assign(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
; 2966 :         // assign _Right [_Roff, _Roff + _Count)
; 2967 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 2968 :         return assign(_As_view.substr(_Roff, _Count));
; 2969 :     }
; 2970 : #endif // _HAS_CXX17
; 2971 : 
; 2972 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 2973 :         // assign [_Ptr, _Ptr + _Count)
; 2974 :         if (_Count <= _Mypair._Myval2._Myres) {
; 2975 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2976 :             _Mypair._Myval2._Mysize = _Count;
; 2977 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 2978 :             _Traits::assign(_Old_ptr[_Count], _Elem());
; 2979 :             return *this;
; 2980 :         }
; 2981 : 
; 2982 :         return _Reallocate_for(
; 2983 :             _Count,
; 2984 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2985 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2987 :             },
; 2988 :             _Ptr);
; 2989 :     }
; 2990 : 
; 2991 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {
; 2992 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 2993 :     }
; 2994 : 
; 2995 :     basic_string& assign(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // assign _Count * _Ch
; 2996 :         if (_Count <= _Mypair._Myval2._Myres) {
; 2997 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2998 :             _Mypair._Myval2._Mysize = _Count;
; 2999 :             _Traits::assign(_Old_ptr, _Count, _Ch);
; 3000 :             _Traits::assign(_Old_ptr[_Count], _Elem());
; 3001 :             return *this;
; 3002 :         }
; 3003 : 
; 3004 :         return _Reallocate_for(
; 3005 :             _Count,
; 3006 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
; 3007 :                 _Traits::assign(_New_ptr, _Count, _Ch);
; 3008 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3009 :             },
; 3010 :             _Ch);
; 3011 :     }
; 3012 : 
; 3013 : #if _HAS_IF_CONSTEXPR
; 3014 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3015 :     basic_string& assign(const _Iter _First, const _Iter _Last) {
; 3016 :         _Adl_verify_range(_First, _Last);
; 3017 :         const auto _UFirst = _Get_unwrapped(_First);
; 3018 :         const auto _ULast  = _Get_unwrapped(_Last);
; 3019 :         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 3020 :             return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3021 :         } else {
; 3022 :             basic_string _Right(_UFirst, _ULast, get_allocator());
; 3023 :             if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
; 3024 :                 _Mypair._Myval2._Orphan_all();
; 3025 :                 _Swap_data(_Right, bool_constant<_Can_memcpy_val>{});
; 3026 :                 return *this;
; 3027 :             } else {
; 3028 :                 return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3029 :             }
; 3030 :         }
; 3031 :     }
; 3032 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 3033 :     template <class _Iter>
; 3034 :     basic_string& _Assign_range(const _Iter _UFirst, const _Iter _ULast, true_type) {
; 3035 :         return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3036 :     }
; 3037 : 
; 3038 :     template <class _Iter>
; 3039 :     basic_string& _Assign_range(const _Iter _UFirst, const _Iter _ULast, false_type) {
; 3040 :         basic_string _Right(_UFirst, _ULast, get_allocator());
; 3041 :         if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
; 3042 :             _Mypair._Myval2._Orphan_all();
; 3043 :             _Swap_data(_Right, bool_constant<_Can_memcpy_val>{});
; 3044 :             return *this;
; 3045 :         } else {
; 3046 :             return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3047 :         }
; 3048 :     }
; 3049 : 
; 3050 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3051 :     basic_string& assign(const _Iter _First, const _Iter _Last) {
; 3052 :         _Adl_verify_range(_First, _Last);
; 3053 :         const auto _UFirst = _Get_unwrapped(_First);
; 3054 :         return _Assign_range(_UFirst, _Get_unwrapped(_Last), _Is_elem_cptr<decltype(_UFirst)>{});
; 3055 :     }
; 3056 : #endif // _HAS_IF_CONSTEXPR
; 3057 : 
; 3058 :     basic_string& insert(const size_type _Off, const basic_string& _Right) { // insert _Right at _Off
; 3059 :         return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3060 :     }
; 3061 : 
; 3062 :     basic_string& insert(
; 3063 :         const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
; 3064 :         // insert _Right [_Roff, _Roff + _Count) at _Off
; 3065 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 3066 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 3067 :         return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 3068 :     }
; 3069 : 
; 3070 : #if _HAS_CXX17
; 3071 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3072 :     basic_string& insert(const size_type _Off, const _StringViewIsh& _Right) { // insert _Right at _Off
; 3073 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3074 :         return insert(_Off, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 3075 :     }
; 3076 : 
; 3077 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3078 :     basic_string& insert(const size_type _Off, const _StringViewIsh& _Right, const size_type _Roff,
; 3079 :         const size_type _Count = npos) { // insert _Right [_Roff, _Roff + _Count) at _Off
; 3080 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3081 :         return insert(_Off, _As_view.substr(_Roff, _Count));
; 3082 :     }
; 3083 : #endif // _HAS_CXX17
; 3084 : 
; 3085 :     basic_string& insert(
; 3086 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
; 3087 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 3088 :         _Mypair._Myval2._Check_offset(_Off);
; 3089 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3090 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 3091 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 3092 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3093 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3094 :             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
; 3095 :             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
; 3096 :             size_type _Ptr_shifted_after;
; 3097 :             if (_Ptr + _Count <= _Insert_at
; 3098 :                 || _Ptr > _Old_ptr + _Old_size) { // inserted content is before the shifted region, or does not alias
; 3099 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts
; 3100 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts
; 3101 :                 _Ptr_shifted_after = 0;
; 3102 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
; 3103 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
; 3104 :             }
; 3105 : 
; 3106 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
; 3107 :             _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
; 3108 :             _Traits::copy(
; 3109 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 3110 :             return *this;
; 3111 :         }
; 3112 : 
; 3113 :         return _Reallocate_grow_by(
; 3114 :             _Count,
; 3115 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3116 :                 const _Elem* const _Ptr, const size_type _Count) {
; 3117 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3118 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3119 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3120 :             },
; 3121 :             _Off, _Ptr, _Count);
; 3122 :     }
; 3123 : 
; 3124 :     basic_string& insert(const size_type _Off, _In_z_ const _Elem* const _Ptr) { // insert [_Ptr, <null>) at _Off
; 3125 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 3126 :     }
; 3127 : 
; 3128 :     basic_string& insert(const size_type _Off, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
; 3129 :         // insert _Count * _Ch at _Off
; 3130 :         _Mypair._Myval2._Check_offset(_Off);
; 3131 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3132 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
; 3133 :             _Mypair._Myval2._Mysize = _Old_size + _Count;
; 3134 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3135 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3136 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
; 3137 :             _Traits::assign(_Insert_at, _Count, _Ch); // fill hole
; 3138 :             return *this;
; 3139 :         }
; 3140 : 
; 3141 :         return _Reallocate_grow_by(
; 3142 :             _Count,
; 3143 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3144 :                 const size_type _Count, const _Elem _Ch) {
; 3145 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3146 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 3147 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3148 :             },
; 3149 :             _Off, _Count, _Ch);
; 3150 :     }
; 3151 : 
; 3152 :     iterator insert(const const_iterator _Where, const _Elem _Ch) { // insert _Ch at _Where
; 3153 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3154 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3155 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3156 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3157 :         insert(_Off, 1, _Ch);
; 3158 :         return begin() + static_cast<difference_type>(_Off);
; 3159 :     }
; 3160 : 
; 3161 :     iterator insert(const const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
; 3162 :         // insert _Count * _Elem at _Where
; 3163 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3164 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3165 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3166 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3167 :         insert(_Off, _Count, _Ch);
; 3168 :         return begin() + static_cast<difference_type>(_Off);
; 3169 :     }
; 3170 : 
; 3171 : #if _HAS_IF_CONSTEXPR
; 3172 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3173 :     iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
; 3174 :         // insert [_First, _Last) at _Where, input iterators
; 3175 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3176 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3177 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3178 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3179 :         _Adl_verify_range(_First, _Last);
; 3180 :         const auto _UFirst = _Get_unwrapped(_First);
; 3181 :         const auto _ULast  = _Get_unwrapped(_Last);
; 3182 :         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 3183 :             insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3184 :         } else {
; 3185 :             const basic_string _Right(_UFirst, _ULast, get_allocator());
; 3186 :             insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3187 :         }
; 3188 : 
; 3189 :         return begin() + static_cast<difference_type>(_Off);
; 3190 :     }
; 3191 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 3192 :     template <class _Iter>
; 3193 :     void _Insert_range(const size_type _Off, const _Iter _UFirst, const _Iter _ULast, true_type) {
; 3194 :         insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 3195 :     }
; 3196 : 
; 3197 :     template <class _Iter>
; 3198 :     void _Insert_range(const size_type _Off, const _Iter _UFirst, const _Iter _ULast, false_type) {
; 3199 :         const basic_string _Right(_UFirst, _ULast, get_allocator());
; 3200 :         insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3201 :     }
; 3202 : 
; 3203 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3204 :     iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
; 3205 :         // insert [_First, _Last) at _Where, input iterators
; 3206 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3207 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3208 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3209 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3210 :         _Adl_verify_range(_First, _Last);
; 3211 :         const auto _UFirst = _Get_unwrapped(_First);
; 3212 :         _Insert_range(_Off, _UFirst, _Get_unwrapped(_Last), _Is_elem_cptr<decltype(_UFirst)>{});
; 3213 :         return begin() + static_cast<difference_type>(_Off);
; 3214 :     }
; 3215 : #endif // _HAS_IF_CONSTEXPR
; 3216 : 
; 3217 :     basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)
; 3218 :         _Mypair._Myval2._Check_offset(_Off);
; 3219 :         _Eos(_Off);
; 3220 :         return *this;
; 3221 :     }
; 3222 : 
; 3223 :     basic_string& erase(const size_type _Off, size_type _Count) { // erase elements [_Off, _Off + _Count)
; 3224 :         _Mypair._Myval2._Check_offset(_Off);
; 3225 :         _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
; 3226 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3227 :         _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
; 3228 :         _Elem* const _Erase_at    = _My_ptr + _Off;
; 3229 :         const size_type _New_size = _Old_size - _Count;
; 3230 :         _Mypair._Myval2._Mysize   = _New_size;
; 3231 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up
; 3232 :         return *this;
; 3233 :     }
; 3234 : 
; 3235 :     iterator erase(const const_iterator _Where) noexcept /* strengthened */ {
; 3236 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3237 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
; 3238 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3239 :         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
; 3240 :         erase(_Off, 1);
; 3241 :         return begin() + static_cast<difference_type>(_Off);
; 3242 :     }
; 3243 : 
; 3244 :     iterator erase(const const_iterator _First, const const_iterator _Last) noexcept /* strengthened */ {
; 3245 :         _Adl_verify_range(_First, _Last);
; 3246 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3247 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3248 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3249 :         const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
; 3250 :         erase(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
; 3251 :         return begin() + static_cast<difference_type>(_Off);
; 3252 :     }
; 3253 : 
; 3254 :     void clear() noexcept { // erase all
; 3255 :         _Eos(0);
; 3256 :     }
; 3257 : 
; 3258 :     basic_string& replace(const size_type _Off, const size_type _N0, const basic_string& _Right) {
; 3259 :         // replace [_Off, _Off + _N0) with _Right
; 3260 :         return replace(_Off, _N0, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3261 :     }
; 3262 : 
; 3263 :     basic_string& replace(const size_type _Off, size_type _N0, const basic_string& _Right, const size_type _Roff,
; 3264 :         size_type _Count = npos) {
; 3265 :         // replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 3266 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 3267 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 3268 :         return replace(_Off, _N0, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
; 3269 :     }
; 3270 : 
; 3271 : #if _HAS_CXX17
; 3272 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3273 :     basic_string& replace(const size_type _Off, const size_type _N0, const _StringViewIsh& _Right) {
; 3274 :         // replace [_Off, _Off + _N0) with _Right
; 3275 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3276 :         return replace(_Off, _N0, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
; 3277 :     }
; 3278 : 
; 3279 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3280 :     basic_string& replace(const size_type _Off, const size_type _N0, const _StringViewIsh& _Right,
; 3281 :         const size_type _Roff, const size_type _Count = npos) {
; 3282 :         // replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 3283 :         basic_string_view<_Elem, _Traits> _As_view = _Right;
; 3284 :         return replace(_Off, _N0, _As_view.substr(_Roff, _Count));
; 3285 :     }
; 3286 : #endif // _HAS_CXX17
; 3287 : 
; 3288 :     basic_string& replace(
; 3289 :         const size_type _Off, size_type _N0, _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {
; 3290 :         // replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 3291 :         _Mypair._Myval2._Check_offset(_Off);
; 3292 :         _N0 = _Mypair._Myval2._Clamp_suffix_size(_Off, _N0);
; 3293 :         if (_N0 == _Count) { // size doesn't change, so a single move does the trick
; 3294 :             _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
; 3295 :             return *this;
; 3296 :         }
; 3297 : 
; 3298 :         const size_type _Old_size    = _Mypair._Myval2._Mysize;
; 3299 :         const size_type _Suffix_size = _Old_size - _N0 - _Off + 1;
; 3300 :         if (_Count < _N0) { // suffix shifts backwards; we don't have to move anything out of the way
; 3301 :             _Mypair._Myval2._Mysize = _Old_size - (_N0 - _Count);
; 3302 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3303 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3304 :             _Traits::move(_Insert_at, _Ptr, _Count);
; 3305 :             _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Suffix_size);
; 3306 :             return *this;
; 3307 :         }
; 3308 : 
; 3309 :         const size_type _Growth = static_cast<size_type>(_Count - _N0);
; 3310 :         if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { // growth fits
; 3311 :             _Mypair._Myval2._Mysize = _Old_size + _Growth;
; 3312 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3313 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3314 :             _Elem* const _Suffix_at = _Insert_at + _N0;
; 3315 : 
; 3316 :             size_type _Ptr_shifted_after; // see rationale in insert
; 3317 :             if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
; 3318 :                 _Ptr_shifted_after = _Count;
; 3319 :             } else if (_Suffix_at <= _Ptr) {
; 3320 :                 _Ptr_shifted_after = 0;
; 3321 :             } else {
; 3322 :                 _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
; 3323 :             }
; 3324 : 
; 3325 :             _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
; 3326 :             // next case must be move, in case _Ptr begins before _Insert_at and contains part of the hole;
; 3327 :             // this case doesn't occur in insert because the new content must come from outside the removed
; 3328 :             // content there (because in insert there is no removed content)
; 3329 :             _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
; 3330 :             // the next case can be copy, because it comes from the chunk moved out of the way in the
; 3331 :             // first move, and the hole we're filling can't alias the chunk we moved out of the way
; 3332 :             _Traits::copy(
; 3333 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 3334 :             return *this;
; 3335 :         }
; 3336 : 
; 3337 :         return _Reallocate_grow_by(
; 3338 :             _Growth,
; 3339 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3340 :                 const size_type _N0, const _Elem* const _Ptr, const size_type _Count) {
; 3341 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3342 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3343 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
; 3344 :             },
; 3345 :             _Off, _N0, _Ptr, _Count);
; 3346 :     }
; 3347 : 
; 3348 :     basic_string& replace(const size_type _Off, const size_type _N0, _In_z_ const _Elem* const _Ptr) {
; 3349 :         // replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 3350 :         return replace(_Off, _N0, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 3351 :     }
; 3352 : 
; 3353 :     basic_string& replace(const size_type _Off, size_type _N0, const size_type _Count, const _Elem _Ch) {
; 3354 :         // replace [_Off, _Off + _N0) with _Count * _Ch
; 3355 :         _Mypair._Myval2._Check_offset(_Off);
; 3356 :         _N0 = _Mypair._Myval2._Clamp_suffix_size(_Off, _N0);
; 3357 :         if (_Count == _N0) {
; 3358 :             _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
; 3359 :             return *this;
; 3360 :         }
; 3361 : 
; 3362 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3363 :         if (_Count < _N0
; 3364 :             || _Count - _N0 <= _Mypair._Myval2._Myres - _Old_size) { // either we are shrinking, or the growth fits
; 3365 :             _Mypair._Myval2._Mysize = _Old_size + _Count - _N0; // may temporarily overflow;
; 3366 :                                                                 // OK because size_type must be unsigned
; 3367 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3368 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3369 :             _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Old_size - _N0 - _Off + 1);
; 3370 :             _Traits::assign(_Insert_at, _Count, _Ch);
; 3371 :             return *this;
; 3372 :         }
; 3373 : 
; 3374 :         return _Reallocate_grow_by(
; 3375 :             _Count - _N0,
; 3376 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3377 :                 const size_type _N0, const size_type _Count, const _Elem _Ch) {
; 3378 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3379 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 3380 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
; 3381 :             },
; 3382 :             _Off, _N0, _Count, _Ch);
; 3383 :     }
; 3384 : 
; 3385 :     basic_string& replace(const const_iterator _First, const const_iterator _Last, const basic_string& _Right) {
; 3386 :         // replace [_First, _Last) with _Right
; 3387 :         _Adl_verify_range(_First, _Last);
; 3388 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3389 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3390 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3391 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3392 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
; 3393 :     }
; 3394 : 
; 3395 : #if _HAS_CXX17
; 3396 :     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
; 3397 :     basic_string& replace(const const_iterator _First, const const_iterator _Last, const _StringViewIsh& _Right) {
; 3398 :         // replace [_First, _Last) with _Right
; 3399 :         _Adl_verify_range(_First, _Last);
; 3400 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3401 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3402 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3403 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3404 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
; 3405 :     }
; 3406 : #endif // _HAS_CXX17
; 3407 : 
; 3408 :     basic_string& replace(const const_iterator _First, const const_iterator _Last,
; 3409 :         _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {
; 3410 :         // replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 3411 :         _Adl_verify_range(_First, _Last);
; 3412 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3413 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3414 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3415 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3416 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
; 3417 :     }
; 3418 : 
; 3419 :     basic_string& replace(const const_iterator _First, const const_iterator _Last, _In_z_ const _Elem* const _Ptr) {
; 3420 :         // replace [_First, _Last) with [_Ptr, <null>)
; 3421 :         _Adl_verify_range(_First, _Last);
; 3422 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3423 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3424 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3425 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3426 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
; 3427 :     }
; 3428 : 
; 3429 :     basic_string& replace(
; 3430 :         const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch) {
; 3431 :         // replace [_First, _Last) with _Count * _Ch
; 3432 :         _Adl_verify_range(_First, _Last);
; 3433 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3434 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3435 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3436 :         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3437 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
; 3438 :     }
; 3439 : 
; 3440 : #if _HAS_IF_CONSTEXPR
; 3441 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3442 :     basic_string& replace(
; 3443 :         const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
; 3444 :         // replace [_First, _Last) with [_First2, _Last2), input iterators
; 3445 :         _Adl_verify_range(_First, _Last);
; 3446 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3447 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3448 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3449 :         const auto _Off    = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
; 3450 :         const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
; 3451 :         _Adl_verify_range(_First2, _Last2);
; 3452 :         const auto _UFirst2 = _Get_unwrapped(_First2);
; 3453 :         const auto _ULast2  = _Get_unwrapped(_Last2);
; 3454 :         if constexpr (_Is_elem_cptr<decltype(_UFirst2)>::value) {
; 3455 :             return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
; 3456 :         } else {
; 3457 :             const basic_string _Right(_UFirst2, _ULast2, get_allocator());
; 3458 :             return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3459 :         }
; 3460 :     }
; 3461 : #else // ^^^ _HAS_IF_CONSTEXPR // !_HAS_IF_CONSTEXPR vvv
; 3462 :     template <class _Ptr>
; 3463 :     basic_string& _Replace_range(
; 3464 :         const size_type _Off, const size_type _Length, const _Ptr _UFirst2, const _Ptr _ULast2, true_type) {
; 3465 :         // replace [_First, _Last) with [_First2, _Last2), pointers
; 3466 :         return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
; 3467 :     }
; 3468 : 
; 3469 :     template <class _Iter>
; 3470 :     basic_string& _Replace_range(
; 3471 :         const size_type _Off, const size_type _Length, const _Iter _First2, const _Iter _Last2, false_type) {
; 3472 :         // replace [_First, _Last) with [_First2, _Last2), input iterators
; 3473 :         const basic_string _Right(_First2, _Last2, get_allocator());
; 3474 :         return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3475 :     }
; 3476 : 
; 3477 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 3478 :     basic_string& replace(
; 3479 :         const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
; 3480 :         // replace [_First, _Last) with [_First2, _Last2), input iterators
; 3481 :         _Adl_verify_range(_First, _Last);
; 3482 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3483 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
; 3484 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3485 :         _Adl_verify_range(_First2, _Last2);
; 3486 :         const auto _UFirst2 = _Get_unwrapped(_First2);
; 3487 :         const auto _ULast2 = _Get_unwrapped(_Last2);
; 3488 :         return _Replace_range(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
; 3489 :             static_cast<size_type>(_Last._Ptr - _First._Ptr), _UFirst2, _ULast2, _Is_elem_cptr<decltype(_UFirst2)>{});
; 3490 :     }
; 3491 : #endif // _HAS_IF_CONSTEXPR
; 3492 : 
; 3493 :     _NODISCARD iterator begin() noexcept {
; 3494 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
; 3495 :     }
; 3496 : 
; 3497 :     _NODISCARD const_iterator begin() const noexcept {
; 3498 :         return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
; 3499 :     }
; 3500 : 
; 3501 :     _NODISCARD iterator end() noexcept {
; 3502 :         return iterator(
; 3503 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3504 :             _STD addressof(_Mypair._Myval2));
; 3505 :     }
; 3506 : 
; 3507 :     _NODISCARD const_iterator end() const noexcept {
; 3508 :         return const_iterator(
; 3509 :             _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3510 :             _STD addressof(_Mypair._Myval2));
; 3511 :     }
; 3512 : 
; 3513 :     _Elem* _Unchecked_begin() noexcept {
; 3514 :         return _Mypair._Myval2._Myptr();
; 3515 :     }
; 3516 : 
; 3517 :     const _Elem* _Unchecked_begin() const noexcept {
; 3518 :         return _Mypair._Myval2._Myptr();
; 3519 :     }
; 3520 : 
; 3521 :     _Elem* _Unchecked_end() noexcept {
; 3522 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
; 3523 :     }
; 3524 : 
; 3525 :     const _Elem* _Unchecked_end() const noexcept {
; 3526 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
; 3527 :     }
; 3528 : 
; 3529 :     _NODISCARD reverse_iterator rbegin() noexcept {
; 3530 :         return reverse_iterator(end());
; 3531 :     }
; 3532 : 
; 3533 :     _NODISCARD const_reverse_iterator rbegin() const noexcept {
; 3534 :         return const_reverse_iterator(end());
; 3535 :     }
; 3536 : 
; 3537 :     _NODISCARD reverse_iterator rend() noexcept {
; 3538 :         return reverse_iterator(begin());
; 3539 :     }
; 3540 : 
; 3541 :     _NODISCARD const_reverse_iterator rend() const noexcept {
; 3542 :         return const_reverse_iterator(begin());
; 3543 :     }
; 3544 : 
; 3545 :     _NODISCARD const_iterator cbegin() const noexcept {
; 3546 :         return begin();
; 3547 :     }
; 3548 : 
; 3549 :     _NODISCARD const_iterator cend() const noexcept {
; 3550 :         return end();
; 3551 :     }
; 3552 : 
; 3553 :     _NODISCARD const_reverse_iterator crbegin() const noexcept {
; 3554 :         return rbegin();
; 3555 :     }
; 3556 : 
; 3557 :     _NODISCARD const_reverse_iterator crend() const noexcept {
; 3558 :         return rend();
; 3559 :     }
; 3560 : 
; 3561 :     void shrink_to_fit() { // reduce capacity
; 3562 :         auto& _My_data = _Mypair._Myval2;
; 3563 :         if (!_My_data._Large_string_engaged()) { // can't shrink from small mode
; 3564 :             return;
; 3565 :         }
; 3566 : 
; 3567 :         if (_My_data._Mysize < _BUF_SIZE) {
; 3568 :             _Become_small();
; 3569 :             return;
; 3570 :         }
; 3571 : 
; 3572 :         const size_type _Target_capacity = _Min_value(_My_data._Mysize | _ALLOC_MASK, max_size());
; 3573 :         if (_Target_capacity < _My_data._Myres) { // worth shrinking, do it
; 3574 :             auto& _Al              = _Getal();
; 3575 :             const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); // throws
; 3576 :             _My_data._Orphan_all();
; 3577 :             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
; 3578 :             _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
; 3579 :             _My_data._Bx._Ptr = _New_ptr;
; 3580 :             _My_data._Myres   = _Target_capacity;
; 3581 :         }
; 3582 :     }
; 3583 : 
; 3584 :     _NODISCARD reference at(const size_type _Off) {
; 3585 :         _Mypair._Myval2._Check_offset_exclusive(_Off);
; 3586 :         return _Mypair._Myval2._Myptr()[_Off];
; 3587 :     }
; 3588 : 
; 3589 :     _NODISCARD const_reference at(const size_type _Off) const {
; 3590 :         _Mypair._Myval2._Check_offset_exclusive(_Off);
; 3591 :         return _Mypair._Myval2._Myptr()[_Off];
; 3592 :     }
; 3593 : 
; 3594 :     _NODISCARD reference operator[](const size_type _Off) noexcept /* strengthened */ {
; 3595 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3596 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3597 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3598 :         return _Mypair._Myval2._Myptr()[_Off];
; 3599 :     }
; 3600 : 
; 3601 :     _NODISCARD const_reference operator[](const size_type _Off) const noexcept /* strengthened */ {
; 3602 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3603 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3604 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3605 :         return _Mypair._Myval2._Myptr()[_Off];
; 3606 :     }
; 3607 : 
; 3608 : #if _HAS_CXX17
; 3609 :     /* implicit */ operator basic_string_view<_Elem, _Traits>() const noexcept {
; 3610 :         // return a string_view around *this's character-type sequence
; 3611 :         return basic_string_view<_Elem, _Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize);
; 3612 :     }
; 3613 : #endif // _HAS_CXX17
; 3614 : 
; 3615 :     void push_back(const _Elem _Ch) { // insert element at end
; 3616 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3617 :         if (_Old_size < _Mypair._Myval2._Myres) {
; 3618 :             _Mypair._Myval2._Mysize = _Old_size + 1;
; 3619 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 3620 :             _Traits::assign(_Ptr[_Old_size], _Ch);
; 3621 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 3622 :             return;
; 3623 :         }
; 3624 : 
; 3625 :         _Reallocate_grow_by(
; 3626 :             1,
; 3627 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 3628 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3629 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 3630 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 3631 :             },
; 3632 :             _Ch);
; 3633 :     }
; 3634 : 
; 3635 :     void pop_back() noexcept /* strengthened */ {
; 3636 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3637 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 3638 :         _STL_VERIFY(_Old_size != 0, "invalid to pop_back empty string");
; 3639 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 3640 :         _Eos(_Old_size - 1);
; 3641 :     }
; 3642 : 
; 3643 :     _NODISCARD reference front() noexcept /* strengthened */ {
; 3644 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3645 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
; 3646 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3647 : 
; 3648 :         return _Mypair._Myval2._Myptr()[0];
; 3649 :     }
; 3650 : 
; 3651 :     _NODISCARD const_reference front() const noexcept /* strengthened */ {
; 3652 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3653 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
; 3654 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3655 : 
; 3656 :         return _Mypair._Myval2._Myptr()[0];
; 3657 :     }
; 3658 : 
; 3659 :     _NODISCARD reference back() noexcept /* strengthened */ {
; 3660 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3661 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "back() called on empty string");
; 3662 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3663 : 
; 3664 :         return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
; 3665 :     }
; 3666 : 
; 3667 :     _NODISCARD const_reference back() const noexcept /* strengthened */ {
; 3668 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3669 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "back() called on empty string");
; 3670 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3671 : 
; 3672 :         return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
; 3673 :     }
; 3674 : 
; 3675 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {
; 3676 :         return _Mypair._Myval2._Myptr();
; 3677 :     }
; 3678 : 
; 3679 :     _NODISCARD _Ret_z_ const _Elem* data() const noexcept {
; 3680 :         return _Mypair._Myval2._Myptr();
; 3681 :     }
; 3682 : 
; 3683 : #if _HAS_CXX17
; 3684 :     _NODISCARD _Ret_z_ _Elem* data() noexcept {
; 3685 :         return _Mypair._Myval2._Myptr();
; 3686 :     }
; 3687 : #endif // _HAS_CXX17
; 3688 : 
; 3689 :     _NODISCARD size_type length() const noexcept {
; 3690 :         return _Mypair._Myval2._Mysize;
; 3691 :     }
; 3692 : 
; 3693 :     _NODISCARD size_type size() const noexcept {
; 3694 :         return _Mypair._Myval2._Mysize;
; 3695 :     }
; 3696 : 
; 3697 :     _NODISCARD size_type max_size() const noexcept {
; 3698 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3699 :         const size_type _Storage_max = // can always store small string
; 3700 :             _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3701 :         return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3702 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3703 :         );
; 3704 :     }
; 3705 : 
; 3706 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Elem _Ch = _Elem()) {
; 3707 :         // determine new length, padding with _Ch elements as needed
; 3708 :         const size_type _Old_size = size();
; 3709 :         if (_Newsize <= _Old_size) {
; 3710 :             _Eos(_Newsize);
; 3711 :         } else {
; 3712 :             append(_Newsize - _Old_size, _Ch);
; 3713 :         }
; 3714 :     }
; 3715 : 
; 3716 :     _NODISCARD size_type capacity() const noexcept {
; 3717 :         return _Mypair._Myval2._Myres;
; 3718 :     }
; 3719 : 
; 3720 : #if _HAS_CXX20
; 3721 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap) { // determine new minimum length of allocated storage
; 3722 :         if (_Mypair._Myval2._Myres >= _Newcap) { // requested capacity is not larger than current capacity, ignore
; 3723 :             return; // nothing to do
; 3724 :         }
; 3725 : 
; 3726 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3727 :         _Reallocate_grow_by(
; 3728 :             _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
; 3729 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00006	40		 inc	 eax

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00007	50		 push	 eax
  00008	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __New_ptr$[ebp]
  0000e	e8 00 00 00 00	 call	 _memcpy
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3730 :             });

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z@QBEXQADQBDI@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  00004	72 0d		 jb	 SHORT $LN10@clear

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 4297 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  00008	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3255 :         _Eos(0);
; 3256 :     }

  00012	c3		 ret	 0
$LN10@clear:

; 4297 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  00013	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0001a	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 3255 :         _Eos(0);
; 3256 :     }

  0001d	c3		 ret	 0
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2830 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 322  :             return __builtin_strlen(_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]

; 2830 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 322  :             return __builtin_strlen(_First);

  00009	8b fa		 mov	 edi, edx

; 2830 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  0000b	8b d9		 mov	 ebx, ecx

; 322  :             return __builtin_strlen(_First);

  0000d	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL17@operator:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL17@operator

; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00017	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 322  :             return __builtin_strlen(_First);

  0001a	2b f9		 sub	 edi, ecx

; 2867 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0001c	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 2868 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  0001f	8b c6		 mov	 eax, esi
  00021	2b c1		 sub	 eax, ecx
  00023	3b f8		 cmp	 edi, eax
  00025	77 2a		 ja	 SHORT $LN8@operator

; 2869 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 2140 :         value_type* _Result = _Bx._Buf;

  0002d	8b c3		 mov	 eax, ebx

; 2158 :         return _BUF_SIZE <= _Myres;

  0002f	83 fe 10	 cmp	 esi, 16			; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  00032	72 02		 jb	 SHORT $LN11@operator

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  00034	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN11@operator:

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00036	57		 push	 edi

; 2871 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  0003a	52		 push	 edx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2872 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00044	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 2831 :         return append(_Ptr);

  00048	8b c3		 mov	 eax, ebx
  0004a	5f		 pop	 edi

; 2832 :     }

  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN8@operator:

; 2876 :         return _Reallocate_grow_by(

  00051	57		 push	 edi
  00052	52		 push	 edx
  00053	ff 75 08	 push	 DWORD PTR $T5[ebp]
  00056	8b cb		 mov	 ecx, ebx
  00058	57		 push	 edi
  00059	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
  0005e	5f		 pop	 edi

; 2832 :     }

  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___param0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
  00000	c2 00 00	 ret	 0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
  00000	c2 00 00	 ret	 0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 51   :     _Tree_unchecked_const_iterator& operator++() {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00004	8b 16		 mov	 edx, DWORD PTR [esi]
  00006	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  00009	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0000d	74 22		 je	 SHORT $LN4@operator

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0000f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00012	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00016	75 12		 jne	 SHORT $LN19@operator
$LL2@operator:
  00018	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0001b	75 0d		 jne	 SHORT $LN19@operator

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	8b d0		 mov	 edx, eax
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 ee		 je	 SHORT $LL2@operator
$LN19@operator:

; 56   :             }
; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())
; 59   :         } else {
; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 61   :         }
; 62   : 
; 63   :         return *this;

  0002a	89 06		 mov	 DWORD PTR [esi], eax

; 64   :     }

  0002c	8b c6		 mov	 eax, esi
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	c3		 ret	 0
$LN4@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00031	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00033	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00037	75 13		 jne	 SHORT $LN9@operator
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL8@operator:
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00042	8b f9		 mov	 edi, ecx
  00044	8b c8		 mov	 ecx, eax
  00046	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004a	74 f4		 je	 SHORT $LL8@operator
$LN9@operator:

; 56   :             }
; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())
; 59   :         } else {
; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 61   :         }
; 62   : 
; 63   :         return *this;

  0004c	89 3e		 mov	 DWORD PTR [esi], edi

; 64   :     }

  0004e	8b c6		 mov	 eax, esi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = ecx

; 44   :         return _Ptr->_Myval;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 45   :     }

  00005	c3		 ret	 0
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 40   :         this->_Adopt(_Plist);
; 41   :     }

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 2050 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00000	8b c1		 mov	 eax, ecx

; 2051 :     }

  00002	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Getal, COMDAT
; _this$ = ecx

; 2042 :         return _Mypair._Myval2._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2043 :     }

  00002	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAEXV?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Myhead$1$ = -4					; size = 4
__Ilist$ = 8						; size = 8
?insert@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAEXV?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::insert, COMDAT
; _this$ = ecx

; 1378 :     void insert(initializer_list<value_type> _Ilist) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1371 :         const auto _ULast  = _Get_unwrapped(_Last);

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Ilist$[ebp+4]

; 1378 :     void insert(initializer_list<value_type> _Ilist) {

  00008	56		 push	 esi

; 1370 :         auto _UFirst       = _Get_unwrapped(_First);

  00009	8b 75 08	 mov	 esi, DWORD PTR __Ilist$[ebp]

; 1378 :     void insert(initializer_list<value_type> _Ilist) {

  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx

; 1372 :         const auto _Myhead = _Get_scary()->_Myhead;

  0000f	8b 07		 mov	 eax, DWORD PTR [edi]
  00011	89 45 fc	 mov	 DWORD PTR __Myhead$1$[ebp], eax
  00014	3b f3		 cmp	 esi, ebx

; 1373 :         for (; _UFirst != _ULast; ++_UFirst) {

  00016	74 13		 je	 SHORT $LN5@insert
$LL6@insert:

; 1374 :             _Emplace_hint(_Myhead, *_UFirst);

  00018	56		 push	 esi
  00019	50		 push	 eax
  0001a	8b cf		 mov	 ecx, edi
  0001c	e8 00 00 00 00	 call	 ??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Emplace_hint<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
  00021	8b 45 fc	 mov	 eax, DWORD PTR __Myhead$1$[ebp]
  00024	83 c6 1c	 add	 esi, 28			; 0000001cH
  00027	3b f3		 cmp	 esi, ebx
  00029	75 ed		 jne	 SHORT $LL6@insert
$LN5@insert:
  0002b	5f		 pop	 edi

; 1379 :         insert(_Ilist.begin(), _Ilist.end());
; 1380 :     }

  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAEXV?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAUHKEY__@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
??0?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAUHKEY__@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >, COMDAT
; _this$ = ecx

; 880  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t(), _Parg, _Zero_then_variadic_args_t()) {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00003	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0001a	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0001c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0001f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00022	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00028	89 06		 mov	 DWORD PTR [esi], eax

; 881  :         _Alloc_sentinel_and_proxy();
; 882  :     }

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAUHKEY__@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1733 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1712 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1713 :         _Lockit _Lock(_LOCK_DEBUG);
; 1714 : 
; 1715 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1716 :         while (*_Pnext) {
; 1717 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1718 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1719 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1720 :             } else { // orphan the iterator
; 1721 :                 (*_Pnext)->_Myproxy = nullptr;
; 1722 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1723 :             }
; 1724 :         }
; 1725 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1726 :         (void) _First;
; 1727 :         (void) _Last;
; 1728 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1729 :     }

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
  0000b	cc		 int	 3
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;
; 1687 :         pointer& _Myfirst = _My_data._Myfirst;
; 1688 :         pointer& _Mylast  = _My_data._Mylast;
; 1689 :         pointer& _Myend   = _My_data._Myend;
; 1690 : 
; 1691 :         _My_data._Orphan_all();
; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 3d		 je	 SHORT $LN2@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN18@Tidy

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 22		 ja	 SHORT $LN15@Tidy

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN18@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00035	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  00038	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  0003f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1701 :     }

  00046	5e		 pop	 esi
  00047	c3		 ret	 0
$LN15@Tidy:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN22@Tidy:
  0004e	cc		 int	 3
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1612 :         _Destroy_range(_First, _Last, _Getal());
; 1613 :     }

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT
; _this$ = ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;
; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1495 :     }

  00005	c3		 ret	 0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT
; _this$dead$ = ecx

; 1488 :         return _Min_value(

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  00005	c3		 ret	 0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Size$1$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1251 :     void _Reallocate_exactly(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5d 08	 mov	 ebx, DWORD PTR __Newcapacity$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 1252 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1253 :         auto& _My_data    = _Mypair._Myval2;
; 1254 :         pointer& _Myfirst = _My_data._Myfirst;
; 1255 :         pointer& _Mylast  = _My_data._Mylast;
; 1256 : 
; 1257 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  0000c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000f	2b 07		 sub	 eax, DWORD PTR [edi]
  00011	89 45 fc	 mov	 DWORD PTR __Size$1$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  0001a	72 23		 jb	 SHORT $LN11@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001c	8d 43 23	 lea	 eax, DWORD PTR [ebx+35]

; 90   :     if (_Block_size <= _Bytes) {

  0001f	3b c3		 cmp	 eax, ebx
  00021	0f 86 8b 00 00
	00		 jbe	 $LN63@Reallocate

; 51   :         return ::operator new(_Bytes);

  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002d	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00030	85 c0		 test	 eax, eax
  00032	74 78		 je	 SHORT $LN54@Reallocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00034	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00037	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0003a	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0003d	eb 13		 jmp	 SHORT $LN10@Reallocate
$LN11@Reallocate:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

  0003f	85 db		 test	 ebx, ebx
  00041	74 0d		 je	 SHORT $LN12@Reallocate

; 51   :         return ::operator new(_Bytes);

  00043	53		 push	 ebx
  00044	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00049	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  0004c	8b f0		 mov	 esi, eax
  0004e	eb 02		 jmp	 SHORT $LN10@Reallocate
$LN12@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  00050	33 f6		 xor	 esi, esi
$LN10@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3750 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00052	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 3751 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3752 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00054	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00057	2b c1		 sub	 eax, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00059	50		 push	 eax
  0005a	51		 push	 ecx
  0005b	56		 push	 esi
  0005c	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00061	8b 07		 mov	 eax, DWORD PTR [edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00066	85 c0		 test	 eax, eax
  00068	74 29		 je	 SHORT $LN47@Reallocate

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0006d	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0006f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00075	72 12		 jb	 SHORT $LN57@Reallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00077	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0007a	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0007d	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00082	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00085	77 25		 ja	 SHORT $LN54@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00087	8b c2		 mov	 eax, edx
$LN57@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00089	51		 push	 ecx
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00090	83 c4 08	 add	 esp, 8
$LN47@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  00093	8b 45 fc	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00096	89 37		 mov	 DWORD PTR [edi], esi
  00098	03 c6		 add	 eax, esi
  0009a	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0009d	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  000a0	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx

; 1269 :     }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 04 00	 ret	 4
$LN54@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN63@Reallocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

  000b2	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN61@Reallocate:
  000b7	cc		 int	 3
?_Reallocate_exactly@?$vector@EV?$allocator@E@std@@@std@@AAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate_exactly
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;
; 1687 :         pointer& _Myfirst = _My_data._Myfirst;
; 1688 :         pointer& _Mylast  = _My_data._Mylast;
; 1689 :         pointer& _Myend   = _My_data._Myend;
; 1690 : 
; 1691 :         _My_data._Orphan_all();
; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 64		 je	 SHORT $LN2@Tidy

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00009	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0000c	56		 push	 esi
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00013	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00016	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001b	8b 37		 mov	 esi, DWORD PTR [edi]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0001d	83 c4 04	 add	 esp, 4

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00020	2b ce		 sub	 ecx, esi
  00022	f7 e9		 imul	 ecx
  00024	c1 fa 02	 sar	 edx, 2
  00027	8b c2		 mov	 eax, edx
  00029	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002c	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002e	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00031	c1 e1 03	 shl	 ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00034	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003a	72 12		 jb	 SHORT $LN20@Tidy

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003c	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  0003f	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00042	2b f2		 sub	 esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00044	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00047	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004a	77 23		 ja	 SHORT $LN17@Tidy

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004c	8b f2		 mov	 esi, edx
$LN20@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0004e	51		 push	 ecx
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00055	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00058	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1698 :             _Mylast  = pointer();

  0005e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1699 :             _Myend   = pointer();

  00065	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  0006c	5e		 pop	 esi
$LN2@Tidy:

; 1701 :     }

  0006d	5f		 pop	 edi
  0006e	c3		 ret	 0
$LN17@Tidy:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Tidy:
  00075	cc		 int	 3
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT
; _this$ = ecx

; 4335 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 4336 :     }

  00002	c3		 ret	 0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4308 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 08	 cmp	 ecx, 8

; 4309 :         _Mypair._Myval2._Orphan_all();
; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 2d		 jb	 SHORT $LN10@Tidy_deall
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN20@Tidy_deall

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 21		 ja	 SHORT $LN17@Tidy_deall

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN20@Tidy_deall:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN10@Tidy_deall:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00038	33 c0		 xor	 eax, eax
  0003a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	66 89 06	 mov	 WORD PTR [esi], ax
  0004b	5e		 pop	 esi

; 4322 :     }

  0004c	c3		 ret	 0
$LN17@Tidy_deall:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Tidy_deall:
  00053	cc		 int	 3
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4301 :         _Mypair._Myval2._Mysize = 0;
; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;
; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00000	33 c0		 xor	 eax, eax
  00002	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00009	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00010	66 89 01	 mov	 WORD PTR [ecx], ax

; 4306 :     }

  00013	c3		 ret	 0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
__Ptr$GSCopy$1$ = -12					; size = 4
__Count$GSCopy$1$ = -8					; size = 4
__New_ptr$1$ = -4					; size = 4
__Result$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2972 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00009	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	89 55 f4	 mov	 DWORD PTR __Ptr$GSCopy$1$[ebp], edx
  00014	89 45 f8	 mov	 DWORD PTR __Count$GSCopy$1$[ebp], eax

; 2973 :         // assign [_Ptr, _Ptr + _Count)
; 2974 :         if (_Count <= _Mypair._Myval2._Myres) {

  00017	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
  0001a	3b c3		 cmp	 eax, ebx
  0001c	77 32		 ja	 SHORT $LN2@assign

; 2140 :         value_type* _Result = _Bx._Buf;

  0001e	89 7d fc	 mov	 DWORD PTR __Result$1$[ebp], edi

; 2158 :         return _BUF_SIZE <= _Myres;

  00021	83 fb 08	 cmp	 ebx, 8

; 2141 :         if (_Large_string_engaged()) {

  00024	72 05		 jb	 SHORT $LN5@assign

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  00026	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00028	89 4d fc	 mov	 DWORD PTR __Result$1$[ebp], ecx
$LN5@assign:
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 246  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  0002b	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2976 :             _Mypair._Myval2._Mysize = _Count;

  0002e	89 47 10	 mov	 DWORD PTR [edi+16], eax
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 246  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00031	56		 push	 esi
  00032	52		 push	 edx
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2978 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	8b 45 fc	 mov	 eax, DWORD PTR __Result$1$[ebp]
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 246  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2978 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0003f	33 c9		 xor	 ecx, ecx
  00041	66 89 0c 06	 mov	 WORD PTR [esi+eax], cx

; 2987 :             },
; 2988 :             _Ptr);
; 2989 :     }

  00045	8b c7		 mov	 eax, edi
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN2@assign:

; 4229 :         if (_New_size > max_size()) {

  00050	3d fe ff ff 7f	 cmp	 eax, 2147483646		; 7ffffffeH
  00055	0f 87 a8 00 00
	00		 ja	 $LN54@assign

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0005b	8b f0		 mov	 esi, eax
  0005d	83 ce 07	 or	 esi, 7
  00060	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00066	76 07		 jbe	 SHORT $LN21@assign

; 4211 :             return _Max;

  00068	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  0006d	eb 1e		 jmp	 SHORT $LN20@assign
$LN21@assign:

; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0006f	8b cb		 mov	 ecx, ebx
  00071	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  00076	d1 e9		 shr	 ecx, 1
  00078	2b c1		 sub	 eax, ecx
  0007a	3b d8		 cmp	 ebx, eax
  0007c	76 07		 jbe	 SHORT $LN22@assign

; 4215 :             return _Max;

  0007e	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  00083	eb 08		 jmp	 SHORT $LN20@assign
$LN22@assign:

; 4216 :         }
; 4217 : 
; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  00085	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  00088	3b f0		 cmp	 esi, eax
  0008a	0f 42 f0	 cmovb	 esi, eax
$LN20@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4236 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0008d	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate

; 4237 :         _Mypair._Myval2._Orphan_all();
; 4238 :         _Mypair._Myval2._Mysize = _New_size;

  00096	8b 4d f8	 mov	 ecx, DWORD PTR __Count$GSCopy$1$[ebp]

; 4239 :         _Mypair._Myval2._Myres  = _New_capacity;

  00099	89 77 14	 mov	 DWORD PTR [edi+20], esi
  0009c	89 45 fc	 mov	 DWORD PTR __New_ptr$1$[ebp], eax
  0009f	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000a2	8d 34 09	 lea	 esi, DWORD PTR [ecx+ecx]
  000a5	56		 push	 esi
  000a6	ff 75 f4	 push	 DWORD PTR __Ptr$GSCopy$1$[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000af	8b 45 fc	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  000b2	33 c9		 xor	 ecx, ecx
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000b7	66 89 0c 06	 mov	 WORD PTR [esi+eax], cx

; 4241 :         if (_BUF_SIZE <= _Old_capacity) {

  000bb	83 fb 08	 cmp	 ebx, 8
  000be	72 30		 jb	 SHORT $LN15@assign
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c0	8b 07		 mov	 eax, DWORD PTR [edi]
  000c2	8d 1c 5d 02 00
	00 00		 lea	 ebx, DWORD PTR [ebx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000c9	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  000cf	72 12		 jb	 SHORT $LN46@assign

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000d1	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  000d4	83 c3 23	 add	 ebx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000d7	2b c1		 sub	 eax, ecx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000d9	83 c0 fc	 add	 eax, -4			; fffffffcH
  000dc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000df	77 1c		 ja	 SHORT $LN43@assign

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000e1	8b c1		 mov	 eax, ecx
$LN46@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

  000e3	53		 push	 ebx
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ea	8b 45 fc	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  000ed	83 c4 08	 add	 esp, 8
$LN15@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2982 :         return _Reallocate_for(

  000f0	89 07		 mov	 DWORD PTR [edi], eax

; 2987 :             },
; 2988 :             _Ptr);
; 2989 :     }

  000f2	8b c7		 mov	 eax, edi
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 08 00	 ret	 8
$LN43@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN54@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4230 :             _Xlen_string(); // result too long

  00103	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN51@assign:
  00108	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??R<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV23@QB_WI@Z@QBEXQA_WI0@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV23@QB_WI@Z@QBEXQA_WI0@Z PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>::operator(), COMDAT
; _this$dead$ = ecx

; 2987 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2987 :             },

  00006	56		 push	 esi
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00007	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2987 :             },

  0000a	57		 push	 edi
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000b	8d 3c 00	 lea	 edi, DWORD PTR [eax+eax]
  0000e	57		 push	 edi
  0000f	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memcpy
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0001b	33 c0		 xor	 eax, eax
  0001d	66 89 04 37	 mov	 WORD PTR [edi+esi], ax
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 2987 :             },

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV23@QB_WI@Z@QBEXQA_WI0@Z ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z
_TEXT	SEGMENT
__Ptr$GSCopy$1$ = -8					; size = 4
_this$GSCopy$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2340 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00009	33 c0		 xor	 eax, eax

; 2340 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	56		 push	 esi

; 163  :             return __builtin_wcslen(_First);

  0000f	8b f1		 mov	 esi, ecx

; 2340 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {

  00011	89 5d fc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  00014	89 4d f8	 mov	 DWORD PTR __Ptr$GSCopy$1$[ebp], ecx

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00017	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0001e	c7 43 14 07 00
	00 00		 mov	 DWORD PTR [ebx+20], 7

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00025	66 89 03	 mov	 WORD PTR [ebx], ax

; 163  :             return __builtin_wcslen(_First);

  00028	8d 56 02	 lea	 edx, DWORD PTR [esi+2]
  0002b	0f 1f 44 00 00	 npad	 5
$LL65@basic_stri:
  00030	66 8b 06	 mov	 ax, WORD PTR [esi]
  00033	83 c6 02	 add	 esi, 2
  00036	66 85 c0	 test	 ax, ax
  00039	75 f5		 jne	 SHORT $LL65@basic_stri
  0003b	2b f2		 sub	 esi, edx
  0003d	d1 fe		 sar	 esi, 1

; 2974 :         if (_Count <= _Mypair._Myval2._Myres) {

  0003f	83 fe 07	 cmp	 esi, 7
  00042	77 20		 ja	 SHORT $LN14@basic_stri

; 2975 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2976 :             _Mypair._Myval2._Mysize = _Count;

  00044	89 73 10	 mov	 DWORD PTR [ebx+16], esi
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 246  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00047	03 f6		 add	 esi, esi
  00049	56		 push	 esi
  0004a	51		 push	 ecx
  0004b	53		 push	 ebx
  0004c	e8 00 00 00 00	 call	 _memmove
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2978 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00054	33 c0		 xor	 eax, eax
  00056	66 89 04 1e	 mov	 WORD PTR [esi+ebx], ax

; 2341 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2342 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2343 :         _Tidy_init();
; 2344 :         assign(_Ptr);
; 2345 :         _Proxy._Release();
; 2346 :     }

  0005a	8b c3		 mov	 eax, ebx
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
$LN14@basic_stri:

; 4229 :         if (_New_size > max_size()) {

  00064	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH
  0006a	77 58		 ja	 SHORT $LN68@basic_stri

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0006c	8b de		 mov	 ebx, esi
  0006e	83 cb 07	 or	 ebx, 7
  00071	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00077	76 07		 jbe	 SHORT $LN33@basic_stri

; 4211 :             return _Max;

  00079	bb fe ff ff 7f	 mov	 ebx, 2147483646		; 7ffffffeH
  0007e	eb 0a		 jmp	 SHORT $LN32@basic_stri
$LN33@basic_stri:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  00080	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00085	3b d8		 cmp	 ebx, eax
  00087	0f 42 d8	 cmovb	 ebx, eax
$LN32@basic_stri:
  0008a	57		 push	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4236 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0008b	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  00094	8b f8		 mov	 edi, eax

; 4237 :         _Mypair._Myval2._Orphan_all();
; 4238 :         _Mypair._Myval2._Mysize = _New_size;

  00096	8b 45 fc	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00099	89 70 10	 mov	 DWORD PTR [eax+16], esi
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0009c	03 f6		 add	 esi, esi
  0009e	56		 push	 esi
  0009f	ff 75 f8	 push	 DWORD PTR __Ptr$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4239 :         _Mypair._Myval2._Myres  = _New_capacity;

  000a2	89 58 14	 mov	 DWORD PTR [eax+20], ebx
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000a5	57		 push	 edi
  000a6	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4245 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000ab	8b 5d fc	 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000b1	33 c0		 xor	 eax, eax
  000b3	66 89 04 3e	 mov	 WORD PTR [esi+edi], ax

; 2341 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2342 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2343 :         _Tidy_init();
; 2344 :         assign(_Ptr);
; 2345 :         _Proxy._Release();
; 2346 :     }

  000b7	8b c3		 mov	 eax, ebx

; 4245 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b9	89 3b		 mov	 DWORD PTR [ebx], edi
  000bb	5f		 pop	 edi

; 2341 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2342 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2343 :         _Tidy_init();
; 2344 :         assign(_Ptr);
; 2345 :         _Proxy._Release();
; 2346 :     }

  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 04 00	 ret	 4
$LN68@basic_stri:

; 4230 :             _Xlen_string(); // result too long

  000c4	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN66@basic_stri:
  000c9	cc		 int	 3
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2185 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	c2 00 00	 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8

; 2149 :         const value_type* _Result = _Bx._Buf;
; 2150 :         if (_Large_string_engaged()) {

  00004	72 03		 jb	 SHORT $LN6@Myptr

; 2151 :             _Result = _Unfancy(_Bx._Ptr);
; 2152 :         }
; 2153 : 
; 2154 :         return _Result;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2155 :     }

  00008	c3		 ret	 0
$LN6@Myptr:

; 2151 :             _Result = _Unfancy(_Bx._Ptr);
; 2152 :         }
; 2153 : 
; 2154 :         return _Result;

  00009	8b c1		 mov	 eax, ecx

; 2155 :     }

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8

; 2140 :         value_type* _Result = _Bx._Buf;
; 2141 :         if (_Large_string_engaged()) {

  00004	72 03		 jb	 SHORT $LN6@Myptr

; 2142 :             _Result = _Unfancy(_Bx._Ptr);
; 2143 :         }
; 2144 : 
; 2145 :         return _Result;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2146 :     }

  00008	c3		 ret	 0
$LN6@Myptr:

; 2142 :             _Result = _Unfancy(_Bx._Ptr);
; 2143 :         }
; 2144 : 
; 2145 :         return _Result;

  00009	8b c1		 mov	 eax, ecx

; 2146 :     }

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newsize$dead$ = 8					; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2141 :         if (_Large_string_engaged()) {

  00004	72 0f		 jb	 SHORT $LN8@Eos

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 4297 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  00008	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4298 :     }

  00012	c2 04 00	 ret	 4
$LN8@Eos:

; 4297 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  00015	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0001c	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 4298 :     }

  0001f	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?copy@?$_WChar_traits@_W@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$_WChar_traits@_W@std@@SAPA_WQA_WQB_WI@Z PROC	; std::_WChar_traits<wchar_t>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 173  :         const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memcpy
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 177  :     }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?copy@?$_WChar_traits@_W@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::_WChar_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ?end@?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ PROC ; std::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::end, COMDAT
; _this$ = ecx

; 43   :         return _Last;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 44   :     }

  00003	c3		 ret	 0
?end@?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ ENDP ; std::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\initializer_list
;	COMDAT ?begin@?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ PROC ; std::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::begin, COMDAT
; _this$ = ecx

; 39   :         return _First;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 40   :     }

  00002	c3		 ret	 0
?begin@?$initializer_list@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ ENDP ; std::initializer_list<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1337 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Min, COMDAT
; __Pnode$ = ecx

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00006	75 0d		 jne	 SHORT $LN9@Min
$LL2@Min:
  00008	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 452  :             _Pnode = _Pnode->_Left;

  0000a	8b c2		 mov	 eax, edx
  0000c	8b d1		 mov	 edx, ecx
  0000e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00012	74 f4		 je	 SHORT $LL2@Min

; 456  :     }

  00014	c3		 ret	 0
$LN9@Min:

; 453  :         }
; 454  : 
; 455  :         return _Pnode;

  00015	8b c1		 mov	 eax, ecx

; 456  :     }

  00017	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2020 :     void _Alloc_sentinel_and_proxy() {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00001	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 2020 :     void _Alloc_sentinel_and_proxy() {

  00003	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0000d	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0000f	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00012	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00015	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 2021 :         const auto _Scary = _Get_scary();
; 2022 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 2023 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2024 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0001b	89 06		 mov	 DWORD PTR [esi], eax
  0001d	5e		 pop	 esi

; 2025 :         _Proxy._Release();
; 2026 :     }

  0001e	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1337 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT
; _this$ = ecx

; 1736 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1737 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@ABEABV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array, COMDAT
; _this$ = ecx

; 1666 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1667 :         // orphan all iterators, discard old array, acquire new array
; 1668 :         auto& _My_data    = _Mypair._Myval2;
; 1669 :         pointer& _Myfirst = _My_data._Myfirst;
; 1670 :         pointer& _Mylast  = _My_data._Mylast;
; 1671 :         pointer& _Myend   = _My_data._Myend;
; 1672 : 
; 1673 :         _My_data._Orphan_all();
; 1674 : 
; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 29		 je	 SHORT $LN8@Change_arr

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000f	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN18@Change_arr

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 26		 ja	 SHORT $LN15@Change_arr

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN18@Change_arr:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
$LN8@Change_arr:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1680 :         _Myfirst = _Newvec;

  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1681 :         _Mylast  = _Newvec + _Newsize;

  00038	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003b	03 c1		 add	 eax, ecx
  0003d	89 0e		 mov	 DWORD PTR [esi], ecx
  0003f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  00042	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00045	03 c1		 add	 eax, ecx
  00047	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004a	5e		 pop	 esi

; 1683 :     }

  0004b	5d		 pop	 ebp
  0004c	c2 0c 00	 ret	 12			; 0000000cH
$LN15@Change_arr:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN22@Change_arr:
  00055	cc		 int	 3
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1605 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000c	2b c2		 sub	 eax, edx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000e	50		 push	 eax
  0000f	52		 push	 edx
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _memmove
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1609 :     }

  00019	5d		 pop	 ebp
  0001a	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	83 c8 ff	 or	 eax, -1

; 681  :     }

  00003	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@E@std@@QAEPAEI@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT
; _this$dead$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 29		 jb	 SHORT $LN4@allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0000d	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

  00010	3b c8		 cmp	 ecx, eax
  00012	76 39		 jbe	 SHORT $LN26@allocate

; 51   :         return ::operator new(_Bytes);

  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001a	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  0001c	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001f	85 c9		 test	 ecx, ecx
  00021	74 0d		 je	 SHORT $LN13@allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00023	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00026	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00029	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
$LN13@allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@allocate:

; 179  :     if (_Bytes != 0) {

  00036	85 c0		 test	 eax, eax
  00038	74 0d		 je	 SHORT $LN5@allocate

; 51   :         return ::operator new(_Bytes);

  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00040	83 c4 04	 add	 esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@allocate:

; 183  :     return nullptr;

  00047	33 c0		 xor	 eax, eax

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN26@allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

  0004d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN24@allocate:
  00052	cc		 int	 3
?allocate@?$allocator@E@std@@QAEPAEI@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXQAEI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXQAEI@Z PROC		; std::allocator<unsigned char>::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00009	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000f	72 12		 jb	 SHORT $LN15@deallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00011	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00014	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	77 10		 ja	 SHORT $LN12@deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00021	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00023	51		 push	 ecx
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8

; 781  :     }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
$LN12@deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  00037	cc		 int	 3
?deallocate@?$allocator@E@std@@QAEXQAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal, COMDAT
; _this$ = ecx

; 1732 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1733 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00006	51		 push	 ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0000f	83 c4 04	 add	 esp, 4

; 1613 :     }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0000c	c1 e2 03	 shl	 edx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000f	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00015	72 14		 jb	 SHORT $LN15@deallocate

; 108  :     _Bytes += _Non_user_size;

  00017	56		 push	 esi

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00018	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
  0001b	83 c2 23	 add	 edx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001e	2b ce		 sub	 ecx, esi

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00020	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 11		 ja	 SHORT $LN12@deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00028	8b ce		 mov	 ecx, esi
  0002a	5e		 pop	 esi
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8

; 781  :     }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN12@deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003f	cc		 int	 3
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1337 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z
_TEXT	SEGMENT
$T14 = -12						; size = 4
__New_ptr$1$ = -8					; size = 4
__Ptr$GSCopy$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2991 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 163  :             return __builtin_wcslen(_First);

  0000b	8b f2		 mov	 esi, edx

; 2991 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  0000d	89 55 fc	 mov	 DWORD PTR __Ptr$GSCopy$1$[ebp], edx
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx

; 163  :             return __builtin_wcslen(_First);

  00013	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
$LL56@assign:
  00016	66 8b 06	 mov	 ax, WORD PTR [esi]
  00019	83 c6 02	 add	 esi, 2
  0001c	66 85 c0	 test	 ax, ax
  0001f	75 f5		 jne	 SHORT $LL56@assign
  00021	2b f1		 sub	 esi, ecx

; 2974 :         if (_Count <= _Mypair._Myval2._Myres) {

  00023	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]

; 163  :             return __builtin_wcslen(_First);

  00026	d1 fe		 sar	 esi, 1

; 2974 :         if (_Count <= _Mypair._Myval2._Myres) {

  00028	89 4d f4	 mov	 DWORD PTR $T14[ebp], ecx
  0002b	3b f1		 cmp	 esi, ecx
  0002d	77 2a		 ja	 SHORT $LN6@assign

; 2140 :         value_type* _Result = _Bx._Buf;

  0002f	8b df		 mov	 ebx, edi

; 2158 :         return _BUF_SIZE <= _Myres;

  00031	83 f9 08	 cmp	 ecx, 8

; 2141 :         if (_Large_string_engaged()) {

  00034	72 02		 jb	 SHORT $LN9@assign

; 2142 :             _Result = _Unfancy(_Bx._Ptr);

  00036	8b 1f		 mov	 ebx, DWORD PTR [edi]
$LN9@assign:

; 2976 :             _Mypair._Myval2._Mysize = _Count;

  00038	89 77 10	 mov	 DWORD PTR [edi+16], esi
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 246  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  0003b	03 f6		 add	 esi, esi
  0003d	56		 push	 esi
  0003e	52		 push	 edx
  0003f	53		 push	 ebx
  00040	e8 00 00 00 00	 call	 _memmove
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2978 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	66 89 04 1e	 mov	 WORD PTR [esi+ebx], ax

; 2992 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0004e	8b c7		 mov	 eax, edi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 2993 :     }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN6@assign:

; 4229 :         if (_New_size > max_size()) {

  00059	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH
  0005f	0f 87 a4 00 00
	00		 ja	 $LN59@assign

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00065	8b de		 mov	 ebx, esi
  00067	83 cb 07	 or	 ebx, 7
  0006a	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00070	76 07		 jbe	 SHORT $LN25@assign

; 4211 :             return _Max;

  00072	bb fe ff ff 7f	 mov	 ebx, 2147483646		; 7ffffffeH
  00077	eb 1e		 jmp	 SHORT $LN24@assign
$LN25@assign:

; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00079	8b d1		 mov	 edx, ecx
  0007b	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  00080	d1 ea		 shr	 edx, 1
  00082	2b c2		 sub	 eax, edx
  00084	3b c8		 cmp	 ecx, eax
  00086	76 07		 jbe	 SHORT $LN26@assign

; 4215 :             return _Max;

  00088	bb fe ff ff 7f	 mov	 ebx, 2147483646		; 7ffffffeH
  0008d	eb 08		 jmp	 SHORT $LN24@assign
$LN26@assign:

; 4216 :         }
; 4217 : 
; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  0008f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  00092	3b d8		 cmp	 ebx, eax
  00094	0f 42 d8	 cmovb	 ebx, eax
$LN24@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4236 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00097	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate

; 4237 :         _Mypair._Myval2._Orphan_all();
; 4238 :         _Mypair._Myval2._Mysize = _New_size;

  000a0	89 77 10	 mov	 DWORD PTR [edi+16], esi
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000a3	03 f6		 add	 esi, esi
  000a5	56		 push	 esi
  000a6	ff 75 fc	 push	 DWORD PTR __Ptr$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4236 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000a9	89 45 f8	 mov	 DWORD PTR __New_ptr$1$[ebp], eax
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000ac	50		 push	 eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4239 :         _Mypair._Myval2._Myres  = _New_capacity;

  000ad	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000b0	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000b5	8b 5d f8	 mov	 ebx, DWORD PTR __New_ptr$1$[ebp]
  000b8	33 c0		 xor	 eax, eax
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000bd	66 89 04 1e	 mov	 WORD PTR [esi+ebx], ax

; 4241 :         if (_BUF_SIZE <= _Old_capacity) {

  000c1	8b 45 f4	 mov	 eax, DWORD PTR $T14[ebp]
  000c4	83 f8 08	 cmp	 eax, 8
  000c7	72 2d		 jb	 SHORT $LN19@assign
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c9	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+2]
  000d0	8b 07		 mov	 eax, DWORD PTR [edi]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000d2	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000d8	72 12		 jb	 SHORT $LN50@assign

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000da	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000dd	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000e0	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000e2	83 c0 fc	 add	 eax, -4			; fffffffcH
  000e5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000e8	77 19		 ja	 SHORT $LN47@assign

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000ea	8b c2		 mov	 eax, edx
$LN50@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

  000ec	51		 push	 ecx
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000f3	83 c4 08	 add	 esp, 8
$LN19@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2982 :         return _Reallocate_for(

  000f6	89 1f		 mov	 DWORD PTR [edi], ebx

; 2992 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000f8	8b c7		 mov	 eax, edi
  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx

; 2993 :     }

  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 04 00	 ret	 4
$LN47@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN59@assign:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4230 :             _Xlen_string(); // result too long

  00109	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN57@assign:
  0010e	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	0f 93 c0	 setae	 al

; 2159 :     }

  00007	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00012	72 14		 jb	 SHORT $LN15@deallocate

; 108  :     _Bytes += _Non_user_size;

  00014	56		 push	 esi

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00015	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
  00018	83 c2 23	 add	 edx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001b	2b ce		 sub	 ecx, esi

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001d	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00020	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00023	77 11		 ja	 SHORT $LN12@deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00025	8b ce		 mov	 ecx, esi
  00027	5e		 pop	 esi
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00028	52		 push	 edx
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8

; 781  :     }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
$LN12@deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003c	cc		 int	 3
?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 215  :         _Left = _Right;

  00000	66 8b 02	 mov	 ax, WORD PTR [edx]
  00003	66 89 01	 mov	 WORD PTR [ecx], ax

; 216  :     }

  00006	c3		 ret	 0
?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?move@?$_WChar_traits@_W@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$_WChar_traits@_W@std@@SAPA_WQA_WQB_WI@Z PROC	; std::_WChar_traits<wchar_t>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 202  :         const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 246  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memmove
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 206  :     }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?move@?$_WChar_traits@_W@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::_WChar_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1595 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000c	2b c2		 sub	 eax, edx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000e	50		 push	 eax
  0000f	52		 push	 edx
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _memmove
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1598 :     }

  00019	5d		 pop	 ebp
  0001a	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1337 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?length@?$_WChar_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
?length@?$_WChar_traits@_W@std@@SAIPB_W@Z PROC		; std::_WChar_traits<wchar_t>::length, COMDAT
; __First$ = ecx

; 160  :         // find length of null-terminated sequence
; 161  : #if _HAS_CXX17
; 162  :         if constexpr (is_same_v<_Elem, wchar_t>) {
; 163  :             return __builtin_wcslen(_First);

  00000	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL3@length:
  00003	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00006	83 c1 02	 add	 ecx, 2
  00009	66 85 c0	 test	 ax, ax
  0000c	75 f5		 jne	 SHORT $LL3@length
  0000e	2b ca		 sub	 ecx, edx
  00010	d1 f9		 sar	 ecx, 1
  00012	8b c1		 mov	 eax, ecx

; 164  :         } else {
; 165  :             return _Char_traits<_Elem, unsigned short>::length(_First);
; 166  :         }
; 167  : #else // _HAS_CXX17
; 168  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));
; 169  : #endif // _HAS_CXX17
; 170  :     }

  00014	c3		 ret	 0
?length@?$_WChar_traits@_W@std@@SAIPB_W@Z ENDP		; std::_WChar_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z
_TEXT	SEGMENT
_delimLength$1$ = -52					; size = 4
_end$1$ = -48						; size = 4
$T26 = -44						; size = 24
$T2 = -44						; size = 24
_delimiter$GSCopy$1$ = -20				; size = 4
__Result$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tokens$ = 8						; size = 4
??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z PROC ; split<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _str$ = ecx
; _delimiter$ = edx

; 28   : size_t split (__in const T& str, __in const T& delimiter, __out std::vector<T>& tokens) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	89 55 ec	 mov	 DWORD PTR _delimiter$GSCopy$1$[ebp], edx
  0002a	89 4d f0	 mov	 DWORD PTR __Result$1$[ebp], ecx
  0002d	8b 7d 08	 mov	 edi, DWORD PTR _tokens$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00030	51		 push	 ecx
  00031	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00034	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00036	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1390 :         _Mylast = _Myfirst;

  0003b	8b 07		 mov	 eax, DWORD PTR [edi]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003d	83 c4 04	 add	 esp, 4
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 32   :     size_t start = 0, end = str.find(delimiter), delimLength = delimiter.length();

  00040	8b 4d f0	 mov	 ecx, DWORD PTR __Result$1$[ebp]
  00043	33 f6		 xor	 esi, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1390 :         _Mylast = _Myfirst;

  00045	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 32   :     size_t start = 0, end = str.find(delimiter), delimLength = delimiter.length();

  00048	56		 push	 esi
  00049	ff 75 ec	 push	 DWORD PTR _delimiter$GSCopy$1$[ebp]
  0004c	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00051	8b d0		 mov	 edx, eax
  00053	8b 45 ec	 mov	 eax, DWORD PTR _delimiter$GSCopy$1$[ebp]
  00056	89 55 d0	 mov	 DWORD PTR _end$1$[ebp], edx
  00059	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005c	89 45 cc	 mov	 DWORD PTR _delimLength$1$[ebp], eax

; 33   : 
; 34   :     while (end != T::npos) {

  0005f	83 fa ff	 cmp	 edx, -1
  00062	0f 84 de 00 00
	00		 je	 $LN3@split
  00068	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@split:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2162 :         if (_Mysize < _Off) {

  00070	8b 45 f0	 mov	 eax, DWORD PTR __Result$1$[ebp]

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00073	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0007a	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00081	c6 45 d4 00	 mov	 BYTE PTR $T2[ebp], 0

; 2162 :         if (_Mysize < _Off) {

  00085	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00088	3b ce		 cmp	 ecx, esi
  0008a	0f 82 84 01 00
	00		 jb	 $LN173@split

; 2179 :         return _Min_value(_Size, _Mysize - _Off);

  00090	2b ce		 sub	 ecx, esi
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 35   :         tokens.emplace_back (str.substr (start, end - start));

  00092	2b d6		 sub	 edx, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2179 :         return _Min_value(_Size, _Mysize - _Off);

  00094	3b ca		 cmp	 ecx, edx
  00096	0f 42 d1	 cmovb	 edx, ecx

; 2150 :         if (_Large_string_engaged()) {

  00099	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0009d	8b c8		 mov	 ecx, eax
  0009f	72 02		 jb	 SHORT $LN172@split

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN172@split:

; 2954 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  000a3	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  000a6	52		 push	 edx
  000a7	50		 push	 eax
  000a8	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  000ab	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 35   :         tokens.emplace_back (str.substr (start, end - start));

  000b0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  000b7	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ba	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  000bd	74 20		 je	 SHORT $LN42@split
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000bf	0f 10 45 d4	 movups	 xmm0, XMMWORD PTR $T2[ebp]

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  000c3	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  000c8	c6 45 d4 00	 mov	 BYTE PTR $T2[ebp], 0

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000cc	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  000cf	f3 0f 7e 45 e4	 movq	 xmm0, QWORD PTR $T2[ebp+16]
  000d4	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 690  :         ++_Mylast;

  000d9	83 47 04 18	 add	 DWORD PTR [edi+4], 24	; 00000018H

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  000dd	eb 0f		 jmp	 SHORT $LN41@split
$LN42@split:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  000df	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  000e2	51		 push	 ecx
  000e3	50		 push	 eax
  000e4	8b cf		 mov	 ecx, edi
  000e6	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  000eb	8b 55 e8	 mov	 edx, DWORD PTR $T2[ebp+20]
$LN41@split:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 35   :         tokens.emplace_back (str.substr (start, end - start));

  000ee	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000f5	83 fa 10	 cmp	 edx, 16			; 00000010H
  000f8	72 2c		 jb	 SHORT $LN73@split
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000fa	8b 4d d4	 mov	 ecx, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000fd	42		 inc	 edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000fe	8b c1		 mov	 eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00100	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00106	72 14		 jb	 SHORT $LN83@split

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00108	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0010b	83 c2 23	 add	 edx, 35			; 00000023H
  0010e	2b c1		 sub	 eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00110	83 c0 fc	 add	 eax, -4			; fffffffcH
  00113	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00116	0f 87 c1 00 00
	00		 ja	 $LN156@split
$LN83@split:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0011c	52		 push	 edx
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00123	83 c4 08	 add	 esp, 8
$LN73@split:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 36   :         start = end + delimLength;

  00126	8b 75 cc	 mov	 esi, DWORD PTR _delimLength$1$[ebp]
  00129	03 75 d0	 add	 esi, DWORD PTR _end$1$[ebp]

; 37   :         end = str.find (delimiter, start);

  0012c	8b 4d f0	 mov	 ecx, DWORD PTR __Result$1$[ebp]
  0012f	56		 push	 esi
  00130	ff 75 ec	 push	 DWORD PTR _delimiter$GSCopy$1$[ebp]
  00133	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00138	8b d0		 mov	 edx, eax
  0013a	89 55 d0	 mov	 DWORD PTR _end$1$[ebp], edx
  0013d	83 fa ff	 cmp	 edx, -1
  00140	0f 85 2a ff ff
	ff		 jne	 $LL2@split
$LN3@split:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2162 :         if (_Mysize < _Off) {

  00146	8b 45 f0	 mov	 eax, DWORD PTR __Result$1$[ebp]

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00149	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T26[ebp+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00150	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T26[ebp+20], 15 ; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00157	c6 45 d4 00	 mov	 BYTE PTR $T26[ebp], 0

; 2162 :         if (_Mysize < _Off) {

  0015b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0015e	3b ce		 cmp	 ecx, esi
  00160	0f 82 ae 00 00
	00		 jb	 $LN173@split

; 2179 :         return _Min_value(_Size, _Mysize - _Off);

  00166	2b ce		 sub	 ecx, esi
  00168	83 ca ff	 or	 edx, -1
  0016b	83 f9 ff	 cmp	 ecx, -1
  0016e	0f 42 d1	 cmovb	 edx, ecx

; 2150 :         if (_Large_string_engaged()) {

  00171	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00175	72 02		 jb	 SHORT $LN111@split

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00177	8b 00		 mov	 eax, DWORD PTR [eax]
$LN111@split:

; 2954 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00179	52		 push	 edx
  0017a	03 c6		 add	 eax, esi
  0017c	8d 4d d4	 lea	 ecx, DWORD PTR $T26[ebp]
  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 40   :     tokens.emplace_back (str.substr (start));

  00185	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0018c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0018f	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00192	74 17		 je	 SHORT $LN118@split
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00194	0f 10 45 d4	 movups	 xmm0, XMMWORD PTR $T26[ebp]
  00198	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0019b	f3 0f 7e 45 e4	 movq	 xmm0, QWORD PTR $T26[ebp+16]
  001a0	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 690  :         ++_Mylast;

  001a5	83 47 04 18	 add	 DWORD PTR [edi+4], 24	; 00000018H

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  001a9	eb 42		 jmp	 SHORT $LN149@split
$LN118@split:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  001ab	8d 4d d4	 lea	 ecx, DWORD PTR $T26[ebp]
  001ae	51		 push	 ecx
  001af	50		 push	 eax
  001b0	8b cf		 mov	 ecx, edi
  001b2	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  001b7	8b 55 e8	 mov	 edx, DWORD PTR $T26[ebp+20]
  001ba	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001bd	72 2e		 jb	 SHORT $LN149@split
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001bf	8b 4d d4	 mov	 ecx, DWORD PTR $T26[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001c2	42		 inc	 edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001c3	8b c1		 mov	 eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001c5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001cb	72 16		 jb	 SHORT $LN159@split

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001cd	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001d0	83 c2 23	 add	 edx, 35			; 00000023H
  001d3	2b c1		 sub	 eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001d5	83 c0 fc	 add	 eax, -4			; fffffffcH
  001d8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001db	76 06		 jbe	 SHORT $LN159@split
$LN156@split:
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN159@split:

; 195  :     ::operator delete(_Ptr, _Bytes);

  001e3	52		 push	 edx
  001e4	51		 push	 ecx
  001e5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001ea	83 c4 08	 add	 esp, 8
$LN149@split:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001ed	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  001f0	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  001f5	2b 0f		 sub	 ecx, DWORD PTR [edi]
  001f7	f7 e9		 imul	 ecx
  001f9	c1 fa 02	 sar	 edx, 2
  001fc	8b c2		 mov	 eax, edx
  001fe	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00201	03 c2		 add	 eax, edx
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 43   : }

  00203	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00206	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0020d	59		 pop	 ecx
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c3		 ret	 0
$LN173@split:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2163 :             _Xran();

  00214	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN175@split:
  00219	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z$1:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR $T26[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$split@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ENDP ; split<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;
; 703  :         pointer& _Mylast = _My_data._Mylast;
; 704  :         if (_Mylast != _My_data._Myend) {

  00005	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00008	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0000b	74 3f		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00010	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00017	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0001e	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00021	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00024	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00029	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0

; 4301 :         _Mypair._Myval2._Mysize = 0;

  0002e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00035	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0003c	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0003f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 690  :         ++_Mylast;

  00042	8d 48 18	 lea	 ecx, DWORD PTR [eax+24]
  00045	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN2@emplace_ba:

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0004c	ff 75 08	 push	 DWORD PTR _<_Val_0>$[ebp]
  0004f	51		 push	 ecx
  00050	8b ca		 mov	 ecx, edx
  00052	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00003	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  0000c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00013	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0001a	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0001d	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00020	f3 0f 7e 42 10	 movq	 xmm0, QWORD PTR [edx+16]
  00025	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0

; 4301 :         _Mypair._Myval2._Mysize = 0;

  0002a	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00031	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00038	c6 02 00	 mov	 BYTE PTR [edx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0003b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 690  :         ++_Mylast;

  0003e	8d 48 18	 lea	 ecx, DWORD PTR [eax+24]
  00041	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 691  : #if _HAS_CXX17
; 692  :         return _Result;

  00044	5e		 pop	 esi

; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z
_TEXT	SEGMENT
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Left$ = ecx
; __Right$dead$ = edx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 4104 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00004	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 2150 :         if (_Large_string_engaged()) {

  00007	72 02		 jb	 SHORT $LN8@operator

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00009	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN8@operator:

; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  0000b	83 f8 01	 cmp	 eax, 1
  0000e	75 17		 jne	 SHORT $LN14@operator

; 302  :             return __builtin_memcmp(_First1, _First2, _Count);

  00010	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00013	3c 3f		 cmp	 al, 63			; 0000003fH
  00015	75 04		 jne	 SHORT $LN18@operator
  00017	33 c0		 xor	 eax, eax
  00019	eb 05		 jmp	 SHORT $LN19@operator
$LN18@operator:
  0001b	1b c0		 sbb	 eax, eax
  0001d	83 c8 01	 or	 eax, 1
$LN19@operator:

; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00020	85 c0		 test	 eax, eax
  00022	75 03		 jne	 SHORT $LN14@operator
  00024	b0 01		 mov	 al, 1

; 4492 :     return _Left._Equal(_Right);
; 4493 : }

  00026	c3		 ret	 0
$LN14@operator:

; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00027	32 c0		 xor	 al, al

; 4492 :     return _Left._Equal(_Right);
; 4493 : }

  00029	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$data@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAEAAV?$vector@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT
??$data@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAEAAV?$vector@EV?$allocator@E@std@@@0@@Z PROC ; std::data<std::vector<unsigned char,std::allocator<unsigned char> > >, COMDAT
; __Cont$ = ecx

; 2097 :     return _Cont.data();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2098 : }

  00002	c3		 ret	 0
??$data@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAEAAV?$vector@EV?$allocator@E@std@@@0@@Z ENDP ; std::data<std::vector<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@AAK@std@@YAAAKAAK@Z
_TEXT	SEGMENT
??$forward@AAK@std@@YAAAKAAK@Z PROC			; std::forward<unsigned long &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@AAK@std@@YAAAKAAK@Z ENDP			; std::forward<unsigned long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$construct@KAAK@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@QAKAAK@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@KAAK@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@QAKAAK@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 02		 mov	 DWORD PTR [edx], eax

; 671  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 672  :     }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
??$construct@KAAK@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@QAKAAK@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Emplace_reallocate@AAK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKAAK@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
__Whereptr$GSCopy$1$ = -8				; size = 4
tv618 = -4						; size = 4
__Whereoff$1$ = -4					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@AAK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKAAK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	89 45 f8	 mov	 DWORD PTR __Whereptr$GSCopy$1$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00011	8b 17		 mov	 edx, DWORD PTR [edi]
  00013	2b c2		 sub	 eax, edx
  00015	c1 f8 02	 sar	 eax, 2
  00018	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0001b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001e	2b c2		 sub	 eax, edx
  00020	c1 f8 02	 sar	 eax, 2

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00023	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00028	0f 84 25 01 00
	00		 je	 $LN88@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00031	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00034	2b ca		 sub	 ecx, edx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00036	89 5d f4	 mov	 DWORD PTR __Newsize$1$[ebp], ebx

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00039	c1 f9 02	 sar	 ecx, 2

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0003c	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00041	8b d1		 mov	 edx, ecx
  00043	d1 ea		 shr	 edx, 1
  00045	2b c2		 sub	 eax, edx
  00047	3b c8		 cmp	 ecx, eax
  00049	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  0004b	8b c3		 mov	 eax, ebx
  0004d	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0004f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  00052	3b c3		 cmp	 eax, ebx
  00054	0f 42 c3	 cmovb	 eax, ebx
$LN13@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 34   :             if (_Count > _Max_possible) {

  00057	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0005c	0f 87 ec 00 00
	00		 ja	 $LN85@Emplace_re

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  00062	8d 1c 85 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*4]

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00069	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  0006f	72 27		 jb	 SHORT $LN24@Emplace_re

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  00071	8d 43 23	 lea	 eax, DWORD PTR [ebx+35]

; 90   :     if (_Block_size <= _Bytes) {

  00074	3b c3		 cmp	 eax, ebx
  00076	0f 86 d2 00 00
	00		 jbe	 $LN85@Emplace_re

; 51   :         return ::operator new(_Bytes);

  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00082	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00085	85 c0		 test	 eax, eax
  00087	0f 84 bb 00 00
	00		 je	 $LN78@Emplace_re

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0008d	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00090	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00093	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00096	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

  00098	85 db		 test	 ebx, ebx
  0009a	74 0d		 je	 SHORT $LN25@Emplace_re

; 51   :         return ::operator new(_Bytes);

  0009c	53		 push	 ebx
  0009d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000a2	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  000a5	8b f0		 mov	 esi, eax
  000a7	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  000a9	33 f6		 xor	 esi, esi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000ab	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]

; 750  :         _Constructed_first = _Newvec + _Whereoff;
; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000ae	8b 55 f8	 mov	 edx, DWORD PTR __Whereptr$GSCopy$1$[ebp]
  000b1	8d 0c 86	 lea	 ecx, DWORD PTR [esi+eax*4]
  000b4	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000b7	89 4d fc	 mov	 DWORD PTR tv618[ebp], ecx
  000ba	8b 00		 mov	 eax, DWORD PTR [eax]
  000bc	89 01		 mov	 DWORD PTR [ecx], eax
  000be	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000c1	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c3	3b d0		 cmp	 edx, eax
  000c5	75 0f		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000c7	2b c1		 sub	 eax, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000c9	50		 push	 eax
  000ca	51		 push	 ecx
  000cb	56		 push	 esi
  000cc	e8 00 00 00 00	 call	 _memmove
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 754  :         } else { // provide basic guarantee

  000d4	eb 23		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000d6	2b d1		 sub	 edx, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000d8	52		 push	 edx
  000d9	51		 push	 ecx
  000da	56		 push	 esi
  000db	e8 00 00 00 00	 call	 _memmove

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000e0	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000e3	8b 4d f8	 mov	 ecx, DWORD PTR __Whereptr$GSCopy$1$[ebp]
  000e6	2b c1		 sub	 eax, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000e8	50		 push	 eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000e9	8b 45 fc	 mov	 eax, DWORD PTR tv618[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000ec	51		 push	 ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000ed	83 c0 04	 add	 eax, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 _memmove
  000f6	83 c4 18	 add	 esp, 24			; 00000018H
$LN5@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000f9	8b 07		 mov	 eax, DWORD PTR [edi]
  000fb	85 c0		 test	 eax, eax
  000fd	74 2c		 je	 SHORT $LN71@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000ff	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00102	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00104	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00107	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0010d	72 12		 jb	 SHORT $LN81@Emplace_re

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0010f	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00112	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00115	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00117	83 c0 fc	 add	 eax, -4			; fffffffcH
  0011a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0011d	77 29		 ja	 SHORT $LN78@Emplace_re

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0011f	8b c2		 mov	 eax, edx
$LN81@Emplace_re:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00121	51		 push	 ecx
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00128	83 c4 08	 add	 esp, 8
$LN71@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0012b	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  0012e	89 37		 mov	 DWORD PTR [edi], esi
  00130	8d 0c 86	 lea	 ecx, DWORD PTR [esi+eax*4]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  00133	8b 45 fc	 mov	 eax, DWORD PTR tv618[ebp]

; 1681 :         _Mylast  = _Newvec + _Newsize;

  00136	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  00139	8d 0c 33	 lea	 ecx, DWORD PTR [ebx+esi]
  0013c	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx

; 767  :     }

  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 08 00	 ret	 8
$LN78@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN85@Emplace_re:

; 91   :         _Throw_bad_array_new_length(); // add overflow

  0014e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN88@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 738  :             _Xlength();

  00153	e8 00 00 00 00	 call	 ?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
$LN86@Emplace_re:
  00158	cc		 int	 3
??$_Emplace_reallocate@AAK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKAAK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$?0PAUHKEY__@@AAY0EF@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0EF@$$CB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$dead$ = 12					; size = 4
??$?0PAUHKEY__@@AAY0EF@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0EF@$$CB_W@Z PROC ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > ><HKEY__ *,wchar_t const (&)[69],0>, COMDAT
; _this$ = ecx

; 152  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_1IK@NJBBFKEK@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00014	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00017	89 06		 mov	 DWORD PTR [esi], eax
  00019	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??$?0PAUHKEY__@@AAY0EF@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0EF@$$CB_W@Z ENDP ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > ><HKEY__ *,wchar_t const (&)[69],0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$?0PAUHKEY__@@AAY0EP@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0EP@$$CB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0PAUHKEY__@@AAY0EP@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0EP@$$CB_W@Z PROC ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > ><HKEY__ *,wchar_t const (&)[79],0>, COMDAT
; _this$ = ecx

; 152  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00007	56		 push	 esi
  00008	ff 75 0c	 push	 DWORD PTR __Val2$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00012	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
??$?0PAUHKEY__@@AAY0EP@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0EP@$$CB_W@Z ENDP ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > ><HKEY__ *,wchar_t const (&)[79],0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$?0PAUHKEY__@@AAY0GI@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0GI@$$CB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0PAUHKEY__@@AAY0GI@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0GI@$$CB_W@Z PROC ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > ><HKEY__ *,wchar_t const (&)[104],0>, COMDAT
; _this$ = ecx

; 152  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00007	56		 push	 esi
  00008	ff 75 0c	 push	 DWORD PTR __Val2$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00012	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
??$?0PAUHKEY__@@AAY0GI@$$CB_W$0A@@?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@$$QAPAUHKEY__@@AAY0GI@$$CB_W@Z ENDP ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > ><HKEY__ *,wchar_t const (&)[104],0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >, COMDAT
; _this$ = ecx

; 750  :     void _Erase_head(_Alnode& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Al$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 751  :         this->_Orphan_all();
; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	ff 70 04	 push	 DWORD PTR [eax+4]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00014	6a 2c		 push	 44			; 0000002cH
  00016	ff 36		 push	 DWORD PTR [esi]
  00018	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001d	83 c4 08	 add	 esp, 8
  00020	5e		 pop	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 754  :     }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$move@AAE@std@@YA$$QAEAAE@Z
_TEXT	SEGMENT
??$move@AAE@std@@YA$$QAEAAE@Z PROC			; std::move<unsigned char &>, COMDAT
; __Arg$ = ecx

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1468 : }

  00002	c3		 ret	 0
??$move@AAE@std@@YA$$QAEAAE@Z ENDP			; std::move<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@E@std@@YA$$QAEAAE@Z
_TEXT	SEGMENT
??$forward@E@std@@YA$$QAEAAE@Z PROC			; std::forward<unsigned char>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@E@std@@YA$$QAEAAE@Z ENDP			; std::forward<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$_Unfancy@E@std@@YAPAEPAE@Z
_TEXT	SEGMENT
??$_Unfancy@E@std@@YAPAEPAE@Z PROC			; std::_Unfancy<unsigned char>, COMDAT
; __Ptr$ = ecx

; 289  :     return _Ptr;

  00000	8b c1		 mov	 eax, ecx

; 290  : }

  00002	c3		 ret	 0
??$_Unfancy@E@std@@YAPAEPAE@Z ENDP			; std::_Unfancy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE$$QAE@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE$$QAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]
  00008	88 02		 mov	 BYTE PTR [edx], al

; 671  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 672  :     }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@QAE$$QAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QAEPAEQAE$$QAE@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
__Whereptr$GSCopy$1$ = -8				; size = 4
tv565 = -4						; size = 4
__Whereoff$1$ = -4					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QAEPAEQAE$$QAE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	89 45 f8	 mov	 DWORD PTR __Whereptr$GSCopy$1$[ebp], eax
  0000f	56		 push	 esi
  00010	57		 push	 edi

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00011	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00013	2b c1		 sub	 eax, ecx
  00015	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001b	2b c1		 sub	 eax, ecx

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00022	0f 84 04 01 00
	00		 je	 $LN84@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0002b	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00030	89 75 f4	 mov	 DWORD PTR __Newsize$1$[ebp], esi

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00033	8b ca		 mov	 ecx, edx
  00035	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0003a	d1 e9		 shr	 ecx, 1
  0003c	2b c1		 sub	 eax, ecx
  0003e	3b d0		 cmp	 edx, eax
  00040	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  00042	8b fe		 mov	 edi, esi
  00044	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00046	8d 3c 11	 lea	 edi, DWORD PTR [ecx+edx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  00049	3b fe		 cmp	 edi, esi
  0004b	0f 42 fe	 cmovb	 edi, esi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0004e	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  00054	72 27		 jb	 SHORT $LN20@Emplace_re

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  00056	8d 47 23	 lea	 eax, DWORD PTR [edi+35]

; 90   :     if (_Block_size <= _Bytes) {

  00059	3b c7		 cmp	 eax, edi
  0005b	0f 86 d0 00 00
	00		 jbe	 $LN85@Emplace_re

; 51   :         return ::operator new(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00067	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0006a	85 c0		 test	 eax, eax
  0006c	0f 84 b4 00 00
	00		 je	 $LN75@Emplace_re

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00072	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00075	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00078	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007b	eb 13		 jmp	 SHORT $LN19@Emplace_re
$LN20@Emplace_re:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

  0007d	85 ff		 test	 edi, edi
  0007f	74 0d		 je	 SHORT $LN21@Emplace_re

; 51   :         return ::operator new(_Bytes);

  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00087	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  0008a	8b f0		 mov	 esi, eax
  0008c	eb 02		 jmp	 SHORT $LN19@Emplace_re
$LN21@Emplace_re:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  0008e	33 f6		 xor	 esi, esi
$LN19@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00090	8b 4d fc	 mov	 ecx, DWORD PTR __Whereoff$1$[ebp]
  00093	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00096	03 ce		 add	 ecx, esi

; 750  :         _Constructed_first = _Newvec + _Whereoff;
; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00098	8b 55 f8	 mov	 edx, DWORD PTR __Whereptr$GSCopy$1$[ebp]
  0009b	89 4d fc	 mov	 DWORD PTR tv565[ebp], ecx
  0009e	8a 00		 mov	 al, BYTE PTR [eax]
  000a0	88 01		 mov	 BYTE PTR [ecx], al
  000a2	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000a5	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000a7	3b d0		 cmp	 edx, eax
  000a9	75 0f		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000ab	2b c1		 sub	 eax, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000ad	50		 push	 eax
  000ae	51		 push	 ecx
  000af	56		 push	 esi
  000b0	e8 00 00 00 00	 call	 _memmove
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 754  :         } else { // provide basic guarantee

  000b8	eb 21		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000ba	2b d1		 sub	 edx, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000bc	52		 push	 edx
  000bd	51		 push	 ecx
  000be	56		 push	 esi
  000bf	e8 00 00 00 00	 call	 _memmove

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000c4	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR __Whereptr$GSCopy$1$[ebp]
  000ca	2b c1		 sub	 eax, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000cc	50		 push	 eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000cd	8b 45 fc	 mov	 eax, DWORD PTR tv565[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000d0	51		 push	 ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000d1	40		 inc	 eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _memmove
  000d8	83 c4 18	 add	 esp, 24			; 00000018H
$LN5@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  000db	8b 03		 mov	 eax, DWORD PTR [ebx]
  000dd	85 c0		 test	 eax, eax
  000df	74 29		 je	 SHORT $LN68@Emplace_re

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e1	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e4	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000e6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ec	72 12		 jb	 SHORT $LN78@Emplace_re

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ee	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f1	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f4	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f6	83 c0 fc	 add	 eax, -4			; fffffffcH
  000f9	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fc	77 28		 ja	 SHORT $LN75@Emplace_re

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000fe	8b c2		 mov	 eax, edx
$LN78@Emplace_re:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00100	51		 push	 ecx
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00107	83 c4 08	 add	 esp, 8
$LN68@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0010a	8b 4d f4	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  0010d	8b 45 fc	 mov	 eax, DWORD PTR tv565[ebp]

; 1681 :         _Mylast  = _Newvec + _Newsize;

  00110	03 ce		 add	 ecx, esi
  00112	89 33		 mov	 DWORD PTR [ebx], esi
  00114	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  00117	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0011c	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  0011f	5b		 pop	 ebx

; 767  :     }

  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 08 00	 ret	 8
$LN75@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN84@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 738  :             _Xlength();

  0012c	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN85@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00131	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN82@Emplace_re:
  00136	cc		 int	 3
??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@QAEPAEQAE$$QAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00007	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00010	c2 08 00	 ret	 8
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00007	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??reserve@01@QAEXI@Z@@Z
_TEXT	SEGMENT
__Old_size$1$ = -12					; size = 4
__New_size$1$ = -8					; size = 4
$T10 = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??reserve@01@QAEXI@Z@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >, COMDAT
; _this$ = ecx

; 4252 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 4253 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4254 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4255 :         auto& _My_data            = _Mypair._Myval2;
; 4256 :         const size_type _Old_size = _My_data._Mysize;
; 4257 :         if (max_size() - _Old_size < _Size_increase) {

  00006	8b 55 08	 mov	 edx, DWORD PTR __Size_increase$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00011	56		 push	 esi
  00012	8b c1		 mov	 eax, ecx
  00014	57		 push	 edi
  00015	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  00018	2b c6		 sub	 eax, esi
  0001a	89 75 f4	 mov	 DWORD PTR __Old_size$1$[ebp], esi
  0001d	3b c2		 cmp	 eax, edx
  0001f	0f 82 ef 00 00
	00		 jb	 $LN65@Reallocate

; 4262 :         const size_type _Old_capacity = _My_data._Myres;

  00025	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
  00028	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0002b	8b f0		 mov	 esi, eax

; 4259 :         }
; 4260 : 
; 4261 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	89 45 f8	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00030	83 ce 0f	 or	 esi, 15			; 0000000fH

; 4262 :         const size_type _Old_capacity = _My_data._Myres;

  00033	89 7d fc	 mov	 DWORD PTR $T10[ebp], edi

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00036	3b f1		 cmp	 esi, ecx

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00038	76 04		 jbe	 SHORT $LN9@Reallocate

; 4211 :             return _Max;

  0003a	8b f1		 mov	 esi, ecx
  0003c	eb 18		 jmp	 SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0003e	8b c7		 mov	 eax, edi
  00040	d1 e8		 shr	 eax, 1
  00042	2b c8		 sub	 ecx, eax
  00044	3b f9		 cmp	 edi, ecx
  00046	76 07		 jbe	 SHORT $LN10@Reallocate

; 4215 :             return _Max;

  00048	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0004d	eb 07		 jmp	 SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4216 :         }
; 4217 : 
; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  0004f	03 c7		 add	 eax, edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  00051	3b f0		 cmp	 esi, eax
  00053	0f 42 f0	 cmovb	 esi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4265 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00056	33 c9		 xor	 ecx, ecx
  00058	8b c6		 mov	 eax, esi
  0005a	83 c0 01	 add	 eax, 1
  0005d	0f 92 c1	 setb	 cl
  00060	f7 d9		 neg	 ecx
  00062	0b c8		 or	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00064	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0006a	72 23		 jb	 SHORT $LN17@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0006c	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 90   :     if (_Block_size <= _Bytes) {

  0006f	3b c1		 cmp	 eax, ecx
  00071	0f 86 a2 00 00
	00		 jbe	 $LN66@Reallocate

; 51   :         return ::operator new(_Bytes);

  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007d	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00080	85 c0		 test	 eax, eax
  00082	74 73		 je	 SHORT $LN53@Reallocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00084	8d 78 23	 lea	 edi, DWORD PTR [eax+35]
  00087	83 e7 e0	 and	 edi, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0008a	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0008d	eb 13		 jmp	 SHORT $LN16@Reallocate
$LN17@Reallocate:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

  0008f	85 c9		 test	 ecx, ecx
  00091	74 0d		 je	 SHORT $LN18@Reallocate

; 51   :         return ::operator new(_Bytes);

  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00099	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  0009c	8b f8		 mov	 edi, eax
  0009e	eb 02		 jmp	 SHORT $LN16@Reallocate
$LN18@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  000a0	33 ff		 xor	 edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4267 :         _My_data._Mysize      = _New_size;

  000a2	8b 45 f8	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  000a5	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 4268 :         _My_data._Myres       = _New_capacity;
; 4269 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000a8	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$1$[ebp]
  000ab	40		 inc	 eax
  000ac	89 73 14	 mov	 DWORD PTR [ebx+20], esi

; 4270 :         if (_BUF_SIZE <= _Old_capacity) {

  000af	83 7d fc 10	 cmp	 DWORD PTR $T10[ebp], 16	; 00000010H
  000b3	50		 push	 eax
  000b4	72 47		 jb	 SHORT $LN3@Reallocate

; 4271 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000b6	8b 33		 mov	 esi, DWORD PTR [ebx]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000b8	56		 push	 esi
  000b9	57		 push	 edi
  000ba	e8 00 00 00 00	 call	 _memcpy

; 4272 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4273 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR $T10[ebp]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4272 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4273 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000c5	41		 inc	 ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000c6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000cc	72 12		 jb	 SHORT $LN56@Reallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ce	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000d1	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000d4	2b f2		 sub	 esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000d6	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  000d9	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000dc	77 19		 ja	 SHORT $LN53@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000de	8b f2		 mov	 esi, edx
$LN56@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  000e0	51		 push	 ecx
  000e1	56		 push	 esi
  000e2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000e7	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4280 :         return *this;

  000ea	89 3b		 mov	 DWORD PTR [ebx], edi
  000ec	8b c3		 mov	 eax, ebx
  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx

; 4281 :     }

  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c2 08 00	 ret	 8
$LN53@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000fd	53		 push	 ebx
  000fe	57		 push	 edi
  000ff	e8 00 00 00 00	 call	 _memcpy
  00104	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4280 :         return *this;

  00107	89 3b		 mov	 DWORD PTR [ebx], edi
  00109	8b c3		 mov	 eax, ebx
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx

; 4281 :     }

  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c2 08 00	 ret	 8
$LN65@Reallocate:

; 4258 :             _Xlen_string(); // result too long

  00114	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN66@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00119	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN63@Reallocate:
  0011e	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??reserve@01@QAEXI@Z@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$insert@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAEXPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@0@Z
_TEXT	SEGMENT
__Myhead$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$insert@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAEXPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@0@Z PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::insert<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const *>, COMDAT
; _this$ = ecx

; 1368 :     void insert(_Iter _First, _Iter _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1369 :         _Adl_verify_range(_First, _Last);
; 1370 :         auto _UFirst       = _Get_unwrapped(_First);
; 1371 :         const auto _ULast  = _Get_unwrapped(_Last);
; 1372 :         const auto _Myhead = _Get_scary()->_Myhead;
; 1373 :         for (; _UFirst != _ULast; ++_UFirst) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx
  0000f	8b 07		 mov	 eax, DWORD PTR [edi]
  00011	89 45 fc	 mov	 DWORD PTR __Myhead$1$[ebp], eax
  00014	3b f3		 cmp	 esi, ebx
  00016	74 13		 je	 SHORT $LN3@insert
$LL4@insert:

; 1374 :             _Emplace_hint(_Myhead, *_UFirst);

  00018	56		 push	 esi
  00019	50		 push	 eax
  0001a	8b cf		 mov	 ecx, edi
  0001c	e8 00 00 00 00	 call	 ??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Emplace_hint<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
  00021	8b 45 fc	 mov	 eax, DWORD PTR __Myhead$1$[ebp]
  00024	83 c6 1c	 add	 esi, 28			; 0000001cH
  00027	3b f3		 cmp	 esi, ebx
  00029	75 ed		 jne	 SHORT $LL4@insert
$LN3@insert:
  0002b	5f		 pop	 edi

; 1375 :         }
; 1376 :     }

  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
??$insert@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QAEXPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@0@Z ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::insert<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Get_unwrapped@AAPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@AAPBU10@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@AAPBU10@@Z PROC ; std::_Get_unwrapped<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const * &>, COMDAT
; __It$ = ecx

; 1197 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1198 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1199 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1200 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1201 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1202 :     } else {
; 1203 :         return static_cast<_Iter&&>(_It);
; 1204 :     }
; 1205 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@AAPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAPBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@AAPBU10@@Z ENDP ; std::_Get_unwrapped<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0ABU?$less@PAUHKEY__@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PAUHKEY__@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PAUHKEY__@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
??$?0ABU?$less@PAUHKEY__@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PAUHKEY__@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PAUHKEY__@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<HKEY__ *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>,1>::_Compressed_pair<std::less<HKEY__ *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>,1><std::less<HKEY__ *> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABU?$less@PAUHKEY__@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PAUHKEY__@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PAUHKEY__@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<HKEY__ *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>,1>::_Compressed_pair<std::less<HKEY__ *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>,1><std::less<HKEY__ *> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 941  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 942  :     using _Ty = typename _Alloc::value_type;
; 943  :     if
; 944  :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 945  :             (void) _First;
; 946  :             (void) _Last;
; 947  :             (void) _Al;
; 948  :         }
; 949  :     else {
; 950  :         for (; _First != _Last; ++_First) {
; 951  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 952  :         }
; 953  :     }
; 954  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z PROC		; std::_Destroy_in_place<wchar_t *>, COMDAT
; __Obj$dead$ = ecx

; 242  :     _Obj.~_Ty();
; 243  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ENDP		; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV34@QB_WI@Z@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QB_WI@Z@PB_W@Z
_TEXT	SEGMENT
_<_Args_0>$GSCopy$1$ = -8				; size = 4
__New_ptr$1$ = -4					; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV34@QB_WI@Z@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QB_WI@Z@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>,wchar_t const *>, COMDAT
; _this$ = ecx

; 4226 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 4227 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4228 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4229 :         if (_New_size > max_size()) {

  0000b	8b 75 08	 mov	 esi, DWORD PTR __New_size$[ebp]
  0000e	89 45 f8	 mov	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp], eax
  00011	57		 push	 edi
  00012	8b f9		 mov	 edi, ecx
  00014	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH
  0001a	0f 87 ab 00 00
	00		 ja	 $LN40@Reallocate

; 4231 :         }
; 4232 : 
; 4233 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  00020	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00023	83 ce 07	 or	 esi, 7
  00026	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0002c	76 07		 jbe	 SHORT $LN9@Reallocate

; 4211 :             return _Max;

  0002e	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  00033	eb 1e		 jmp	 SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00035	8b cb		 mov	 ecx, ebx
  00037	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  0003c	d1 e9		 shr	 ecx, 1
  0003e	2b c1		 sub	 eax, ecx
  00040	3b d8		 cmp	 ebx, eax
  00042	76 07		 jbe	 SHORT $LN10@Reallocate

; 4215 :             return _Max;

  00044	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  00049	eb 08		 jmp	 SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4216 :         }
; 4217 : 
; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  0004b	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  0004e	3b f0		 cmp	 esi, eax
  00050	0f 42 f0	 cmovb	 esi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4236 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00053	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  0005c	8b c8		 mov	 ecx, eax

; 4237 :         _Mypair._Myval2._Orphan_all();
; 4238 :         _Mypair._Myval2._Mysize = _New_size;
; 4239 :         _Mypair._Myval2._Myres  = _New_capacity;

  0005e	89 77 14	 mov	 DWORD PTR [edi+20], esi
  00061	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00064	89 4d fc	 mov	 DWORD PTR __New_ptr$1$[ebp], ecx
  00067	89 47 10	 mov	 DWORD PTR [edi+16], eax
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0006a	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]
  0006d	56		 push	 esi
  0006e	ff 75 f8	 push	 DWORD PTR _<_Args_0>$GSCopy$1$[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00077	8b 45 fc	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  0007a	33 c9		 xor	 ecx, ecx
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2986 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	66 89 0c 06	 mov	 WORD PTR [esi+eax], cx

; 4240 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4241 :         if (_BUF_SIZE <= _Old_capacity) {

  00083	83 fb 08	 cmp	 ebx, 8
  00086	72 30		 jb	 SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00088	8b 07		 mov	 eax, DWORD PTR [edi]
  0008a	8d 0c 5d 02 00
	00 00		 lea	 ecx, DWORD PTR [ebx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00091	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00097	72 12		 jb	 SHORT $LN34@Reallocate

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00099	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0009c	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0009f	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a1	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000a7	77 1c		 ja	 SHORT $LN31@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000a9	8b c2		 mov	 eax, edx
$LN34@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  000ab	51		 push	 ecx
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000b2	8b 45 fc	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  000b5	83 c4 08	 add	 esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4248 :         return *this;

  000b8	89 07		 mov	 DWORD PTR [edi], eax
  000ba	8b c7		 mov	 eax, edi
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx

; 4249 :     }

  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 0c 00	 ret	 12			; 0000000cH
$LN31@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN40@Reallocate:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4230 :             _Xlen_string(); // result too long

  000cb	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN38@Reallocate:
  000d0	cc		 int	 3
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV34@QB_WI@Z@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QB_WI@Z@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT
; __Ptr$ = ecx

; 289  :     return _Ptr;

  00000	8b c1		 mov	 eax, ecx

; 290  : }

  00002	c3		 ret	 0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >, COMDAT
; __Al$dead$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00000	6a 2c		 push	 44			; 0000002cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0000a	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0000c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0000f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00012	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 348  :         _Pnode->_Isnil = true;
; 349  :         return _Pnode;
; 350  :     }

  00018	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 940  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b fa		 mov	 edi, edx
  00007	8b f1		 mov	 esi, ecx

; 950  :         for (; _First != _Last; ++_First) {

  00009	3b f7		 cmp	 esi, edi
  0000b	74 4a		 je	 SHORT $LN45@Destroy_ra
  0000d	0f 1f 00	 npad	 3
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00010	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00013	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00016	72 27		 jb	 SHORT $LN23@Destroy_ra
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001a	41		 inc	 ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00021	72 12		 jb	 SHORT $LN33@Destroy_ra

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00023	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00026	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00029	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00031	77 28		 ja	 SHORT $LN30@Destroy_ra

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00033	8b c2		 mov	 eax, edx
$LN33@Destroy_ra:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00035	51		 push	 ecx
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN23@Destroy_ra:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4317 :         _Mypair._Myval2._Mysize = 0;

  0003f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4318 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00046	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4319 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4320 :         // write can alias this
; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004d	c6 06 00	 mov	 BYTE PTR [esi], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 950  :         for (; _First != _Last; ++_First) {

  00050	83 c6 18	 add	 esi, 24			; 00000018H
  00053	3b f7		 cmp	 esi, edi
  00055	75 b9		 jne	 SHORT $LL4@Destroy_ra
$LN45@Destroy_ra:
  00057	5f		 pop	 edi

; 951  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 952  :         }
; 953  :     }
; 954  : }

  00058	5e		 pop	 esi
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN30@Destroy_ra:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN46@Destroy_ra:
  00061	cc		 int	 3
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__Last$GSCopy$1$ = -4					; size = 4
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1646 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b c2		 mov	 eax, edx
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR __Dest$[ebp]
  0000e	89 45 fc	 mov	 DWORD PTR __Last$GSCopy$1$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00011	2b c3		 sub	 eax, ebx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	50		 push	 eax
  00014	53		 push	 ebx
  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 _memmove
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1655 :         return _Dest + (_ULast - _UFirst);

  0001e	2b fb		 sub	 edi, ebx
  00020	03 7d fc	 add	 edi, DWORD PTR __Last$GSCopy$1$[ebp]
  00023	8b c7		 mov	 eax, edi
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx

; 1656 :         (void) _Al;
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAE@std@@YAPAEABQAE@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAE@std@@YAPAEABQAE@Z PROC		; std::_Get_unwrapped<unsigned char * const &>, COMDAT
; __It$ = ecx

; 1197 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1198 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1199 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1200 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1201 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1202 :     } else {
; 1203 :         return static_cast<_Iter&&>(_It);
; 1204 :     }
; 1205 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQAE@std@@YAPAEABQAE@Z ENDP		; std::_Get_unwrapped<unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 51   :         return ::operator new(_Bytes);

  00000	6a 2c		 push	 44			; 0000002cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  0000a	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00006	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0000d	8b ca		 mov	 ecx, edx
  0000f	d1 e9		 shr	 ecx, 1
  00011	2b c1		 sub	 eax, ecx
  00013	3b d0		 cmp	 edx, eax
  00015	77 08		 ja	 SHORT $LN7@Calculate_

; 1620 :             return _Newsize; // geometric growth would overflow
; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00017	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0001a	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0001d	73 03		 jae	 SHORT $LN1@Calculate_
$LN7@Calculate_:

; 1626 :             return _Newsize; // geometric growth would be insufficient

  0001f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
$LN1@Calculate_:

; 1627 :         }
; 1628 : 
; 1629 :         return _Geometric; // geometric growth is sufficient
; 1630 :     }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Umove@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAE00@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove, COMDAT
; _this$dead$ = ecx

; 1591 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000f	8b cf		 mov	 ecx, edi
  00011	2b ce		 sub	 ecx, esi

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	53		 push	 ebx
  00016	e8 00 00 00 00	 call	 _memmove
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0001e	2b de		 sub	 ebx, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1655 :         return _Dest + (_ULast - _UFirst);

  00020	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx

; 1593 :     }

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Umove@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAE00@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ
_TEXT	SEGMENT
?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::data, COMDAT
; _this$ = ecx

; 1402 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1403 :     }

  00002	c3		 ret	 0
?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$allocator@E@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@E@std@@QAE@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@E@std@@QAE@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1712 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1713 :         _Lockit _Lock(_LOCK_DEBUG);
; 1714 : 
; 1715 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1716 :         while (*_Pnext) {
; 1717 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1718 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1719 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1720 :             } else { // orphan the iterator
; 1721 :                 (*_Pnext)->_Myproxy = nullptr;
; 1722 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1723 :             }
; 1724 :         }
; 1725 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1726 :         (void) _First;
; 1727 :         (void) _Last;
; 1728 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1729 :     }

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT
; _this$ = ecx

; 1483 :         auto& _My_data = _Mypair._Myval2;
; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 02	 sar	 edx, 2
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1485 :     }

  00016	c3		 ret	 0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00003	51		 push	 ecx
  00004	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00007	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00009	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);
; 1390 :         _Mylast = _Myfirst;

  0000e	8b 06		 mov	 eax, DWORD PTR [esi]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00010	83 c4 04	 add	 esp, 4

; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);
; 1390 :         _Mylast = _Myfirst;

  00013	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00016	5e		 pop	 esi

; 1391 :     }

  00017	c3		 ret	 0
?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4221 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00006	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  0000b	83 ca 07	 or	 edx, 7

; 4221 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  0000e	56		 push	 esi

; 4222 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0000f	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00012	3b d0		 cmp	 edx, eax

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00014	77 1d		 ja	 SHORT $LN3@Calculate_

; 4211 :             return _Max;
; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00016	8b ce		 mov	 ecx, esi
  00018	d1 e9		 shr	 ecx, 1
  0001a	2b c1		 sub	 eax, ecx
  0001c	3b f0		 cmp	 esi, eax
  0001e	76 0a		 jbe	 SHORT $LN5@Calculate_

; 4222 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00020	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  00025	5e		 pop	 esi

; 4223 :     }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN5@Calculate_:

; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  0002a	03 ce		 add	 ecx, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  0002c	3b d1		 cmp	 edx, ecx
  0002e	0f 42 d1	 cmovb	 edx, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4222 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00031	8b c2		 mov	 eax, edx
$LN3@Calculate_:
  00033	5e		 pop	 esi

; 4223 :     }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$dead$ = ecx

; 3698 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3699 :         const size_type _Storage_max = // can always store small string
; 3700 :             _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3701 :         return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00000	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 3702 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3703 :         );
; 3704 :     }

  00005	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$dead$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   :             if (_Count > _Max_possible) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000b	77 49		 ja	 SHORT $LN27@allocate

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  0000d	03 c0		 add	 eax, eax

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00014	72 29		 jb	 SHORT $LN8@allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  00016	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

  00019	3b c8		 cmp	 ecx, eax
  0001b	76 39		 jbe	 SHORT $LN27@allocate

; 51   :         return ::operator new(_Bytes);

  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00023	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  00025	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	85 c9		 test	 ecx, ecx
  0002a	74 0d		 je	 SHORT $LN17@allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0002c	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002f	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00032	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN17@allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN8@allocate:

; 179  :     if (_Bytes != 0) {

  0003f	85 c0		 test	 eax, eax
  00041	74 0d		 je	 SHORT $LN9@allocate

; 51   :         return ::operator new(_Bytes);

  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00049	83 c4 04	 add	 esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
$LN9@allocate:

; 183  :     return nullptr;

  00050	33 c0		 xor	 eax, eax

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
$LN27@allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00056	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN28@allocate:
  0005b	cc		 int	 3
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT
; _this$ = ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 4104 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00004	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 2150 :         if (_Large_string_engaged()) {

  00007	72 02		 jb	 SHORT $LN6@Equal

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00009	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN6@Equal:

; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  0000b	83 f8 01	 cmp	 eax, 1
  0000e	75 19		 jne	 SHORT $LN12@Equal

; 302  :             return __builtin_memcmp(_First1, _First2, _Count);

  00010	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00013	3c 3f		 cmp	 al, 63			; 0000003fH
  00015	75 04		 jne	 SHORT $LN16@Equal
  00017	33 c0		 xor	 eax, eax
  00019	eb 05		 jmp	 SHORT $LN17@Equal
$LN16@Equal:
  0001b	1b c0		 sbb	 eax, eax
  0001d	83 c8 01	 or	 eax, 1
$LN17@Equal:

; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00020	85 c0		 test	 eax, eax
  00022	75 05		 jne	 SHORT $LN12@Equal
  00024	b0 01		 mov	 al, 1

; 4105 :     }

  00026	c2 04 00	 ret	 4
$LN12@Equal:

; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00029	32 c0		 xor	 al, al

; 4105 :     }

  0002b	c2 04 00	 ret	 4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -4				; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 4093 :     _NODISCARD basic_string substr(const size_type _Off = 0, const size_type _Count = npos) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR __Off$[ebp]
  0000f	89 75 fc	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00019	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00020	c6 06 00	 mov	 BYTE PTR [esi], 0

; 2162 :         if (_Mysize < _Off) {

  00023	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00026	3b c7		 cmp	 eax, edi
  00028	72 24		 jb	 SHORT $LN32@substr

; 2179 :         return _Min_value(_Size, _Mysize - _Off);

  0002a	2b c7		 sub	 eax, edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  0002c	3b c2		 cmp	 eax, edx
  0002e	0f 42 d0	 cmovb	 edx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00031	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2150 :         if (_Large_string_engaged()) {

  00035	72 02		 jb	 SHORT $LN24@substr

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00037	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN24@substr:

; 2954 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00039	03 cf		 add	 ecx, edi
  0003b	52		 push	 edx
  0003c	51		 push	 ecx
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 4094 :         // return [_Off, _Off + _Count) as new string
; 4095 :         return basic_string(*this, _Off, _Count, get_allocator());

  00044	5f		 pop	 edi
  00045	8b c6		 mov	 eax, esi
  00047	5e		 pop	 esi

; 4096 :     }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 0c 00	 ret	 12			; 0000000cH
$LN32@substr:

; 2163 :             _Xran();

  0004e	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN30@substr:
  00053	cc		 int	 3
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z
_TEXT	SEGMENT
$T11 = -8						; size = 4
__Result$1$ = -4					; size = 4
__Possible_matches_end$1$ = 8				; size = 4
__Right$ = 8						; size = 4
tv301 = 12						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 3873 :     _NODISCARD size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 3874 :         // look for _Right beginning at or after _Off
; 3875 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  0000a	8b d1		 mov	 edx, ecx
  0000c	56		 push	 esi
  0000d	89 4d fc	 mov	 DWORD PTR __Result$1$[ebp], ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00010	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 3874 :         // look for _Right beginning at or after _Off
; 3875 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

  00014	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  00017	89 75 f8	 mov	 DWORD PTR $T11[ebp], esi

; 2150 :         if (_Large_string_engaged()) {

  0001a	72 02		 jb	 SHORT $LN4@find

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  0001c	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN4@find:

; 2158 :         return _BUF_SIZE <= _Myres;

  0001e	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 3874 :         // look for _Right beginning at or after _Off
; 3875 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

  00022	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]

; 2150 :         if (_Large_string_engaged()) {

  00025	72 05		 jb	 SHORT $LN9@find

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00027	8b 12		 mov	 edx, DWORD PTR [edx]
  00029	89 55 fc	 mov	 DWORD PTR __Result$1$[ebp], edx
$LN9@find:

; 538  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  0002c	3b f1		 cmp	 esi, ecx
  0002e	0f 87 d2 00 00
	00		 ja	 $LN18@find
  00034	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00037	2b ce		 sub	 ecx, esi
  00039	3b c1		 cmp	 eax, ecx
  0003b	0f 87 c5 00 00
	00		 ja	 $LN18@find

; 539  :         // xpos cannot exist, report failure
; 540  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 541  :         // 1. _Start_at <= xpos
; 542  :         // 2. xpos + _Needle_size <= _Hay_size;
; 543  :         // therefore:
; 544  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 545  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 546  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 547  :         return static_cast<size_t>(-1);
; 548  :     }
; 549  : 
; 550  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  00041	85 f6		 test	 esi, esi
  00043	0f 84 a7 00 00
	00		 je	 $LN15@find
  00049	57		 push	 edi

; 551  :         return _Start_at;
; 552  :     }
; 553  : 
; 554  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0004a	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  0004d	03 fa		 add	 edi, edx

; 555  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

  0004f	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]

; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);

  00052	0f be 13	 movsx	 edx, BYTE PTR [ebx]

; 554  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00055	89 7d 08	 mov	 DWORD PTR __Possible_matches_end$1$[ebp], edi

; 556  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  00058	2b f9		 sub	 edi, ecx

; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);

  0005a	57		 push	 edi
  0005b	52		 push	 edx
  0005c	51		 push	 ecx
  0005d	89 55 0c	 mov	 DWORD PTR tv301[ebp], edx
  00060	e8 00 00 00 00	 call	 _memchr
  00065	8b f8		 mov	 edi, eax
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 557  :         if (!_Match_try) { // didn't find first character; report failure

  0006a	85 ff		 test	 edi, edi
  0006c	74 7e		 je	 SHORT $LN28@find
  0006e	66 90		 npad	 2
$LL16@find:

; 302  :             return __builtin_memcmp(_First1, _First2, _Count);

  00070	8b d7		 mov	 edx, edi
  00072	8b c3		 mov	 eax, ebx
  00074	83 ee 04	 sub	 esi, 4
  00077	72 18		 jb	 SHORT $LN35@find
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL36@find:
  00080	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00082	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00084	75 10		 jne	 SHORT $LN34@find
  00086	83 c2 04	 add	 edx, 4
  00089	83 c0 04	 add	 eax, 4
  0008c	83 ee 04	 sub	 esi, 4
  0008f	73 ef		 jae	 SHORT $LL36@find
$LN35@find:
  00091	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00094	74 34		 je	 SHORT $LN33@find
$LN34@find:
  00096	8a 0a		 mov	 cl, BYTE PTR [edx]
  00098	3a 08		 cmp	 cl, BYTE PTR [eax]
  0009a	75 27		 jne	 SHORT $LN37@find
  0009c	83 fe fd	 cmp	 esi, -3			; fffffffdH
  0009f	74 29		 je	 SHORT $LN33@find
  000a1	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  000a4	3a 48 01	 cmp	 cl, BYTE PTR [eax+1]
  000a7	75 1a		 jne	 SHORT $LN37@find
  000a9	83 fe fe	 cmp	 esi, -2			; fffffffeH
  000ac	74 1c		 je	 SHORT $LN33@find
  000ae	8a 4a 02	 mov	 cl, BYTE PTR [edx+2]
  000b1	3a 48 02	 cmp	 cl, BYTE PTR [eax+2]
  000b4	75 0d		 jne	 SHORT $LN37@find
  000b6	83 fe ff	 cmp	 esi, -1
  000b9	74 0f		 je	 SHORT $LN33@find
  000bb	8a 4a 03	 mov	 cl, BYTE PTR [edx+3]
  000be	3a 48 03	 cmp	 cl, BYTE PTR [eax+3]
  000c1	74 07		 je	 SHORT $LN33@find
$LN37@find:
  000c3	1b c0		 sbb	 eax, eax
  000c5	83 c8 01	 or	 eax, 1
  000c8	eb 02		 jmp	 SHORT $LN38@find
$LN33@find:
  000ca	33 c0		 xor	 eax, eax
$LN38@find:

; 561  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

  000cc	85 c0		 test	 eax, eax
  000ce	74 28		 je	 SHORT $LN29@find

; 555  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

  000d0	8b 45 08	 mov	 eax, DWORD PTR __Possible_matches_end$1$[ebp]
  000d3	47		 inc	 edi

; 556  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  000d4	2b c7		 sub	 eax, edi

; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);

  000d6	50		 push	 eax
  000d7	ff 75 0c	 push	 DWORD PTR tv301[ebp]
  000da	57		 push	 edi
  000db	e8 00 00 00 00	 call	 _memchr

; 557  :         if (!_Match_try) { // didn't find first character; report failure

  000e0	8b 75 f8	 mov	 esi, DWORD PTR $T11[ebp]

; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);

  000e3	8b f8		 mov	 edi, eax
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 557  :         if (!_Match_try) { // didn't find first character; report failure

  000e8	85 ff		 test	 edi, edi
  000ea	75 84		 jne	 SHORT $LL16@find
$LN28@find:

; 3874 :         // look for _Right beginning at or after _Off
; 3875 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

  000ec	83 c8 ff	 or	 eax, -1
  000ef	5f		 pop	 edi
$LN15@find:

; 3876 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
; 3877 :     }

  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 08 00	 ret	 8
$LN29@find:

; 562  :             return static_cast<size_t>(_Match_try - _Haystack);

  000f8	2b 7d fc	 sub	 edi, DWORD PTR __Result$1$[ebp]

; 3874 :         // look for _Right beginning at or after _Off
; 3875 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

  000fb	8b c7		 mov	 eax, edi
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi

; 3876 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
; 3877 :     }

  000ff	5b		 pop	 ebx
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 08 00	 ret	 8
$LN18@find:
  00106	5e		 pop	 esi

; 3874 :         // look for _Right beginning at or after _Off
; 3875 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

  00107	83 c8 ff	 or	 eax, -1

; 3876 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
; 3877 :     }

  0010a	5b		 pop	 ebx
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 3690 :         return _Mypair._Myval2._Mysize;

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 3691 :     }

  00003	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?compare@?$_Narrow_char_traits@DH@std@@SAHQBD0I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?compare@?$_Narrow_char_traits@DH@std@@SAHQBD0I@Z PROC	; std::_Narrow_char_traits<char,int>::compare, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 293  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 294  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 295  : #if _HAS_CXX17
; 296  : #if _HAS_U8_INTRINSICS
; 297  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 298  :             return __builtin_u8memcmp(_First1, _First2, _Count);
; 299  :         } else
; 300  : #endif // _HAS_U8_INTRINSICS
; 301  :         {
; 302  :             return __builtin_memcmp(_First1, _First2, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  00007	83 ee 04	 sub	 esi, 4
  0000a	72 15		 jb	 SHORT $LN5@compare
  0000c	0f 1f 40 00	 npad	 4
$LL6@compare:
  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	3b 02		 cmp	 eax, DWORD PTR [edx]
  00014	75 10		 jne	 SHORT $LN4@compare
  00016	83 c1 04	 add	 ecx, 4
  00019	83 c2 04	 add	 edx, 4
  0001c	83 ee 04	 sub	 esi, 4
  0001f	73 ef		 jae	 SHORT $LL6@compare
$LN5@compare:
  00021	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00024	74 35		 je	 SHORT $LN3@compare
$LN4@compare:
  00026	8a 01		 mov	 al, BYTE PTR [ecx]
  00028	3a 02		 cmp	 al, BYTE PTR [edx]
  0002a	75 27		 jne	 SHORT $LN7@compare
  0002c	83 fe fd	 cmp	 esi, -3			; fffffffdH
  0002f	74 2a		 je	 SHORT $LN3@compare
  00031	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00034	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  00037	75 1a		 jne	 SHORT $LN7@compare
  00039	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0003c	74 1d		 je	 SHORT $LN3@compare
  0003e	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00041	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  00044	75 0d		 jne	 SHORT $LN7@compare
  00046	83 fe ff	 cmp	 esi, -1
  00049	74 10		 je	 SHORT $LN3@compare
  0004b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0004e	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00051	74 08		 je	 SHORT $LN3@compare
$LN7@compare:
  00053	1b c0		 sbb	 eax, eax
  00055	83 c8 01	 or	 eax, 1
  00058	5e		 pop	 esi

; 303  :         }
; 304  : #else // _HAS_CXX17
; 305  :         return _CSTD memcmp(_First1, _First2, _Count);
; 306  : #endif // _HAS_CXX17
; 307  :     }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN3@compare:

; 294  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 295  : #if _HAS_CXX17
; 296  : #if _HAS_U8_INTRINSICS
; 297  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 298  :             return __builtin_u8memcmp(_First1, _First2, _Count);
; 299  :         } else
; 300  : #endif // _HAS_U8_INTRINSICS
; 301  :         {
; 302  :             return __builtin_memcmp(_First1, _First2, _Count);

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 303  :         }
; 304  : #else // _HAS_CXX17
; 305  :         return _CSTD memcmp(_First1, _First2, _Count);
; 306  : #endif // _HAS_CXX17
; 307  :     }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?compare@?$_Narrow_char_traits@DH@std@@SAHQBD0I@Z ENDP	; std::_Narrow_char_traits<char,int>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT
; _this$ = ecx

; 4339 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 4340 :     }

  00002	c3		 ret	 0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z
_TEXT	SEGMENT
__Max$ = 8						; size = 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT
; __Requested$ = ecx
; __Old$ = edx

; 4208 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 4209 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Max$[ebp]
  00008	83 c9 07	 or	 ecx, 7
  0000b	3b cf		 cmp	 ecx, edi

; 4210 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000d	77 1a		 ja	 SHORT $LN7@Calculate_

; 4211 :             return _Max;
; 4212 :         }
; 4213 : 
; 4214 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0000f	8b f2		 mov	 esi, edx
  00011	8b c7		 mov	 eax, edi
  00013	d1 ee		 shr	 esi, 1
  00015	2b c6		 sub	 eax, esi
  00017	3b d0		 cmp	 edx, eax
  00019	77 0e		 ja	 SHORT $LN7@Calculate_

; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  0001b	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  0001e	3b c8		 cmp	 ecx, eax
  00020	5f		 pop	 edi
  00021	0f 42 c8	 cmovb	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4218 :         return _Max_value(_Masked, _Old + _Old / 2);

  00024	8b c1		 mov	 eax, ecx

; 4219 :     }

  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN7@Calculate_:

; 4215 :             return _Max;

  00029	8b c7		 mov	 eax, edi
  0002b	5f		 pop	 edi

; 4219 :     }

  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2183 :         _Bxty() {} // user-provided, for fancy pointers

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 681  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$dead$ = ecx

; 4202 :     _NODISCARD allocator_type get_allocator() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4203 :         return static_cast<allocator_type>(_Getal());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4204 :     }

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$dead$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2311 :     basic_string(

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 2162 :         if (_Mysize < _Off) {

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Roff$[ebp]

; 2311 :     basic_string(

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi

; 4301 :         _Mypair._Myval2._Mysize = 0;

  0000d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0001b	c6 06 00	 mov	 BYTE PTR [esi], 0

; 2162 :         if (_Mysize < _Off) {

  0001e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00021	3b ca		 cmp	 ecx, edx
  00023	72 26		 jb	 SHORT $LN27@basic_stri
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  00025	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2179 :         return _Min_value(_Size, _Mysize - _Off);

  00028	2b ca		 sub	 ecx, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  0002a	3b cf		 cmp	 ecx, edi
  0002c	0f 42 f9	 cmovb	 edi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  0002f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2150 :         if (_Large_string_engaged()) {

  00033	72 02		 jb	 SHORT $LN20@basic_stri

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00035	8b 00		 mov	 eax, DWORD PTR [eax]
$LN20@basic_stri:

; 2954 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00037	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  0003a	57		 push	 edi
  0003b	51		 push	 ecx
  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2312 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2313 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2314 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2315 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2316 :         _Tidy_init();
; 2317 :         assign(_Right, _Roff, _Count);
; 2318 :         _Proxy._Release();
; 2319 :     }

  00043	5f		 pop	 edi
  00044	8b c6		 mov	 eax, esi
  00046	5e		 pop	 esi
  00047	5d		 pop	 ebp
  00048	c2 10 00	 ret	 16			; 00000010H
$LN27@basic_stri:

; 2163 :             _Xran();

  0004b	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN25@basic_stri:
  00050	cc		 int	 3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2950 :     basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx

; 2162 :         if (_Mysize < _Off) {

  00010	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00013	3b ce		 cmp	 ecx, esi
  00015	72 20		 jb	 SHORT $LN18@assign

; 2179 :         return _Min_value(_Size, _Mysize - _Off);

  00017	2b ce		 sub	 ecx, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  00019	3b ca		 cmp	 ecx, edx
  0001b	0f 42 d1	 cmovb	 edx, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  0001e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2150 :         if (_Large_string_engaged()) {

  00022	72 02		 jb	 SHORT $LN12@assign

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00024	8b 00		 mov	 eax, DWORD PTR [eax]
$LN12@assign:

; 2951 :         // assign _Right [_Roff, _Roff + _Count)
; 2952 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 2953 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
; 2954 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00026	52		 push	 edx
  00027	03 c6		 add	 eax, esi
  00029	8b cf		 mov	 ecx, edi
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 2955 :     }

  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
$LN18@assign:

; 2163 :             _Xran();

  00037	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN16@assign:
  0003c	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z
_TEXT	SEGMENT
??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z PROC ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Ptr$ = ecx

; 289  :     return _Ptr;

  00000	8b c1		 mov	 eax, ecx

; 290  : }

  00002	c3		 ret	 0
??$_Unfancy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@@Z ENDP ; std::_Unfancy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00006	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
  0000d	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00014	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00017	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0001a	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001f	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00024	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0002b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00032	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 672  :     }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -20					; size = 4
_<_Val_0>$GSCopy$1$ = -16				; size = 4
_this$GSCopy$1$ = -12					; size = 4
__Whereptr$GSCopy$1$ = -8				; size = 4
_this$1$ = -4						; size = 4
__Whereoff$1$ = -4					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR _<_Val_0>$GSCopy$1$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	53		 push	 ebx
  00012	8b d9		 mov	 ebx, ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00017	56		 push	 esi
  00018	89 4d f8	 mov	 DWORD PTR __Whereptr$GSCopy$1$[ebp], ecx
  0001b	57		 push	 edi
  0001c	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0001e	2b cf		 sub	 ecx, edi
  00020	f7 e9		 imul	 ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00022	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00025	c1 fa 02	 sar	 edx, 2
  00028	2b cf		 sub	 ecx, edi
  0002a	8b c2		 mov	 eax, edx
  0002c	89 5d f4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  0002f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00032	03 c2		 add	 eax, edx
  00034	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  00037	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0003c	f7 e9		 imul	 ecx
  0003e	c1 fa 02	 sar	 edx, 2
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00046	03 c2		 add	 eax, edx
  00048	89 45 ec	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0004b	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00050	0f 84 79 01 00
	00		 je	 $LN94@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00056	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00059	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0005c	2b cf		 sub	 ecx, edi
  0005e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00063	f7 e9		 imul	 ecx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00065	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0006a	c1 fa 02	 sar	 edx, 2
  0006d	8b ca		 mov	 ecx, edx
  0006f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00072	03 ca		 add	 ecx, edx

; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00074	8b d1		 mov	 edx, ecx
  00076	d1 ea		 shr	 edx, 1
  00078	2b c2		 sub	 eax, edx
  0007a	3b c8		 cmp	 ecx, eax
  0007c	76 04		 jbe	 SHORT $LN12@Emplace_re

; 1620 :             return _Newsize; // geometric growth would overflow

  0007e	8b c6		 mov	 eax, esi
  00080	eb 08		 jmp	 SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00082	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  00085	3b c6		 cmp	 eax, esi
  00087	0f 42 c6	 cmovb	 eax, esi
$LN13@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 34   :             if (_Count > _Max_possible) {

  0008a	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0008f	0f 87 35 01 00
	00		 ja	 $LN90@Emplace_re

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  00095	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  00098	c1 e7 03	 shl	 edi, 3

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0009b	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  000a1	72 27		 jb	 SHORT $LN24@Emplace_re

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  000a3	8d 47 23	 lea	 eax, DWORD PTR [edi+35]

; 90   :     if (_Block_size <= _Bytes) {

  000a6	3b c7		 cmp	 eax, edi
  000a8	0f 86 1c 01 00
	00		 jbe	 $LN90@Emplace_re

; 51   :         return ::operator new(_Bytes);

  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b4	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000b7	85 c0		 test	 eax, eax
  000b9	0f 84 05 01 00
	00		 je	 $LN83@Emplace_re

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000bf	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  000c2	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000c5	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c8	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

  000ca	85 ff		 test	 edi, edi
  000cc	74 0d		 je	 SHORT $LN25@Emplace_re

; 51   :         return ::operator new(_Bytes);

  000ce	57		 push	 edi
  000cf	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000d4	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  000d7	8b f0		 mov	 esi, eax
  000d9	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  000db	33 f6		 xor	 esi, esi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000dd	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000e0	8b 4d f0	 mov	 ecx, DWORD PTR _<_Val_0>$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000e3	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  000e6	c7 44 c6 10 00
	00 00 00	 mov	 DWORD PTR [esi+eax*8+16], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000ee	8d 04 c6	 lea	 eax, DWORD PTR [esi+eax*8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  000f1	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000f8	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000fb	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000fe	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00101	f3 0f 7e 41 10	 movq	 xmm0, QWORD PTR [ecx+16]
  00106	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0010b	8b 45 f8	 mov	 eax, DWORD PTR __Whereptr$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4301 :         _Mypair._Myval2._Mysize = 0;

  0010e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00115	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0011c	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0011f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00121	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00124	51		 push	 ecx
  00125	56		 push	 esi
  00126	3b c2		 cmp	 eax, edx
  00128	74 17		 je	 SHORT $LN92@Emplace_re

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0012a	8b d0		 mov	 edx, eax
  0012c	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee
; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00131	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00134	83 c4 04	 add	 esp, 4
  00137	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee
; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0013a	83 c0 18	 add	 eax, 24			; 00000018H

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0013d	8b 4d f8	 mov	 ecx, DWORD PTR __Whereptr$GSCopy$1$[ebp]
  00140	50		 push	 eax
$LN92@Emplace_re:

; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00141	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00146	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00148	83 c4 08	 add	 esp, 8
  0014b	85 c9		 test	 ecx, ecx
  0014d	74 54		 je	 SHORT $LN76@Emplace_re

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0014f	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00152	51		 push	 ecx
  00153	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00158	8b 4d f4	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0015b	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00160	8b 1b		 mov	 ebx, DWORD PTR [ebx]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00162	83 c4 04	 add	 esp, 4

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00165	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00168	2b cb		 sub	 ecx, ebx
  0016a	f7 e9		 imul	 ecx
  0016c	c1 fa 02	 sar	 edx, 2
  0016f	8b c2		 mov	 eax, edx
  00171	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00174	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00176	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00179	c1 e1 03	 shl	 ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0017c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00182	72 12		 jb	 SHORT $LN86@Emplace_re

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00184	8b 53 fc	 mov	 edx, DWORD PTR [ebx-4]
  00187	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0018a	2b da		 sub	 ebx, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0018c	8d 43 fc	 lea	 eax, DWORD PTR [ebx-4]
  0018f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00192	77 30		 ja	 SHORT $LN83@Emplace_re

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00194	8b da		 mov	 ebx, edx
$LN86@Emplace_re:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00196	51		 push	 ecx
  00197	53		 push	 ebx
  00198	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0019d	8b 5d f4	 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  001a0	83 c4 08	 add	 esp, 8
$LN76@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1681 :         _Mylast  = _Newvec + _Newsize;

  001a3	8b 45 ec	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  001a6	40		 inc	 eax
  001a7	89 33		 mov	 DWORD PTR [ebx], esi
  001a9	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  001ac	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]

; 1681 :         _Mylast  = _Newvec + _Newsize;

  001af	8d 0c ce	 lea	 ecx, DWORD PTR [esi+ecx*8]
  001b2	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  001b5	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  001b8	5f		 pop	 edi
  001b9	5e		 pop	 esi

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  001ba	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  001bd	5b		 pop	 ebx

; 767  :     }

  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c2 08 00	 ret	 8
$LN83@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN90@Emplace_re:

; 91   :         _Throw_bad_array_new_length(); // add overflow

  001ca	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN94@Emplace_re:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 738  :             _Xlength();

  001cf	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN91@Emplace_re:
  001d4	cc		 int	 3
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@PAUHKEY__@@@std@@YA$$QAPAUHKEY__@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@PAUHKEY__@@@std@@YA$$QAPAUHKEY__@@AAPAU1@@Z PROC ; std::forward<HKEY__ *>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@PAUHKEY__@@@std@@YA$$QAPAUHKEY__@@AAPAU1@@Z ENDP ; std::forward<HKEY__ *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@AAY0EF@$$CB_W@std@@YAAAY0EF@$$CB_WAAY0EF@$$CB_W@Z
_TEXT	SEGMENT
??$forward@AAY0EF@$$CB_W@std@@YAAAY0EF@$$CB_WAAY0EF@$$CB_W@Z PROC ; std::forward<wchar_t const (&)[69]>, COMDAT
; __Arg$dead$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1IK@NJBBFKEK@?$AAS?$AAO?$AAF?$AAT?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAC?$AAl?$AAa?$AAs?$AAs?$AAe@

; 1456 : }

  00005	c3		 ret	 0
??$forward@AAY0EF@$$CB_W@std@@YAAAY0EF@$$CB_WAAY0EF@$$CB_W@Z ENDP ; std::forward<wchar_t const (&)[69]>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@AAY0EP@$$CB_W@std@@YAAAY0EP@$$CB_WAAY0EP@$$CB_W@Z
_TEXT	SEGMENT
??$forward@AAY0EP@$$CB_W@std@@YAAAY0EP@$$CB_WAAY0EP@$$CB_W@Z PROC ; std::forward<wchar_t const (&)[79]>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@AAY0EP@$$CB_W@std@@YAAAY0EP@$$CB_WAAY0EP@$$CB_W@Z ENDP ; std::forward<wchar_t const (&)[79]>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@AAY0GI@$$CB_W@std@@YAAAY0GI@$$CB_WAAY0GI@$$CB_W@Z
_TEXT	SEGMENT
??$forward@AAY0GI@$$CB_W@std@@YAAAY0GI@$$CB_WAAY0GI@$$CB_W@Z PROC ; std::forward<wchar_t const (&)[104]>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@AAY0GI@$$CB_W@std@@YAAAY0GI@$$CB_WAAY0GI@$$CB_W@Z ENDP ; std::forward<wchar_t const (&)[104]>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$GSCopy$1$ = -4					; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  00007	53		 push	 ebx
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	89 45 fc	 mov	 DWORD PTR __Al$GSCopy$1$[ebp], eax

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00011	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00015	75 77		 jne	 SHORT $LN73@Erase_tree
  00017	56		 push	 esi
$LL2@Erase_tree:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 77 08	 push	 DWORD PTR [edi+8]
  0001b	8b cb		 mov	 ecx, ebx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b f7		 mov	 esi, edi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 3f		 mov	 edi, DWORD PTR [edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00027	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0002a	83 f9 08	 cmp	 ecx, 8

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0002d	72 2e		 jb	 SHORT $LN29@Erase_tree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00032	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00039	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003f	72 12		 jb	 SHORT $LN39@Erase_tree

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00041	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00044	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00047	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00049	83 c0 fc	 add	 eax, -4			; fffffffcH
  0004c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004f	77 36		 ja	 SHORT $LN36@Erase_tree

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00051	8b c2		 mov	 eax, edx
$LN39@Erase_tree:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00053	51		 push	 ecx
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005a	83 c4 08	 add	 esp, 8
$LN29@Erase_tree:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0005d	33 c0		 xor	 eax, eax
  0005f	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00066	6a 2c		 push	 44			; 0000002cH
  00068	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4318 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00069	c7 46 28 07 00
	00 00		 mov	 DWORD PTR [esi+40], 7

; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00070	66 89 46 14	 mov	 WORD PTR [esi+20], ax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00074	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00079	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0007c	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00080	75 0b		 jne	 SHORT $LN74@Erase_tree
  00082	8b 45 fc	 mov	 eax, DWORD PTR __Al$GSCopy$1$[ebp]
  00085	eb 91		 jmp	 SHORT $LL2@Erase_tree
$LN36@Erase_tree:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN74@Erase_tree:
  0008d	5e		 pop	 esi
$LN73@Erase_tree:
  0008e	5f		 pop	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 747  :     }

  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 08 00	 ret	 8
$LN75@Erase_tree:
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00000	6a 2c		 push	 44			; 0000002cH
  00002	52		 push	 edx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00008	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 374  :     }

  0000b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Adl_verify_range@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PBU12@@std@@YAXABQBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PBU12@@std@@YAXABQBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const *,std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1157 :     // check that [_First, _Last) forms an iterator range
; 1158 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1159 :         _Verify_range(_First, _Last);
; 1160 :     } else {
; 1161 :         (void) _First; // TRANSITION, VSO-486357
; 1162 :         (void) _Last; // TRANSITION, VSO-486357
; 1163 :     }
; 1164 : }

  00000	c2 00 00	 ret	 0
??$_Adl_verify_range@PBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PBU12@@std@@YAXABQBU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const *,std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -56						; size = 12
$T4 = -52						; size = 8
__Loc$ = -44						; size = 12
__Myhead$1$ = -32					; size = 4
$T30 = -28						; size = 4
__Result$1$ = -24					; size = 4
__Right_size$1$ = -20					; size = 4
_<_Vals_0>$GSCopy$1$ = -20				; size = 4
__$EHRec$ = -12						; size = 12
__Hint$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Emplace_hint<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>, COMDAT
; _this$ = ecx

; 1100 :     _Nodeptr _Emplace_hint(const _Nodeptr _Hint, _Valtys&&... _Vals) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 ec 28	 sub	 esp, 40			; 00000028H
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	8b f9		 mov	 edi, ecx
  0003d	8b 4b 0c	 mov	 ecx, DWORD PTR _<_Vals_0>$[ebx]
  00040	8b 43 08	 mov	 eax, DWORD PTR __Hint$[ebx]

; 1101 :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 1102 :         const auto _Scary             = _Get_scary();
; 1103 :         _Tree_find_hint_result<_Nodeptr> _Loc;
; 1104 :         _Nodeptr _Inserted;
; 1105 :         if constexpr (!_Multi && _In_place_key_extractor::_Extractable) {
; 1106 :             _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));

  00043	51		 push	 ecx
  00044	50		 push	 eax
  00045	8d 45 c8	 lea	 eax, DWORD PTR $T1[ebp]
  00048	89 4d ec	 mov	 DWORD PTR _<_Vals_0>$GSCopy$1$[ebp], ecx
  0004b	50		 push	 eax
  0004c	8b cf		 mov	 ecx, edi
  0004e	e8 00 00 00 00	 call	 ??$_Find_hint@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_hint_result@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABQAUHKEY__@@@Z ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Find_hint<HKEY__ *>
  00053	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00057	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005a	66 0f d6 45 d4	 movq	 QWORD PTR __Loc$[ebp], xmm0
  0005f	89 45 dc	 mov	 DWORD PTR __Loc$[ebp+8], eax

; 1107 :             if (_Loc._Duplicate) {

  00062	84 c0		 test	 al, al
  00064	74 08		 je	 SHORT $LN2@Emplace_hi

; 1108 :                 return _Loc._Location._Parent;

  00066	8b 45 d4	 mov	 eax, DWORD PTR __Loc$[ebp]
  00069	e9 e2 00 00 00	 jmp	 $LN1@Emplace_hi
$LN2@Emplace_hi:

; 1722 :         if (max_size() == _Get_scary()->_Mysize) {

  0006e	81 7f 04 5d 74
	d1 05		 cmp	 DWORD PTR [edi+4], 97612893 ; 05d1745dH
  00075	0f 84 eb 00 00
	00		 je	 $LN149@Emplace_hi

; 1109 :             }
; 1110 : 
; 1111 :             _Check_grow_by_1();
; 1112 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  0007b	8b 07		 mov	 eax, DWORD PTR [edi]
  0007d	89 45 e0	 mov	 DWORD PTR __Myhead$1$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00080	89 7d cc	 mov	 DWORD PTR $T4[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00083	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0008a	6a 2c		 push	 44			; 0000002cH

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0008c	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], 0

; 51   :         return ::operator new(_Bytes);

  00093	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1044 :         _Ptr = _Al.allocate(1);

  00098	8b f0		 mov	 esi, eax

; 51   :         return ::operator new(_Bytes);

  0009a	83 c4 04	 add	 esp, 4

; 1044 :         _Ptr = _Al.allocate(1);

  0009d	89 75 d0	 mov	 DWORD PTR $T4[ebp+4], esi
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

  000a0	8b 45 ec	 mov	 eax, DWORD PTR _<_Vals_0>$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  000a3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

  000aa	8b 08		 mov	 ecx, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2661 :         auto& _Right_data             = _Right._Mypair._Myval2;

  000ac	83 c0 04	 add	 eax, 4
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

  000af	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  000b2	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  000b9	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 2158 :         return _BUF_SIZE <= _Myres;

  000c0	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8

; 2662 :         const size_type _Right_size   = _Right_data._Mysize;

  000c4	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000c7	89 45 e8	 mov	 DWORD PTR __Result$1$[ebp], eax
  000ca	89 4d ec	 mov	 DWORD PTR __Right_size$1$[ebp], ecx

; 2150 :         if (_Large_string_engaged()) {

  000cd	72 05		 jb	 SHORT $LN60@Emplace_hi

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  000cf	8b 00		 mov	 eax, DWORD PTR [eax]
  000d1	89 45 e8	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN60@Emplace_hi:

; 2665 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  000d4	83 f9 08	 cmp	 ecx, 8
  000d7	73 0e		 jae	 SHORT $LN57@Emplace_hi
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000d9	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2668 :             _My_data._Myres  = _BUF_SIZE - 1;

  000dc	b8 07 00 00 00	 mov	 eax, 7
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000e1	0f 11 46 14	 movups	 XMMWORD PTR [esi+20], xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2669 :             return;

  000e5	eb 44		 jmp	 SHORT $LN56@Emplace_hi
$LN57@Emplace_hi:

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  000e7	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  000e9	b9 fe ff ff 7f	 mov	 ecx, 2147483646		; 7ffffffeH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  000ee	83 c8 07	 or	 eax, 7
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  000f1	3b c1		 cmp	 eax, ecx
  000f3	0f 47 c1	 cmova	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000f6	33 c9		 xor	 ecx, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  000f8	89 45 e4	 mov	 DWORD PTR $T30[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000fb	83 c0 01	 add	 eax, 1
  000fe	0f 92 c1	 setb	 cl
  00101	f7 d9		 neg	 ecx
  00103	0b c8		 or	 ecx, eax
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2675 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  0010e	89 46 14	 mov	 DWORD PTR [esi+20], eax
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00111	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00118	51		 push	 ecx
  00119	ff 75 e8	 push	 DWORD PTR __Result$1$[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _memcpy
  00122	8b 45 e4	 mov	 eax, DWORD PTR $T30[ebp]
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH
  00128	8b 4d ec	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
$LN56@Emplace_hi:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  0012b	89 4e 24	 mov	 DWORD PTR [esi+36], ecx

; 1113 :             // nothrow hereafter
; 1114 :         } else {
; 1115 :             _Tree_temp_node<_Alnode> _Newnode(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...);
; 1116 :             _Loc = _Find_hint(_Hint, _Traits::_Kfn(_Newnode._Ptr->_Myval));
; 1117 :             if constexpr (!_Multi) {
; 1118 :                 if (_Loc._Duplicate) {
; 1119 :                     return _Loc._Location._Parent;
; 1120 :                 }
; 1121 :             }
; 1122 : 
; 1123 :             _Check_grow_by_1();
; 1124 :             // nothrow hereafter
; 1125 :             _Inserted = _Newnode._Release();
; 1126 :         }
; 1127 : 
; 1128 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

  0012e	8b cf		 mov	 ecx, edi

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00130	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00133	8b 45 e0	 mov	 eax, DWORD PTR __Myhead$1$[ebp]

; 1113 :             // nothrow hereafter
; 1114 :         } else {
; 1115 :             _Tree_temp_node<_Alnode> _Newnode(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...);
; 1116 :             _Loc = _Find_hint(_Hint, _Traits::_Kfn(_Newnode._Ptr->_Myval));
; 1117 :             if constexpr (!_Multi) {
; 1118 :                 if (_Loc._Duplicate) {
; 1119 :                     return _Loc._Location._Parent;
; 1120 :                 }
; 1121 :             }
; 1122 : 
; 1123 :             _Check_grow_by_1();
; 1124 :             // nothrow hereafter
; 1125 :             _Inserted = _Newnode._Release();
; 1126 :         }
; 1127 : 
; 1128 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

  00136	56		 push	 esi
  00137	ff 75 d8	 push	 DWORD PTR __Loc$[ebp+4]

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  0013a	89 06		 mov	 DWORD PTR [esi], eax

; 1113 :             // nothrow hereafter
; 1114 :         } else {
; 1115 :             _Tree_temp_node<_Alnode> _Newnode(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...);
; 1116 :             _Loc = _Find_hint(_Hint, _Traits::_Kfn(_Newnode._Ptr->_Myval));
; 1117 :             if constexpr (!_Multi) {
; 1118 :                 if (_Loc._Duplicate) {
; 1119 :                     return _Loc._Location._Parent;
; 1120 :                 }
; 1121 :             }
; 1122 : 
; 1123 :             _Check_grow_by_1();
; 1124 :             // nothrow hereafter
; 1125 :             _Inserted = _Newnode._Release();
; 1126 :         }
; 1127 : 
; 1128 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

  0013c	ff 75 d4	 push	 DWORD PTR __Loc$[ebp]

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  0013f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00142	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 810  :         this->_Ptr->_Color = _Red;

  00145	66 c7 46 0c 00
	00		 mov	 WORD PTR [esi+12], 0

; 1113 :             // nothrow hereafter
; 1114 :         } else {
; 1115 :             _Tree_temp_node<_Alnode> _Newnode(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...);
; 1116 :             _Loc = _Find_hint(_Hint, _Traits::_Kfn(_Newnode._Ptr->_Myval));
; 1117 :             if constexpr (!_Multi) {
; 1118 :                 if (_Loc._Duplicate) {
; 1119 :                     return _Loc._Location._Parent;
; 1120 :                 }
; 1121 :             }
; 1122 : 
; 1123 :             _Check_grow_by_1();
; 1124 :             // nothrow hereafter
; 1125 :             _Inserted = _Newnode._Release();
; 1126 :         }
; 1127 : 
; 1128 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

  0014b	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Insert_node
$LN1@Emplace_hi:

; 1129 :     }

  00150	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00153	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015a	59		 pop	 ecx
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	8b e3		 mov	 esp, ebx
  00162	5b		 pop	 ebx
  00163	c2 08 00	 ret	 8
$LN149@Emplace_hi:

; 1723 :             _Throw_tree_length_error();

  00166	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN147@Emplace_hi:
  0016b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$2:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
__unwindfunclet$??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_hint@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@QAU21@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Emplace_hint<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABU?$less@PAUHKEY__@@@std@@@std@@YAABU?$less@PAUHKEY__@@@0@ABU10@@Z
_TEXT	SEGMENT
??$forward@ABU?$less@PAUHKEY__@@@std@@@std@@YAABU?$less@PAUHKEY__@@@0@ABU10@@Z PROC ; std::forward<std::less<HKEY__ *> const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABU?$less@PAUHKEY__@@@std@@@std@@YAABU?$less@PAUHKEY__@@@0@ABU10@@Z ENDP ; std::forward<std::less<HKEY__ *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z
_TEXT	SEGMENT
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

  00004	c3		 ret	 0
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

  00004	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 675  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN18@destroy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN28@destroy

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN25@destroy

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN28@destroy:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN18@destroy:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4317 :         _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4318 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4319 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4320 :         // write can alias this
; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 677  :     }

  00044	c3		 ret	 0
$LN25@destroy:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN35@destroy:
  0004b	cc		 int	 3
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 3749 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3750 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 3751 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 3752 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3755 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 3756 : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CM@@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$0CM@@std@@YAII@Z PROC		; std::_Get_size_of_n<44>, COMDAT
; __Count$dead$ = ecx

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {
; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  00000	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH

; 40   : }

  00005	c3		 ret	 0
??$_Get_size_of_n@$0CM@@std@@YAII@Z ENDP		; std::_Get_size_of_n<44>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z
_TEXT	SEGMENT
??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z PROC		; std::_Unfancy_maybe_null<unsigned char>, COMDAT
; __Ptr$ = ecx

; 407  :     return _Ptr;

  00000	8b c1		 mov	 eax, ecx

; 408  : }

  00002	c3		 ret	 0
??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z ENDP		; std::_Unfancy_maybe_null<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Get_size_of_n@$01@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$01@std@@YAII@Z PROC			; std::_Get_size_of_n<2>, COMDAT
; __Count$ = ecx

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {

  00000	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00006	0f 87 00 00 00
	00		 ja	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  0000c	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]

; 40   : }

  0000f	c3		 ret	 0
??$_Get_size_of_n@$01@std@@YAII@Z ENDP			; std::_Get_size_of_n<2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
__Right_size$ = 12					; size = 4
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z PROC ; std::_Traits_equal<std::char_traits<char> >, COMDAT
; __Left$ = ecx
; __Left_size$ = edx

; 507  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 508  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00003	3b 55 0c	 cmp	 edx, DWORD PTR __Right_size$[ebp]
  00006	75 60		 jne	 SHORT $LN3@Traits_equ

; 302  :             return __builtin_memcmp(_First1, _First2, _Count);

  00008	56		 push	 esi
  00009	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_01OGPIMHDM@?$DP@
  0000e	83 ea 04	 sub	 edx, 4
  00011	72 11		 jb	 SHORT $LN9@Traits_equ
$LL10@Traits_equ:
  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	3b 06		 cmp	 eax, DWORD PTR [esi]
  00017	75 10		 jne	 SHORT $LN8@Traits_equ
  00019	83 c1 04	 add	 ecx, 4
  0001c	83 c6 04	 add	 esi, 4
  0001f	83 ea 04	 sub	 edx, 4
  00022	73 ef		 jae	 SHORT $LL10@Traits_equ
$LN9@Traits_equ:
  00024	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00027	74 34		 je	 SHORT $LN7@Traits_equ
$LN8@Traits_equ:
  00029	8a 01		 mov	 al, BYTE PTR [ecx]
  0002b	3a 06		 cmp	 al, BYTE PTR [esi]
  0002d	75 27		 jne	 SHORT $LN11@Traits_equ
  0002f	83 fa fd	 cmp	 edx, -3			; fffffffdH
  00032	74 29		 je	 SHORT $LN7@Traits_equ
  00034	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00037	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  0003a	75 1a		 jne	 SHORT $LN11@Traits_equ
  0003c	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0003f	74 1c		 je	 SHORT $LN7@Traits_equ
  00041	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00044	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00047	75 0d		 jne	 SHORT $LN11@Traits_equ
  00049	83 fa ff	 cmp	 edx, -1
  0004c	74 0f		 je	 SHORT $LN7@Traits_equ
  0004e	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00051	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00054	74 07		 je	 SHORT $LN7@Traits_equ
$LN11@Traits_equ:
  00056	1b c0		 sbb	 eax, eax
  00058	83 c8 01	 or	 eax, 1
  0005b	eb 02		 jmp	 SHORT $LN12@Traits_equ
$LN7@Traits_equ:
  0005d	33 c0		 xor	 eax, eax
$LN12@Traits_equ:
  0005f	5e		 pop	 esi

; 508  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00060	85 c0		 test	 eax, eax
  00062	75 04		 jne	 SHORT $LN3@Traits_equ
  00064	b0 01		 mov	 al, 1

; 510  : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
$LN3@Traits_equ:

; 508  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 509  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00068	32 c0		 xor	 al, al

; 510  : }

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQBDI0I@Z ENDP ; std::_Traits_equal<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z
_TEXT	SEGMENT
__Haystack$1$ = -8					; size = 4
tv85 = -4						; size = 4
__Start_at$ = 8						; size = 4
__Needle$ = 12						; size = 4
__Possible_matches_end$1$ = 16				; size = 4
__Needle_size$ = 16					; size = 4
??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT
; __Haystack$ = ecx
; __Hay_size$ = edx

; 536  :     const size_t _Needle_size) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 537  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 538  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Needle_size$[ebp]
  0000a	89 4d f8	 mov	 DWORD PTR __Haystack$1$[ebp], ecx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	3b da		 cmp	 ebx, edx
  00011	0f 87 c5 00 00
	00		 ja	 $LN6@Traits_fin
  00017	8b 7d 08	 mov	 edi, DWORD PTR __Start_at$[ebp]
  0001a	8b f2		 mov	 esi, edx
  0001c	2b f3		 sub	 esi, ebx
  0001e	3b fe		 cmp	 edi, esi
  00020	0f 87 b6 00 00
	00		 ja	 $LN6@Traits_fin

; 539  :         // xpos cannot exist, report failure
; 540  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 541  :         // 1. _Start_at <= xpos
; 542  :         // 2. xpos + _Needle_size <= _Hay_size;
; 543  :         // therefore:
; 544  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 545  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 546  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 547  :         return static_cast<size_t>(-1);
; 548  :     }
; 549  : 
; 550  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  00026	85 db		 test	 ebx, ebx
  00028	0f 84 bb 00 00
	00		 je	 $LN27@Traits_fin

; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);

  0002e	8b 75 0c	 mov	 esi, DWORD PTR __Needle$[ebp]

; 551  :         return _Start_at;
; 552  :     }
; 553  : 
; 554  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00031	8b c1		 mov	 eax, ecx
  00033	2b c3		 sub	 eax, ebx
  00035	42		 inc	 edx
  00036	03 c2		 add	 eax, edx

; 555  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

  00038	03 cf		 add	 ecx, edi
  0003a	89 45 10	 mov	 DWORD PTR __Possible_matches_end$1$[ebp], eax

; 556  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  0003d	2b c1		 sub	 eax, ecx

; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);

  0003f	0f be 16	 movsx	 edx, BYTE PTR [esi]
  00042	50		 push	 eax
  00043	52		 push	 edx
  00044	51		 push	 ecx
  00045	89 55 fc	 mov	 DWORD PTR tv85[ebp], edx
  00048	e8 00 00 00 00	 call	 _memchr
  0004d	8b f8		 mov	 edi, eax
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 557  :         if (!_Match_try) { // didn't find first character; report failure

  00052	85 ff		 test	 edi, edi
  00054	0f 84 82 00 00
	00		 je	 $LN6@Traits_fin
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Traits_fin:

; 302  :             return __builtin_memcmp(_First1, _First2, _Count);

  00060	8b ce		 mov	 ecx, esi
  00062	8b d7		 mov	 edx, edi
  00064	8b f3		 mov	 esi, ebx
  00066	83 ee 04	 sub	 esi, 4
  00069	72 16		 jb	 SHORT $LN23@Traits_fin
  0006b	0f 1f 44 00 00	 npad	 5
$LL24@Traits_fin:
  00070	8b 02		 mov	 eax, DWORD PTR [edx]
  00072	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00074	75 10		 jne	 SHORT $LN22@Traits_fin
  00076	83 c2 04	 add	 edx, 4
  00079	83 c1 04	 add	 ecx, 4
  0007c	83 ee 04	 sub	 esi, 4
  0007f	73 ef		 jae	 SHORT $LL24@Traits_fin
$LN23@Traits_fin:
  00081	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00084	74 34		 je	 SHORT $LN21@Traits_fin
$LN22@Traits_fin:
  00086	8a 02		 mov	 al, BYTE PTR [edx]
  00088	3a 01		 cmp	 al, BYTE PTR [ecx]
  0008a	75 27		 jne	 SHORT $LN25@Traits_fin
  0008c	83 fe fd	 cmp	 esi, -3			; fffffffdH
  0008f	74 29		 je	 SHORT $LN21@Traits_fin
  00091	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00094	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  00097	75 1a		 jne	 SHORT $LN25@Traits_fin
  00099	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0009c	74 1c		 je	 SHORT $LN21@Traits_fin
  0009e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  000a1	3a 41 02	 cmp	 al, BYTE PTR [ecx+2]
  000a4	75 0d		 jne	 SHORT $LN25@Traits_fin
  000a6	83 fe ff	 cmp	 esi, -1
  000a9	74 0f		 je	 SHORT $LN21@Traits_fin
  000ab	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  000ae	3a 41 03	 cmp	 al, BYTE PTR [ecx+3]
  000b1	74 07		 je	 SHORT $LN21@Traits_fin
$LN25@Traits_fin:
  000b3	1b c0		 sbb	 eax, eax
  000b5	83 c8 01	 or	 eax, 1
  000b8	eb 02		 jmp	 SHORT $LN26@Traits_fin
$LN21@Traits_fin:
  000ba	33 c0		 xor	 eax, eax
$LN26@Traits_fin:

; 558  :             return static_cast<size_t>(-1);
; 559  :         }
; 560  : 
; 561  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

  000bc	85 c0		 test	 eax, eax
  000be	74 26		 je	 SHORT $LN17@Traits_fin

; 555  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

  000c0	8b 45 10	 mov	 eax, DWORD PTR __Possible_matches_end$1$[ebp]
  000c3	47		 inc	 edi

; 556  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  000c4	2b c7		 sub	 eax, edi

; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);

  000c6	50		 push	 eax
  000c7	ff 75 fc	 push	 DWORD PTR tv85[ebp]
  000ca	57		 push	 edi
  000cb	e8 00 00 00 00	 call	 _memchr

; 557  :         if (!_Match_try) { // didn't find first character; report failure

  000d0	8b 75 0c	 mov	 esi, DWORD PTR __Needle$[ebp]

; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);

  000d3	8b f8		 mov	 edi, eax
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 557  :         if (!_Match_try) { // didn't find first character; report failure

  000d8	85 ff		 test	 edi, edi
  000da	75 84		 jne	 SHORT $LL4@Traits_fin
$LN6@Traits_fin:
  000dc	5f		 pop	 edi

; 563  :         }
; 564  :     }
; 565  : }

  000dd	5e		 pop	 esi
  000de	83 c8 ff	 or	 eax, -1
  000e1	5b		 pop	 ebx
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN17@Traits_fin:

; 562  :             return static_cast<size_t>(_Match_try - _Haystack);

  000e6	2b 7d f8	 sub	 edi, DWORD PTR __Haystack$1$[ebp]
$LN27@Traits_fin:

; 563  :         }
; 564  :     }
; 565  : }

  000e9	8b c7		 mov	 eax, edi
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	5b		 pop	 ebx
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2728 :     ~basic_string() noexcept {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  00006	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00009	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0000c	72 27		 jb	 SHORT $LN16@scalar
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00010	41		 inc	 ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN26@scalar

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 24		 ja	 SHORT $LN23@scalar

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN26@scalar:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
$LN16@scalar:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4317 :         _Mypair._Myval2._Mysize = 0;

  00035	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0003c	8b c6		 mov	 eax, esi

; 4318 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0003e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4319 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4320 :         // write can alias this
; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00045	c6 06 00	 mov	 BYTE PTR [esi], 0
  00048	5e		 pop	 esi
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN23@scalar:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN32@scalar:
  00053	cc		 int	 3
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 818  :         if (this->_Ptr) {

  00004	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00007	85 f6		 test	 esi, esi
  00009	74 4a		 je	 SHORT $LN7@Tree_temp_
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  0000b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0000e	83 f9 08	 cmp	 ecx, 8

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00011	72 2e		 jb	 SHORT $LN24@Tree_temp_
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00023	72 12		 jb	 SHORT $LN34@Tree_temp_

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00025	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00028	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002b	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00030	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00033	77 35		 ja	 SHORT $LN31@Tree_temp_

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00035	8b c2		 mov	 eax, edx
$LN34@Tree_temp_:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00037	51		 push	 ecx
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003e	83 c4 08	 add	 esp, 8
$LN24@Tree_temp_:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00041	33 c0		 xor	 eax, eax
  00043	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  0004a	c7 46 28 07 00
	00 00		 mov	 DWORD PTR [esi+40], 7
  00051	66 89 46 14	 mov	 WORD PTR [esi+20], ax
$LN7@Tree_temp_:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1048 :         if (_Ptr) {

  00055	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	85 c0		 test	 eax, eax
  0005c	74 0b		 je	 SHORT $LN53@Tree_temp_

; 195  :     ::operator delete(_Ptr, _Bytes);

  0005e	6a 2c		 push	 44			; 0000002cH
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN53@Tree_temp_:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 824  :     }

  00069	c3		 ret	 0
$LN31@Tree_temp_:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN68@Tree_temp_:
  00070	cc		 int	 3
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Release, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00003	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1040 :     }

  0000a	c3		 ret	 0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map@PAUHKEY__@@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAABQAUHKEY__@@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z
_TEXT	SEGMENT
?_Extract@?$_In_place_key_extract_map@PAUHKEY__@@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAABQAUHKEY__@@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z PROC ; std::_In_place_key_extract_map<HKEY__ *,std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Extract, COMDAT
; __Val$ = ecx

; 1964 :         return _Val.first;

  00000	8b c1		 mov	 eax, ecx

; 1965 :     }

  00002	c3		 ret	 0
?_Extract@?$_In_place_key_extract_map@PAUHKEY__@@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAABQAUHKEY__@@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z ENDP ; std::_In_place_key_extract_map<HKEY__ *,std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 645  :         ++_Mysize;
; 646  :         const auto _Head  = _Myhead;
; 647  :         _Newnode->_Parent = _Loc._Parent;

  00006	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	ff 40 04	 inc	 DWORD PTR [eax+4]
  00013	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	89 4d f8	 mov	 DWORD PTR __Head$1$[ebp], ecx
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  0001c	3b d1		 cmp	 edx, ecx
  0001e	75 12		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 650  :             _Head->_Parent   = _Newnode;

  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 651  :             _Head->_Right    = _Newnode;

  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 652  :             _Newnode->_Color = _Black; // the root is black

  00028	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 711  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 653  :             return _Newnode;
; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00032	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00036	75 0d		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  00038	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003e	75 0d		 jne	 SHORT $LN9@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00040	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  00043	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  00045	89 02		 mov	 DWORD PTR [edx], eax

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00047	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00049	75 02		 jne	 SHORT $LN9@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004d	8b d0		 mov	 edx, eax
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00056	0f 85 99 01 00
	00		 jne	 $LN3@Insert_nod
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	57		 push	 edi
  0005f	90		 npad	 1
$LL2@Insert_nod:

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00063	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00066	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00069	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	3b c8		 cmp	 ecx, eax
  00070	0f 85 ba 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00079	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0007d	0f 84 b3 00 00
	00		 je	 $LN53@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;
; 676  :                     _Parent_sibling->_Color          = _Black;
; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 679  :                 } else { // parent's sibling has red and black children
; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  00083	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00086	3b d6		 cmp	 edx, esi
  00088	75 47		 jne	 SHORT $LN51@Insert_nod

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]

; 681  :                         _Pnode = _Pnode->_Parent;

  0008c	8b d1		 mov	 edx, ecx

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00097	75 03		 jne	 SHORT $LN20@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00099	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN20@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  000a9	75 0b		 jne	 SHORT $LN21@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  000ab	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000ae	8b fb		 mov	 edi, ebx
  000b0	89 16		 mov	 DWORD PTR [esi], edx
  000b2	89 33		 mov	 DWORD PTR [ebx], esi
  000b4	eb 1d		 jmp	 SHORT $LN49@Insert_nod
$LN21@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ba	75 0a		 jne	 SHORT $LN23@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  000bc	89 30		 mov	 DWORD PTR [eax], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000be	8b fb		 mov	 edi, ebx
  000c0	89 16		 mov	 DWORD PTR [esi], edx
  000c2	89 33		 mov	 DWORD PTR [ebx], esi
  000c4	eb 0d		 jmp	 SHORT $LN49@Insert_nod
$LN23@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  000c6	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000c9	8b fb		 mov	 edi, ebx
  000cb	89 16		 mov	 DWORD PTR [esi], edx
  000cd	89 33		 mov	 DWORD PTR [ebx], esi
  000cf	eb 02		 jmp	 SHORT $LN49@Insert_nod
$LN51@Insert_nod:
  000d1	8b f1		 mov	 esi, ecx
$LN49@Insert_nod:

; 682  :                         _Lrotate(_Pnode);
; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000d3	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000e0	8b 07		 mov	 eax, DWORD PTR [edi]
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000e5	8b 31		 mov	 esi, DWORD PTR [ecx]

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  000ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ef	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f3	75 03		 jne	 SHORT $LN27@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  000f5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN27@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  000f8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fb	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00106	75 0b		 jne	 SHORT $LN28@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  00108	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0010e	e9 cc 00 00 00	 jmp	 $LN52@Insert_nod
$LN28@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00119	75 0b		 jne	 SHORT $LN30@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  0011b	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0011e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00121	e9 b9 00 00 00	 jmp	 $LN52@Insert_nod
$LN30@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00126	89 30		 mov	 DWORD PTR [eax], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00128	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0012b	e9 af 00 00 00	 jmp	 $LN52@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00130	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00134	75 1b		 jne	 SHORT $LN15@Insert_nod
$LN53@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00136	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  0013a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0013e	8b 07		 mov	 eax, DWORD PTR [edi]
  00140	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00143	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  00147	8b 07		 mov	 eax, DWORD PTR [edi]
  00149	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014c	e9 91 00 00 00	 jmp	 $LN46@Insert_nod
$LN15@Insert_nod:

; 692  :                     _Pnode->_Parent->_Color          = _Black;
; 693  :                     _Parent_sibling->_Color          = _Black;
; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 696  :                 } else { // parent's sibling has red and black children
; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	3b d0		 cmp	 edx, eax
  00155	75 3e		 jne	 SHORT $LN39@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  00157	8b d1		 mov	 edx, ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00159	8b c8		 mov	 ecx, eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  0015b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0015e	89 02		 mov	 DWORD PTR [edx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  00160	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00163	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00167	75 03		 jne	 SHORT $LN34@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00169	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN34@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00171	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00174	8b 00		 mov	 eax, DWORD PTR [eax]
  00176	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00179	75 05		 jne	 SHORT $LN35@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  0017b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0017e	eb 0e		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00185	75 05		 jne	 SHORT $LN37@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00187	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  0018a	eb 02		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  0018c	89 08		 mov	 DWORD PTR [eax], ecx
$LN38@Insert_nod:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0018e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 499  :         _Wherenode->_Parent = _Pnode;

  00191	8b fb		 mov	 edi, ebx
  00193	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN39@Insert_nod:

; 699  :                         _Rrotate(_Pnode);
; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  00195	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00199	8b 07		 mov	 eax, DWORD PTR [edi]
  0019b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001a2	8b 07		 mov	 eax, DWORD PTR [edi]
  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  001a7	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  001aa	8b 06		 mov	 eax, DWORD PTR [esi]
  001ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  001af	8b 06		 mov	 eax, DWORD PTR [esi]
  001b1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001b5	75 03		 jne	 SHORT $LN41@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  001b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN41@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  001ba	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001bd	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001c8	75 05		 jne	 SHORT $LN42@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  001ca	89 70 04	 mov	 DWORD PTR [eax+4], esi
  001cd	eb 0e		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001cf	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001d2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d4	75 04		 jne	 SHORT $LN44@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  001d6	89 30		 mov	 DWORD PTR [eax], esi

; 472  :         } else {

  001d8	eb 03		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  001da	89 70 08	 mov	 DWORD PTR [eax+8], esi
$LN45@Insert_nod:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  001dd	89 0e		 mov	 DWORD PTR [esi], ecx
$LN52@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
$LN46@Insert_nod:
  001e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001e9	0f 84 71 fe ff
	ff		 je	 $LL2@Insert_nod
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR __Head$1$[ebp]
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
$LN3@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }
; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001f5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001f8	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001fc	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]

; 711  :     }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >, COMDAT
; _this$ = ecx

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1722 :         if (max_size() == _Get_scary()->_Mysize) {

  00000	81 79 04 5d 74
	d1 05		 cmp	 DWORD PTR [ecx+4], 97612893 ; 05d1745dH
  00007	0f 84 00 00 00
	00		 je	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error

; 1723 :             _Throw_tree_length_error();
; 1724 :         }
; 1725 :     }

  0000d	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::deallocate, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 664  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 195  :     ::operator delete(_Ptr, _Bytes);

  00003	6a 2c		 push	 44			; 0000002cH
  00005	52		 push	 edx
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8

; 665  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 666  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
; 667  :     }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength, COMDAT

; 1704 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
  0000b	cc		 int	 3
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array, COMDAT
; _this$ = ecx

; 1666 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 1667 :         // orphan all iterators, discard old array, acquire new array
; 1668 :         auto& _My_data    = _Mypair._Myval2;
; 1669 :         pointer& _Myfirst = _My_data._Myfirst;
; 1670 :         pointer& _Mylast  = _My_data._Mylast;
; 1671 :         pointer& _Myend   = _My_data._Myend;
; 1672 : 
; 1673 :         _My_data._Orphan_all();
; 1674 : 
; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00008	85 c9		 test	 ecx, ecx
  0000a	74 50		 je	 SHORT $LN10@Change_arr

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0000c	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0000f	56		 push	 esi
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00016	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	8b 37		 mov	 esi, DWORD PTR [edi]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00020	83 c4 04	 add	 esp, 4

; 1676 :             _Destroy(_Myfirst, _Mylast);
; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00023	2b ce		 sub	 ecx, esi
  00025	f7 e9		 imul	 ecx
  00027	c1 fa 02	 sar	 edx, 2
  0002a	8b c2		 mov	 eax, edx
  0002c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002f	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00031	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00034	c1 e1 03	 shl	 ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00037	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003d	72 12		 jb	 SHORT $LN20@Change_arr

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003f	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00042	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00045	2b f2		 sub	 esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00047	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0004a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004d	77 2f		 ja	 SHORT $LN17@Change_arr

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004f	8b f2		 mov	 esi, edx
$LN20@Change_arr:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00051	51		 push	 ecx
  00052	56		 push	 esi
  00053	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00058	83 c4 08	 add	 esp, 8
  0005b	5e		 pop	 esi
$LN10@Change_arr:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1680 :         _Myfirst = _Newvec;

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0005f	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00062	89 0f		 mov	 DWORD PTR [edi], ecx
  00064	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00067	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0006a	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0006d	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00070	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00073	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00076	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00079	5f		 pop	 edi

; 1683 :     }

  0007a	5d		 pop	 ebp
  0007b	c2 0c 00	 ret	 12			; 0000000cH
$LN17@Change_arr:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Change_arr:
  00084	cc		 int	 3
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	f7 ea		 imul	 edx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  0000f	56		 push	 esi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00010	c1 fa 02	 sar	 edx, 2

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00013	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00018	8b ca		 mov	 ecx, edx
  0001a	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0001d	03 ca		 add	 ecx, edx

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  0001f	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00022	8b f1		 mov	 esi, ecx
  00024	d1 ee		 shr	 esi, 1
  00026	2b c6		 sub	 eax, esi
  00028	3b c8		 cmp	 ecx, eax
  0002a	77 07		 ja	 SHORT $LN7@Calculate_

; 1620 :             return _Newsize; // geometric growth would overflow
; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0002c	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0002f	3b c2		 cmp	 eax, edx
  00031	73 02		 jae	 SHORT $LN1@Calculate_
$LN7@Calculate_:

; 1626 :             return _Newsize; // geometric growth would be insufficient

  00033	8b c2		 mov	 eax, edx
$LN1@Calculate_:
  00035	5e		 pop	 esi

; 1627 :         }
; 1628 : 
; 1629 :         return _Geometric; // geometric growth is sufficient
; 1630 :     }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1605 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00012	83 c4 08	 add	 esp, 8

; 1606 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,
; 1608 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1609 :     }

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@00@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove, COMDAT
; _this$dead$ = ecx

; 1591 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00012	83 c4 08	 add	 esp, 8

; 1593 :     }

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?_Umove@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$dead$ = ecx

; 1488 :         return _Min_value(

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  00005	c3		 ret	 0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; _this$dead$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   :             if (_Count > _Max_possible) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0000b	77 4d		 ja	 SHORT $LN27@allocate

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  0000d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00010	c1 e0 03	 shl	 eax, 3

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 29		 jb	 SHORT $LN8@allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001a	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

  0001d	3b c8		 cmp	 ecx, eax
  0001f	76 39		 jbe	 SHORT $LN27@allocate

; 51   :         return ::operator new(_Bytes);

  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00027	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  00029	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002c	85 c9		 test	 ecx, ecx
  0002e	74 0d		 je	 SHORT $LN17@allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00033	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00036	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN17@allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN8@allocate:

; 179  :     if (_Bytes != 0) {

  00043	85 c0		 test	 eax, eax
  00045	74 0d		 je	 SHORT $LN9@allocate

; 51   :         return ::operator new(_Bytes);

  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004d	83 c4 04	 add	 esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
$LN9@allocate:

; 183  :     return nullptr;

  00054	33 c0		 xor	 eax, eax

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
$LN27@allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

  0005a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN28@allocate:
  0005f	cc		 int	 3
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?find@?$_Narrow_char_traits@DH@std@@SAPBDQBDIABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?find@?$_Narrow_char_traits@DH@std@@SAPBDQBDIABD@Z PROC	; std::_Narrow_char_traits<char,int>::find, COMDAT
; __First$ = ecx
; __Count$ = edx

; 344  :         const _Elem& _Ch) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 345  :         // look for _Ch in [_First, _First + _Count)
; 346  : #if _HAS_CXX17
; 347  : #ifdef __cpp_char8_t
; 348  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 349  : #if _HAS_U8_INTRINSICS
; 350  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 351  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 352  :             return _Char_traits<_Elem, _Int_type>::find(_First, _Count, _Ch);
; 353  : #endif // _HAS_U8_INTRINSICS
; 354  :         } else
; 355  : #endif // __cpp_char8_t
; 356  :         {
; 357  :             return __builtin_char_memchr(_First, _Ch, _Count);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	52		 push	 edx
  00007	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _memchr
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 358  :         }
; 359  : #else // _HAS_CXX17
; 360  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));
; 361  : #endif // _HAS_CXX17
; 362  :     }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?find@?$_Narrow_char_traits@DH@std@@SAPBDQBDIABD@Z ENDP	; std::_Narrow_char_traits<char,int>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >, COMDAT
; _this$ = ecx

; 1048 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN10@Tree_temp_

; 195  :     ::operator delete(_Ptr, _Bytes);

  00007	6a 2c		 push	 44			; 0000002cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN10@Tree_temp_:
  00012	c3		 ret	 0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >, COMDAT
; _this$ = ecx

; 1048 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 195  :     ::operator delete(_Ptr, _Bytes);

  00007	6a 2c		 push	 44			; 0000002cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 1049 :             _Al.deallocate(_Ptr, 1);
; 1050 :         }
; 1051 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0e		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;
; 499  :         _Wherenode->_Parent = _Pnode;
; 500  :     }

  0002a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0002d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00038	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003b	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;
; 499  :         _Wherenode->_Parent = _Pnode;
; 500  :     }

  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00043	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00046	5e		 pop	 esi
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN5@Rrotate:

; 494  :         } else {
; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;
; 499  :         _Wherenode->_Parent = _Pnode;
; 500  :     }

  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;
; 477  :         _Wherenode->_Parent = _Pnode;
; 478  :     }

  0002a	89 16		 mov	 DWORD PTR [esi], edx
  0002c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00037	3b 10		 cmp	 edx, DWORD PTR [eax]
  00039	75 0c		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  0003b	89 30		 mov	 DWORD PTR [eax], esi

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;
; 477  :         _Wherenode->_Parent = _Pnode;
; 478  :     }

  0003d	89 16		 mov	 DWORD PTR [esi], edx
  0003f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@Lrotate:

; 472  :         } else {
; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00047	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;
; 477  :         _Wherenode->_Parent = _Pnode;
; 478  :     }

  0004a	89 16		 mov	 DWORD PTR [esi], edx
  0004c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0004f	5e		 pop	 esi
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1309 :         return _Min_value(

  00000	b8 5d 74 d1 05	 mov	 eax, 97612893		; 05d1745dH

; 1310 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1311 :     }

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal, COMDAT
; _this$ = ecx

; 1736 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1737 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1595 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1596 :         // move [_First, _Last) to raw _Dest, using allocator
; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00012	83 c4 08	 add	 esp, 8

; 1598 :     }

  00015	5d		 pop	 ebp
  00016	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity, COMDAT
; _this$ = ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;
; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 02	 sar	 edx, 2
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1495 :     }

  00016	c3		 ret	 0
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 681  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Getal, COMDAT
; _this$ = ecx

; 2046 :         return _Mypair._Myval2._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2047 :     }

  00002	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::max_size, COMDAT
; ___formal$dead$ = ecx

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 5d 74 d1 05	 mov	 eax, 97612893		; 05d1745dH

; 681  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 195  :     ::operator delete(_Ptr, _Bytes);

  00006	6a 2c		 push	 44			; 0000002cH
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 781  :     }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@0@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@0@Z PROC ; std::exchange<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * &>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 572  :     // assign _New_val to _Val, return previous _Val
; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	8b 12		 mov	 edx, DWORD PTR [edx]
  00004	89 11		 mov	 DWORD PTR [ecx], edx

; 575  :     return _Old_val;
; 576  : }

  00006	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@0@Z ENDP ; std::exchange<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 377  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00006	83 f9 08	 cmp	 ecx, 8

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 2e		 jb	 SHORT $LN23@Freenode
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0000e	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001b	72 12		 jb	 SHORT $LN33@Freenode

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00020	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00023	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00025	83 c0 fc	 add	 eax, -4			; fffffffcH
  00028	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002b	77 2d		 ja	 SHORT $LN30@Freenode

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002d	8b c2		 mov	 eax, edx
$LN33@Freenode:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002f	51		 push	 ecx
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	83 c4 08	 add	 esp, 8
$LN23@Freenode:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00039	33 c0		 xor	 eax, eax
  0003b	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00042	6a 2c		 push	 44			; 0000002cH
  00044	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4318 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00045	c7 46 28 07 00
	00 00		 mov	 DWORD PTR [esi+40], 7

; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004c	66 89 46 14	 mov	 WORD PTR [esi+20], ax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00050	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00055	83 c4 08	 add	 esp, 8
  00058	5e		 pop	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 381  :     }

  00059	c3		 ret	 0
$LN30@Freenode:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN62@Freenode:
  00060	cc		 int	 3
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *>, COMDAT
; __Obj$dead$ = ecx

; 242  :     _Obj.~_Ty();
; 243  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Find_hint@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_hint_result@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABQAUHKEY__@@@Z
_TEXT	SEGMENT
__Loc$7$sroa$143$1$ = -4				; size = 4
___$ReturnUdt$ = 8					; size = 4
__Hint$ = 12						; size = 4
__Keyval$ = 16						; size = 4
tv976 = 19						; size = 1
??$_Find_hint@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_hint_result@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABQAUHKEY__@@@Z PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Find_hint<HKEY__ *>, COMDAT
; _this$ = ecx

; 1584 :     _Tree_find_hint_result<_Nodeptr> _Find_hint(const _Nodeptr _Hint, const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1585 :         const auto& _Comp = _Getcomp();
; 1586 :         const auto _Head  = _Get_scary()->_Myhead;
; 1587 :         if
; 1588 :             _CONSTEXPR_IF(_Multi) { // insert even if duplicate
; 1589 :                 if (_Hint->_Isnil) {
; 1590 :                     // insert at end if greater than or equal to last element
; 1591 :                     if (_Head->_Parent->_Isnil
; 1592 :                         || !_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Head->_Right->_Myval))) {
; 1593 :                         return {{_Head->_Right, _Tree_child::_Right}, false};
; 1594 :                     }
; 1595 : 
; 1596 :                     // _Hint is end(); it must be closer to the end of equivalents
; 1597 :                     return {_Find_upper_bound(_Keyval)._Location, false};
; 1598 :                 }
; 1599 : 
; 1600 :                 if (_Hint == _Head->_Left) {
; 1601 :                     // insert at beginning if less than or equal to first element
; 1602 :                     if (!_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint->_Myval), _Keyval)) {
; 1603 :                         return {{_Hint, _Tree_child::_Left}, false};
; 1604 :                     }
; 1605 : 
; 1606 :                     // _Hint is begin(); it must be closer to the beginning of equivalents
; 1607 :                     return {_Find_lower_bound(_Keyval)._Location, false};
; 1608 :                 }
; 1609 : 
; 1610 :                 if (!_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint->_Myval), _Keyval)) {
; 1611 :                     // _Val <= *_Hint
; 1612 :                     const auto _Prev = (--(_Unchecked_const_iterator(_Hint, nullptr)))._Ptr;
; 1613 :                     if (!_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Prev->_Myval))) {
; 1614 :                         // _Val <= *_Hint and _Val >= *prev(_Hint); insert here
; 1615 :                         if (_Prev->_Right->_Isnil) {
; 1616 :                             return {{_Prev, _Tree_child::_Right}, false};
; 1617 :                         } else {
; 1618 :                             return {{_Hint, _Tree_child::_Left}, false};
; 1619 :                         }
; 1620 :                     }
; 1621 : 
; 1622 :                     // _Val goes before *_Hint; _Hint must be closer to the end of equivalents
; 1623 :                     return {_Find_upper_bound(_Keyval)._Location, false};
; 1624 :                 }
; 1625 : 
; 1626 :                 // _Val goes after *_Hint; _Hint must be closer to the beginning of equivalents
; 1627 :                 return {_Find_lower_bound(_Keyval)._Location, false};
; 1628 :             }
; 1629 :         else { // insert only if unique
; 1630 :             if (_Hint->_Isnil) { // insert at end if after last element

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Hint$[ebp]
  00007	53		 push	 ebx
  00008	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0000a	56		 push	 esi
  0000b	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0000f	57		 push	 edi
  00010	89 5d fc	 mov	 DWORD PTR __Loc$7$sroa$143$1$[ebp], ebx
  00013	74 38		 je	 SHORT $LN2@Find_hint

; 1632 :                 if (_Head->_Parent->_Isnil || _DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Head->_Right->_Myval), _Keyval)) {

  00015	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00018	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001c	75 13		 jne	 SHORT $LN95@Find_hint
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef

; 127  :         return _Left < _Right;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00021	8b 38		 mov	 edi, DWORD PTR [eax]
  00023	8b f7		 mov	 esi, edi
  00025	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00028	39 78 10	 cmp	 DWORD PTR [eax+16], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1632 :                 if (_Head->_Parent->_Isnil || _DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Head->_Right->_Myval), _Keyval)) {

  0002b	0f 83 2b 01 00
	00		 jae	 $LN16@Find_hint
$LN95@Find_hint:

; 1633 :                     return {{_Head->_Right, _Tree_child::_Right}, false};

  00031	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00034	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00037	89 08		 mov	 DWORD PTR [eax], ecx
  00039	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0

; 1673 :         }
; 1674 :     }

  0003d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Find_hint:

; 1634 :                 }
; 1635 :             } else if (_Hint == _Head->_Left) {

  0004d	8b 45 10	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00050	8b 38		 mov	 edi, DWORD PTR [eax]
  00052	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00055	3b 13		 cmp	 edx, DWORD PTR [ebx]
  00057	75 21		 jne	 SHORT $LN6@Find_hint
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef

; 127  :         return _Left < _Right;

  00059	3b f8		 cmp	 edi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1637 :                 if (_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Hint->_Myval))) {

  0005b	0f 83 9e 00 00
	00		 jae	 $LN13@Find_hint

; 1638 :                     return {{_Hint, _Tree_child::_Left}, false};

  00061	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00064	89 10		 mov	 DWORD PTR [eax], edx
  00066	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1
  0006d	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0

; 1673 :         }
; 1674 :     }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 0c 00	 ret	 12			; 0000000cH
$LN6@Find_hint:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef

; 127  :         return _Left < _Right;

  0007a	3b f8		 cmp	 edi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1640 :             } else if (_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Hint->_Myval))) {

  0007c	0f 83 81 00 00
	00		 jae	 $LN9@Find_hint

; 75   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree

  00082	8b 02		 mov	 eax, DWORD PTR [edx]

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00084	8b ca		 mov	 ecx, edx

; 75   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree

  00086	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0008a	74 21		 je	 SHORT $LN34@Find_hint

; 76   :             _Nodeptr _Pnode;
; 77   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {

  0008c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0008f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00093	75 0f		 jne	 SHORT $LN31@Find_hint
$LL30@Find_hint:
  00095	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00097	75 0b		 jne	 SHORT $LN31@Find_hint

; 78   :                 _Ptr = _Pnode; // ==> parent while left subtree

  00099	8b c8		 mov	 ecx, eax
  0009b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000a2	74 f1		 je	 SHORT $LL30@Find_hint
$LN31@Find_hint:

; 79   :             }
; 80   : 
; 81   :             if (!_Ptr->_Isnil) { // decrement non-begin()
; 82   :                 _Ptr = _Pnode; // ==> parent if not head
; 83   :             }
; 84   :         } else {

  000a4	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000a8	0f 45 c1	 cmovne	 eax, ecx
  000ab	eb 14		 jmp	 SHORT $LN35@Find_hint
$LN34@Find_hint:

; 443  :         while (!_Pnode->_Right->_Isnil) {

  000ad	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b0	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000b4	75 0b		 jne	 SHORT $LN35@Find_hint
$LL39@Find_hint:

; 444  :             _Pnode = _Pnode->_Right;

  000b6	8b c1		 mov	 eax, ecx
  000b8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000bb	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000bf	74 f5		 je	 SHORT $LL39@Find_hint
$LN35@Find_hint:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef

; 127  :         return _Left < _Right;

  000c1	39 78 10	 cmp	 DWORD PTR [eax+16], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1643 :                 if (_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Prev->_Myval), _Keyval)) {

  000c4	73 39		 jae	 SHORT $LN13@Find_hint

; 1644 :                     // _Val < *_Hint and _Val > *prev(_Hint); insert here
; 1645 :                     if (_Prev->_Right->_Isnil) {

  000c6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c9	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000cc	8a 49 0d	 mov	 cl, BYTE PTR [ecx+13]
  000cf	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
  000d3	84 c9		 test	 cl, cl
  000d5	74 14		 je	 SHORT $LN12@Find_hint

; 1646 :                         return {{_Prev, _Tree_child::_Right}, false};

  000d7	89 06		 mov	 DWORD PTR [esi], eax
  000d9	8b c6		 mov	 eax, esi
  000db	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1673 :         }
; 1674 :     }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 0c 00	 ret	 12			; 0000000cH
$LN12@Find_hint:

; 1647 :                     } else {
; 1648 :                         return {{_Hint, _Tree_child::_Left}, false};

  000eb	89 16		 mov	 DWORD PTR [esi], edx
  000ed	8b c6		 mov	 eax, esi
  000ef	c7 46 04 01 00
	00 00		 mov	 DWORD PTR [esi+4], 1

; 1673 :         }
; 1674 :     }

  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 0c 00	 ret	 12			; 0000000cH
$LN13@Find_hint:

; 1704 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  000ff	8b f7		 mov	 esi, edi
  00101	eb 59		 jmp	 SHORT $LN16@Find_hint
$LN9@Find_hint:

; 1649 :                     }
; 1650 :                 }
; 1651 :             } else if (_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint->_Myval), _Keyval)) {

  00103	0f 86 ea 00 00
	00		 jbe	 $LN14@Find_hint

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00109	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0010c	8b ca		 mov	 ecx, edx

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  0010e	8a 58 0d	 mov	 bl, BYTE PTR [eax+13]
  00111	88 5d 13	 mov	 BYTE PTR tv976[ebp], bl
  00114	84 db		 test	 bl, bl
  00116	74 1b		 je	 SHORT $LN51@Find_hint

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  00118	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0011b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0011f	75 2f		 jne	 SHORT $LN99@Find_hint
$LL49@Find_hint:
  00121	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00124	75 26		 jne	 SHORT $LN52@Find_hint

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  00126	8b c8		 mov	 ecx, eax
  00128	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0012b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0012f	74 f0		 je	 SHORT $LL49@Find_hint

; 56   :             }
; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())
; 59   :         } else {

  00131	eb 19		 jmp	 SHORT $LN52@Find_hint
$LN51@Find_hint:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00133	8b 30		 mov	 esi, DWORD PTR [eax]
  00135	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00139	75 11		 jne	 SHORT $LN52@Find_hint
  0013b	0f 1f 44 00 00	 npad	 5
$LL55@Find_hint:
  00140	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 452  :             _Pnode = _Pnode->_Left;

  00142	8b c6		 mov	 eax, esi
  00144	8b f1		 mov	 esi, ecx
  00146	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0014a	74 f4		 je	 SHORT $LL55@Find_hint
$LN52@Find_hint:

; 1654 :                 if (_Next->_Isnil || _DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Next->_Myval))) {

  0014c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
$LN99@Find_hint:
  00150	8b 5d fc	 mov	 ebx, DWORD PTR __Loc$7$sroa$143$1$[ebp]
  00153	75 69		 jne	 SHORT $LN17@Find_hint
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef

; 127  :         return _Left < _Right;

  00155	8b f7		 mov	 esi, edi
  00157	3b 78 10	 cmp	 edi, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1654 :                 if (_Next->_Isnil || _DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Next->_Myval))) {

  0015a	72 62		 jb	 SHORT $LN17@Find_hint
$LN16@Find_hint:

; 1704 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  0015c	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0015f	33 c9		 xor	 ecx, ecx

; 1705 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1706 :         while (!_Trynode->_Isnil) {

  00161	38 4a 0d	 cmp	 BYTE PTR [edx+13], cl
  00164	75 1f		 jne	 SHORT $LN62@Find_hint
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef

; 127  :         return _Left < _Right;

  00166	8b c2		 mov	 eax, edx
$LL61@Find_hint:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1707 :             _Result._Location._Parent = _Trynode;

  00168	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef

; 127  :         return _Left < _Right;

  0016a	39 70 10	 cmp	 DWORD PTR [eax+16], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1708 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  0016d	73 07		 jae	 SHORT $LN63@Find_hint

; 1709 :                 _Result._Location._Child = _Tree_child::_Right;
; 1710 :                 _Trynode                 = _Trynode->_Right;

  0016f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00172	33 c9		 xor	 ecx, ecx

; 1711 :             } else {

  00174	eb 09		 jmp	 SHORT $LN64@Find_hint
$LN63@Find_hint:

; 1712 :                 _Result._Location._Child = _Tree_child::_Left;
; 1713 :                 _Result._Bound           = _Trynode;

  00176	8b d8		 mov	 ebx, eax
  00178	b9 01 00 00 00	 mov	 ecx, 1

; 1714 :                 _Trynode                 = _Trynode->_Left;

  0017d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN64@Find_hint:

; 1705 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1706 :         while (!_Trynode->_Isnil) {

  0017f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00183	74 e3		 je	 SHORT $LL61@Find_hint
$LN62@Find_hint:

; 1698 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00185	80 7b 0d 00	 cmp	 BYTE PTR [ebx+13], 0
  00189	75 1e		 jne	 SHORT $LN70@Find_hint
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef

; 127  :         return _Left < _Right;

  0018b	3b 7b 10	 cmp	 edi, DWORD PTR [ebx+16]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1698 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0018e	72 19		 jb	 SHORT $LN70@Find_hint

; 1665 :             }
; 1666 : 
; 1667 :             const auto _Loc = _Find_lower_bound(_Keyval);
; 1668 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
; 1669 :                 return {{_Loc._Bound, _Tree_child::_Unused}, true};

  00190	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00193	89 18		 mov	 DWORD PTR [eax], ebx
  00195	c7 40 04 02 00
	00 00		 mov	 DWORD PTR [eax+4], 2
  0019c	c6 40 08 01	 mov	 BYTE PTR [eax+8], 1

; 1673 :         }
; 1674 :     }

  001a0	5f		 pop	 edi
  001a1	5e		 pop	 esi
  001a2	5b		 pop	 ebx
  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c2 0c 00	 ret	 12			; 0000000cH
$LN70@Find_hint:

; 1670 :             }
; 1671 : 
; 1672 :             return {_Loc._Location, false};

  001a9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ac	89 10		 mov	 DWORD PTR [eax], edx
  001ae	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001b1	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0

; 1673 :         }
; 1674 :     }

  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx
  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c2 0c 00	 ret	 12			; 0000000cH
$LN17@Find_hint:

; 1655 :                     // _Val > *_Hint and _Val < *next(_Hint); insert here
; 1656 :                     if (_Hint->_Right->_Isnil) {

  001be	80 7d 13 00	 cmp	 BYTE PTR tv976[ebp], 0
  001c2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001c5	c6 41 08 00	 mov	 BYTE PTR [ecx+8], 0
  001c9	74 14		 je	 SHORT $LN18@Find_hint

; 1657 :                         return {{_Hint, _Tree_child::_Right}, false};

  001cb	89 11		 mov	 DWORD PTR [ecx], edx
  001cd	8b c1		 mov	 eax, ecx
  001cf	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 1673 :         }
; 1674 :     }

  001d6	5f		 pop	 edi
  001d7	5e		 pop	 esi
  001d8	5b		 pop	 ebx
  001d9	8b e5		 mov	 esp, ebp
  001db	5d		 pop	 ebp
  001dc	c2 0c 00	 ret	 12			; 0000000cH
$LN18@Find_hint:

; 1658 :                     }
; 1659 : 
; 1660 :                     return {{_Next, _Tree_child::_Left}, false};

  001df	89 01		 mov	 DWORD PTR [ecx], eax
  001e1	8b c1		 mov	 eax, ecx
  001e3	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 1673 :         }
; 1674 :     }

  001ea	5f		 pop	 edi
  001eb	5e		 pop	 esi
  001ec	5b		 pop	 ebx
  001ed	8b e5		 mov	 esp, ebp
  001ef	5d		 pop	 ebp
  001f0	c2 0c 00	 ret	 12			; 0000000cH
$LN14@Find_hint:

; 1661 :                 }
; 1662 :             } else {
; 1663 :                 // _Val is equivalent to *_Hint; don't insert
; 1664 :                 return {{_Hint, _Tree_child::_Right}, true};

  001f3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1673 :         }
; 1674 :     }

  001f6	5f		 pop	 edi
  001f7	5e		 pop	 esi
  001f8	5b		 pop	 ebx
  001f9	89 10		 mov	 DWORD PTR [eax], edx
  001fb	c6 40 08 01	 mov	 BYTE PTR [eax+8], 1
  001ff	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c2 0c 00	 ret	 12			; 0000000cH
??$_Find_hint@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_hint_result@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABQAUHKEY__@@@Z ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Find_hint<HKEY__ *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@ABU10@@Z
_TEXT	SEGMENT
??$forward@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@ABU10@@Z PROC ; std::forward<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@ABU10@@Z ENDP ; std::forward<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -28					; size = 4
$T20 = -24						; size = 4
__Result$1$ = -20					; size = 4
__Right_size$1$ = -16					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > ><std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0002c	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  0002f	8b 75 10	 mov	 esi, DWORD PTR _<_Vals_0>$[ebp]
  00032	89 7d e4	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00035	89 07		 mov	 DWORD PTR [edi], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0003e	6a 2c		 push	 44			; 0000002cH

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00040	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 51   :         return ::operator new(_Bytes);

  00047	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0004c	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  0004e	83 c4 04	 add	 esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00051	89 4d e8	 mov	 DWORD PTR $T20[ebp], ecx

; 1044 :         _Ptr = _Al.allocate(1);

  00054	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00057	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

  0005e	8b 06		 mov	 eax, DWORD PTR [esi]
  00060	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2661 :         auto& _Right_data             = _Right._Mypair._Myval2;

  00063	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00066	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  0006d	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 2158 :         return _BUF_SIZE <= _Myres;

  00074	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8

; 2662 :         const size_type _Right_size   = _Right_data._Mysize;

  00078	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0007b	89 45 ec	 mov	 DWORD PTR __Result$1$[ebp], eax
  0007e	89 55 f0	 mov	 DWORD PTR __Right_size$1$[ebp], edx

; 2150 :         if (_Large_string_engaged()) {

  00081	72 05		 jb	 SHORT $LN52@allocator

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00083	8b 00		 mov	 eax, DWORD PTR [eax]
  00085	89 45 ec	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN52@allocator:

; 2665 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00088	83 fa 08	 cmp	 edx, 8
  0008b	73 0e		 jae	 SHORT $LN49@allocator
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0008d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2668 :             _My_data._Myres  = _BUF_SIZE - 1;

  00090	be 07 00 00 00	 mov	 esi, 7
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00095	0f 11 41 14	 movups	 XMMWORD PTR [ecx+20], xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2669 :             return;

  00099	eb 48		 jmp	 SHORT $LN48@allocator
$LN49@allocator:

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  0009b	8b f2		 mov	 esi, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  0009d	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  000a2	83 ce 07	 or	 esi, 7
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  000a5	3b f0		 cmp	 esi, eax
  000a7	0f 47 f0	 cmova	 esi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000aa	33 c9		 xor	 ecx, ecx
  000ac	8b c6		 mov	 eax, esi
  000ae	83 c0 01	 add	 eax, 1
  000b1	0f 92 c1	 setb	 cl
  000b4	f7 d9		 neg	 ecx
  000b6	0b c8		 or	 ecx, eax
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  000be	8b c8		 mov	 ecx, eax

; 2675 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  000c0	8b 45 e8	 mov	 eax, DWORD PTR $T20[ebp]
  000c3	89 48 14	 mov	 DWORD PTR [eax+20], ecx
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000c6	8b 45 f0	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  000c9	8d 04 45 02 00
	00 00		 lea	 eax, DWORD PTR [eax*2+2]
  000d0	50		 push	 eax
  000d1	ff 75 ec	 push	 DWORD PTR __Result$1$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _memcpy
  000da	8b 4d e8	 mov	 ecx, DWORD PTR $T20[ebp]
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e0	8b 55 f0	 mov	 edx, DWORD PTR __Right_size$1$[ebp]
$LN48@allocator:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  000e3	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);
; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);
; 810  :         this->_Ptr->_Color = _Red;
; 811  :         this->_Ptr->_Isnil = false;
; 812  :     }

  000e6	8b c7		 mov	 eax, edi
  000e8	8b 55 0c	 mov	 edx, DWORD PTR __Myhead$[ebp]
  000eb	89 71 28	 mov	 DWORD PTR [ecx+40], esi
  000ee	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000f1	89 11		 mov	 DWORD PTR [ecx], edx
  000f3	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000f6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000f9	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000fc	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000ff	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00102	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00106	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00109	c6 41 0d 00	 mov	 BYTE PTR [ecx+13], 0
  0010d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00110	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00117	59		 pop	 ecx
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$1:
  00000	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
__unwindfunclet$??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0:
  00008	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > ><std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z
_TEXT	SEGMENT
??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z PROC		; std::forward<wchar_t * const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z ENDP		; std::forward<wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *>, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$forward@ABQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAPAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAPAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@AAU10@@Z PROC ; std::addressof<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAPAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$destroy@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::destroy<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 675  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00006	83 f9 08	 cmp	 ecx, 8

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 2e		 jb	 SHORT $LN21@destroy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000e	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001b	72 12		 jb	 SHORT $LN31@destroy

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00020	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00023	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00025	83 c0 fc	 add	 eax, -4			; fffffffcH
  00028	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002b	77 22		 ja	 SHORT $LN28@destroy

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002d	8b c2		 mov	 eax, edx
$LN31@destroy:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002f	51		 push	 ecx
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	83 c4 08	 add	 esp, 8
$LN21@destroy:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00039	33 c0		 xor	 eax, eax
  0003b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00042	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00049	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  0004d	5e		 pop	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 677  :     }

  0004e	c3		 ret	 0
$LN28@destroy:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN39@destroy:
  00055	cc		 int	 3
??$destroy@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::destroy<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::nullptr_t>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 572  :     // assign _New_val to _Val, return previous _Val
; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	8b 12		 mov	 edx, DWORD PTR [edx]
  00004	89 11		 mov	 DWORD PTR [ecx], edx

; 575  :     return _Old_val;
; 576  : }

  00006	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1646 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]

; 1647 :     // move [_First, _Last) to raw _Dest, using _Al
; 1648 :     // note: only called internally from elsewhere in the STL
; 1649 :     using _Ptrval     = typename _Alloc::value_type*;
; 1650 :     auto _UFirst      = _Get_unwrapped(_First);
; 1651 :     const auto _ULast = _Get_unwrapped(_Last);
; 1652 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1653 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1654 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1655 :         return _Dest + (_ULast - _UFirst);
; 1656 :         (void) _Al;
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00007	3b ca		 cmp	 ecx, edx
  00009	74 3f		 je	 SHORT $LN3@Uninitiali

; 1646 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  0000b	8b c6		 mov	 eax, esi
  0000d	2b c1		 sub	 eax, ecx
  0000f	90		 npad	 1
$LL4@Uninitiali:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c7 44 08 14 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+20], 0

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0001f	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00022	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00025	f3 0f 7e 41 10	 movq	 xmm0, QWORD PTR [ecx+16]
  0002a	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1499 :         ++_Last;

  0002f	83 c6 18	 add	 esi, 24			; 00000018H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00032	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1499 :         ++_Last;

  00043	83 c1 18	 add	 ecx, 24			; 00000018H

; 1647 :     // move [_First, _Last) to raw _Dest, using _Al
; 1648 :     // note: only called internally from elsewhere in the STL
; 1649 :     using _Ptrval     = typename _Alloc::value_type*;
; 1650 :     auto _UFirst      = _Get_unwrapped(_First);
; 1651 :     const auto _ULast = _Get_unwrapped(_Last);
; 1652 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1653 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1654 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1655 :         return _Dest + (_ULast - _UFirst);
; 1656 :         (void) _Al;
; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {

  00046	3b ca		 cmp	 ecx, edx
  00048	75 c6		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1493 :         _Destroy_range(_First, _Last, _Al);

  0004a	51		 push	 ecx
  0004b	8b d6		 mov	 edx, esi
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00054	83 c4 04	 add	 esp, 4

; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();

  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi

; 1664 :     }
; 1665 : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABQAV10@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABQAV10@@Z PROC ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>, COMDAT
; __It$ = ecx

; 1197 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1198 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1199 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1200 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1201 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1202 :     } else {
; 1203 :         return static_cast<_Iter&&>(_It);
; 1204 :     }
; 1205 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABQAV10@@Z ENDP ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??_G?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_G?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAXI@Z PROC ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2158 :         return _BUF_SIZE <= _Myres;

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00009	83 f9 08	 cmp	 ecx, 8

; 4310 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0000c	72 2e		 jb	 SHORT $LN19@scalar
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN29@scalar

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 27		 ja	 SHORT $LN26@scalar

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN29@scalar:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00039	83 c4 08	 add	 esp, 8
$LN19@scalar:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0003c	33 c0		 xor	 eax, eax
  0003e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00045	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  00049	8b c6		 mov	 eax, esi

; 4311 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4312 :             auto& _Al          = _Getal();
; 4313 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4314 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);
; 4315 :         }
; 4316 : 
; 4317 :         _Mypair._Myval2._Mysize = 0;
; 4318 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0004b	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7

; 4321 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00052	5e		 pop	 esi
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN26@scalar:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN36@scalar:
  0005d	cc		 int	 3
??_G?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAXI@Z ENDP ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00007	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0000e	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release, COMDAT
; _this$ = ecx

; 1503 :         _First = _Last;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	89 01		 mov	 DWORD PTR [ecx], eax

; 1504 :         return _Last;
; 1505 :     }

  00005	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 1493 :         _Destroy_range(_First, _Last, _Al);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	51		 push	 ecx
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0000b	59		 pop	 ecx

; 1494 :     }

  0000c	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Al_$[ebp]
  0000e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00011	8b c1		 mov	 eax, ecx
  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >, COMDAT
; _this$ = ecx

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00029	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  0002c	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00035	6a 2c		 push	 44			; 0000002cH

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00037	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 51   :         return ::operator new(_Bytes);

  0003e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1044 :         _Ptr = _Al.allocate(1);

  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 51   :         return ::operator new(_Bytes);

  00046	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 786  :     }

  00049	8b c6		 mov	 eax, esi
  0004b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00055	59		 pop	 ecx
  00056	5e		 pop	 esi
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
tv322 = -4						; size = 4
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 72   :     _Tree_unchecked_const_iterator& operator--() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 73   :         if (_Ptr->_Isnil) {

  00007	8b 16		 mov	 edx, DWORD PTR [esi]
  00009	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0000d	74 0c		 je	 SHORT $LN4@operator

; 74   :             _Ptr = _Ptr->_Right; // end() ==> rightmost

  0000f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00012	89 06		 mov	 DWORD PTR [esi], eax

; 86   :         }
; 87   : 
; 88   :         return *this;
; 89   :     }

  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN4@operator:

; 75   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree

  0001b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0001d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00021	74 3c		 je	 SHORT $LN6@operator

; 76   :             _Nodeptr _Pnode;
; 77   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {

  00023	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00026	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002a	75 24		 jne	 SHORT $LN23@operator
  0002c	57		 push	 edi
  0002d	8b ca		 mov	 ecx, edx
  0002f	8b fa		 mov	 edi, edx
  00031	53		 push	 ebx
$LL2@operator:
  00032	8b d8		 mov	 ebx, eax
  00034	89 45 fc	 mov	 DWORD PTR tv322[ebp], eax
  00037	8b d7		 mov	 edx, edi
  00039	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0003b	75 11		 jne	 SHORT $LN25@operator

; 78   :                 _Ptr = _Pnode; // ==> parent while left subtree

  0003d	89 06		 mov	 DWORD PTR [esi], eax
  0003f	8b c8		 mov	 ecx, eax
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	8b f9		 mov	 edi, ecx
  00046	8b d3		 mov	 edx, ebx
  00048	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004c	74 e4		 je	 SHORT $LL2@operator
$LN25@operator:
  0004e	5b		 pop	 ebx
  0004f	5f		 pop	 edi
$LN23@operator:

; 79   :             }
; 80   : 
; 81   :             if (!_Ptr->_Isnil) { // decrement non-begin()

  00050	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00054	75 27		 jne	 SHORT $LN26@operator

; 82   :                 _Ptr = _Pnode; // ==> parent if not head

  00056	89 06		 mov	 DWORD PTR [esi], eax

; 86   :         }
; 87   : 
; 88   :         return *this;
; 89   :     }

  00058	8b c6		 mov	 eax, esi
  0005a	5e		 pop	 esi
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN6@operator:

; 443  :         while (!_Pnode->_Right->_Isnil) {

  0005f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00062	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00066	75 13		 jne	 SHORT $LN12@operator
  00068	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL11@operator:

; 444  :             _Pnode = _Pnode->_Right;

  00070	8b c8		 mov	 ecx, eax
  00072	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00075	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00079	74 f5		 je	 SHORT $LL11@operator
$LN12@operator:

; 83   :             }
; 84   :         } else {
; 85   :             _Ptr = _Mytree::_Max(_Ptr->_Left); // ==> largest of left subtree

  0007b	89 0e		 mov	 DWORD PTR [esi], ecx
$LN26@operator:

; 86   :         }
; 87   : 
; 88   :         return *this;
; 89   :     }

  0007d	8b c6		 mov	 eax, esi
  0007f	5e		 pop	 esi
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??R?$less@PAUHKEY__@@@std@@QBE_NABQAUHKEY__@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PAUHKEY__@@@std@@QBE_NABQAUHKEY__@@0@Z PROC	; std::less<HKEY__ *>::operator(), COMDAT
; _this$dead$ = ecx

; 126  :     constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 127  :         return _Left < _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000d	0f 92 c0	 setb	 al

; 128  :     }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??R?$less@PAUHKEY__@@@std@@QBE_NABQAUHKEY__@@0@Z ENDP	; std::less<HKEY__ *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 2054 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00000	8b c1		 mov	 eax, ecx

; 2055 :     }

  00002	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@PAUHKEY__@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@PAUHKEY__@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 2038 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2039 :     }

  00002	c3		 ret	 0
?_Getcomp@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@PAUHKEY__@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1042 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 51   :         return ::operator new(_Bytes);

  00003	6a 2c		 push	 44			; 0000002cH

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00005	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 51   :         return ::operator new(_Bytes);

  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 1044 :         _Ptr = _Al.allocate(1);

  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	5e		 pop	 esi

; 1045 :     }

  00018	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >, COMDAT
; _this$ = ecx

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@PAUHKEY__@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@PAUHKEY__@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@PAUHKEY__@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@PAUHKEY__@@@2@XZ PROC ; std::_Compressed_pair<std::less<HKEY__ *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@PAUHKEY__@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@PAUHKEY__@@@2@XZ ENDP ; std::_Compressed_pair<std::less<HKEY__ *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Max, COMDAT
; __Pnode$ = ecx

; 443  :         while (!_Pnode->_Right->_Isnil) {

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00007	75 12		 jne	 SHORT $LN9@Max
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Max:

; 444  :             _Pnode = _Pnode->_Right;

  00010	8b c8		 mov	 ecx, eax
  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN9@Max:

; 445  :         }
; 446  : 
; 447  :         return _Pnode;
; 448  :     }

  0001b	8b c1		 mov	 eax, ecx
  0001d	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
;	COMDAT ??$_Kfn@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@SAABQAUHKEY__@@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
_TEXT	SEGMENT
??$_Kfn@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@SAABQAUHKEY__@@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z PROC ; std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0>::_Kfn<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; __Val$ = ecx

; 69   :         return _Val.first;

  00000	8b c1		 mov	 eax, ecx

; 70   :     }

  00002	c3		 ret	 0
??$_Kfn@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@SAABQAUHKEY__@@ABU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ENDP ; std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0>::_Kfn<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Find_lower_bound@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@ABQAUHKEY__@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@ABQAUHKEY__@@@Z PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Find_lower_bound<HKEY__ *>, COMDAT
; _this$ = ecx

; 1702 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1703 :         const auto _Scary = _Get_scary();
; 1704 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000b	89 02		 mov	 DWORD PTR [edx], eax
  0000d	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00014	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1705 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1706 :         while (!_Trynode->_Isnil) {

  00017	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001b	75 28		 jne	 SHORT $LN12@Find_lower
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef

; 127  :         return _Left < _Right;

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00020	56		 push	 esi
  00021	8b 31		 mov	 esi, DWORD PTR [ecx]
$LL2@Find_lower:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1707 :             _Result._Location._Parent = _Trynode;

  00023	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef

; 127  :         return _Left < _Right;

  00025	39 70 10	 cmp	 DWORD PTR [eax+16], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1708 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00028	73 07		 jae	 SHORT $LN4@Find_lower

; 1709 :                 _Result._Location._Child = _Tree_child::_Right;
; 1710 :                 _Trynode                 = _Trynode->_Right;

  0002a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002d	33 c9		 xor	 ecx, ecx

; 1711 :             } else {

  0002f	eb 0a		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1712 :                 _Result._Location._Child = _Tree_child::_Left;
; 1713 :                 _Result._Bound           = _Trynode;

  00031	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1714 :                 _Trynode                 = _Trynode->_Left;

  00034	b9 01 00 00 00	 mov	 ecx, 1
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
$LN5@Find_lower:

; 1705 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1706 :         while (!_Trynode->_Isnil) {

  0003b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0003e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00042	74 df		 je	 SHORT $LL2@Find_lower

; 1715 :             }
; 1716 :         }
; 1717 : 
; 1718 :         return _Result;

  00044	5e		 pop	 esi
$LN12@Find_lower:

; 1719 :     }

  00045	8b c2		 mov	 eax, edx
  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
??$_Find_lower_bound@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@ABQAUHKEY__@@@Z ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Find_lower_bound<HKEY__ *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABQAUHKEY__@@@Z
_TEXT	SEGMENT
__Bound$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Lower_bound_duplicate@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABQAUHKEY__@@@Z PROC ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Lower_bound_duplicate<HKEY__ *>, COMDAT
; _this$dead$ = ecx

; 1697 :     bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1698 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Bound$[ebp]
  00006	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0000a	75 10		 jne	 SHORT $LN3@Lower_boun
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef

; 127  :         return _Left < _Right;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1698 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00014	72 06		 jb	 SHORT $LN3@Lower_boun
  00016	b0 01		 mov	 al, 1

; 1699 :     }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN3@Lower_boun:

; 1698 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001c	32 c0		 xor	 al, al

; 1699 :     }

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
??$_Lower_bound_duplicate@PAUHKEY__@@@?$_Tree@V?$_Tmap_traits@PAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@PAUHKEY__@@@3@V?$allocator@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@1@ABQAUHKEY__@@@Z ENDP ; std::_Tree<std::_Tmap_traits<HKEY__ *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<HKEY__ *>,std::allocator<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,0> >::_Lower_bound_duplicate<HKEY__ *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$construct@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABU31@@Z
_TEXT	SEGMENT
__Right_size$1$ = 8					; size = 4
_<_Args_0>$ = 8						; size = 4
??$construct@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::construct<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2661 :         auto& _Right_data             = _Right._Mypair._Myval2;

  0000a	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 07		 mov	 DWORD PTR [edi], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00011	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  00018	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0

; 2158 :         return _BUF_SIZE <= _Myres;

  0001f	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8

; 2662 :         const size_type _Right_size   = _Right_data._Mysize;

  00023	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00026	89 45 08	 mov	 DWORD PTR __Right_size$1$[ebp], eax

; 2150 :         if (_Large_string_engaged()) {

  00029	72 02		 jb	 SHORT $LN16@construct

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  0002b	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN16@construct:

; 2665 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  0002d	83 f8 08	 cmp	 eax, 8
  00030	73 15		 jae	 SHORT $LN13@construct
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00032	0f 10 03	 movups	 xmm0, XMMWORD PTR [ebx]
  00035	0f 11 47 04	 movups	 XMMWORD PTR [edi+4], xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 672  :     }

  00039	89 47 14	 mov	 DWORD PTR [edi+20], eax
  0003c	c7 47 18 07 00
	00 00		 mov	 DWORD PTR [edi+24], 7
  00043	5f		 pop	 edi
  00044	5b		 pop	 ebx
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN13@construct:
  00047	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  00048	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  0004a	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  0004f	83 ce 07	 or	 esi, 7
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  00052	3b f0		 cmp	 esi, eax
  00054	0f 47 f0	 cmova	 esi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  00057	33 c9		 xor	 ecx, ecx
  00059	8b c6		 mov	 eax, esi
  0005b	83 c0 01	 add	 eax, 1
  0005e	0f 92 c1	 setb	 cl
  00061	f7 d9		 neg	 ecx
  00063	0b c8		 or	 ecx, eax
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2675 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  0006e	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00071	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00078	51		 push	 ecx
  00079	53		 push	 ebx
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 672  :     }

  00080	8b 45 08	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 672  :     }

  00086	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00089	89 77 18	 mov	 DWORD PTR [edi+24], esi
  0008c	5e		 pop	 esi
  0008d	5f		 pop	 edi
  0008e	5b		 pop	 ebx
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
??$construct@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@ABU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@1@QAU?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> > >::construct<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@0@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

  00004	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> *,std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1497 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00006	8b 55 08	 mov	 edx, DWORD PTR _<_Vals_0>$[ebp]

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00009	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00010	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 2612 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00017	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  0001a	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0001d	f3 0f 7e 42 10	 movq	 xmm0, QWORD PTR [edx+16]
  00022	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00027	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0002e	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00035	c6 02 00	 mov	 BYTE PTR [edx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1499 :         ++_Last;

  00038	83 41 04 18	 add	 DWORD PTR [ecx+4], 24	; 00000018H

; 1500 :     }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > const >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
;	COMDAT ??0?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right_size$1$ = 8					; size = 4
___that$ = 8						; size = 4
??0?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABU01@@Z PROC ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	57		 push	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2661 :         auto& _Right_data             = _Right._Mypair._Myval2;

  0000e	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

  00011	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00014	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00016	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0001d	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 2158 :         return _BUF_SIZE <= _Myres;

  00024	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8

; 2662 :         const size_type _Right_size   = _Right_data._Mysize;

  00028	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0002b	89 45 08	 mov	 DWORD PTR __Right_size$1$[ebp], eax

; 2150 :         if (_Large_string_engaged()) {

  0002e	72 02		 jb	 SHORT $LN14@pair

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00030	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN14@pair:

; 2665 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00032	83 f8 08	 cmp	 eax, 8
  00035	73 1d		 jae	 SHORT $LN11@pair
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00037	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2668 :             _My_data._Myres  = _BUF_SIZE - 1;

  0003a	bb 07 00 00 00	 mov	 ebx, 7
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

  0003f	5f		 pop	 edi
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00040	0f 11 46 04	 movups	 XMMWORD PTR [esi+4], xmm0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

  00044	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00047	8b c6		 mov	 eax, esi
  00049	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
$LN11@pair:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  00054	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  00056	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  0005b	83 cb 07	 or	 ebx, 7
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  0005e	3b d8		 cmp	 ebx, eax
  00060	0f 47 d8	 cmova	 ebx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  00063	33 c9		 xor	 ecx, ecx
  00065	8b c3		 mov	 eax, ebx
  00067	83 c0 01	 add	 eax, 1
  0006a	0f 92 c1	 setb	 cl
  0006d	f7 d9		 neg	 ecx
  0006f	0b c8		 or	 ecx, eax
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00077	8b 4d 08	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2675 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  0007a	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0007d	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00084	51		 push	 ecx
  00085	57		 push	 edi
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _memcpy
  0008c	8b 45 08	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

  00092	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00095	8b c6		 mov	 eax, esi
  00097	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
??0?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABU01@@Z ENDP ; std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right_size$1$ = 8					; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2277 :     basic_string(const basic_string& _Right)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 2662 :         const size_type _Right_size   = _Right_data._Mysize;

  00008	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  0000b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00012	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2158 :         return _BUF_SIZE <= _Myres;

  00019	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8

; 2662 :         const size_type _Right_size   = _Right_data._Mysize;

  0001d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00020	89 45 08	 mov	 DWORD PTR __Right_size$1$[ebp], eax

; 2150 :         if (_Large_string_engaged()) {

  00023	72 02		 jb	 SHORT $LN11@basic_stri

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00025	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN11@basic_stri:

; 2665 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00027	83 f8 08	 cmp	 eax, 8
  0002a	73 1a		 jae	 SHORT $LN8@basic_stri
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0002c	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2668 :             _My_data._Myres  = _BUF_SIZE - 1;

  0002f	bb 07 00 00 00	 mov	 ebx, 7

; 2283 :     }

  00034	5f		 pop	 edi
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00035	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2283 :     }

  00038	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0003b	8b c6		 mov	 eax, esi
  0003d	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
$LN8@basic_stri:

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  00046	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  00048	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  0004d	83 cb 07	 or	 ebx, 7
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  00050	3b d8		 cmp	 ebx, eax
  00052	0f 47 d8	 cmova	 ebx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  00055	33 c9		 xor	 ecx, ecx
  00057	8b c3		 mov	 eax, ebx
  00059	83 c0 01	 add	 eax, 1
  0005c	0f 92 c1	 setb	 cl
  0005f	f7 d9		 neg	 ecx
  00061	0b c8		 or	 ecx, eax
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00069	8b 4d 08	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2675 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  0006c	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0006e	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00075	51		 push	 ecx
  00076	57		 push	 edi
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _memcpy
  0007d	8b 45 08	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2283 :     }

  00083	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00086	8b c6		 mov	 eax, esi
  00088	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Right_size$1$ = 8					; size = 4
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2656 :     void _Construct_lv_contents(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 2657 :         // assign by copying data stored in _Right
; 2658 :         // pre: this != &_Right
; 2659 :         // pre: *this owns no memory, iterators orphaned (note:
; 2660 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2661 :         auto& _Right_data             = _Right._Mypair._Myval2;
; 2662 :         const size_type _Right_size   = _Right_data._Mysize;

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b d9		 mov	 ebx, ecx

; 2158 :         return _BUF_SIZE <= _Myres;

  0000a	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8

; 2657 :         // assign by copying data stored in _Right
; 2658 :         // pre: this != &_Right
; 2659 :         // pre: *this owns no memory, iterators orphaned (note:
; 2660 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2661 :         auto& _Right_data             = _Right._Mypair._Myval2;
; 2662 :         const size_type _Right_size   = _Right_data._Mysize;

  0000e	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00011	89 45 08	 mov	 DWORD PTR __Right_size$1$[ebp], eax

; 2150 :         if (_Large_string_engaged()) {

  00014	72 02		 jb	 SHORT $LN5@Construct_

; 2151 :             _Result = _Unfancy(_Bx._Ptr);

  00016	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN5@Construct_:

; 2663 :         const _Elem* const _Right_ptr = _Right_data._Myptr();
; 2664 :         auto& _My_data                = _Mypair._Myval2;
; 2665 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00018	83 f8 08	 cmp	 eax, 8
  0001b	73 16		 jae	 SHORT $LN2@Construct_
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0001d	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00020	5f		 pop	 edi
  00021	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2679 :     }

  00024	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00027	c7 43 14 07 00
	00 00		 mov	 DWORD PTR [ebx+20], 7
  0002e	5b		 pop	 ebx
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN2@Construct_:
  00033	56		 push	 esi

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  00034	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  00036	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2673 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

  0003b	83 ce 07	 or	 esi, 7
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

  0003e	3b f0		 cmp	 esi, eax
  00040	0f 47 f0	 cmova	 esi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2674 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  00043	33 c9		 xor	 ecx, ecx
  00045	8b c6		 mov	 eax, esi
  00047	83 c0 01	 add	 eax, 1
  0004a	0f 92 c1	 setb	 cl
  0004d	f7 d9		 neg	 ecx
  0004f	0b c8		 or	 ecx, eax
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00057	8b 4d 08	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2675 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  0005a	89 03		 mov	 DWORD PTR [ebx], eax
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0005c	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00063	51		 push	 ecx
  00064	57		 push	 edi
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2679 :     }

  0006b	8b 45 08	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
; File C:\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2679 :     }

  00071	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00074	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  00077	5e		 pop	 esi
  00078	5f		 pop	 edi
  00079	5b		 pop	 ebx
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 684  :         return _Al;

  00000	8b c1		 mov	 eax, ecx

; 685  :     }

  00002	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QAUHKEY__@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<HKEY__ * const,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,void *> * &>
_TEXT	ENDS
END
