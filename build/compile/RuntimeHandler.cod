; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	c:\users\neonik\desktop\csgo cheat sources\otc-source\otc\cpp\runtime\runtimehandler.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_C@_0BL@CHOBNDMJ@Variable?5or?5value?5is?5null?4@ ; `string'
PUBLIC	??_C@_0CB@OJCABHLM@Allocated?5memory?5pointer?5is?5nul@ ; `string'
PUBLIC	??_C@_0L@DLBPKAOP@Function?3?5@			; `string'
PUBLIC	??_C@_05LHNIPNPB@?5?$DM?$HM?$DO?5@		; `string'
PUBLIC	??_C@_08PHLEJAAL@Module?3?5@			; `string'
PUBLIC	??_C@_0CA@LNJEDMFL@Can?$GAt?5find?5module?5or?5function?4?5@ ; `string'
PUBLIC	??_C@_05MEGJJFDG@?5?$DM?9?$DO?5@		; `string'
PUBLIC	??_C@_0CB@FHNJEIA@Can?8t?5find?5offset?5type?4?5Offset?3@ ; `string'
PUBLIC	??_C@_0BC@MFGAJMC@OEP?5value?5is?5null@		; `string'
EXTRN	__imp__VirtualAlloc@16:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z:PROC
EXTRN	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	__imp_?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC
EXTRN	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync
EXTRN	__imp_?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
EXTRN	__imp_?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC
EXTRN	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow
EXTRN	__imp_?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
CONST	ENDS
;	COMDAT ??_C@_0BC@MFGAJMC@OEP?5value?5is?5null@
CONST	SEGMENT
??_C@_0BC@MFGAJMC@OEP?5value?5is?5null@ DB 'OEP value is null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FHNJEIA@Can?8t?5find?5offset?5type?4?5Offset?3@
CONST	SEGMENT
??_C@_0CB@FHNJEIA@Can?8t?5find?5offset?5type?4?5Offset?3@ DB 'Can''t find'
	DB	' offset type. Offset: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEGJJFDG@?5?$DM?9?$DO?5@
CONST	SEGMENT
??_C@_05MEGJJFDG@?5?$DM?9?$DO?5@ DB ' <-> ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LNJEDMFL@Can?$GAt?5find?5module?5or?5function?4?5@
CONST	SEGMENT
??_C@_0CA@LNJEDMFL@Can?$GAt?5find?5module?5or?5function?4?5@ DB 'Can`t fi'
	DB	'nd module or function. ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PHLEJAAL@Module?3?5@
CONST	SEGMENT
??_C@_08PHLEJAAL@Module?3?5@ DB 'Module: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LHNIPNPB@?5?$DM?$HM?$DO?5@
CONST	SEGMENT
??_C@_05LHNIPNPB@?5?$DM?$HM?$DO?5@ DB ' <|> ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DLBPKAOP@Function?3?5@
CONST	SEGMENT
??_C@_0L@DLBPKAOP@Function?3?5@ DB 'Function: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OJCABHLM@Allocated?5memory?5pointer?5is?5nul@
CONST	SEGMENT
??_C@_0CB@OJCABHLM@Allocated?5memory?5pointer?5is?5nul@ DB 'Allocated mem'
	DB	'ory pointer is null', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CHOBNDMJ@Variable?5or?5value?5is?5null?4@
CONST	SEGMENT
??_C@_0BL@CHOBNDMJ@Variable?5or?5value?5is?5null?4@ DB 'Variable or value'
	DB	' is null.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	050H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allo'
	DB	'cator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	050H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
PUBLIC	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * &>
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::nullptr_t>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * &>
PUBLIC	??$construct@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@QAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@AAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::construct<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >::deallocate
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Buynode<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>
PUBLIC	??$forward@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@YAAAU?$pair@$$CBW4ImportType@SegmentHeader@@K@0@AAU10@@Z ; std::forward<std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>
PUBLIC	??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Buynode<std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>
PUBLIC	?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Orphan_ptr
PUBLIC	??$forward@ABQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@ABQAU10@@Z ; std::forward<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * const &>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *>
PUBLIC	??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree_and_orphan<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_or_move<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,std::integral_constant<bool,0> >
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >
PUBLIC	??$_Get_size_of_n@$0BI@@std@@YAII@Z		; std::_Get_size_of_n<24>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * const &>
PUBLIC	??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>
PUBLIC	??$forward@U?$less@W4ImportType@SegmentHeader@@@std@@@std@@YA$$QAU?$less@W4ImportType@SegmentHeader@@@0@AAU10@@Z ; std::forward<std::less<enum SegmentHeader::ImportType> >
PUBLIC	??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1><std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >::allocate
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Max
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>
PUBLIC	??$?0U?$less@W4ImportType@SegmentHeader@@@std@@U_One_then_variadic_args_t@1@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@?$_Compressed_pair@U?$less@W4ImportType@SegmentHeader@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$less@W4ImportType@SegmentHeader@@@1@$$QAU21@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ; std::_Compressed_pair<std::less<enum SegmentHeader::ImportType>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>,1>::_Compressed_pair<std::less<enum SegmentHeader::ImportType>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>,1><std::less<enum SegmentHeader::ImportType>,std::_One_then_variadic_args_t,std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	??$forward@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@0@AAV10@@Z ; std::forward<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@W4ImportType@SegmentHeader@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@W4ImportType@SegmentHeader@@@2@XZ ; std::_Compressed_pair<std::less<enum SegmentHeader::ImportType>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>,1>::_Get_first
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEABU?$less@W4ImportType@SegmentHeader@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Getcomp
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AU?$less@W4ImportType@SegmentHeader@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::key_comp
PUBLIC	??0?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@AAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@1@@Z ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >
PUBLIC	?_Release@?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAEXXZ ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::_Release
PUBLIC	??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAE@XZ ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::~_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >
PUBLIC	??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> ><std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>::_Get_first
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::select_on_container_copy_construction
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Getal
PUBLIC	??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z ; std::multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >
PUBLIC	??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z	; SegmentHeader::ImportInfo::ImportInfo
PUBLIC	??$construct@UImportInfo@SegmentHeader@@AAU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SAXAAV?$allocator@UImportInfo@SegmentHeader@@@1@QAUImportInfo@SegmentHeader@@AAU34@@Z ; std::_Default_allocator_traits<std::allocator<SegmentHeader::ImportInfo> >::construct<SegmentHeader::ImportInfo,SegmentHeader::ImportInfo &>
PUBLIC	??$forward@AAUImportInfo@SegmentHeader@@@std@@YAAAUImportInfo@SegmentHeader@@AAU12@@Z ; std::forward<SegmentHeader::ImportInfo &>
PUBLIC	??$_Emplace_back@AAUImportInfo@SegmentHeader@@@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEXAAUImportInfo@SegmentHeader@@@Z ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::_Emplace_back<SegmentHeader::ImportInfo &>
PUBLIC	??$destroy@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@QAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::destroy<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >
PUBLIC	??$addressof@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@YAPAU?$pair@$$CBW4ImportType@SegmentHeader@@K@0@AAU10@@Z ; std::addressof<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@PAUImportInfo@SegmentHeader@@AAV?$allocator@UImportInfo@SegmentHeader@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEPAUImportInfo@SegmentHeader@@XZ ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::__autoclassinit2
PUBLIC	??$_Get_unwrapped@ABQAUImportInfo@SegmentHeader@@@std@@YAPAUImportInfo@SegmentHeader@@ABQAU12@@Z ; std::_Get_unwrapped<SegmentHeader::ImportInfo * const &>
PUBLIC	??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Uninitialized_copy<SegmentHeader::ImportInfo *,std::allocator<SegmentHeader::ImportInfo> >
PUBLIC	??$forward@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YA$$QAV?$allocator@UImportInfo@SegmentHeader@@@0@AAV10@@Z ; std::forward<std::allocator<SegmentHeader::ImportInfo> >
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * &>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >
PUBLIC	??$_Get_size_of_n@$0M@@std@@YAII@Z		; std::_Get_size_of_n<12>
PUBLIC	??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Ucopy<SegmentHeader::ImportInfo *>
PUBLIC	??$?0V?$allocator@UImportInfo@SegmentHeader@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@UImportInfo@SegmentHeader@@@1@@Z ; std::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1>::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1><std::allocator<SegmentHeader::ImportInfo> >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * &>
PUBLIC	?allocate@?$allocator@UImportInfo@SegmentHeader@@@std@@QAEPAUImportInfo@SegmentHeader@@I@Z ; std::allocator<SegmentHeader::ImportInfo>::allocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QBEABV?$allocator@UImportInfo@SegmentHeader@@@2@XZ ; std::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1>::_Get_first
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SA?AV?$allocator@UImportInfo@SegmentHeader@@@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<SegmentHeader::ImportInfo> >::select_on_container_copy_construction
PUBLIC	?_Buy_raw@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXI@Z ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Buy_raw
PUBLIC	?_Getal@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@ABEABV?$allocator@UImportInfo@SegmentHeader@@@2@XZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Getal
PUBLIC	??1?$_Tidy_guard@V?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
PUBLIC	??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >
PUBLIC	??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z ; std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::nullptr_t>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * &>
PUBLIC	??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::construct<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>::_Get_first
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Get_scary
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::deallocate
PUBLIC	??1?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::~_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	??1?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@XZ ; std::multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::~multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >
PUBLIC	??1ImportInfo@SegmentHeader@@QAE@XZ		; SegmentHeader::ImportInfo::~ImportInfo
PUBLIC	??_GImportInfo@SegmentHeader@@QAEPAXI@Z		; SegmentHeader::ImportInfo::`scalar deleting destructor'
PUBLIC	??$destroy@UImportInfo@SegmentHeader@@@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SAXAAV?$allocator@UImportInfo@SegmentHeader@@@1@QAUImportInfo@SegmentHeader@@@Z ; std::_Default_allocator_traits<std::allocator<SegmentHeader::ImportInfo> >::destroy<SegmentHeader::ImportInfo>
PUBLIC	??$_Unfancy@UImportInfo@SegmentHeader@@@std@@YAPAUImportInfo@SegmentHeader@@PAU12@@Z ; std::_Unfancy<SegmentHeader::ImportInfo>
PUBLIC	??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Buynode<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>
PUBLIC	??$forward@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@YAAAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@0@AAU10@@Z ; std::forward<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>
PUBLIC	??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
PUBLIC	??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Buynode<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QAEAAV?$allocator@UImportInfo@SegmentHeader@@@2@XZ ; std::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@UImportInfo@SegmentHeader@@@std@@QAEXQAUImportInfo@SegmentHeader@@I@Z ; std::allocator<SegmentHeader::ImportInfo>::deallocate
PUBLIC	?_Destroy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXPAUImportInfo@SegmentHeader@@0@Z ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Destroy
PUBLIC	?_Getal@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEAAV?$allocator@UImportInfo@SegmentHeader@@@2@XZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Getal
PUBLIC	?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy
PUBLIC	?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Orphan_ptr
PUBLIC	??1?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::~vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >
PUBLIC	??1?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ ; std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
PUBLIC	??_G?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAEPAXI@Z ; std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::`scalar deleting destructor'
PUBLIC	??$destroy@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::destroy<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >
PUBLIC	??$addressof@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@YAPAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >
PUBLIC	??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_tree_and_orphan<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_or_move<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,std::integral_constant<bool,0> >
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > const >
PUBLIC	??$forward@ABQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@ABQAU10@@Z ; std::forward<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * const &>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * &>
PUBLIC	??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_tag>
PUBLIC	??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_One_then_variadic_args_t>
PUBLIC	??$forward@U?$less@PBD@std@@@std@@YA$$QAU?$less@PBD@0@AAU10@@Z ; std::forward<std::less<char const *> >
PUBLIC	??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1><std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::deallocate
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Get_scary
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Max
PUBLIC	??$_Get_size_of_n@$0CA@@std@@YAII@Z		; std::_Get_size_of_n<32>
PUBLIC	??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * const &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy<std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_tag>
PUBLIC	??$?0U?$less@PBD@std@@U_One_then_variadic_args_t@1@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$less@PBD@1@$$QAU21@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1><std::less<char const *>,std::_One_then_variadic_args_t,std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	??$forward@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@0@AAV10@@Z ; std::forward<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	??$_Uninitialized_copy@PAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z ; std::_Uninitialized_copy<unsigned long *,std::allocator<unsigned long> >
PUBLIC	??$forward@V?$allocator@K@std@@@std@@YA$$QAV?$allocator@K@0@AAV10@@Z ; std::forward<std::allocator<unsigned long> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@PBD@2@XZ ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Get_first
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEABU?$less@PBD@2@XZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Getcomp
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::allocate
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@PBD@2@XZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::key_comp
PUBLIC	??0?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@AAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >
PUBLIC	?_Release@?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAEXXZ ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::_Release
PUBLIC	??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::~_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >
PUBLIC	??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > const >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> ><std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
PUBLIC	??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>
PUBLIC	??$?0V?$allocator@K@std@@$$V@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@K@1@@Z ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1><std::allocator<unsigned long> >
PUBLIC	??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Max_value@PAD@std@@YAABQADABQAD0@Z		; std::_Max_value<char *>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Min
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Get_first
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	?eq@?$_Narrow_char_traits@DH@std@@SA_NABD0@Z	; std::_Narrow_char_traits<char,int>::eq
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Get_scary
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Min
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::select_on_container_copy_construction
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Getal
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Get_scary
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SA?AV?$allocator@K@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<unsigned long> >::select_on_container_copy_construction
PUBLIC	?_Buy_raw@?$vector@KV?$allocator@K@std@@@std@@AAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy_raw
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>
PUBLIC	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::operator++
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>
PUBLIC	?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ; std::pointer_traits<char *>::pointer_to
PUBLIC	??1?$_Tidy_guard@V?$vector@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned long,std::allocator<unsigned long> > >::~_Tidy_guard<std::vector<unsigned long,std::allocator<unsigned long> > >
PUBLIC	??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >
PUBLIC	??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AU_Default_sentinel@2@XZ ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Unchecked_end
PUBLIC	??1?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::~_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >
PUBLIC	?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU_Default_sentinel@2@XZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Unchecked_end
PUBLIC	??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
PUBLIC	??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	?_Unchecked_begin@?$vector@KV?$allocator@K@std@@@std@@QAEPAKXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@KV?$allocator@K@std@@@std@@QAEPAKXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unchecked_end
PUBLIC	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::operator!=
PUBLIC	??D?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@XZ ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::operator*
PUBLIC	??E?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::operator++
PUBLIC	?_Unchecked_begin@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QBEPBUImportInfo@SegmentHeader@@XZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QBEPBUImportInfo@SegmentHeader@@XZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Unchecked_end
PUBLIC	??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::operator++
PUBLIC	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::operator!=
PUBLIC	?InvokeOEP@RuntimeHandler@@QAEXXZ		; RuntimeHandler::InvokeOEP
PUBLIC	?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	?__autoclassinit2@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	?__autoclassinit2@?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXI@Z ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::__autoclassinit2
PUBLIC	?ReconstructHotPoints@RuntimeHandler@@QAEXXZ	; RuntimeHandler::ReconstructHotPoints
PUBLIC	?ExtractSegment@RuntimeHandler@@QAEXXZ		; RuntimeHandler::ExtractSegment
PUBLIC	??1SegmentHeader@@QAE@XZ			; SegmentHeader::~SegmentHeader
PUBLIC	??0SegmentHeader@@QAE@ABV0@@Z			; SegmentHeader::SegmentHeader
PUBLIC	?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ	; Segment::GetHeader
PUBLIC	??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::~map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
PUBLIC	?GetRelocations@SegmentHeader@@QAE?AV?$vector@KV?$allocator@K@std@@@std@@XZ ; SegmentHeader::GetRelocations
PUBLIC	?GetImports@SegmentHeader@@QAE?AV?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@XZ ; SegmentHeader::GetImports
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
EXTRN	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0SegmentHeader@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SegmentHeader@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SegmentHeader@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SegmentHeader@@QAE@ABV0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$2
	DD	03H
	DD	FLAT:__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$3
	DD	05H
	DD	FLAT:__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$4
	DD	06H
	DD	FLAT:__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$6
	DD	08H
	DD	FLAT:__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$5
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z DD 03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$6
__catchsym$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$3
__catchsym$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z$0
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$dead$ = ecx

; 1068 :     void _Adopt(const void*) noexcept {}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
;	COMDAT ?GetImports@SegmentHeader@@QAE?AV?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetImports@SegmentHeader@@QAE?AV?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@XZ PROC ; SegmentHeader::GetImports, COMDAT
; _this$ = ecx

; 55   :     std::map <const char*, std::vector<ImportInfo>> GetImports() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   :         return m_imports;

  00003	51		 push	 ecx
  00004	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00007	e8 00 00 00 00	 call	 ??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 57   :     }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?GetImports@SegmentHeader@@QAE?AV?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@XZ ENDP ; SegmentHeader::GetImports
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
;	COMDAT ?GetRelocations@SegmentHeader@@QAE?AV?$vector@KV?$allocator@K@std@@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetRelocations@SegmentHeader@@QAE?AV?$vector@KV?$allocator@K@std@@@std@@XZ PROC ; SegmentHeader::GetRelocations, COMDAT
; _this$ = ecx

; 59   :     std::vector <DWORD> GetRelocations() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   :         return m_relocations;

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 61   :     }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?GetRelocations@SegmentHeader@@QAE?AV?$vector@KV?$allocator@K@std@@@std@@XZ ENDP ; SegmentHeader::GetRelocations
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::~map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >, COMDAT
; _this$ = ecx

; 1189 :         _Scary->_Erase_head(_Getal());

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
  00006	c3		 ret	 0
??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::~map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h
;	COMDAT ?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ PROC	; Segment::GetHeader, COMDAT
; _this$ = ecx

; 39   : 	SegmentHeader GetHeader () {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00029	8b cf		 mov	 ecx, edi
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
  00031	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003b	51		 push	 ecx
  0003c	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0003f	e8 00 00 00 00	 call	 ??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >

; 40   : 		return m_Header;

  00044	8b c7		 mov	 eax, edi

; 41   : 	}

  00046	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00049	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00050	59		 pop	 ecx
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ$1:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetHeader@Segment@@QAE?AVSegmentHeader@@XZ ENDP	; Segment::GetHeader
; Function compile flags: /Ogtp
;	COMDAT ??0SegmentHeader@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SegmentHeader@@QAE@ABV0@@Z PROC			; SegmentHeader::SegmentHeader, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SegmentHeader@@QAE@ABV0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002a	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
  00033	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	50		 push	 eax
  0003e	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00041	e8 00 00 00 00	 call	 ??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
  00046	8b c7		 mov	 eax, edi
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00052	59		 pop	 ecx
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SegmentHeader@@QAE@ABV0@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0SegmentHeader@@QAE@ABV0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SegmentHeader@@QAE@ABV0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SegmentHeader@@QAE@ABV0@@Z ENDP			; SegmentHeader::SegmentHeader
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1SegmentHeader@@QAE@XZ
_TEXT	SEGMENT
??1SegmentHeader@@QAE@XZ PROC				; SegmentHeader::~SegmentHeader, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00006	85 c0		 test	 eax, eax
  00008	74 41		 je	 SHORT $LN6@SegmentHea

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000a	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000d	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000f	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00012	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00018	72 12		 jb	 SHORT $LN22@SegmentHea

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001d	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00020	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00022	83 c0 fc	 add	 eax, -4			; fffffffcH
  00025	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00028	77 2b		 ja	 SHORT $LN19@SegmentHea

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002a	8b c2		 mov	 eax, edx
$LN22@SegmentHea:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002c	51		 push	 ecx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00033	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0003a	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  0003d	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 1699 :             _Myend   = pointer();

  00044	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$LN6@SegmentHea:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1189 :         _Scary->_Erase_head(_Getal());

  0004b	56		 push	 esi
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
  00053	5e		 pop	 esi
  00054	c3		 ret	 0
$LN19@SegmentHea:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN33@SegmentHea:
  0005b	cc		 int	 3
??1SegmentHeader@@QAE@XZ ENDP				; SegmentHeader::~SegmentHeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
;	COMDAT ?ExtractSegment@RuntimeHandler@@QAEXXZ
_TEXT	SEGMENT
?ExtractSegment@RuntimeHandler@@QAEXXZ PROC		; RuntimeHandler::ExtractSegment, COMDAT
; _this$dead$ = ecx

; 4    :     //Allocate memory for segment, and set pointer.
; 5    :     PanicUtils::SetImportant (&Segment::UnsafeAllocatedPointer, reinterpret_cast<DWORD> (VirtualAlloc (NULL, SegmentHeader::Datacase::ALLOCATION, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)));

  00000	6a 40		 push	 64			; 00000040H
  00002	68 00 30 00 00	 push	 12288			; 00003000H
  00007	68 40 89 96 00	 push	 9865536			; 00968940H
  0000c	6a 00		 push	 0
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 4    :     if (variable && value) {

  00014	85 c0		 test	 eax, eax
  00016	74 28		 je	 SHORT $LN4@ExtractSeg
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 8    :     PanicUtils::RequireNonNull (PanicUtils::Layers::INIT, reinterpret_cast<DWORD> (memcpy (reinterpret_cast<PVOID> (Segment::GetSafeAllocationPointer()), SegmentData, SegmentHeader::Datacase::SIZE)), "Allocated memory pointer is null");

  00018	68 00 6a 18 00	 push	 1600000			; 00186a00H
  0001d	68 00 00 00 00	 push	 OFFSET ?SegmentData@@3QBEB ; SegmentData
  00022	50		 push	 eax
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 5    :         *variable = value;

  00023	a3 00 00 00 00	 mov	 DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA, eax ; Segment::UnsafeAllocatedPointer
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 8    :     PanicUtils::RequireNonNull (PanicUtils::Layers::INIT, reinterpret_cast<DWORD> (memcpy (reinterpret_cast<PVOID> (Segment::GetSafeAllocationPointer()), SegmentData, SegmentHeader::Datacase::SIZE)), "Allocated memory pointer is null");

  00028	e8 00 00 00 00	 call	 _memcpy
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00030	85 c0		 test	 eax, eax
  00032	75 1b		 jne	 SHORT $LN15@ExtractSeg

; 14   :         PanicUtils::Release (layer, reason);

  00034	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CB@OJCABHLM@Allocated?5memory?5pointer?5is?5nul@
  00039	33 c9		 xor	 ecx, ecx
  0003b	e9 00 00 00 00	 jmp	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN4@ExtractSeg:

; 8    :         PanicUtils::Release (Layers::ROUTINE, reason);

  00040	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BL@CHOBNDMJ@Variable?5or?5value?5is?5null?4@
  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	e9 00 00 00 00	 jmp	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN15@ExtractSeg:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 9    : }

  0004f	c3		 ret	 0
?ExtractSegment@RuntimeHandler@@QAEXXZ ENDP		; RuntimeHandler::ExtractSegment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
;	COMDAT ?ReconstructHotPoints@RuntimeHandler@@QAEXXZ
_TEXT	SEGMENT
$T19 = -232						; size = 24
$T14 = -232						; size = 24
_<end>$L2$1$ = -208					; size = 4
$T8 = -204						; size = 20
$T3 = -204						; size = 20
_<begin>$L2$1$ = -184					; size = 4
_message$23 = -180					; size = 152
_message$24 = -180					; size = 152
_$S1$25 = -28						; size = 12
_$S2$26 = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ReconstructHotPoints@RuntimeHandler@@QAEXXZ PROC	; RuntimeHandler::ReconstructHotPoints, COMDAT
; _this$ = ecx

; 11   : void RuntimeHandler::ReconstructHotPoints () {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b d9		 mov	 ebx, ecx
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h

; 40   : 		return m_Header;

  00030	8b 33		 mov	 esi, DWORD PTR [ebx]
  00032	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
  0003e	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	50		 push	 eax
  00049	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+8]
  0004f	e8 00 00 00 00	 call	 ??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h

; 60   :         return m_relocations;

  00054	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp+8]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 17   :     for (const auto& relocation : m_Segment.GetHeader().GetRelocations ()) {

  0005a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h

; 60   :         return m_relocations;

  00061	50		 push	 eax
  00062	8d 4d e4	 lea	 ecx, DWORD PTR _$S1$25[ebp]
  00065	e8 00 00 00 00	 call	 ??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 17   :     for (const auto& relocation : m_Segment.GetHeader().GetRelocations ()) {

  0006a	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00077	e8 00 00 00 00	 call	 ??1SegmentHeader@@QAE@XZ
  0007c	8b 75 e4	 mov	 esi, DWORD PTR _$S1$25[ebp]
  0007f	8b d6		 mov	 edx, esi
  00081	8b 7d e8	 mov	 edi, DWORD PTR _$S1$25[ebp+4]
  00084	3b d7		 cmp	 edx, edi
  00086	74 28		 je	 SHORT $LN3@Reconstruc
  00088	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@Reconstruc:

; 18   :         //Subtract value with old base address in segment from memory.
; 19   :         *reinterpret_cast<DWORD*> (Segment::UnsafeAllocatedPointer + relocation) -= SegmentHeader::Datacase::RUNTIME;

  00090	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
  00097	81 04 01 00 00
	a0 c2		 add	 DWORD PTR [ecx+eax], -1029701632 ; c2a00000H

; 20   :         //Add new base address in segment to relocations.
; 21   :         *reinterpret_cast<DWORD*> (Segment::UnsafeAllocatedPointer + relocation) += Segment::UnsafeAllocatedPointer;

  0009e	8b 02		 mov	 eax, DWORD PTR [edx]
  000a0	83 c2 04	 add	 edx, 4
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
  000a9	01 0c 08	 add	 DWORD PTR [eax+ecx], ecx
  000ac	3b d7		 cmp	 edx, edi
  000ae	75 e0		 jne	 SHORT $LL4@Reconstruc
$LN3@Reconstruc:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  000b0	85 f6		 test	 esi, esi
  000b2	74 39		 je	 SHORT $LN44@Reconstruc

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b4	8b 45 ec	 mov	 eax, DWORD PTR _$S1$25[ebp+8]
  000b7	2b c6		 sub	 eax, esi
  000b9	c1 f8 02	 sar	 eax, 2
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bc	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  000c3	8b c6		 mov	 eax, esi

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000c5	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000cb	72 16		 jb	 SHORT $LN60@Reconstruc

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000cd	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  000d0	83 c1 23	 add	 ecx, 35			; 00000023H
  000d3	2b c6		 sub	 eax, esi

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000d5	83 c0 fc	 add	 eax, -4			; fffffffcH
  000d8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000db	76 06		 jbe	 SHORT $LN60@Reconstruc
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN60@Reconstruc:

; 195  :     ::operator delete(_Ptr, _Bytes);

  000e3	51		 push	 ecx
  000e4	56		 push	 esi
  000e5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ea	83 c4 08	 add	 esp, 8
$LN44@Reconstruc:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\Segment.h

; 40   : 		return m_Header;

  000ed	8b 33		 mov	 esi, DWORD PTR [ebx]
  000ef	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  000f5	56		 push	 esi
  000f6	e8 00 00 00 00	 call	 ??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
  000fb	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  000fe	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00105	50		 push	 eax
  00106	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp+8]
  0010c	e8 00 00 00 00	 call	 ??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h

; 56   :         return m_imports;

  00111	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 29   :     for (const auto& importsMap : m_Segment.GetHeader().GetImports ()) {

  00117	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\headers\segment\SegmentHeader.h

; 56   :         return m_imports;

  0011e	50		 push	 eax
  0011f	8d 4d e8	 lea	 ecx, DWORD PTR _$S2$26[ebp]
  00122	e8 00 00 00 00	 call	 ??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 29   :     for (const auto& importsMap : m_Segment.GetHeader().GetImports ()) {

  00127	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  0012b	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR $T8[ebp+8]
  00131	85 c9		 test	 ecx, ecx
  00133	74 5a		 je	 SHORT $LN84@Reconstruc

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00135	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp+16]
  0013b	2b c1		 sub	 eax, ecx
  0013d	c1 f8 02	 sar	 eax, 2
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00140	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  00147	8b c1		 mov	 eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00149	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0014f	72 16		 jb	 SHORT $LN100@Reconstruc

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00151	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00154	83 c2 23	 add	 edx, 35			; 00000023H
  00157	2b c1		 sub	 eax, ecx

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00159	83 c0 fc	 add	 eax, -4			; fffffffcH
  0015c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0015f	76 06		 jbe	 SHORT $LN100@Reconstruc
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN100@Reconstruc:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00167	52		 push	 edx
  00168	51		 push	 ecx
  00169	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0016e	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00171	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+8], 0

; 1698 :             _Mylast  = pointer();

  0017b	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+12], 0

; 1699 :             _Myend   = pointer();

  00185	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+16], 0
$LN84@Reconstruc:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1189 :         _Scary->_Erase_head(_Getal());

  0018f	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00195	50		 push	 eax
  00196	8b c8		 mov	 ecx, eax
  00198	e8 00 00 00 00	 call	 ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0019d	8b 7d e8	 mov	 edi, DWORD PTR _$S2$26[ebp]
  001a0	8b 3f		 mov	 edi, DWORD PTR [edi]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 29   :     for (const auto& importsMap : m_Segment.GetHeader().GetImports ()) {

  001a2	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  001a6	0f 85 3a 01 00
	00		 jne	 $LN274@Reconstruc
  001ac	0f 1f 40 00	 npad	 4
$LL127@Reconstruc:

; 30   : 
; 31   :         //Get info about import from value at map.
; 32   :         for (const auto& importInfo : importsMap.second) {

  001b0	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  001b3	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  001b6	89 85 48 ff ff
	ff		 mov	 DWORD PTR _<begin>$L2$1$[ebp], eax
  001bc	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _<end>$L2$1$[ebp], ecx
  001c2	3b c1		 cmp	 eax, ecx
  001c4	0f 84 d5 00 00
	00		 je	 $LN5@Reconstruc
  001ca	66 0f 1f 44 00
	00		 npad	 6
$LL10@Reconstruc:

; 35   :             DWORD functionPointer = Utils::GetFunction (importsMap.first, importInfo.function);

  001d0	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  001d3	8b 18		 mov	 ebx, DWORD PTR [eax]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\Utils.cpp

; 5    :    HMODULE hModule = GetModuleHandleA (module);

  001d5	56		 push	 esi
  001d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4

; 6    : 
; 7    :    if (!hModule) {

  001dc	85 c0		 test	 eax, eax
  001de	75 07		 jne	 SHORT $LN142@Reconstruc

; 8    :        hModule = LoadLibraryA (module);

  001e0	56		 push	 esi
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
$LN142@Reconstruc:

; 24   :    return reinterpret_cast<DWORD> (GetProcAddress(GetModule(module), function));

  001e7	53		 push	 ebx
  001e8	50		 push	 eax
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 35   :             DWORD functionPointer = Utils::GetFunction (importsMap.first, importInfo.function);

  001ef	8b d8		 mov	 ebx, eax

; 36   : 
; 37   :             //Check non-nullptr at function and module. (Why don't use RequireNonNull? Because it's slow!)
; 38   :             if (!functionPointer) {

  001f1	85 db		 test	 ebx, ebx
  001f3	0f 84 14 01 00
	00		 je	 $LN248@Reconstruc
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1261 :         return _Unchecked_const_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  001f9	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _<begin>$L2$1$[ebp]
  001ff	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00202	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 46   :             for (const auto& parsedOffset : importInfo.offsetsMap) {

  00204	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00208	0f 85 7c 00 00
	00		 jne	 $LN8@Reconstruc
  0020e	66 90		 npad	 2
$LL188@Reconstruc:

; 47   : 
; 48   :                 //More about ImportType: SegmentHeader.h
; 49   :                 switch (parsedOffset.first) {

  00210	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00213	83 e8 00	 sub	 eax, 0
  00216	74 16		 je	 SHORT $LN17@Reconstruc
  00218	83 e8 01	 sub	 eax, 1
  0021b	0f 85 7b 01 00
	00		 jne	 $LN276@Reconstruc

; 54   :                       break;
; 55   : 
; 56   :                     case SegmentHeader::ImportType::PUBLIC:
; 57   :                         //Patch global variables.
; 58   :                         *reinterpret_cast<DWORD*> (Segment::UnsafeAllocatedPointer + parsedOffset.second) = functionPointer;

  00221	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00224	a1 00 00 00 00	 mov	 eax, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
  00229	89 1c 08	 mov	 DWORD PTR [eax+ecx], ebx

; 59   :                       break;

  0022c	eb 14		 jmp	 SHORT $LN11@Reconstruc
$LN17@Reconstruc:

; 50   : 
; 51   :                     case SegmentHeader::ImportType::INTERNAL:
; 52   :                         //Patch functions (and in them) that call import.
; 53   :                         *reinterpret_cast<DWORD*> (Segment::UnsafeAllocatedPointer + parsedOffset.second) = functionPointer - (Segment::UnsafeAllocatedPointer + parsedOffset.second + 0x4);

  0022e	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00231	8b cb		 mov	 ecx, ebx
  00233	a1 00 00 00 00	 mov	 eax, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
  00238	2b ca		 sub	 ecx, edx
  0023a	2b c8		 sub	 ecx, eax
  0023c	83 e9 04	 sub	 ecx, 4
  0023f	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx
$LN11@Reconstruc:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00242	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00245	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00249	74 1d		 je	 SHORT $LN187@Reconstruc

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0024b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0024e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00252	75 10		 jne	 SHORT $LN186@Reconstruc
$LL185@Reconstruc:
  00254	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00257	75 0b		 jne	 SHORT $LN186@Reconstruc

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  00259	8b f0		 mov	 esi, eax
  0025b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0025e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00262	74 f0		 je	 SHORT $LL185@Reconstruc
$LN186@Reconstruc:

; 56   :             }
; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())

  00264	8b f0		 mov	 esi, eax

; 59   :         } else {

  00266	eb 16		 jmp	 SHORT $LN252@Reconstruc
$LN187@Reconstruc:

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00268	8b f0		 mov	 esi, eax

; 451  :         while (!_Pnode->_Left->_Isnil) {

  0026a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0026c	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00270	75 0c		 jne	 SHORT $LN252@Reconstruc
$LL191@Reconstruc:
  00272	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00274	8b f1		 mov	 esi, ecx
  00276	8b c8		 mov	 ecx, eax
  00278	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0027c	74 f4		 je	 SHORT $LL191@Reconstruc
$LN252@Reconstruc:

; 111  :         return !_Ptr->_Isnil;

  0027e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 46   :             for (const auto& parsedOffset : importInfo.offsetsMap) {

  00282	74 8c		 je	 SHORT $LL188@Reconstruc
  00284	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _<begin>$L2$1$[ebp]
$LN8@Reconstruc:

; 30   : 
; 31   :         //Get info about import from value at map.
; 32   :         for (const auto& importInfo : importsMap.second) {

  0028a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0028d	89 85 48 ff ff
	ff		 mov	 DWORD PTR _<begin>$L2$1$[ebp], eax
  00293	3b 85 30 ff ff
	ff		 cmp	 eax, DWORD PTR _<end>$L2$1$[ebp]
  00299	0f 85 31 ff ff
	ff		 jne	 $LL10@Reconstruc
$LN5@Reconstruc:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  0029f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  002a2	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  002a6	74 1d		 je	 SHORT $LN126@Reconstruc

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  002a8	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  002ab	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  002af	75 10		 jne	 SHORT $LN125@Reconstruc
$LL124@Reconstruc:
  002b1	3b 78 08	 cmp	 edi, DWORD PTR [eax+8]
  002b4	75 0b		 jne	 SHORT $LN125@Reconstruc

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  002b6	8b f8		 mov	 edi, eax
  002b8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002bb	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  002bf	74 f0		 je	 SHORT $LL124@Reconstruc
$LN125@Reconstruc:

; 56   :             }
; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())

  002c1	8b f8		 mov	 edi, eax

; 59   :         } else {

  002c3	eb 17		 jmp	 SHORT $LN256@Reconstruc
$LN126@Reconstruc:

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  002c5	8b f8		 mov	 edi, eax

; 451  :         while (!_Pnode->_Left->_Isnil) {

  002c7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002c9	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  002cd	75 0d		 jne	 SHORT $LN256@Reconstruc
  002cf	90		 npad	 1
$LL130@Reconstruc:
  002d0	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  002d2	8b f9		 mov	 edi, ecx
  002d4	8b c8		 mov	 ecx, eax
  002d6	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  002da	74 f4		 je	 SHORT $LL130@Reconstruc
$LN256@Reconstruc:

; 111  :         return !_Ptr->_Isnil;

  002dc	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 29   :     for (const auto& importsMap : m_Segment.GetHeader().GetImports ()) {

  002e0	0f 84 ca fe ff
	ff		 je	 $LL127@Reconstruc
$LN274@Reconstruc:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1189 :         _Scary->_Erase_head(_Getal());

  002e6	8d 45 e8	 lea	 eax, DWORD PTR _$S2$26[ebp]
  002e9	50		 push	 eax
  002ea	8b c8		 mov	 ecx, eax
  002ec	e8 00 00 00 00	 call	 ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 77   : }

  002f1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002fb	59		 pop	 ecx
  002fc	5f		 pop	 edi
  002fd	5e		 pop	 esi
  002fe	5b		 pop	 ebx
  002ff	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00302	33 cd		 xor	 ecx, ebp
  00304	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00309	8b e5		 mov	 esp, ebp
  0030b	5d		 pop	 ebp
  0030c	c3		 ret	 0
$LN248@Reconstruc:

; 39   :                 //Just error. Message, value, etc.
; 40   :                 std::ostringstream message;

  0030d	51		 push	 ecx
  0030e	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _message$24[ebp]
  00314	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
  00319	51		 push	 ecx
  0031a	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _message$24[ebp]
  00320	e8 00 00 00 00	 call	 ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >

; 41   :                 message << "Can`t find module or function. " << "Module: " << importsMap.first << " <|> " << "Function: " << importInfo.function;

  00325	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CA@LNJEDMFL@Can?$GAt?5find?5module?5or?5function?4?5@
  0032a	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0032e	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _message$24[ebp]
  00334	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00339	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08PHLEJAAL@Module?3?5@
  0033e	8b c8		 mov	 ecx, eax
  00340	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00345	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00348	8b c8		 mov	 ecx, eax
  0034a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0034f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05LHNIPNPB@?5?$DM?$HM?$DO?5@
  00354	8b c8		 mov	 ecx, eax
  00356	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0035b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0L@DLBPKAOP@Function?3?5@
  00360	8b c8		 mov	 ecx, eax
  00362	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00367	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _<begin>$L2$1$[ebp]
  0036d	8b c8		 mov	 ecx, eax
  0036f	8b 12		 mov	 edx, DWORD PTR [edx]
  00371	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 42   :                 PanicUtils::Release (PanicUtils::Layers::INIT, message.str().c_str());

  00376	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  0037c	50		 push	 eax
  0037d	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _message$24[ebp]
  00383	e8 00 00 00 00	 call	 ?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
  00388	8b c8		 mov	 ecx, eax
  0038a	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0038e	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00393	8b d0		 mov	 edx, eax
  00395	33 c9		 xor	 ecx, ecx
  00397	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN276@Reconstruc:

; 60   : 
; 61   :                     default:
; 62   :                         //Just error. Message, value, etc.
; 63   :                         std::ostringstream message;

  0039c	51		 push	 ecx
  0039d	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _message$23[ebp]
  003a3	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
  003a8	51		 push	 ecx
  003a9	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _message$23[ebp]
  003af	e8 00 00 00 00	 call	 ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >

; 64   :                         message << "Can't find offset type. Offset: " << parsedOffset.second << " <-> " << "Function: " << importInfo.function;

  003b4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0CB@FHNJEIA@Can?8t?5find?5offset?5type?4?5Offset?3@
  003b9	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  003bd	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _message$23[ebp]
  003c3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003c8	ff 76 14	 push	 DWORD PTR [esi+20]
  003cb	8b c8		 mov	 ecx, eax
  003cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
  003d3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05MEGJJFDG@?5?$DM?9?$DO?5@
  003d8	8b c8		 mov	 ecx, eax
  003da	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003df	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0L@DLBPKAOP@Function?3?5@
  003e4	8b c8		 mov	 ecx, eax
  003e6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003eb	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _<begin>$L2$1$[ebp]
  003f1	8b c8		 mov	 ecx, eax
  003f3	8b 12		 mov	 edx, DWORD PTR [edx]
  003f5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 65   :                         PanicUtils::Release (PanicUtils::Layers::ROUTINE, message.str().c_str());

  003fa	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  00400	50		 push	 eax
  00401	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _message$23[ebp]
  00407	e8 00 00 00 00	 call	 ?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
  0040c	8b c8		 mov	 ecx, eax
  0040e	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00412	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00417	8b d0		 mov	 edx, eax
  00419	b9 01 00 00 00	 mov	 ecx, 1
  0041e	e8 00 00 00 00	 call	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN282@Reconstruc:
  00423	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$9:
  00000	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$0:
  0000b	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1SegmentHeader@@QAE@XZ
__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$13:
  00016	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$2:
  00021	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1SegmentHeader@@QAE@XZ
__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$3:
  0002c	8d 4d e8	 lea	 ecx, DWORD PTR _$S2$26[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$4:
  00034	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _message$24[ebp]
  0003a	e9 00 00 00 00	 jmp	 ??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$5:
  0003f	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$6:
  0004a	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _message$23[ebp]
  00050	e9 00 00 00 00	 jmp	 ??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ$7:
  00055	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00060	cc		 int	 3
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
__ehhandler$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ:
  00065	90		 npad	 1
  00066	90		 npad	 1
  00067	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0006b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0006e	8b 8a 14 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-236]
  00074	33 c8		 xor	 ecx, eax
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0007e	33 c8		 xor	 ecx, eax
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ReconstructHotPoints@RuntimeHandler@@QAEXXZ
  0008a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ReconstructHotPoints@RuntimeHandler@@QAEXXZ ENDP	; RuntimeHandler::ReconstructHotPoints
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	c2 04 00	 ret	 4
?__autoclassinit2@?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 489  :     virtual ~basic_ostringstream() noexcept {}

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8d 71 50	 lea	 esi, DWORD PTR [ecx+80]
  00006	8d 4e b4	 lea	 ecx, DWORD PTR [esi-76]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 b0 00
	00 00 00	 mov	 DWORD PTR [eax+esi-80], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00014	8b 46 b0	 mov	 eax, DWORD PTR [esi-80]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 b0	 lea	 eax, DWORD PTR [edx-80]
  0001d	89 44 32 ac	 mov	 DWORD PTR [edx+esi-84], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00026	8d 4e b8	 lea	 ecx, DWORD PTR [esi-72]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  0002f	8b ce		 mov	 ecx, esi
  00031	5e		 pop	 esi
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	68 98 00 00 00	 push	 152			; 00000098H
  00005	6a 00		 push	 0
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memset
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00010	c2 04 00	 ret	 4
?__autoclassinit2@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	c2 04 00	 ret	 4
?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
;	COMDAT ?InvokeOEP@RuntimeHandler@@QAEXXZ
_TEXT	SEGMENT
?InvokeOEP@RuntimeHandler@@QAEXXZ PROC			; RuntimeHandler::InvokeOEP, COMDAT
; _this$dead$ = ecx
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?UnsafeAllocatedPointer@Segment@@2KA ; Segment::UnsafeAllocatedPointer
  00005	85 c0		 test	 eax, eax
  00007	75 0d		 jne	 SHORT $LN6@InvokeOEP

; 14   :         PanicUtils::Release (layer, reason);

  00009	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BM@FGCKGLBN@Allocation?5pointer?5is?5null?4@
  0000e	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00011	e9 00 00 00 00	 jmp	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN6@InvokeOEP:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 81   :     SegmentHeader::DLLMAIN_CALLBACK DllMain = reinterpret_cast <SegmentHeader::DLLMAIN_CALLBACK> (Segment::GetSafeAllocationPointer() + SegmentHeader::Datacase::OEP);

  00016	8d 88 8c 73 04
	00		 lea	 ecx, DWORD PTR [eax+291724]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\utils\PanicUtils.cpp

; 13   :     if (!value) {

  0001c	85 c9		 test	 ecx, ecx
  0001e	75 0a		 jne	 SHORT $LN11@InvokeOEP

; 14   :         PanicUtils::Release (layer, reason);

  00020	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@MFGAJMC@OEP?5value?5is?5null@
  00025	e9 00 00 00 00	 jmp	 ?Release@PanicUtils@@SAXW4Layers@1@PBD@Z ; PanicUtils::Release
$LN11@InvokeOEP:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

; 85   :     DllMain (reinterpret_cast<HMODULE> (Segment::GetSafeAllocationPointer()), DLL_PROCESS_ATTACH, NULL);

  0002a	6a 00		 push	 0
  0002c	6a 01		 push	 1
  0002e	50		 push	 eax
  0002f	ff d1		 call	 ecx

; 86   : }

  00031	c3		 ret	 0
?InvokeOEP@RuntimeHandler@@QAEXXZ ENDP			; RuntimeHandler::InvokeOEP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::operator!=, COMDAT
; _this$ = ecx

; 111  :         return !_Ptr->_Isnil;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00006	0f 94 c0	 sete	 al

; 112  :     }

  00009	c2 04 00	 ret	 4
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 51   :     _Tree_unchecked_const_iterator& operator++() {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00004	8b 16		 mov	 edx, DWORD PTR [esi]
  00006	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  00009	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0000d	74 22		 je	 SHORT $LN4@operator

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0000f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00012	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00016	75 12		 jne	 SHORT $LN19@operator
$LL2@operator:
  00018	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0001b	75 0d		 jne	 SHORT $LN19@operator

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	8b d0		 mov	 edx, eax
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 ee		 je	 SHORT $LL2@operator
$LN19@operator:

; 56   :             }
; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())
; 59   :         } else {
; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 61   :         }
; 62   : 
; 63   :         return *this;

  0002a	89 06		 mov	 DWORD PTR [esi], eax

; 64   :     }

  0002c	8b c6		 mov	 eax, esi
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	c3		 ret	 0
$LN4@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00031	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00033	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00037	75 13		 jne	 SHORT $LN9@operator
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL8@operator:
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00042	8b f9		 mov	 edi, ecx
  00044	8b c8		 mov	 ecx, eax
  00046	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004a	74 f4		 je	 SHORT $LL8@operator
$LN9@operator:

; 56   :             }
; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())
; 59   :         } else {
; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 61   :         }
; 62   : 
; 63   :         return *this;

  0004c	89 3e		 mov	 DWORD PTR [esi], edi

; 64   :     }

  0004e	8b c6		 mov	 eax, esi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@XZ
_TEXT	SEGMENT
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = ecx

; 44   :         return _Ptr->_Myval;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 45   :     }

  00005	c3		 ret	 0
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__Seeklow$1$ = -24					; size = 4
__Off$2$ = -20						; size = 4
__Gptr_old$1$ = -16					; size = 4
tv257 = -12						; size = 4
tv231 = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT
; _this$ = ecx

; 264  :     virtual pos_type seekpos(pos_type _Pos, ios_base::openmode _Mode = ios_base::in | ios_base::out) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 70   :         return _Myoff + _Fpos;

  00009	8b 45 10	 mov	 eax, DWORD PTR __Pos$[ebp+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 264  :     virtual pos_type seekpos(pos_type _Pos, ios_base::openmode _Mode = ios_base::in | ios_base::out) {

  0000c	53		 push	 ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 70   :         return _Myoff + _Fpos;

  0000d	8b 5d 0c	 mov	 ebx, DWORD PTR __Pos$[ebp]
  00010	03 5d 14	 add	 ebx, DWORD PTR __Pos$[ebp+8]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 264  :     virtual pos_type seekpos(pos_type _Pos, ios_base::openmode _Mode = ios_base::in | ios_base::out) {

  00013	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 70   :         return _Myoff + _Fpos;

  00014	13 45 18	 adc	 eax, DWORD PTR __Pos$[ebp+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 264  :     virtual pos_type seekpos(pos_type _Pos, ios_base::openmode _Mode = ios_base::in | ios_base::out) {

  00017	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	57		 push	 edi
  0001b	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 70   :         return _Myoff + _Fpos;

  0001d	89 44 24 14	 mov	 DWORD PTR __Off$2$[esp+40], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  00021	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	89 44 24 18	 mov	 DWORD PTR __Gptr_old$1$[esp+40], eax

; 195  :         return *_IPnext;

  0002a	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 269  :         if (_Pptr_old && _Seekhigh < _Pptr_old) { // update high-water pointer

  0002f	85 c9		 test	 ecx, ecx
  00031	74 08		 je	 SHORT $LN2@seekpos
  00033	39 4f 38	 cmp	 DWORD PTR [edi+56], ecx
  00036	73 03		 jae	 SHORT $LN2@seekpos

; 270  :             _Seekhigh = _Pptr_old;

  00038	89 4f 38	 mov	 DWORD PTR [edi+56], ecx
$LN2@seekpos:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  0003b	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0003e	8b 10		 mov	 edx, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 274  :         const auto _Seekdist = _Seekhigh - _Seeklow;

  00040	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00043	89 44 24 20	 mov	 DWORD PTR tv231[esp+40], eax
  00047	2b c2		 sub	 eax, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00049	89 54 24 10	 mov	 DWORD PTR __Seeklow$1$[esp+40], edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 275  :         if (static_cast<unsigned long long>(_Off) > static_cast<unsigned long long>(_Seekdist)) {

  0004d	99		 cdq
  0004e	39 54 24 14	 cmp	 DWORD PTR __Off$2$[esp+40], edx
  00052	0f 87 80 00 00
	00		 ja	 $LN5@seekpos
  00058	72 04		 jb	 SHORT $LN30@seekpos
  0005a	3b d8		 cmp	 ebx, eax
  0005c	77 7a		 ja	 SHORT $LN5@seekpos
$LN30@seekpos:

; 276  :             return pos_type(off_type(-1));
; 277  :         }
; 278  : 
; 279  :         if (_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old))) {

  0005e	8b 55 24	 mov	 edx, DWORD PTR __Mode$[ebp]
  00061	8b c3		 mov	 eax, ebx
  00063	0b 44 24 14	 or	 eax, DWORD PTR __Off$2$[esp+40]
  00067	74 15		 je	 SHORT $LN4@seekpos
  00069	f6 c2 01	 test	 dl, 1
  0006c	74 07		 je	 SHORT $LN6@seekpos
  0006e	83 7c 24 18 00	 cmp	 DWORD PTR __Gptr_old$1$[esp+40], 0
  00073	74 63		 je	 SHORT $LN5@seekpos
$LN6@seekpos:
  00075	f6 c2 02	 test	 dl, 2
  00078	74 04		 je	 SHORT $LN4@seekpos
  0007a	85 c9		 test	 ecx, ecx
  0007c	74 5a		 je	 SHORT $LN5@seekpos
$LN4@seekpos:

; 280  :             return pos_type(off_type(-1));
; 281  :         }
; 282  : 
; 283  :         const auto _Newptr = _Seeklow + _Off; // may perform nullptr + 0

  0007e	8b 44 24 10	 mov	 eax, DWORD PTR __Seeklow$1$[esp+40]
  00082	03 c3		 add	 eax, ebx

; 284  :         if ((_Mode & ios_base::in) && _Gptr_old) {

  00084	f6 c2 01	 test	 dl, 1
  00087	74 1a		 je	 SHORT $LN7@seekpos
  00089	83 7c 24 18 00	 cmp	 DWORD PTR __Gptr_old$1$[esp+40], 0
  0008e	74 13		 je	 SHORT $LN7@seekpos
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 209  :         *_IGnext  = _Next;

  00090	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  00093	89 02		 mov	 DWORD PTR [edx], eax

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00095	8b 54 24 20	 mov	 edx, DWORD PTR tv231[esp+40]
  00099	2b d0		 sub	 edx, eax
  0009b	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0009e	89 10		 mov	 DWORD PTR [eax], edx
  000a0	8b 55 24	 mov	 edx, DWORD PTR __Mode$[ebp]
$LN7@seekpos:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 288  :         if ((_Mode & ios_base::out) && _Pptr_old) {

  000a3	f6 c2 02	 test	 dl, 2
  000a6	74 25		 je	 SHORT $LN8@seekpos
  000a8	85 c9		 test	 ecx, ecx
  000aa	74 21		 je	 SHORT $LN8@seekpos
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 214  :         return *_IPnext + *_IPcount;

  000ac	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000af	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  000b2	8b 10		 mov	 edx, DWORD PTR [eax]

; 249  :         *_IPfirst = _First;

  000b4	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 214  :         return *_IPnext + *_IPcount;

  000b7	03 11		 add	 edx, DWORD PTR [ecx]

; 249  :         *_IPfirst = _First;

  000b9	8b 4c 24 10	 mov	 ecx, DWORD PTR __Seeklow$1$[esp+40]
  000bd	89 08		 mov	 DWORD PTR [eax], ecx

; 250  :         *_IPnext  = _Next;

  000bf	03 cb		 add	 ecx, ebx
  000c1	8b 47 20	 mov	 eax, DWORD PTR [edi+32]

; 251  :         *_IPcount = static_cast<int>(_Last - _Next);

  000c4	2b d1		 sub	 edx, ecx
  000c6	89 08		 mov	 DWORD PTR [eax], ecx
  000c8	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000cb	89 10		 mov	 DWORD PTR [eax], edx
$LN8@seekpos:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  000cd	8b 44 24 14	 mov	 eax, DWORD PTR __Off$2$[esp+40]
  000d1	89 1e		 mov	 DWORD PTR [esi], ebx
  000d3	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 292  :         return pos_type(_Off);

  000d6	eb 0d		 jmp	 SHORT $LN31@seekpos
$LN5@seekpos:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  000d8	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
  000de	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1
$LN31@seekpos:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 293  :     }

  000e5	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  000ec	0f 57 c0	 xorps	 xmm0, xmm0
  000ef	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  000f6	8b c6		 mov	 eax, esi
  000f8	5f		 pop	 edi
  000f9	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
__Gptr_old$1$ = -28					; size = 4
__Off$2$ = -24						; size = 4
__Newoff$ = -24						; size = 8
__Newptr$1$ = -16					; size = 4
__Seekdist$1$ = -16					; size = 4
__Seeklow$1$ = -12					; size = 4
tv229 = -8						; size = 4
tv188 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
__Mode$ = 24						; size = 4
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT
; _this$ = ecx

; 205  :         off_type _Off, ios_base::seekdir _Way, ios_base::openmode _Mode = ios_base::in | ios_base::out) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  0000e	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00011	8b 38		 mov	 edi, DWORD PTR [eax]

; 195  :         return *_IPnext;

  00013	8b 46 20	 mov	 eax, DWORD PTR [esi+32]

; 187  :         return *_IGnext;

  00016	89 7c 24 0c	 mov	 DWORD PTR __Gptr_old$1$[esp+40], edi

; 195  :         return *_IPnext;

  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 209  :         if (_Pptr_old && _Seekhigh < _Pptr_old) { // update high-water pointer

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 08		 je	 SHORT $LN4@seekoff
  00020	39 4e 38	 cmp	 DWORD PTR [esi+56], ecx
  00023	73 03		 jae	 SHORT $LN4@seekoff

; 210  :             _Seekhigh = _Pptr_old;

  00025	89 4e 38	 mov	 DWORD PTR [esi+56], ecx
$LN4@seekoff:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00028	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 216  :         switch (_Way) {

  0002b	8b 5d 18	 mov	 ebx, DWORD PTR __Mode$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 214  :         const auto _Seekdist = _Seekhigh - _Seeklow;

  00030	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00033	89 44 24 24	 mov	 DWORD PTR tv188[esp+40], eax
  00037	2b c2		 sub	 eax, edx
  00039	89 44 24 18	 mov	 DWORD PTR __Seekdist$1$[esp+40], eax

; 216  :         switch (_Way) {

  0003d	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00040	89 54 24 1c	 mov	 DWORD PTR __Seeklow$1$[esp+40], edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 216  :         switch (_Way) {

  00044	83 e8 00	 sub	 eax, 0
  00047	74 62		 je	 SHORT $LN5@seekoff
  00049	83 e8 01	 sub	 eax, 1
  0004c	74 14		 je	 SHORT $LN7@seekoff
  0004e	83 e8 01	 sub	 eax, 1
  00051	0f 85 ff 00 00
	00		 jne	 $LN18@seekoff

; 219  :             break;
; 220  :         case ios_base::end:
; 221  :             _Newoff = _Seekdist;

  00057	8b 44 24 18	 mov	 eax, DWORD PTR __Seekdist$1$[esp+40]
  0005b	99		 cdq
  0005c	8b f8		 mov	 edi, eax
  0005e	8b c2		 mov	 eax, edx

; 222  :             break;

  00060	eb 5a		 jmp	 SHORT $LN2@seekoff
$LN7@seekoff:

; 223  :         case ios_base::cur: {
; 224  :             constexpr auto _Both = ios_base::in | ios_base::out;
; 225  :             if ((_Mode & _Both) != _Both) { // prohibited by N4727 [stringbuf.virtuals] Table 107 "seekoff positioning"

  00062	8b c3		 mov	 eax, ebx
  00064	83 e0 03	 and	 eax, 3
  00067	3c 03		 cmp	 al, 3
  00069	0f 84 e7 00 00
	00		 je	 $LN18@seekoff

; 226  :                 if (_Mode & ios_base::in) {

  0006f	f6 c3 01	 test	 bl, 1
  00072	74 17		 je	 SHORT $LN9@seekoff

; 227  :                     if (_Gptr_old || !_Seeklow) {

  00074	85 ff		 test	 edi, edi
  00076	75 08		 jne	 SHORT $LN12@seekoff
  00078	85 d2		 test	 edx, edx
  0007a	0f 85 d6 00 00
	00		 jne	 $LN18@seekoff
$LN12@seekoff:

; 228  :                         _Newoff = _Gptr_old - _Seeklow;

  00080	8b c7		 mov	 eax, edi
  00082	2b c2		 sub	 eax, edx
  00084	99		 cdq
  00085	8b f8		 mov	 edi, eax
  00087	8b c2		 mov	 eax, edx

; 229  :                         break;

  00089	eb 31		 jmp	 SHORT $LN2@seekoff
$LN9@seekoff:

; 230  :                     }
; 231  :                 } else if ((_Mode & ios_base::out) && (_Pptr_old || !_Seeklow)) {

  0008b	f6 c3 02	 test	 bl, 2
  0008e	0f 84 c2 00 00
	00		 je	 $LN18@seekoff
  00094	85 c9		 test	 ecx, ecx
  00096	75 08		 jne	 SHORT $LN14@seekoff
  00098	85 d2		 test	 edx, edx
  0009a	0f 85 b6 00 00
	00		 jne	 $LN18@seekoff
$LN14@seekoff:

; 232  :                     _Newoff = _Pptr_old - _Seeklow;

  000a0	8b c1		 mov	 eax, ecx
  000a2	2b c2		 sub	 eax, edx
  000a4	99		 cdq
  000a5	8b f8		 mov	 edi, eax
  000a7	8b c2		 mov	 eax, edx

; 233  :                     break;

  000a9	eb 11		 jmp	 SHORT $LN2@seekoff
$LN5@seekoff:
  000ab	0f 57 c0	 xorps	 xmm0, xmm0

; 217  :         case ios_base::beg:
; 218  :             _Newoff = 0;

  000ae	66 0f 13 44 24
	10		 movlpd	 QWORD PTR __Newoff$[esp+40], xmm0
  000b4	8b 44 24 14	 mov	 eax, DWORD PTR __Newoff$[esp+44]
  000b8	8b 7c 24 10	 mov	 edi, DWORD PTR __Newoff$[esp+40]
$LN2@seekoff:

; 234  :                 }
; 235  :             }
; 236  :         }
; 237  : 
; 238  :             // fallthrough
; 239  :         default:
; 240  :             return pos_type(off_type(-1));
; 241  :         }
; 242  : 
; 243  :         if (static_cast<unsigned long long>(_Off) + _Newoff > static_cast<unsigned long long>(_Seekdist)) {

  000bc	03 7d 0c	 add	 edi, DWORD PTR __Off$[ebp]
  000bf	13 45 10	 adc	 eax, DWORD PTR __Off$[ebp+4]
  000c2	89 44 24 10	 mov	 DWORD PTR __Off$2$[esp+40], eax
  000c6	8b 44 24 18	 mov	 eax, DWORD PTR __Seekdist$1$[esp+40]
  000ca	99		 cdq
  000cb	39 54 24 10	 cmp	 DWORD PTR __Off$2$[esp+40], edx
  000cf	0f 87 81 00 00
	00		 ja	 $LN18@seekoff
  000d5	72 04		 jb	 SHORT $LN43@seekoff
  000d7	3b f8		 cmp	 edi, eax
  000d9	77 7b		 ja	 SHORT $LN18@seekoff
$LN43@seekoff:

; 244  :             return pos_type(off_type(-1));
; 245  :         }
; 246  : 
; 247  :         _Off += _Newoff;
; 248  :         if (_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old))) {

  000db	8b 54 24 0c	 mov	 edx, DWORD PTR __Gptr_old$1$[esp+40]
  000df	8b c7		 mov	 eax, edi
  000e1	0b 44 24 10	 or	 eax, DWORD PTR __Off$2$[esp+40]
  000e5	74 12		 je	 SHORT $LN17@seekoff
  000e7	f6 c3 01	 test	 bl, 1
  000ea	74 04		 je	 SHORT $LN19@seekoff
  000ec	85 d2		 test	 edx, edx
  000ee	74 66		 je	 SHORT $LN18@seekoff
$LN19@seekoff:
  000f0	f6 c3 02	 test	 bl, 2
  000f3	74 04		 je	 SHORT $LN17@seekoff
  000f5	85 c9		 test	 ecx, ecx
  000f7	74 5d		 je	 SHORT $LN18@seekoff
$LN17@seekoff:

; 249  :             return pos_type(off_type(-1));
; 250  :         }
; 251  : 
; 252  :         const auto _Newptr = _Seeklow + _Off; // may perform nullptr + 0

  000f9	8b 44 24 1c	 mov	 eax, DWORD PTR __Seeklow$1$[esp+40]
  000fd	03 c7		 add	 eax, edi
  000ff	89 44 24 18	 mov	 DWORD PTR __Newptr$1$[esp+40], eax

; 253  :         if ((_Mode & ios_base::in) && _Gptr_old) {

  00103	f6 c3 01	 test	 bl, 1
  00106	74 14		 je	 SHORT $LN20@seekoff
  00108	85 d2		 test	 edx, edx
  0010a	74 10		 je	 SHORT $LN20@seekoff
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 209  :         *_IGnext  = _Next;

  0010c	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  0010f	89 02		 mov	 DWORD PTR [edx], eax

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00111	8b 54 24 24	 mov	 edx, DWORD PTR tv188[esp+40]
  00115	2b d0		 sub	 edx, eax
  00117	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0011a	89 10		 mov	 DWORD PTR [eax], edx
$LN20@seekoff:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 257  :         if ((_Mode & ios_base::out) && _Pptr_old) {

  0011c	f6 c3 02	 test	 bl, 2
  0011f	74 27		 je	 SHORT $LN21@seekoff
  00121	85 c9		 test	 ecx, ecx
  00123	74 23		 je	 SHORT $LN21@seekoff
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 214  :         return *_IPnext + *_IPcount;

  00125	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00128	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0012b	8b 10		 mov	 edx, DWORD PTR [eax]

; 249  :         *_IPfirst = _First;

  0012d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 214  :         return *_IPnext + *_IPcount;

  00130	03 11		 add	 edx, DWORD PTR [ecx]

; 249  :         *_IPfirst = _First;

  00132	8b 4c 24 1c	 mov	 ecx, DWORD PTR __Seeklow$1$[esp+40]
  00136	89 08		 mov	 DWORD PTR [eax], ecx

; 250  :         *_IPnext  = _Next;

  00138	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0013b	8b 4c 24 18	 mov	 ecx, DWORD PTR __Newptr$1$[esp+40]

; 251  :         *_IPcount = static_cast<int>(_Last - _Next);

  0013f	2b d1		 sub	 edx, ecx
  00141	89 08		 mov	 DWORD PTR [eax], ecx
  00143	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00146	89 10		 mov	 DWORD PTR [eax], edx
$LN21@seekoff:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  00148	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014b	8b 4c 24 10	 mov	 ecx, DWORD PTR __Off$2$[esp+40]
  0014f	89 38		 mov	 DWORD PTR [eax], edi
  00151	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 261  :         return pos_type(_Off);

  00154	eb 10		 jmp	 SHORT $LN46@seekoff
$LN18@seekoff:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  00156	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00159	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0015f	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
$LN46@seekoff:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 262  :     }

  00166	5f		 pop	 edi
  00167	0f 57 c0	 xorps	 xmm0, xmm0
  0016a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00171	5e		 pop	 esi
  00172	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00179	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT
; _this$ = ecx

; 178  :     virtual int_type underflow() { // get an element from stream, but don't point past it

  00000	56		 push	 esi
  00001	57		 push	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  00002	8b 79 1c	 mov	 edi, DWORD PTR [ecx+28]
  00005	8b 17		 mov	 edx, DWORD PTR [edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 180  :         if (!_Gptr) { // no character buffer, fail

  00007	85 d2		 test	 edx, edx
  00009	74 45		 je	 SHORT $LN5@underflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

  0000b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 184  :         if (_Gptr < _Mysb::egptr()) {

  00012	3b d0		 cmp	 edx, eax
  00014	73 06		 jae	 SHORT $LN3@underflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

  00016	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00019	5f		 pop	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 202  :     }

  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
$LN3@underflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 195  :         return *_IPnext;

  0001c	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 189  :         const auto _Pptr = _Mysb::pptr();

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	85 c0		 test	 eax, eax

; 190  :         if (!_Pptr || (_Mystate & _Noread)) { // no put area or read disallowed

  00023	74 2b		 je	 SHORT $LN5@underflow
  00025	f6 41 3c 04	 test	 BYTE PTR [ecx+60], 4
  00029	75 25		 jne	 SHORT $LN5@underflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  0002b	8b 71 38	 mov	 esi, DWORD PTR [ecx+56]
  0002e	3b f0		 cmp	 esi, eax
  00030	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 195  :         if (_Local_highwater <= _Gptr) { // nothing in the put area to take

  00033	3b f2		 cmp	 esi, edx
  00035	76 19		 jbe	 SHORT $LN5@underflow

; 196  :             return _Traits::eof();
; 197  :         }
; 198  : 
; 199  :         _Seekhigh = _Local_highwater;

  00037	89 71 38	 mov	 DWORD PTR [ecx+56], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  0003a	8b 07		 mov	 eax, DWORD PTR [edi]

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  0003c	2b f0		 sub	 esi, eax
  0003e	89 07		 mov	 DWORD PTR [edi], eax
  00040	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00043	5f		 pop	 edi
  00044	89 30		 mov	 DWORD PTR [eax], esi

; 187  :         return *_IGnext;

  00046	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 202  :     }

  00049	5e		 pop	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 393  :         return static_cast<unsigned char>(_Ch);

  0004c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 202  :     }

  0004f	c3		 ret	 0
$LN5@underflow:
  00050	5f		 pop	 edi

; 191  :             return _Traits::eof();

  00051	83 c8 ff	 or	 eax, -1

; 202  :     }

  00054	5e		 pop	 esi
  00055	c3		 ret	 0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT
; _this$ = ecx

; 161  :     virtual int_type pbackfail(int_type _Meta = _Traits::eof()) { // put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  00003	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 161  :     virtual int_type pbackfail(int_type _Meta = _Traits::eof()) { // put an element back to stream

  00006	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  00007	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 164  :             || (!_Traits::eq_int_type(_Traits::eof(), _Meta) && !_Traits::eq(_Traits::to_char_type(_Meta), _Gptr[-1])

  00009	85 f6		 test	 esi, esi
  0000b	74 3f		 je	 SHORT $LN3@pbackfail
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  0000d	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 164  :             || (!_Traits::eq_int_type(_Traits::eof(), _Meta) && !_Traits::eq(_Traits::to_char_type(_Meta), _Gptr[-1])

  00010	3b 30		 cmp	 esi, DWORD PTR [eax]
  00012	76 38		 jbe	 SHORT $LN3@pbackfail
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 397  :         return _Left == _Right;

  00014	8b 55 08	 mov	 edx, DWORD PTR __Meta$[ebp]
  00017	83 fa ff	 cmp	 edx, -1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 164  :             || (!_Traits::eq_int_type(_Traits::eof(), _Meta) && !_Traits::eq(_Traits::to_char_type(_Meta), _Gptr[-1])

  0001a	74 0b		 je	 SHORT $LN2@pbackfail
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 381  :         return _Left == _Right;

  0001c	3a 56 ff	 cmp	 dl, BYTE PTR [esi-1]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 164  :             || (!_Traits::eq_int_type(_Traits::eof(), _Meta) && !_Traits::eq(_Traits::to_char_type(_Meta), _Gptr[-1])

  0001f	74 06		 je	 SHORT $LN2@pbackfail
  00021	f6 41 3c 02	 test	 BYTE PTR [ecx+60], 2
  00025	75 25		 jne	 SHORT $LN3@pbackfail
$LN2@pbackfail:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 203  :         *_IGcount -= _Off;

  00027	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0002a	ff 00		 inc	 DWORD PTR [eax]

; 204  :         *_IGnext += _Off;

  0002c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0002f	ff 08		 dec	 DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 397  :         return _Left == _Right;

  00031	83 fa ff	 cmp	 edx, -1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 171  :         if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00034	74 07		 je	 SHORT $LN4@pbackfail
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  00036	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 172  :             *_Mysb::gptr() = _Traits::to_char_type(_Meta);

  0003b	88 11		 mov	 BYTE PTR [ecx], dl
$LN4@pbackfail:

; 173  :         }
; 174  : 
; 175  :         return _Traits::not_eof(_Meta);

  0003d	33 c0		 xor	 eax, eax
  0003f	83 fa ff	 cmp	 edx, -1
  00042	5e		 pop	 esi
  00043	0f 44 d0	 cmove	 edx, eax
  00046	8b c2		 mov	 eax, edx

; 176  :     }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN3@pbackfail:

; 165  :                 && (_Mystate & _Constant))) { // can't put back, fail
; 166  :             return _Traits::eof();

  0004c	83 c8 ff	 or	 eax, -1
  0004f	5e		 pop	 esi

; 176  :     }

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Back_shift$1$ = -8					; size = 4
__Newsize$1$ = -4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT
; _this$ = ecx

; 104  :     virtual int_type overflow(int_type _Meta = _Traits::eof()) { // put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 105  :         if (_Mystate & _Constant) {

  0000b	f6 47 3c 02	 test	 BYTE PTR [edi+60], 2
  0000f	0f 85 94 01 00
	00		 jne	 $LN10@overflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 397  :         return _Left == _Right;

  00015	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  00018	83 fb ff	 cmp	 ebx, -1
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 109  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  0001b	75 0b		 jne	 SHORT $LN3@overflow

; 159  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	33 c0		 xor	 eax, eax
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN3@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 195  :         return *_IPnext;

  00028	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0002b	8b 30		 mov	 esi, DWORD PTR [eax]

; 214  :         return *_IPnext + *_IPcount;

  0002d	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	03 ce		 add	 ecx, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 115  :         if (_Pptr && _Pptr < _Epptr) { // room in buffer, store it

  00034	85 f6		 test	 esi, esi
  00036	74 1f		 je	 SHORT $LN86@overflow
  00038	3b f1		 cmp	 esi, ecx
  0003a	73 1b		 jae	 SHORT $LN86@overflow

; 116  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  0003c	8b cf		 mov	 ecx, edi
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ

; 117  :             _Seekhigh        = _Pptr + 1;

  00044	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00047	88 18		 mov	 BYTE PTR [eax], bl

; 118  :             return _Meta;

  00049	8b c3		 mov	 eax, ebx
  0004b	89 4f 38	 mov	 DWORD PTR [edi+56], ecx
  0004e	5f		 pop	 edi

; 159  :     }

  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN86@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00057	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0005a	8b 18		 mov	 ebx, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 129  :         if (_Oldsize < _MINSIZE) {

  0005c	2b cb		 sub	 ecx, ebx
  0005e	f7 de		 neg	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00060	89 5d f8	 mov	 DWORD PTR __Back_shift$1$[ebp], ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 129  :         if (_Oldsize < _MINSIZE) {

  00063	1b f6		 sbb	 esi, esi
  00065	23 f1		 and	 esi, ecx
  00067	83 fe 20	 cmp	 esi, 32			; 00000020H
  0006a	73 15		 jae	 SHORT $LN6@overflow

; 130  :             _Newsize = _MINSIZE;

  0006c	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00071	50		 push	 eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 130  :             _Newsize = _MINSIZE;

  00072	89 45 fc	 mov	 DWORD PTR __Newsize$1$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00075	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007a	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  0007d	8b d8		 mov	 ebx, eax
  0007f	eb 6e		 jmp	 SHORT $LN32@overflow
$LN6@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 131  :         } else if (_Oldsize < INT_MAX / 2) { // grow by 50 percent

  00081	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  00087	73 34		 jae	 SHORT $LN8@overflow

; 132  :             _Newsize = _Oldsize << 1;

  00089	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  0008c	89 45 fc	 mov	 DWORD PTR __Newsize$1$[ebp], eax
  0008f	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00091	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00096	72 10		 jb	 SHORT $LN33@overflow

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  00098	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0009b	89 4d fc	 mov	 DWORD PTR __Newsize$1$[ebp], ecx

; 90   :     if (_Block_size <= _Bytes) {

  0009e	3b c1		 cmp	 eax, ecx
  000a0	0f 86 0f 01 00
	00		 jbe	 $LN90@overflow
  000a6	eb 2d		 jmp	 SHORT $LN43@overflow
$LN33@overflow:

; 179  :     if (_Bytes != 0) {

  000a8	85 c0		 test	 eax, eax
  000aa	74 0d		 je	 SHORT $LN34@overflow

; 51   :         return ::operator new(_Bytes);

  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b2	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  000b5	8b d8		 mov	 ebx, eax
  000b7	eb 36		 jmp	 SHORT $LN32@overflow
$LN34@overflow:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  000b9	33 db		 xor	 ebx, ebx
  000bb	eb 32		 jmp	 SHORT $LN32@overflow
$LN8@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 133  :         } else if (_Oldsize < INT_MAX) {

  000bd	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  000c3	0f 83 e0 00 00
	00		 jae	 $LN10@overflow

; 134  :             _Newsize = INT_MAX;

  000c9	c7 45 fc ff ff
	ff 7f		 mov	 DWORD PTR __Newsize$1$[ebp], 2147483647 ; 7fffffffH
  000d0	b8 22 00 00 80	 mov	 eax, -2147483614	; 80000022H
$LN43@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000db	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000de	85 c0		 test	 eax, eax
  000e0	0f 84 bd 00 00
	00		 je	 $LN75@overflow

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000e6	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000e9	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000ec	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
$LN32@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  000ef	56		 push	 esi
  000f0	ff 75 f8	 push	 DWORD PTR __Back_shift$1$[ebp]
  000f3	53		 push	 ebx
  000f4	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 142  :         const auto _New_pnext = _Newptr + _Oldsize;

  000f9	8d 14 1e	 lea	 edx, DWORD PTR [esi+ebx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 251  :         *_IPcount = static_cast<int>(_Last - _Next);

  000fc	8b cb		 mov	 ecx, ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 143  :         _Seekhigh             = _New_pnext + 1; // to include _Meta

  000fe	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 251  :         *_IPcount = static_cast<int>(_Last - _Next);

  00101	2b ca		 sub	 ecx, edx
  00103	03 4d fc	 add	 ecx, DWORD PTR __Newsize$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00106	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 143  :         _Seekhigh             = _New_pnext + 1; // to include _Meta

  00109	89 47 38	 mov	 DWORD PTR [edi+56], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 249  :         *_IPfirst = _First;

  0010c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0010f	89 18		 mov	 DWORD PTR [eax], ebx

; 250  :         *_IPnext  = _Next;

  00111	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00114	89 10		 mov	 DWORD PTR [eax], edx

; 251  :         *_IPcount = static_cast<int>(_Last - _Next);

  00116	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00119	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 146  :         if (_Mystate & _Noread) { // maintain eback() == allocated pointer invariant

  0011b	f6 47 3c 04	 test	 BYTE PTR [edi+60], 4
  0011f	74 15		 je	 SHORT $LN12@overflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 208  :         *_IGfirst = _First;

  00121	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00124	89 18		 mov	 DWORD PTR [eax], ebx

; 209  :         *_IGnext  = _Next;

  00126	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00129	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  0012f	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00132	89 18		 mov	 DWORD PTR [eax], ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 148  :         } else { // if readable, set the get area to initialized region

  00134	eb 1e		 jmp	 SHORT $LN13@overflow
$LN12@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  00136	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 149  :             _Mysb::setg(_Newptr, _Newptr + (_Mysb::gptr() - _Oldptr), _Seekhigh);

  00139	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  0013c	8b 08		 mov	 ecx, DWORD PTR [eax]

; 208  :         *_IGfirst = _First;

  0013e	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 187  :         return *_IGnext;

  00141	2b 4d f8	 sub	 ecx, DWORD PTR __Back_shift$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 149  :             _Mysb::setg(_Newptr, _Newptr + (_Mysb::gptr() - _Oldptr), _Seekhigh);

  00144	03 cb		 add	 ecx, ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00146	2b d1		 sub	 edx, ecx
  00148	89 18		 mov	 DWORD PTR [eax], ebx
  0014a	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0014d	89 08		 mov	 DWORD PTR [eax], ecx
  0014f	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00152	89 10		 mov	 DWORD PTR [eax], edx
$LN13@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 152  :         if (_Mystate & _Allocated) {

  00154	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00157	a8 01		 test	 al, 1
  00159	74 2a		 je	 SHORT $LN68@overflow
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0015b	8b 45 f8	 mov	 eax, DWORD PTR __Back_shift$1$[ebp]
  0015e	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00164	72 12		 jb	 SHORT $LN78@overflow

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00166	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00169	83 c6 23	 add	 esi, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0016c	2b c1		 sub	 eax, ecx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0016e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00171	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00174	77 2d		 ja	 SHORT $LN75@overflow

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00176	8b c1		 mov	 eax, ecx
$LN78@overflow:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00178	56		 push	 esi
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0017f	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00182	83 c4 08	 add	 esp, 8
$LN68@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 156  :         _Mystate |= _Allocated;

  00185	83 c8 01	 or	 eax, 1

; 157  :         *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00188	8b cf		 mov	 ecx, edi
  0018a	89 47 3c	 mov	 DWORD PTR [edi+60], eax
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
  00193	8b 4d 08	 mov	 ecx, DWORD PTR __Meta$[ebp]
  00196	5f		 pop	 edi

; 159  :     }

  00197	5e		 pop	 esi
  00198	88 08		 mov	 BYTE PTR [eax], cl
  0019a	8b c1		 mov	 eax, ecx
  0019c	5b		 pop	 ebx
  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c2 04 00	 ret	 4
$LN75@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN10@overflow:
  001a9	5f		 pop	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 159  :     }

  001aa	5e		 pop	 esi
  001ab	83 c8 ff	 or	 eax, -1
  001ae	5b		 pop	 ebx
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c2 04 00	 ret	 4
$LN90@overflow:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  001b5	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN88@overflow:
  001ba	cc		 int	 3
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 69   :     virtual ~basic_stringbuf() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 330  :         if (_Mystate & _Allocated) {

  00003	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1

; 69   :     virtual ~basic_stringbuf() noexcept {

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 330  :         if (_Mystate & _Allocated) {

  0000d	74 47		 je	 SHORT $LN23@basic_stri
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 195  :         return *_IPnext;

  0000f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 331  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	85 c9		 test	 ecx, ecx
  00016	74 09		 je	 SHORT $LN6@basic_stri
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 214  :         return *_IPnext + *_IPcount;

  00018	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	03 d1		 add	 edx, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 331  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

  0001f	eb 0a		 jmp	 SHORT $LN7@basic_stri
$LN6@basic_stri:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

  00021	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00024	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	03 11		 add	 edx, DWORD PTR [ecx]
$LN7@basic_stri:

; 183  :         return *_IGfirst;

  0002b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 331  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	2b d0		 sub	 edx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00032	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00038	72 12		 jb	 SHORT $LN33@basic_stri

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003a	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003d	83 c2 23	 add	 edx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00040	2b c1		 sub	 eax, ecx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00042	83 c0 fc	 add	 eax, -4			; fffffffcH
  00045	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00048	77 56		 ja	 SHORT $LN30@basic_stri

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004a	8b c1		 mov	 eax, ecx
$LN33@basic_stri:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0004c	52		 push	 edx
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00053	83 c4 08	 add	 esp, 8
$LN23@basic_stri:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 208  :         *_IGfirst = _First;

  00056	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 71   :     }

  00059	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 208  :         *_IGfirst = _First;

  0005b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  :         *_IGnext  = _Next;

  00061	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00064	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  0006a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0006d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 242  :         *_IPfirst = _First;

  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 243  :         *_IPnext  = _First;

  0007c	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0007f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 244  :         *_IPcount = static_cast<int>(_Last - _First);

  00085	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00088	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 339  :         _Mystate &= ~_Allocated;

  0008e	83 66 3c fe	 and	 DWORD PTR [esi+60], -2	; fffffffeH
  00092	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 71   :     }

  00099	5e		 pop	 esi
  0009a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN30@basic_stri:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN42@basic_stri:
  000a6	cc		 int	 3
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -20				; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 495  :     _NODISCARD _Mystr str() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	89 75 ec	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
  00030	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 496  :         return _Stringbuffer.str();

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4301 :         _Mypair._Myval2._Mysize = 0;

  0003e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00045	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0004c	c6 06 00	 mov	 BYTE PTR [esi], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 87   :         if (!(_Mystate & _Constant) && _Mysb::pptr()) { // writable, make string from write buffer

  0004f	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]

; 93   :         }
; 94   : 
; 95   :         return _Result;

  00052	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR $T1[ebp], 2
  00059	f6 c1 02	 test	 cl, 2
  0005c	75 1b		 jne	 SHORT $LN6@str
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 195  :         return *_IPnext;

  0005e	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 87   :         if (!(_Mystate & _Constant) && _Mysb::pptr()) { // writable, make string from write buffer

  00061	8b 18		 mov	 ebx, DWORD PTR [eax]
  00063	85 db		 test	 ebx, ebx
  00065	74 12		 je	 SHORT $LN6@str
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 191  :         return *_IPfirst;

  00067	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  0006a	3b 5f 3c	 cmp	 ebx, DWORD PTR [edi+60]
  0006d	0f 42 5f 3c	 cmovb	 ebx, DWORD PTR [edi+60]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 191  :         return *_IPfirst;

  00071	8b 10		 mov	 edx, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 89   :             _Result.assign(_Base, static_cast<_Mysize_type>(_Max_value(_Mysb::pptr(), _Seekhigh) - _Base));

  00073	2b da		 sub	 ebx, edx
  00075	53		 push	 ebx
  00076	52		 push	 edx
  00077	eb 1e		 jmp	 SHORT $LN38@str
$LN6@str:

; 90   :         } else if (!(_Mystate & _Noread) && _Mysb::gptr()) { // readable, make string from read buffer

  00079	f6 c1 04	 test	 cl, 4
  0007c	75 20		 jne	 SHORT $LN35@str
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  0007e	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 90   :         } else if (!(_Mystate & _Noread) && _Mysb::gptr()) { // readable, make string from read buffer

  00081	8b 10		 mov	 edx, DWORD PTR [eax]
  00083	85 d2		 test	 edx, edx
  00085	74 17		 je	 SHORT $LN35@str
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00087	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0008a	8b 08		 mov	 ecx, DWORD PTR [eax]

; 199  :         return *_IGnext + *_IGcount;

  0008c	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  0008f	8b 00		 mov	 eax, DWORD PTR [eax]
  00091	2b c1		 sub	 eax, ecx
  00093	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 92   :             _Result.assign(_Base, static_cast<_Mysize_type>(_Mysb::egptr() - _Base));

  00095	50		 push	 eax
  00096	51		 push	 ecx
$LN38@str:

; 497  :     }

  00097	8b ce		 mov	 ecx, esi
  00099	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN35@str:
  0009e	8b c6		 mov	 eax, esi
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000aa	59		 pop	 ecx
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$1:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 02	 and	 eax, 2
  00006	0f 84 0c 00 00
	00		 je	 $LN11@str
  0000c	83 65 f0 fd	 and	 DWORD PTR $T1[ebp], -3	; fffffffdH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN11@str:
  00018	c3		 ret	 0
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
__ehhandler$?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ:
  0001e	90		 npad	 1
  0001f	90		 npad	 1
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 489  :     virtual ~basic_ostringstream() noexcept {}

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 b0	 mov	 eax, DWORD PTR [esi-80]
  00006	8d 4e b4	 lea	 ecx, DWORD PTR [esi-76]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 b0 00
	00 00 00	 mov	 DWORD PTR [eax+esi-80], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00014	8b 46 b0	 mov	 eax, DWORD PTR [esi-80]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 b0	 lea	 eax, DWORD PTR [edx-80]
  0001d	89 44 32 ac	 mov	 DWORD PTR [edx+esi-84], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00026	8d 4e b8	 lea	 ecx, DWORD PTR [esi-72]
  00029	5e		 pop	 esi
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_$initVBases$dead$ = 8					; size = 4
??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 455  :     basic_ostringstream() : _Mybase(_STD addressof(_Stringbuffer)), _Stringbuffer(ios_base::out) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00033	8d 4f 50	 lea	 ecx, DWORD PTR [edi+80]
  00036	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	56		 push	 esi
  00051	8b cf		 mov	 ecx, edi
  00053	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00060	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00067	8b 07		 mov	 eax, DWORD PTR [edi]
  00069	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006c	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00073	8b 07		 mov	 eax, DWORD PTR [edi]
  00075	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00078	8d 41 b0	 lea	 eax, DWORD PTR [ecx-80]
  0007b	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax

; 34   :     explicit basic_stringbuf(ios_base::openmode _Mode) : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al() {}

  0007f	8b ce		 mov	 ecx, esi
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00087	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 455  :     basic_ostringstream() : _Mybase(_STD addressof(_Stringbuffer)), _Stringbuffer(ios_base::out) {}

  0008d	8b c7		 mov	 eax, edi

; 34   :     explicit basic_stringbuf(ios_base::openmode _Mode) : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al() {}

  0008f	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00096	c7 46 3c 04 00
	00 00		 mov	 DWORD PTR [esi+60], 4

; 455  :     basic_ostringstream() : _Mybase(_STD addressof(_Stringbuffer)), _Stringbuffer(ios_base::out) {}

  0009d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a7	59		 pop	 ecx
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 10 00 00
	00		 je	 $LN5@basic_ostr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 50	 add	 ecx, 80			; 00000050H
  00016	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_ostr:
  0001c	c3		 ret	 0
__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$1:
  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	83 c1 08	 add	 ecx, 8
  00023	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
  0002d	cc		 int	 3
__ehhandler$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  0002e	90		 npad	 1
  0002f	90		 npad	 1
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QBEPBUImportInfo@SegmentHeader@@XZ
_TEXT	SEGMENT
?_Unchecked_end@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QBEPBUImportInfo@SegmentHeader@@XZ PROC ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1474 :         return _Mypair._Myval2._Mylast;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1475 :     }

  00003	c3		 ret	 0
?_Unchecked_end@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QBEPBUImportInfo@SegmentHeader@@XZ ENDP ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QBEPBUImportInfo@SegmentHeader@@XZ
_TEXT	SEGMENT
?_Unchecked_begin@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QBEPBUImportInfo@SegmentHeader@@XZ PROC ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1466 :         return _Mypair._Myval2._Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1467 :     }

  00002	c3		 ret	 0
?_Unchecked_begin@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QBEPBUImportInfo@SegmentHeader@@XZ ENDP ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??E?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::operator++, COMDAT
; _this$ = ecx

; 140  :     _Tree_unchecked_iterator& operator++() {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00004	8b 16		 mov	 edx, DWORD PTR [esi]
  00006	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  00009	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0000d	74 22		 je	 SHORT $LN6@operator

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0000f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00012	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00016	75 12		 jne	 SHORT $LN21@operator
$LL4@operator:
  00018	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0001b	75 0d		 jne	 SHORT $LN21@operator

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	8b d0		 mov	 edx, eax
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 ee		 je	 SHORT $LL4@operator
$LN21@operator:

; 141  :         _Mybase::operator++();
; 142  :         return *this;

  0002a	89 06		 mov	 DWORD PTR [esi], eax

; 143  :     }

  0002c	8b c6		 mov	 eax, esi
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	c3		 ret	 0
$LN6@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00031	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00033	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00037	75 13		 jne	 SHORT $LN11@operator
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@operator:
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00042	8b f9		 mov	 edi, ecx
  00044	8b c8		 mov	 ecx, eax
  00046	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004a	74 f4		 je	 SHORT $LL10@operator
$LN11@operator:

; 141  :         _Mybase::operator++();
; 142  :         return *this;

  0004c	89 3e		 mov	 DWORD PTR [esi], edi

; 143  :     }

  0004e	8b c6		 mov	 eax, esi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	c3		 ret	 0
??E?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??D?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@XZ PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::operator*, COMDAT
; _this$ = ecx

; 44   :         return _Ptr->_Myval;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 133  :         return const_cast<reference>(_Mybase::operator*());
; 134  :     }

  00005	c3		 ret	 0
??D?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@XZ ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::operator!=, COMDAT
; _this$ = ecx

; 111  :         return !_Ptr->_Isnil;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00006	0f 94 c0	 sete	 al

; 112  :     }

  00009	c2 04 00	 ret	 4
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NU_Default_sentinel@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Unchecked_end@?$vector@KV?$allocator@K@std@@@std@@QAEPAKXZ
_TEXT	SEGMENT
?_Unchecked_end@?$vector@KV?$allocator@K@std@@@std@@QAEPAKXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1470 :         return _Mypair._Myval2._Mylast;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1471 :     }

  00003	c3		 ret	 0
?_Unchecked_end@?$vector@KV?$allocator@K@std@@@std@@QAEPAKXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@KV?$allocator@K@std@@@std@@QAEPAKXZ
_TEXT	SEGMENT
?_Unchecked_begin@?$vector@KV?$allocator@K@std@@@std@@QAEPAKXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1462 :         return _Mypair._Myval2._Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1463 :     }

  00002	c3		 ret	 0
?_Unchecked_begin@?$vector@KV?$allocator@K@std@@@std@@QAEPAKXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Rightfirst$1$ = -8					; size = 4
__Rightlast$1$ = -4					; size = 4
__Right$ = 8						; size = 4
??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 519  :     vector(const vector& _Right)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00013	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0001a	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 520  :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 521  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 522  :         auto& _My_data            = _Mypair._Myval2;
; 523  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00021	8b 18		 mov	 ebx, DWORD PTR [eax]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  00023	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00026	89 5d f8	 mov	 DWORD PTR __Rightfirst$1$[ebp], ebx

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  00029	3b d8		 cmp	 ebx, eax
  0002b	74 77		 je	 SHORT $LN49@vector

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  0002d	2b c3		 sub	 eax, ebx
  0002f	8b d8		 mov	 ebx, eax
  00031	89 45 fc	 mov	 DWORD PTR __Rightlast$1$[ebp], eax
  00034	c1 fb 02	 sar	 ebx, 2
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 34   :             if (_Count > _Max_possible) {

  00037	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  0003d	77 6f		 ja	 SHORT $LN70@vector

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  0003f	c1 e3 02	 shl	 ebx, 2
  00042	56		 push	 esi

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00043	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  00049	72 25		 jb	 SHORT $LN18@vector

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0004b	8d 43 23	 lea	 eax, DWORD PTR [ebx+35]

; 90   :     if (_Block_size <= _Bytes) {

  0004e	3b c3		 cmp	 eax, ebx
  00050	76 5c		 jbe	 SHORT $LN70@vector

; 51   :         return ::operator new(_Bytes);

  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00058	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0005b	85 c0		 test	 eax, eax
  0005d	74 0b		 je	 SHORT $LN27@vector

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0005f	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00062	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00065	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00068	eb 19		 jmp	 SHORT $LN17@vector
$LN27@vector:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@vector:

; 179  :     if (_Bytes != 0) {

  00070	85 db		 test	 ebx, ebx
  00072	74 0d		 je	 SHORT $LN19@vector

; 51   :         return ::operator new(_Bytes);

  00074	53		 push	 ebx
  00075	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007a	83 c4 04	 add	 esp, 4

; 180  :         return _Traits::_Allocate(_Bytes);

  0007d	8b f0		 mov	 esi, eax
  0007f	eb 02		 jmp	 SHORT $LN17@vector
$LN19@vector:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

  00081	33 f6		 xor	 esi, esi
$LN17@vector:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00083	ff 75 fc	 push	 DWORD PTR __Rightlast$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  00086	89 37		 mov	 DWORD PTR [edi], esi

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00088	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0008b	ff 75 f8	 push	 DWORD PTR __Rightfirst$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1644 :         _Mylast            = _Newvec;

  0008e	89 77 04	 mov	 DWORD PTR [edi+4], esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00091	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00092	89 47 08	 mov	 DWORD PTR [edi+8], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00095	e8 00 00 00 00	 call	 _memmove
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0009d	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000a0	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000a3	5e		 pop	 esi
$LN49@vector:

; 535  :     }

  000a4	8b c7		 mov	 eax, edi
  000a6	5f		 pop	 edi
  000a7	5b		 pop	 ebx
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 04 00	 ret	 4
$LN70@vector:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  000ae	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN71@vector:
  000b3	cc		 int	 3
??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
;	COMDAT ??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Sentinel$20 = -20					; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T16 = 8						; size = 1
__Right$ = 8						; size = 4
??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >, COMDAT
; _this$ = ecx

; 111  :     map(const map& _Right) : _Mybase(_Right, _Alnode_traits::select_on_container_copy_construction(_Right._Getal())) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0002c	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0002e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00034	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 766  :     _Tree_head_scoped_ptr(_Alnode& _Al_, _Scary_val& _Mycont_) : _Al(_Al_), _Mycont(_STD addressof(_Mycont_)) {

  0003b	89 7d ec	 mov	 DWORD PTR __Sentinel$20[ebp], edi
  0003e	89 7d f0	 mov	 DWORD PTR __Sentinel$20[ebp+4], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00041	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00046	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00049	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0004b	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0004e	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00051	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 767  :         _Mycont->_Myhead = _Alnode::value_type::_Buyheadnode(_Al);

  00057	89 07		 mov	 DWORD PTR [edi], eax

; 896  :         _Tree_head_scoped_ptr<_Alnode, _Scary_val> _Sentinel(_Getal(), *_Scary);

  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1731 :         _Scary->_Myhead->_Parent = _Copy_nodes(_Right_scary->_Myhead->_Parent, _Scary->_Myhead, _Movefl);

  00060	8b cf		 mov	 ecx, edi
  00062	ff 75 08	 push	 DWORD PTR $T16[ebp]
  00065	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00068	50		 push	 eax
  00069	8b 06		 mov	 eax, DWORD PTR [esi]
  0006b	ff 70 04	 push	 DWORD PTR [eax+4]
  0006e	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_tag>
  00073	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00075	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1732 :         _Scary->_Mysize          = _Right_scary->_Mysize;

  00078	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1733 :         if (!_Scary->_Myhead->_Parent->_Isnil) { // nonempty tree, look for new smallest and largest

  0007b	8b 37		 mov	 esi, DWORD PTR [edi]
  0007d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00080	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00083	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00087	75 37		 jne	 SHORT $LN44@map

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00089	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0008b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0008f	75 0c		 jne	 SHORT $LN49@map
$LL48@map:
  00091	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00093	8b d1		 mov	 edx, ecx
  00095	8b c8		 mov	 ecx, eax
  00097	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0009b	74 f4		 je	 SHORT $LL48@map
$LN49@map:

; 1734 :             _Scary->_Myhead->_Left  = _Scary_val::_Min(_Scary->_Myhead->_Parent);

  0009d	89 16		 mov	 DWORD PTR [esi], edx

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  0009f	8b 17		 mov	 edx, DWORD PTR [edi]
  000a1	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 443  :         while (!_Pnode->_Right->_Isnil) {

  000a4	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000a7	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000ab	75 0e		 jne	 SHORT $LN53@map
  000ad	0f 1f 00	 npad	 3
$LL52@map:

; 444  :             _Pnode = _Pnode->_Right;

  000b0	8b c8		 mov	 ecx, eax
  000b2	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000b5	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000b9	74 f5		 je	 SHORT $LL52@map
$LN53@map:

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  000bb	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1736 :         } else { // empty tree, just tidy head pointers

  000be	eb 07		 jmp	 SHORT $LN68@map
$LN44@map:

; 1737 :             _Scary->_Myhead->_Left  = _Scary->_Myhead;

  000c0	89 36		 mov	 DWORD PTR [esi], esi

; 1738 :             _Scary->_Myhead->_Right = _Scary->_Myhead;

  000c2	8b 07		 mov	 eax, DWORD PTR [edi]
  000c4	89 40 08	 mov	 DWORD PTR [eax+8], eax
$LN68@map:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map

; 111  :     map(const map& _Right) : _Mybase(_Right, _Alnode_traits::select_on_container_copy_construction(_Right._Getal())) {}

  000c7	8b c7		 mov	 eax, edi
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z$1:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Sentinel$20[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::~_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$map@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::map<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Unchecked_end@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU_Default_sentinel@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU_Default_sentinel@2@XZ PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Unchecked_end, COMDAT
; _this$dead$ = ecx

; 1264 :     _Default_sentinel _Unchecked_end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1265 :         return {};

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1266 :     }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Unchecked_end@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU_Default_sentinel@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1256 :     _Unchecked_iterator _Unchecked_begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1257 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1258 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::~_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >, COMDAT
; _this$ = ecx

; 1188 :         const auto _Scary = _Get_scary();
; 1189 :         _Scary->_Erase_head(_Getal());

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >

; 1190 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1191 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1192 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1193 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1194 :     }

  00006	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::~_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Unchecked_end@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AU_Default_sentinel@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AU_Default_sentinel@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Unchecked_end, COMDAT
; _this$dead$ = ecx

; 1264 :     _Default_sentinel _Unchecked_end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1265 :         return {};

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1266 :     }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Unchecked_end@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AU_Default_sentinel@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1260 :     _Unchecked_const_iterator _Unchecked_begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1261 :         return _Unchecked_const_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1262 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 44		 push	 68			; 00000044H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 489  :     virtual ~basic_ostringstream() noexcept {}

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 b0	 mov	 eax, DWORD PTR [esi-80]
  00009	57		 push	 edi
  0000a	8d 7e b0	 lea	 edi, DWORD PTR [esi-80]
  0000d	8d 4e b4	 lea	 ecx, DWORD PTR [esi-76]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	c7 44 30 b0 00
	00 00 00	 mov	 DWORD PTR [eax+esi-80], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0001b	8b 07		 mov	 eax, DWORD PTR [edi]
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	8d 42 b0	 lea	 eax, DWORD PTR [edx-80]
  00023	89 44 32 ac	 mov	 DWORD PTR [edx+esi-84], eax
  00027	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  0002c	8d 4e b8	 lea	 ecx, DWORD PTR [esi-72]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00035	8b ce		 mov	 ecx, esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0003d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00041	74 0e		 je	 SHORT $LN9@scalar
  00043	68 98 00 00 00	 push	 152			; 00000098H
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___param0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??1?$_Tidy_guard@V?$vector@KV?$allocator@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$vector@KV?$allocator@K@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<unsigned long,std::allocator<unsigned long> > >::~_Tidy_guard<std::vector<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 5692 :     ~_Tidy_guard() {

  00000	56		 push	 esi

; 5693 :         if (_Target) {

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]
  00003	85 f6		 test	 esi, esi
  00005	74 46		 je	 SHORT $LN5@Tidy_guard
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 40		 je	 SHORT $LN5@Tidy_guard

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00010	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00012	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001b	72 12		 jb	 SHORT $LN21@Tidy_guard

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00020	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00023	2b c2		 sub	 eax, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00025	83 c0 fc	 add	 eax, -4			; fffffffcH
  00028	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002b	77 22		 ja	 SHORT $LN18@Tidy_guard

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002d	8b c2		 mov	 eax, edx
$LN21@Tidy_guard:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002f	51		 push	 ecx
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0003c	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1698 :             _Mylast  = pointer();

  0003f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1699 :             _Myend   = pointer();

  00046	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@Tidy_guard:
  0004d	5e		 pop	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 5696 :     }

  0004e	c3		 ret	 0
$LN18@Tidy_guard:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN26@Tidy_guard:
  00055	cc		 int	 3
??1?$_Tidy_guard@V?$vector@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<unsigned long,std::allocator<unsigned long> > >::~_Tidy_guard<std::vector<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z PROC	; std::pointer_traits<char *>::pointer_to, COMDAT
; __Val$ = ecx

; 122  :         return _STD addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 123  :     }

  00002	c3		 ret	 0
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ENDP	; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 40   :         this->_Adopt(_Plist);
; 41   :     }

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 329  :     void _Tidy() noexcept { // discard any allocated buffer and clear pointers

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 330  :         if (_Mystate & _Allocated) {

  00003	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  00007	74 47		 je	 SHORT $LN20@Tidy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 195  :         return *_IPnext;

  00009	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 331  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 09		 je	 SHORT $LN4@Tidy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 214  :         return *_IPnext + *_IPcount;

  00012	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00015	8b 10		 mov	 edx, DWORD PTR [eax]
  00017	03 d1		 add	 edx, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 331  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

  00019	eb 0a		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 199  :         return *_IGnext + *_IGcount;

  0001b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001e	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	03 11		 add	 edx, DWORD PTR [ecx]
$LN5@Tidy:

; 183  :         return *_IGfirst;

  00025	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 331  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	2b d0		 sub	 edx, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0002c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00032	72 12		 jb	 SHORT $LN30@Tidy

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00034	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00037	83 c2 23	 add	 edx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0003a	2b c1		 sub	 eax, ecx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0003f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00042	77 4f		 ja	 SHORT $LN27@Tidy

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00044	8b c1		 mov	 eax, ecx
$LN30@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00046	52		 push	 edx
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004d	83 c4 08	 add	 esp, 8
$LN20@Tidy:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 208  :         *_IGfirst = _First;

  00050	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00053	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  :         *_IGnext  = _Next;

  00059	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

  00062	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00065	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 242  :         *_IPfirst = _First;

  0006b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 243  :         *_IPnext  = _First;

  00074	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00077	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 244  :         *_IPcount = static_cast<int>(_Last - _First);

  0007d	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00080	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 339  :         _Mystate &= ~_Allocated;

  00086	83 66 3c fe	 and	 DWORD PTR [esi+60], -2	; fffffffeH
  0008a	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00091	5e		 pop	 esi

; 340  :     }

  00092	c3		 ret	 0
$LN27@Tidy:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN38@Tidy:
  00099	cc		 int	 3
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 85   :     _NODISCARD _Mystr str() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f9		 mov	 edi, ecx
  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 4301 :         _Mypair._Myval2._Mysize = 0;

  0002f	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 95   :         return _Result;

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  0004d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00054	f6 c1 02	 test	 cl, 2
  00057	75 1b		 jne	 SHORT $LN2@str
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 195  :         return *_IPnext;

  00059	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 87   :         if (!(_Mystate & _Constant) && _Mysb::pptr()) { // writable, make string from write buffer

  0005c	8b 18		 mov	 ebx, DWORD PTR [eax]
  0005e	85 db		 test	 ebx, ebx
  00060	74 12		 je	 SHORT $LN2@str
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 191  :         return *_IPfirst;

  00062	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

  00065	3b 5f 38	 cmp	 ebx, DWORD PTR [edi+56]
  00068	0f 42 5f 38	 cmovb	 ebx, DWORD PTR [edi+56]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 191  :         return *_IPfirst;

  0006c	8b 10		 mov	 edx, DWORD PTR [eax]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 89   :             _Result.assign(_Base, static_cast<_Mysize_type>(_Max_value(_Mysb::pptr(), _Seekhigh) - _Base));

  0006e	2b da		 sub	 ebx, edx
  00070	53		 push	 ebx
  00071	52		 push	 edx
  00072	eb 1e		 jmp	 SHORT $LN34@str
$LN2@str:

; 90   :         } else if (!(_Mystate & _Noread) && _Mysb::gptr()) { // readable, make string from read buffer

  00074	f6 c1 04	 test	 cl, 4
  00077	75 20		 jne	 SHORT $LN31@str
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 187  :         return *_IGnext;

  00079	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 90   :         } else if (!(_Mystate & _Noread) && _Mysb::gptr()) { // readable, make string from read buffer

  0007c	8b 10		 mov	 edx, DWORD PTR [eax]
  0007e	85 d2		 test	 edx, edx
  00080	74 17		 je	 SHORT $LN31@str
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\streambuf

; 183  :         return *_IGfirst;

  00082	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]

; 199  :         return *_IGnext + *_IGcount;

  00087	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0008a	8b 00		 mov	 eax, DWORD PTR [eax]
  0008c	2b c1		 sub	 eax, ecx
  0008e	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream

; 92   :             _Result.assign(_Base, static_cast<_Mysize_type>(_Mysb::egptr() - _Base));

  00090	50		 push	 eax
  00091	51		 push	 ecx
$LN34@str:

; 96   :     }

  00092	8b ce		 mov	 ecx, esi
  00094	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN31@str:
  00099	8b c6		 mov	 eax, esi
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a5	59		 pop	 ecx
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN7@str
  0000c	83 65 f0 fe	 and	 DWORD PTR $T1[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN7@str:
  00018	c3		 ret	 0
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
__ehhandler$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ:
  0001e	90		 npad	 1
  0001f	90		 npad	 1
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Mode$ = 8						; size = 4
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   :     explicit basic_stringbuf(ios_base::openmode _Mode) : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ

; 355  :         if (!(_Mode & ios_base::out)) {

  00011	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]
  00014	8b d3		 mov	 edx, ebx
  00016	f7 d2		 not	 edx

; 34   :     explicit basic_stringbuf(ios_base::openmode _Mode) : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al() {}

  00018	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 355  :         if (!(_Mode & ios_base::out)) {

  0001e	83 e2 01	 and	 edx, 1

; 34   :     explicit basic_stringbuf(ios_base::openmode _Mode) : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al() {}

  00021	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 355  :         if (!(_Mode & ios_base::out)) {

  00028	c1 e2 02	 shl	 edx, 2
  0002b	8b c3		 mov	 eax, ebx

; 356  :             _State |= _Constant;
; 357  :         }
; 358  : 
; 359  :         if (_Mode & ios_base::app) {

  0002d	8b ca		 mov	 ecx, edx
  0002f	83 c9 02	 or	 ecx, 2
  00032	24 02		 and	 al, 2
  00034	8b c3		 mov	 eax, ebx
  00036	0f 45 ca	 cmovne	 ecx, edx

; 360  :             _State |= _Append;
; 361  :         }
; 362  : 
; 363  :         if (_Mode & ios_base::ate) {

  00039	8b d1		 mov	 edx, ecx
  0003b	83 ca 08	 or	 edx, 8
  0003e	24 08		 and	 al, 8
  00040	0f 44 d1	 cmove	 edx, ecx

; 34   :     explicit basic_stringbuf(ios_base::openmode _Mode) : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al() {}

  00043	8b c2		 mov	 eax, edx
  00045	83 c8 10	 or	 eax, 16			; 00000010H

; 363  :         if (_Mode & ios_base::ate) {

  00048	80 e3 04	 and	 bl, 4

; 34   :     explicit basic_stringbuf(ios_base::openmode _Mode) : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al() {}

  0004b	0f 44 c2	 cmove	 eax, edx
  0004e	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00051	8b c6		 mov	 eax, esi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 51   :     _Tree_unchecked_const_iterator& operator++() {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00004	8b 16		 mov	 edx, DWORD PTR [esi]
  00006	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  00009	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0000d	74 22		 je	 SHORT $LN4@operator

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0000f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00012	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00016	75 12		 jne	 SHORT $LN19@operator
$LL2@operator:
  00018	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0001b	75 0d		 jne	 SHORT $LN19@operator

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	8b d0		 mov	 edx, eax
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 ee		 je	 SHORT $LL2@operator
$LN19@operator:

; 56   :             }
; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())
; 59   :         } else {
; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 61   :         }
; 62   : 
; 63   :         return *this;

  0002a	89 06		 mov	 DWORD PTR [esi], eax

; 64   :     }

  0002c	8b c6		 mov	 eax, esi
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	c3		 ret	 0
$LN4@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00031	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00033	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00037	75 13		 jne	 SHORT $LN9@operator
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL8@operator:
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00042	8b f9		 mov	 edi, ecx
  00044	8b c8		 mov	 ecx, eax
  00046	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004a	74 f4		 je	 SHORT $LL8@operator
$LN9@operator:

; 56   :             }
; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())
; 59   :         } else {
; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 61   :         }
; 62   : 
; 63   :         return *this;

  0004c	89 3e		 mov	 DWORD PTR [esi], edi

; 64   :     }

  0004e	8b c6		 mov	 eax, esi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = ecx

; 44   :         return _Ptr->_Myval;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 45   :     }

  00005	c3		 ret	 0
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 40   :         this->_Adopt(_Plist);
; 41   :     }

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Buy_raw@?$vector@KV?$allocator@K@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@KV?$allocator@K@std@@@std@@AAEXI@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1632 :     void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 34   :             if (_Count > _Max_possible) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newcapacity$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1632 :     void _Buy_raw(const size_type _Newcapacity) {

  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 34   :             if (_Count > _Max_possible) {

  0000a	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  00010	77 6f		 ja	 SHORT $LN30@Buy_raw

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  00012	c1 e6 02	 shl	 esi, 2

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  0001b	72 35		 jb	 SHORT $LN10@Buy_raw

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001d	8d 46 23	 lea	 eax, DWORD PTR [esi+35]

; 90   :     if (_Block_size <= _Bytes) {

  00020	3b c6		 cmp	 eax, esi
  00022	76 5d		 jbe	 SHORT $LN30@Buy_raw

; 51   :         return ::operator new(_Bytes);

  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0002a	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  0002c	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002f	85 c9		 test	 ecx, ecx
  00031	74 19		 je	 SHORT $LN19@Buy_raw

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00033	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00036	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00039	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  0003c	89 07		 mov	 DWORD PTR [edi], eax

; 1644 :         _Mylast            = _Newvec;

  0003e	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00041	03 c6		 add	 eax, esi
  00043	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi

; 1646 :     }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN19@Buy_raw:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN10@Buy_raw:

; 179  :     if (_Bytes != 0) {

  00052	85 f6		 test	 esi, esi
  00054	74 19		 je	 SHORT $LN11@Buy_raw

; 51   :         return ::operator new(_Bytes);

  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  0005c	89 07		 mov	 DWORD PTR [edi], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0005e	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1644 :         _Mylast            = _Newvec;

  00061	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00064	03 c6		 add	 eax, esi
  00066	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi

; 1646 :     }

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
$LN11@Buy_raw:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 183  :     return nullptr;

  0006f	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  00071	89 07		 mov	 DWORD PTR [edi], eax

; 1644 :         _Mylast            = _Newvec;

  00073	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00076	8b c6		 mov	 eax, esi
  00078	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1646 :     }

  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
$LN30@Buy_raw:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00081	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN31@Buy_raw:
  00086	cc		 int	 3
?_Buy_raw@?$vector@KV?$allocator@K@std@@@std@@AAEXI@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SA?AV?$allocator@K@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SA?AV?$allocator@K@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned long> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 684  :         return _Al;

  00000	8b c1		 mov	 eax, ecx

; 685  :     }

  00002	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SA?AV?$allocator@K@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned long> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 2050 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00000	8b c1		 mov	 eax, ecx

; 2051 :     }

  00002	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Getal, COMDAT
; _this$ = ecx

; 2046 :         return _Mypair._Myval2._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2047 :     }

  00002	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Getal, COMDAT
; _this$ = ecx

; 2042 :         return _Mypair._Myval2._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2043 :     }

  00002	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 684  :         return _Al;

  00000	8b c1		 mov	 eax, ecx

; 685  :     }

  00002	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Min, COMDAT
; __Pnode$ = ecx

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00006	75 0d		 jne	 SHORT $LN9@Min
$LL2@Min:
  00008	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 452  :             _Pnode = _Pnode->_Left;

  0000a	8b c2		 mov	 eax, edx
  0000c	8b d1		 mov	 edx, ecx
  0000e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00012	74 f4		 je	 SHORT $LL2@Min

; 456  :     }

  00014	c3		 ret	 0
$LN9@Min:

; 453  :         }
; 454  : 
; 455  :         return _Pnode;

  00015	8b c1		 mov	 eax, ecx

; 456  :     }

  00017	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Get_scary, COMDAT
; _this$ = ecx

; 2054 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00000	8b c1		 mov	 eax, ecx

; 2055 :     }

  00002	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ?eq@?$_Narrow_char_traits@DH@std@@SA_NABD0@Z
_TEXT	SEGMENT
?eq@?$_Narrow_char_traits@DH@std@@SA_NABD0@Z PROC	; std::_Narrow_char_traits<char,int>::eq, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 381  :         return _Left == _Right;

  00000	8a 01		 mov	 al, BYTE PTR [ecx]
  00002	3a 02		 cmp	 al, BYTE PTR [edx]
  00004	0f 94 c0	 sete	 al

; 382  :     }

  00007	c3		 ret	 0
?eq@?$_Narrow_char_traits@DH@std@@SA_NABD0@Z ENDP	; std::_Narrow_char_traits<char,int>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z
_TEXT	SEGMENT
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT
; __Mode$ = ecx

; 349  :     static int _Getstate(ios_base::openmode _Mode) { // convert open mode to stream state bits

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 350  :         int _State = 0;
; 351  :         if (!(_Mode & ios_base::in)) {
; 352  :             _State |= _Noread;
; 353  :         }
; 354  : 
; 355  :         if (!(_Mode & ios_base::out)) {

  00003	8b d3		 mov	 edx, ebx
  00005	8b c3		 mov	 eax, ebx
  00007	f7 d2		 not	 edx
  00009	83 e2 01	 and	 edx, 1
  0000c	c1 e2 02	 shl	 edx, 2
  0000f	56		 push	 esi

; 356  :             _State |= _Constant;
; 357  :         }
; 358  : 
; 359  :         if (_Mode & ios_base::app) {

  00010	8b f2		 mov	 esi, edx
  00012	83 ce 02	 or	 esi, 2
  00015	24 02		 and	 al, 2
  00017	8b c3		 mov	 eax, ebx
  00019	0f 45 f2	 cmovne	 esi, edx

; 360  :             _State |= _Append;
; 361  :         }
; 362  : 
; 363  :         if (_Mode & ios_base::ate) {

  0001c	8b ce		 mov	 ecx, esi
  0001e	83 c9 08	 or	 ecx, 8
  00021	24 08		 and	 al, 8
  00023	0f 44 ce	 cmove	 ecx, esi

; 364  :             _State |= _Atend;
; 365  :         }
; 366  : 
; 367  :         return _State;

  00026	8b c1		 mov	 eax, ecx
  00028	83 c8 10	 or	 eax, 16			; 00000010H
  0002b	80 e3 04	 and	 bl, 4
  0002e	5e		 pop	 esi
  0002f	0f 44 c1	 cmove	 eax, ecx
  00032	5b		 pop	 ebx

; 368  :     }

  00033	c3		 ret	 0
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1337 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Min, COMDAT
; __Pnode$ = ecx

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00006	75 0d		 jne	 SHORT $LN9@Min
$LL2@Min:
  00008	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 452  :             _Pnode = _Pnode->_Left;

  0000a	8b c2		 mov	 eax, edx
  0000c	8b d1		 mov	 edx, ecx
  0000e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00012	74 f4		 je	 SHORT $LL2@Min

; 456  :     }

  00014	c3		 ret	 0
$LN9@Min:

; 453  :         }
; 454  : 
; 455  :         return _Pnode;

  00015	8b c1		 mov	 eax, ecx

; 456  :     }

  00017	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 4301 :         _Mypair._Myval2._Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 2298 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2299 :         _Tidy_init();
; 2300 :     }

  00007	8b c1		 mov	 eax, ecx

; 4302 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00009	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 4303 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4304 :         // write can alias this
; 4305 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 2298 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2299 :         _Tidy_init();
; 2300 :     }

  00013	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$_Max_value@PAD@std@@YAABQADABQAD0@Z
_TEXT	SEGMENT
??$_Max_value@PAD@std@@YAABQADABQAD0@Z PROC		; std::_Max_value<char *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 37   :     return _Left < _Right ? _Right : _Left;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 02		 cmp	 eax, DWORD PTR [edx]
  00004	0f 42 ca	 cmovb	 ecx, edx
  00007	8b c1		 mov	 eax, ecx

; 38   : }

  00009	c3		 ret	 0
??$_Max_value@PAD@std@@YAABQADABQAD0@Z ENDP		; std::_Max_value<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0V?$allocator@K@std@@$$V@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@K@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@K@std@@$$V@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@K@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1><std::allocator<unsigned long> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 08 00	 ret	 8
??$?0V?$allocator@K@std@@$$V@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@K@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1><std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKPAK00@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>, COMDAT
; _this$dead$ = ecx

; 1587 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000e	2b f8		 sub	 edi, eax

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  0001b	c1 ff 02	 sar	 edi, 2
  0001e	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1589 :     }

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKPAK00@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Sentinel$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
$T15 = 8						; size = 1
__Right$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> ><std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; _this$ = ecx

; 892  :             _STD forward<_Any_alloc>(_Al)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00029	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0002b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00031	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 766  :     _Tree_head_scoped_ptr(_Alnode& _Al_, _Scary_val& _Mycont_) : _Al(_Al_), _Mycont(_STD addressof(_Mycont_)) {

  00038	89 7d ec	 mov	 DWORD PTR __Sentinel$[ebp], edi
  0003b	89 7d f0	 mov	 DWORD PTR __Sentinel$[ebp+4], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0003e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00043	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00046	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00048	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0004b	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  0004e	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 767  :         _Mycont->_Myhead = _Alnode::value_type::_Buyheadnode(_Al);

  00054	89 07		 mov	 DWORD PTR [edi], eax

; 893  :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 894  :         const auto _Scary = _Get_scary();
; 895  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, *_Scary);
; 896  :         _Tree_head_scoped_ptr<_Alnode, _Scary_val> _Sentinel(_Getal(), *_Scary);

  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1731 :         _Scary->_Myhead->_Parent = _Copy_nodes(_Right_scary->_Myhead->_Parent, _Scary->_Myhead, _Movefl);

  0005d	8b cf		 mov	 ecx, edi
  0005f	ff 75 08	 push	 DWORD PTR $T15[ebp]
  00062	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00065	50		 push	 eax
  00066	8b 06		 mov	 eax, DWORD PTR [esi]
  00068	ff 70 04	 push	 DWORD PTR [eax+4]
  0006b	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_tag>
  00070	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00072	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1732 :         _Scary->_Mysize          = _Right_scary->_Mysize;

  00075	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1733 :         if (!_Scary->_Myhead->_Parent->_Isnil) { // nonempty tree, look for new smallest and largest

  00078	8b 37		 mov	 esi, DWORD PTR [edi]
  0007a	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0007d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00080	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00084	75 3a		 jne	 SHORT $LN41@ImportInfo

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00086	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00088	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0008c	75 0e		 jne	 SHORT $LN46@ImportInfo
  0008e	66 90		 npad	 2
$LL45@ImportInfo:
  00090	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00092	8b d1		 mov	 edx, ecx
  00094	8b c8		 mov	 ecx, eax
  00096	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0009a	74 f4		 je	 SHORT $LL45@ImportInfo
$LN46@ImportInfo:

; 1734 :             _Scary->_Myhead->_Left  = _Scary_val::_Min(_Scary->_Myhead->_Parent);

  0009c	89 16		 mov	 DWORD PTR [esi], edx

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  0009e	8b 17		 mov	 edx, DWORD PTR [edi]
  000a0	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 443  :         while (!_Pnode->_Right->_Isnil) {

  000a3	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000a6	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000aa	75 0f		 jne	 SHORT $LN50@ImportInfo
  000ac	0f 1f 40 00	 npad	 4
$LL49@ImportInfo:

; 444  :             _Pnode = _Pnode->_Right;

  000b0	8b c8		 mov	 ecx, eax
  000b2	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000b5	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000b9	74 f5		 je	 SHORT $LL49@ImportInfo
$LN50@ImportInfo:

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  000bb	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1736 :         } else { // empty tree, just tidy head pointers

  000be	eb 07		 jmp	 SHORT $LN64@ImportInfo
$LN41@ImportInfo:

; 1737 :             _Scary->_Myhead->_Left  = _Scary->_Myhead;

  000c0	89 36		 mov	 DWORD PTR [esi], esi

; 1738 :             _Scary->_Myhead->_Right = _Scary->_Myhead;

  000c2	8b 07		 mov	 eax, DWORD PTR [edi]
  000c4	89 40 08	 mov	 DWORD PTR [eax+8], eax
$LN64@ImportInfo:

; 897  :         _Copy(_Right, _Copy_tag());
; 898  :         _Sentinel._Release();
; 899  :         _Proxy._Release();
; 900  :     }

  000c7	8b c7		 mov	 eax, edi
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Sentinel$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::~_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> ><std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al$GSCopy$1$ = -4					; size = 4
__Al$ = 8						; size = 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; _this$ = ecx

; 750  :     void _Erase_head(_Alnode& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	57		 push	 edi
  0000b	89 4d fc	 mov	 DWORD PTR __Al$GSCopy$1$[ebp], ecx

; 751  :         this->_Orphan_all();
; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  0000e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00010	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00013	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00017	75 35		 jne	 SHORT $LN5@Erase_head
  00019	56		 push	 esi
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Erase_head:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00020	ff 77 08	 push	 DWORD PTR [edi+8]
  00023	51		 push	 ecx
  00024	8b cb		 mov	 ecx, ebx
  00026	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b f7		 mov	 esi, edi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  0002d	8b 3f		 mov	 edi, DWORD PTR [edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002f	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 673  :         _Tidy();

  00032	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00037	6a 20		 push	 32			; 00000020H
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __Al$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00042	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00045	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00049	74 d5		 je	 SHORT $LL4@Erase_head
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0004d	5e		 pop	 esi
$LN5@Erase_head:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0004e	6a 20		 push	 32			; 00000020H
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00056	83 c4 08	 add	 esp, 8
  00059	5f		 pop	 edi
  0005a	5b		 pop	 ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 754  :     }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > const >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; __Al$dead$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00000	6a 20		 push	 32			; 00000020H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0000a	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0000c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0000f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00012	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 348  :         _Pnode->_Isnil = true;
; 349  :         return _Pnode;
; 350  :     }

  00018	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00007	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstring

; 2129 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::~_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >, COMDAT
; _this$ = ecx

; 775  :         if (_Mycont) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 09		 je	 SHORT $LN2@Tree_head_

; 776  :             _Mycont->_Erase_head(_Al);

  00007	ff 31		 push	 DWORD PTR [ecx]
  00009	8b c8		 mov	 ecx, eax
  0000b	e8 00 00 00 00	 call	 ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
$LN2@Tree_head_:

; 777  :         }
; 778  :     }

  00010	c3		 ret	 0
??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::~_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Release@?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Release@?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAEXXZ PROC ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::_Release, COMDAT
; _this$ = ecx

; 771  :         _Mycont = nullptr;

  00000	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 772  :     }

  00007	c3		 ret	 0
?_Release@?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAEXXZ ENDP ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@AAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
__Mycont_$ = 12						; size = 4
??0?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@AAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >, COMDAT
; _this$ = ecx

; 766  :     _Tree_head_scoped_ptr(_Alnode& _Al_, _Scary_val& _Mycont_) : _Al(_Al_), _Mycont(_STD addressof(_Mycont_)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00009	6a 20		 push	 32			; 00000020H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 766  :     _Tree_head_scoped_ptr(_Alnode& _Al_, _Scary_val& _Mycont_) : _Al(_Al_), _Mycont(_STD addressof(_Mycont_)) {

  0000b	89 06		 mov	 DWORD PTR [esi], eax
  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Mycont_$[ebp]
  00010	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00018	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0001b	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0001d	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00020	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00023	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 767  :         _Mycont->_Myhead = _Alnode::value_type::_Buyheadnode(_Al);

  00029	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002c	89 01		 mov	 DWORD PTR [ecx], eax

; 768  :     }

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
??0?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@AAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@PBD@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@PBD@2@XZ PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::key_comp, COMDAT
; _this$dead$ = ecx

; 1321 :     _NODISCARD key_compare key_comp() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1322 :         return _Getcomp();

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1323 :     }

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?key_comp@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@PBD@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::key_comp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 51   :         return ::operator new(_Bytes);

  00000	6a 20		 push	 32			; 00000020H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  0000a	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEABU?$less@PBD@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEABU?$less@PBD@2@XZ PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 2038 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2039 :     }

  00002	c3		 ret	 0
?_Getcomp@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEABU?$less@PBD@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@PBD@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@PBD@2@XZ PROC ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@PBD@2@XZ ENDP ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@V?$allocator@K@std@@@std@@YA$$QAV?$allocator@K@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@K@std@@@std@@YA$$QAV?$allocator@K@0@AAV10@@Z PROC ; std::forward<std::allocator<unsigned long> >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@V?$allocator@K@std@@@std@@YA$$QAV?$allocator@K@0@AAV10@@Z ENDP ; std::forward<std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z PROC ; std::_Uninitialized_copy<unsigned long *,std::allocator<unsigned long> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1517 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1528 :         _Dest += _ULast - _UFirst;

  00017	c1 ff 02	 sar	 edi, 2
  0001a	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]

; 1529 :         (void) _Al;
; 1530 :     } else {
; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1533 :             _Backout._Emplace_back(*_UFirst);
; 1534 :         }
; 1535 : 
; 1536 :         _Dest = _Backout._Release();
; 1537 :     }
; 1538 : 
; 1539 :     return _Dest;

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 1540 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninitialized_copy@PAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z ENDP ; std::_Uninitialized_copy<unsigned long *,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@0@AAV10@@Z PROC ; std::forward<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0U?$less@PBD@std@@U_One_then_variadic_args_t@1@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$less@PBD@1@$$QAU21@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
_<_Val2_1>$dead$ = 20					; size = 4
??$?0U?$less@PBD@std@@U_One_then_variadic_args_t@1@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$less@PBD@1@$$QAU21@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z PROC ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1><std::less<char const *>,std::_One_then_variadic_args_t,std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 10 00	 ret	 16			; 00000010H
??$?0U?$less@PBD@std@@U_One_then_variadic_args_t@1@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@?$_Compressed_pair@U?$less@PBD@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$less@PBD@1@$$QAU21@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ENDP ; std::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1>::_Compressed_pair<std::less<char const *>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>,1><std::less<char const *>,std::_One_then_variadic_args_t,std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Movefl$ = 12						; size = 1
??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy<std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_tag>, COMDAT
; _this$ = ecx

; 1728 :     void _Copy(const _Tree& _Right, _Moveit _Movefl) { // copy or move entire tree from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1729 :         const auto _Scary        = _Get_scary();
; 1730 :         const auto _Right_scary  = _Right._Get_scary();
; 1731 :         _Scary->_Myhead->_Parent = _Copy_nodes(_Right_scary->_Myhead->_Parent, _Scary->_Myhead, _Movefl);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	ff 75 0c	 push	 DWORD PTR __Movefl$[ebp]
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 06		 mov	 eax, DWORD PTR [esi]
  0000f	ff 37		 push	 DWORD PTR [edi]
  00011	ff 70 04	 push	 DWORD PTR [eax+4]
  00014	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_tag>
  00019	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0001b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1732 :         _Scary->_Mysize          = _Right_scary->_Mysize;

  0001e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1733 :         if (!_Scary->_Myhead->_Parent->_Isnil) { // nonempty tree, look for new smallest and largest

  00021	8b 37		 mov	 esi, DWORD PTR [edi]
  00023	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00026	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00029	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0002d	75 38		 jne	 SHORT $LN2@Copy

; 451  :         while (!_Pnode->_Left->_Isnil) {

  0002f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00031	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00035	75 0c		 jne	 SHORT $LN7@Copy
$LL6@Copy:
  00037	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00039	8b d1		 mov	 edx, ecx
  0003b	8b c8		 mov	 ecx, eax
  0003d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00041	74 f4		 je	 SHORT $LL6@Copy
$LN7@Copy:

; 1734 :             _Scary->_Myhead->_Left  = _Scary_val::_Min(_Scary->_Myhead->_Parent);

  00043	89 16		 mov	 DWORD PTR [esi], edx

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  00045	8b 17		 mov	 edx, DWORD PTR [edi]
  00047	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 443  :         while (!_Pnode->_Right->_Isnil) {

  0004a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0004d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00051	75 0b		 jne	 SHORT $LN11@Copy
$LL10@Copy:

; 444  :             _Pnode = _Pnode->_Right;

  00053	8b c8		 mov	 ecx, eax
  00055	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00058	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0005c	74 f5		 je	 SHORT $LL10@Copy
$LN11@Copy:
  0005e	5f		 pop	 edi

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  0005f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1739 :         }
; 1740 :     }

  00062	5e		 pop	 esi
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
$LN2@Copy:

; 1736 :         } else { // empty tree, just tidy head pointers
; 1737 :             _Scary->_Myhead->_Left  = _Scary->_Myhead;

  00067	89 36		 mov	 DWORD PTR [esi], esi

; 1738 :             _Scary->_Myhead->_Right = _Scary->_Myhead;

  00069	8b 07		 mov	 eax, DWORD PTR [edi]
  0006b	5f		 pop	 edi

; 1739 :         }
; 1740 :     }

  0006c	5e		 pop	 esi
  0006d	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy<std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$GSCopy$1$ = -4					; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	8b 75 0c	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	89 45 fc	 mov	 DWORD PTR __Al$GSCopy$1$[ebp], eax

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00011	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00015	75 2d		 jne	 SHORT $LN3@Erase_tree
  00017	57		 push	 edi
$LL2@Erase_tree:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 76 08	 push	 DWORD PTR [esi+8]
  0001b	8b cb		 mov	 ecx, ebx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b fe		 mov	 edi, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00027	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 673  :         _Tidy();

  0002a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002f	6a 20		 push	 32			; 00000020H
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00037	8b 45 fc	 mov	 eax, DWORD PTR __Al$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0003a	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0003d	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00041	74 d5		 je	 SHORT $LL2@Erase_tree
  00043	5f		 pop	 edi
$LN3@Erase_tree:
  00044	5e		 pop	 esi

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 746  :         }
; 747  :     }

  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00000	6a 20		 push	 32			; 00000020H
  00002	52		 push	 edx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00008	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 374  :     }

  0000b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

  00004	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CA@@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$0CA@@std@@YAII@Z PROC		; std::_Get_size_of_n<32>, COMDAT
; __Count$dead$ = ecx

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {
; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  00000	b8 20 00 00 00	 mov	 eax, 32			; 00000020H

; 40   : }

  00005	c3		 ret	 0
??$_Get_size_of_n@$0CA@@std@@YAII@Z ENDP		; std::_Get_size_of_n<32>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Max, COMDAT
; __Pnode$ = ecx

; 443  :         while (!_Pnode->_Right->_Isnil) {

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00007	75 12		 jne	 SHORT $LN9@Max
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Max:

; 444  :             _Pnode = _Pnode->_Right;

  00010	8b c8		 mov	 ecx, eax
  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN9@Max:

; 445  :         }
; 446  : 
; 447  :         return _Pnode;
; 448  :     }

  0001b	8b c1		 mov	 eax, ecx
  0001d	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >, COMDAT
; _this$ = ecx

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 2054 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00000	8b c1		 mov	 eax, ecx

; 2055 :     }

  00002	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::deallocate, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 664  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 195  :     ::operator delete(_Ptr, _Bytes);

  00003	6a 20		 push	 32			; 00000020H
  00005	52		 push	 edx
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8

; 665  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 666  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
; 667  :     }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1><std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 08 00	 ret	 8
??$?0V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >,1><std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@U?$less@PBD@std@@@std@@YA$$QAU?$less@PBD@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$less@PBD@std@@@std@@YA$$QAU?$less@PBD@0@AAU10@@Z PROC ; std::forward<std::less<char const *> >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@U?$less@PBD@std@@@std@@YA$$QAU?$less@PBD@0@AAU10@@Z ENDP ; std::forward<std::less<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_One_then_variadic_args_t>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_One_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
_TEXT	SEGMENT
__Guard$25 = -72					; size = 4
__Newnode$26 = -68					; size = 8
_this$GSCopy$ = -60					; size = 4
__Rightlast$1$ = -56					; size = 4
_this$GSCopy$1$ = -52					; size = 4
__Movefl$GSCopy$ = -48					; size = 1
__Rootnode$GSCopy$1$ = -44				; size = 4
__My_data$1$ = -40					; size = 4
__Myhead$1$ = -36					; size = 4
__Newroot$ = -36					; size = 4
__Backout$27 = -32					; size = 12
__$ArrayPad$28 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
__Movefl$ = 16						; size = 1
??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_tag>, COMDAT
; _this$ = ecx

; 1758 :     _Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode, _Moveit _Movefl) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$28[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	89 4d cc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00031	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00034	8a 45 10	 mov	 al, BYTE PTR __Movefl$[ebp]

; 1759 :         // copy entire subtree, recursively
; 1760 :         const auto _Scary = _Get_scary();

  00037	8b 31		 mov	 esi, DWORD PTR [ecx]
  00039	89 4d c4	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 1761 :         _Nodeptr _Newroot = _Scary->_Myhead; // point at nil node
; 1762 : 
; 1763 :         if (!_Rootnode->_Isnil) { // copy or move a node, then any subtrees

  0003c	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00040	89 7d d4	 mov	 DWORD PTR __Rootnode$GSCopy$1$[ebp], edi
  00043	88 45 d0	 mov	 BYTE PTR __Movefl$GSCopy$[ebp], al
  00046	89 75 dc	 mov	 DWORD PTR __Myhead$1$[ebp], esi
  00049	0f 85 0e 01 00
	00		 jne	 $LN8@Copy_nodes
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0004f	89 4d bc	 mov	 DWORD PTR __Newnode$26[ebp], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 356  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);

  00052	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00059	6a 20		 push	 32			; 00000020H

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0005b	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR __Newnode$26[ebp+4], 0

; 51   :         return ::operator new(_Bytes);

  00062	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1044 :         _Ptr = _Al.allocate(1);

  00067	8b d8		 mov	 ebx, eax

; 51   :         return ::operator new(_Bytes);

  00069	83 c4 04	 add	 esp, 4
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  0006c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1044 :         _Ptr = _Al.allocate(1);

  0006f	89 5d c0	 mov	 DWORD PTR __Newnode$26[ebp+4], ebx
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  00072	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00075	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00078	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0007e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00085	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  0008c	8b 7f 14	 mov	 edi, DWORD PTR [edi+20]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  0008f	89 45 d8	 mov	 DWORD PTR __My_data$1$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  00092	8b 45 d4	 mov	 eax, DWORD PTR __Rootnode$GSCopy$1$[ebp]
  00095	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00098	89 45 c8	 mov	 DWORD PTR __Rightlast$1$[ebp], eax

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  0009b	3b f8		 cmp	 edi, eax
  0009d	74 71		 je	 SHORT $LN80@Copy_nodes

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  0009f	8b 5d d8	 mov	 ebx, DWORD PTR __My_data$1$[ebp]
  000a2	8b c8		 mov	 ecx, eax
  000a4	2b cf		 sub	 ecx, edi
  000a6	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000ab	f7 e9		 imul	 ecx
  000ad	8b cb		 mov	 ecx, ebx
  000af	d1 fa		 sar	 edx, 1
  000b1	8b c2		 mov	 eax, edx
  000b3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000b6	03 c2		 add	 eax, edx
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXI@Z ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Buy_raw

; 529  :             _Tidy_guard<vector> _Guard{this};

  000be	89 5d b8	 mov	 DWORD PTR __Guard$25[ebp], ebx

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  000c1	8b 33		 mov	 esi, DWORD PTR [ebx]
  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	66 0f d6 45 e0	 movq	 QWORD PTR __Backout$27[ebp], xmm0
  000cb	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Backout$27[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000d2	89 75 e0	 mov	 DWORD PTR __Backout$27[ebp], esi
  000d5	89 75 e4	 mov	 DWORD PTR __Backout$27[ebp+4], esi
  000d8	89 5d e8	 mov	 DWORD PTR __Backout$27[ebp+8], ebx
  000db	8b 5d c8	 mov	 ebx, DWORD PTR __Rightlast$1$[ebp]

; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  000de	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
$LL64@Copy_nodes:

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  000e2	57		 push	 edi
  000e3	8b ce		 mov	 ecx, esi
  000e5	e8 00 00 00 00	 call	 ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z

; 1499 :         ++_Last;

  000ea	83 c6 0c	 add	 esi, 12			; 0000000cH

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000ed	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1499 :         ++_Last;

  000f0	89 75 e4	 mov	 DWORD PTR __Backout$27[ebp+4], esi

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000f3	3b fb		 cmp	 edi, ebx
  000f5	75 eb		 jne	 SHORT $LL64@Copy_nodes

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000f7	51		 push	 ecx
  000f8	8b d6		 mov	 edx, esi
  000fa	8b ce		 mov	 ecx, esi
  000fc	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00101	8b 45 d8	 mov	 eax, DWORD PTR __My_data$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1493 :         _Destroy_range(_First, _Last, _Al);

  00104	83 c4 04	 add	 esp, 4
  00107	8b 5d c0	 mov	 ebx, DWORD PTR __Newnode$26[ebp+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  0010a	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0010d	8b 75 dc	 mov	 esi, DWORD PTR __Myhead$1$[ebp]
$LN80@Copy_nodes:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1767 :             _Pnode->_Color  = _Rootnode->_Color;

  00110	8b 7d d4	 mov	 edi, DWORD PTR __Rootnode$GSCopy$1$[ebp]
  00113	8b 45 0c	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 1773 :             _Pnode->_Left  = _Copy_nodes(_Rootnode->_Left, _Pnode, _Movefl);

  00116	8b 4d cc	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]

; 359  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);

  00119	89 33		 mov	 DWORD PTR [ebx], esi

; 360  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);
; 361  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);

  0011b	89 73 08	 mov	 DWORD PTR [ebx+8], esi

; 362  :         _Newnode._Ptr->_Color = _Red;

  0011e	66 c7 43 0c 00
	00		 mov	 WORD PTR [ebx+12], 0

; 1764 :             typename is_same<key_type, value_type>::type _Is_set;
; 1765 :             _Nodeptr _Pnode = _Copy_or_move(_Rootnode->_Myval, _Movefl, _Is_set);
; 1766 :             _Pnode->_Parent = _Wherenode;

  00124	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1767 :             _Pnode->_Color  = _Rootnode->_Color;

  00127	8a 47 0c	 mov	 al, BYTE PTR [edi+12]
  0012a	88 43 0c	 mov	 BYTE PTR [ebx+12], al

; 1768 :             if (_Newroot->_Isnil) {

  0012d	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0

; 1769 :                 _Newroot = _Pnode; // memorize new root
; 1770 :             }
; 1771 : 
; 1772 :             _TRY_BEGIN

  00131	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3

; 1773 :             _Pnode->_Left  = _Copy_nodes(_Rootnode->_Left, _Pnode, _Movefl);

  00138	ff 75 d0	 push	 DWORD PTR __Movefl$GSCopy$[ebp]
  0013b	0f 45 f3	 cmovne	 esi, ebx
  0013e	53		 push	 ebx
  0013f	ff 37		 push	 DWORD PTR [edi]
  00141	89 75 dc	 mov	 DWORD PTR __Newroot$[ebp], esi
  00144	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_tag>

; 1774 :             _Pnode->_Right = _Copy_nodes(_Rootnode->_Right, _Pnode, _Movefl);

  00149	ff 75 d0	 push	 DWORD PTR __Movefl$GSCopy$[ebp]
  0014c	8b 4d cc	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0014f	53		 push	 ebx
  00150	89 03		 mov	 DWORD PTR [ebx], eax
  00152	ff 77 08	 push	 DWORD PTR [edi+8]
  00155	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_tag>
  0015a	89 43 08	 mov	 DWORD PTR [ebx+8], eax
$LN8@Copy_nodes:

; 1778 :             _CATCH_END
; 1779 :         }
; 1780 : 
; 1781 :         return _Newroot; // return newly constructed tree

  0015d	8b c6		 mov	 eax, esi

; 1782 :     }

  0015f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00162	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00169	59		 pop	 ecx
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$28[ebp]
  00170	33 cd		 xor	 ecx, ebp
  00172	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c2 0c 00	 ret	 12			; 0000000cH
__catch$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$0:

; 1775 :             _CATCH_ALL
; 1776 :             _Scary->_Erase_tree_and_orphan(_Getal(), _Newroot); // subtree copy failed, bail out

  0017d	ff 75 dc	 push	 DWORD PTR __Newroot$[ebp]
  00180	8b 4d c4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00183	e8 00 00 00 00	 call	 ?_Getal@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Getal
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_tree_and_orphan<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >

; 1777 :             _RERAISE;

  0018e	6a 00		 push	 0
  00190	6a 00		 push	 0
  00192	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN115@Copy_nodes:
  00197	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$2:
  00000	8d 4d bc	 lea	 ecx, DWORD PTR __Newnode$26[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
__unwindfunclet$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$4:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR __Guard$25[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
__unwindfunclet$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$5:
  00010	8d 4d e0	 lea	 ecx, DWORD PTR __Backout$27[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_tag>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@0@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@0@Z PROC ; std::exchange<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * &>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 572  :     // assign _New_val to _Val, return previous _Val
; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	8b 12		 mov	 edx, DWORD PTR [edx]
  00004	89 11		 mov	 DWORD PTR [ecx], edx

; 575  :     return _Old_val;
; 576  : }

  00006	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@0@Z ENDP ; std::exchange<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 377  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx

; 378  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00003	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 673  :         _Tidy();

  00006	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0000b	6a 20		 push	 32			; 00000020H
  0000d	56		 push	 esi
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00013	83 c4 08	 add	 esp, 8
  00016	5e		 pop	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 381  :     }

  00017	c3		 ret	 0
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *>, COMDAT
; __Obj$dead$ = ecx

; 242  :     _Obj.~_Ty();
; 243  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *>, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$forward@ABQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > const >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
__Guard$25 = -52					; size = 4
__Newnode$26 = -48					; size = 8
__Myhead$1$ = -40					; size = 4
__Rightlast$1$ = -36					; size = 4
__My_data$1$ = -32					; size = 4
__Backout$27 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_or_move<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,std::integral_constant<bool,0> >, COMDAT
; _this$ = ecx

; 1743 :     _Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set) { // copy to new node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2030 :         return _Node::_Buynode(_Getal(), _Get_scary()->_Myhead, _STD forward<_Valty>(_Val)...);

  0002b	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1743 :     _Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set) { // copy to new node

  0002d	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]

; 2030 :         return _Node::_Buynode(_Getal(), _Get_scary()->_Myhead, _STD forward<_Valty>(_Val)...);

  00030	89 45 d8	 mov	 DWORD PTR __Myhead$1$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00033	89 4d d0	 mov	 DWORD PTR __Newnode$26[ebp], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 356  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);

  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0003d	6a 20		 push	 32			; 00000020H

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0003f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR __Newnode$26[ebp+4], 0

; 51   :         return ::operator new(_Bytes);

  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  0004b	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1044 :         _Ptr = _Al.allocate(1);

  0004d	8b d8		 mov	 ebx, eax
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  0004f	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1044 :         _Ptr = _Al.allocate(1);

  00052	89 5d d4	 mov	 DWORD PTR __Newnode$26[ebp+4], ebx
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  00055	89 45 e0	 mov	 DWORD PTR __My_data$1$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00058	83 c4 04	 add	 esp, 4
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  0005b	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0005e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00064	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0006b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  00072	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00075	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00078	89 45 dc	 mov	 DWORD PTR __Rightlast$1$[ebp], eax

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  0007b	3b f0		 cmp	 esi, eax
  0007d	74 6e		 je	 SHORT $LN71@Copy_or_mo

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  0007f	8b 5d e0	 mov	 ebx, DWORD PTR __My_data$1$[ebp]
  00082	8b c8		 mov	 ecx, eax
  00084	2b ce		 sub	 ecx, esi
  00086	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0008b	f7 e9		 imul	 ecx
  0008d	8b cb		 mov	 ecx, ebx
  0008f	d1 fa		 sar	 edx, 1
  00091	8b c2		 mov	 eax, edx
  00093	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00096	03 c2		 add	 eax, edx
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXI@Z ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Buy_raw

; 529  :             _Tidy_guard<vector> _Guard{this};

  0009e	89 5d cc	 mov	 DWORD PTR __Guard$25[ebp], ebx

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  000a1	8b 3b		 mov	 edi, DWORD PTR [ebx]
  000a3	0f 57 c0	 xorps	 xmm0, xmm0
  000a6	66 0f d6 45 e4	 movq	 QWORD PTR __Backout$27[ebp], xmm0
  000ab	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Backout$27[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000b2	89 7d e4	 mov	 DWORD PTR __Backout$27[ebp], edi
  000b5	89 7d e8	 mov	 DWORD PTR __Backout$27[ebp+4], edi
  000b8	89 5d ec	 mov	 DWORD PTR __Backout$27[ebp+8], ebx
  000bb	8b 5d dc	 mov	 ebx, DWORD PTR __Rightlast$1$[ebp]

; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  000be	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
$LL55@Copy_or_mo:

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  000c2	56		 push	 esi
  000c3	8b cf		 mov	 ecx, edi
  000c5	e8 00 00 00 00	 call	 ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z

; 1499 :         ++_Last;

  000ca	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000cd	83 c6 0c	 add	 esi, 12			; 0000000cH

; 1499 :         ++_Last;

  000d0	89 7d e8	 mov	 DWORD PTR __Backout$27[ebp+4], edi

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000d3	3b f3		 cmp	 esi, ebx
  000d5	75 eb		 jne	 SHORT $LL55@Copy_or_mo

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000d7	51		 push	 ecx
  000d8	8b d7		 mov	 edx, edi
  000da	8b cf		 mov	 ecx, edi
  000dc	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000e1	8b 45 e0	 mov	 eax, DWORD PTR __My_data$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000e4	83 c4 04	 add	 esp, 4
  000e7	8b 5d d4	 mov	 ebx, DWORD PTR __Newnode$26[ebp+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000ea	89 78 04	 mov	 DWORD PTR [eax+4], edi
$LN71@Copy_or_mo:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 359  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);

  000ed	8b 45 d8	 mov	 eax, DWORD PTR __Myhead$1$[ebp]
  000f0	89 03		 mov	 DWORD PTR [ebx], eax

; 360  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);

  000f2	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 361  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);

  000f5	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1744 :         return _Buynode(_Val);

  000f8	8b c3		 mov	 eax, ebx

; 362  :         _Newnode._Ptr->_Color = _Red;

  000fa	66 c7 43 0c 00
	00		 mov	 WORD PTR [ebx+12], 0

; 1745 :     }

  00100	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00103	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010a	59		 pop	 ecx
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00111	33 cd		 xor	 ecx, ebp
  00113	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Newnode$26[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
__unwindfunclet$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z$2:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR __Guard$25[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
__unwindfunclet$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z$3:
  00010	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$27[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Copy_or_move@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Copy_or_move<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,std::integral_constant<bool,0> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$GSCopy$1$ = -4					; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_tree_and_orphan<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; _this$ = ecx

; 732  :     void _Erase_tree_and_orphan(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	8b 75 0c	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	89 45 fc	 mov	 DWORD PTR __Al$GSCopy$1$[ebp], eax

; 733  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00011	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00015	75 2d		 jne	 SHORT $LN3@Erase_tree
  00017	57		 push	 edi
$LL2@Erase_tree:

; 734  :             _Erase_tree_and_orphan(_Al, _Rootnode->_Right);

  00018	ff 76 08	 push	 DWORD PTR [esi+8]
  0001b	8b cb		 mov	 ecx, ebx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_tree_and_orphan<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b fe		 mov	 edi, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00027	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 673  :         _Tidy();

  0002a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002f	6a 20		 push	 32			; 00000020H
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 733  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00037	8b 45 fc	 mov	 eax, DWORD PTR __Al$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0003a	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 733  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0003d	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00041	74 d5		 je	 SHORT $LL2@Erase_tree
  00043	5f		 pop	 edi
$LN3@Erase_tree:
  00044	5e		 pop	 esi

; 735  :             auto _To_delete = _STD exchange(_Rootnode, _Rootnode->_Left);
; 736  :             _Orphan_ptr(_To_delete);
; 737  :             _Alnode::value_type::_Freenode(_Al, _To_delete);
; 738  :         }
; 739  :     }

  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Erase_tree_and_orphan<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@YAPAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@YAPAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@0@AAU10@@Z PROC ; std::addressof<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@YAPAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$destroy@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::destroy<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 675  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 673  :         _Tidy();

  00003	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy
??$destroy@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::destroy<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??_G?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_G?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAEPAXI@Z PROC ; std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 673  :         _Tidy();

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00006	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy
  0000b	8b c6		 mov	 eax, esi
  0000d	5e		 pop	 esi
  0000e	c2 04 00	 ret	 4
??_G?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAEPAXI@Z ENDP ; std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??1?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ PROC ; std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >, COMDAT
; _this$ = ecx
  00000	83 c1 04	 add	 ecx, 4

; 673  :         _Tidy();

  00003	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy
??1?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ ENDP ; std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??1?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ PROC ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::~vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >, COMDAT
; _this$ = ecx

; 673  :         _Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy
??1?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ENDP ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::~vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Orphan_ptr, COMDAT
; _this$dead$ = ecx

; 714  : #if _ITERATOR_DEBUG_LEVEL == 2
; 715  :         _Lockit _Lock(_LOCK_DEBUG);
; 716  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 717  :         while (*_Pnext) {
; 718  :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 719  :             if (_Pnextptr == _Myhead || (_Ptr != nullptr && _Pnextptr != _Ptr)) {
; 720  :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 721  :             } else { // orphan the iterator
; 722  :                 (*_Pnext)->_Myproxy = nullptr;
; 723  :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 724  :             }
; 725  :         }
; 726  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 727  :         (void) _Ptr;
; 728  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 729  :     }

  00000	c2 04 00	 ret	 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > > >::_Orphan_ptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ PROC ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;
; 1687 :         pointer& _Myfirst = _My_data._Myfirst;
; 1688 :         pointer& _Mylast  = _My_data._Mylast;
; 1689 :         pointer& _Myend   = _My_data._Myend;
; 1690 : 
; 1691 :         _My_data._Orphan_all();
; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 63		 je	 SHORT $LN2@Tidy

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00009	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0000c	56		 push	 esi
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00013	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00016	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001b	8b 37		 mov	 esi, DWORD PTR [edi]

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0001d	83 c4 04	 add	 esp, 4

; 1694 :             _Destroy(_Myfirst, _Mylast);
; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00020	2b ce		 sub	 ecx, esi
  00022	f7 e9		 imul	 ecx
  00024	d1 fa		 sar	 edx, 1
  00026	8b c2		 mov	 eax, edx
  00028	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002b	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002d	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00030	c1 e1 02	 shl	 ecx, 2

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00033	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN20@Tidy

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003b	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  0003e	83 c1 23	 add	 ecx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b f2		 sub	 esi, edx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 23		 ja	 SHORT $LN17@Tidy

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004b	8b f2		 mov	 esi, edx
$LN20@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0004d	51		 push	 ecx
  0004e	56		 push	 esi
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1697 :             _Myfirst = pointer();

  00057	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1698 :             _Mylast  = pointer();

  0005d	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1699 :             _Myend   = pointer();

  00064	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  0006b	5e		 pop	 esi
$LN2@Tidy:

; 1701 :     }

  0006c	5f		 pop	 edi
  0006d	c3		 ret	 0
$LN17@Tidy:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Tidy:
  00074	cc		 int	 3
?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ ENDP ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Getal@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEAAV?$allocator@UImportInfo@SegmentHeader@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEAAV?$allocator@UImportInfo@SegmentHeader@@@2@XZ PROC ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1733 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEAAV?$allocator@UImportInfo@SegmentHeader@@@2@XZ ENDP ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Destroy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXPAUImportInfo@SegmentHeader@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXPAUImportInfo@SegmentHeader@@0@Z PROC ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00006	51		 push	 ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
  0000f	83 c4 04	 add	 esp, 4

; 1613 :     }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?_Destroy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXPAUImportInfo@SegmentHeader@@0@Z ENDP ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$allocator@UImportInfo@SegmentHeader@@@std@@QAEXQAUImportInfo@SegmentHeader@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UImportInfo@SegmentHeader@@@std@@QAEXQAUImportInfo@SegmentHeader@@I@Z PROC ; std::allocator<SegmentHeader::ImportInfo>::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0000c	c1 e2 02	 shl	 edx, 2

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000f	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00015	72 14		 jb	 SHORT $LN15@deallocate

; 108  :     _Bytes += _Non_user_size;

  00017	56		 push	 esi

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00018	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
  0001b	83 c2 23	 add	 edx, 35			; 00000023H

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001e	2b ce		 sub	 ecx, esi

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00020	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 11		 ja	 SHORT $LN12@deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00028	8b ce		 mov	 ecx, esi
  0002a	5e		 pop	 esi
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8

; 781  :     }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN12@deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003f	cc		 int	 3
?deallocate@?$allocator@UImportInfo@SegmentHeader@@@std@@QAEXQAUImportInfo@SegmentHeader@@I@Z ENDP ; std::allocator<SegmentHeader::ImportInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QAEAAV?$allocator@UImportInfo@SegmentHeader@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QAEAAV?$allocator@UImportInfo@SegmentHeader@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1337 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QAEAAV?$allocator@UImportInfo@SegmentHeader@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Guard$24 = -52					; size = 4
__Newnode$25 = -48					; size = 8
__Myhead$1$ = -40					; size = 4
__Rightlast$1$ = -36					; size = 4
__My_data$1$ = -32					; size = 4
__Backout$26 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_<_Val_0>$ = 8						; size = 4
??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Buynode<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>, COMDAT
; _this$ = ecx

; 2029 :     _Nodeptr _Buynode(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2030 :         return _Node::_Buynode(_Getal(), _Get_scary()->_Myhead, _STD forward<_Valty>(_Val)...);

  0002b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002d	8b 7d 08	 mov	 edi, DWORD PTR _<_Val_0>$[ebp]
  00030	89 45 d8	 mov	 DWORD PTR __Myhead$1$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00033	89 4d d0	 mov	 DWORD PTR __Newnode$25[ebp], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 356  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);

  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0003d	6a 20		 push	 32			; 00000020H

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0003f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR __Newnode$25[ebp+4], 0

; 51   :         return ::operator new(_Bytes);

  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  0004b	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1044 :         _Ptr = _Al.allocate(1);

  0004d	8b d8		 mov	 ebx, eax
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  0004f	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1044 :         _Ptr = _Al.allocate(1);

  00052	89 5d d4	 mov	 DWORD PTR __Newnode$25[ebp+4], ebx
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  00055	89 45 e0	 mov	 DWORD PTR __My_data$1$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00058	83 c4 04	 add	 esp, 4
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  0005b	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0005e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00064	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0006b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  00072	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00075	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00078	89 45 dc	 mov	 DWORD PTR __Rightlast$1$[ebp], eax

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  0007b	3b f0		 cmp	 esi, eax
  0007d	74 6e		 je	 SHORT $LN69@Buynode

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  0007f	8b 5d e0	 mov	 ebx, DWORD PTR __My_data$1$[ebp]
  00082	8b c8		 mov	 ecx, eax
  00084	2b ce		 sub	 ecx, esi
  00086	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0008b	f7 e9		 imul	 ecx
  0008d	8b cb		 mov	 ecx, ebx
  0008f	d1 fa		 sar	 edx, 1
  00091	8b c2		 mov	 eax, edx
  00093	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00096	03 c2		 add	 eax, edx
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXI@Z ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Buy_raw

; 529  :             _Tidy_guard<vector> _Guard{this};

  0009e	89 5d cc	 mov	 DWORD PTR __Guard$24[ebp], ebx

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  000a1	8b 3b		 mov	 edi, DWORD PTR [ebx]
  000a3	0f 57 c0	 xorps	 xmm0, xmm0
  000a6	66 0f d6 45 e4	 movq	 QWORD PTR __Backout$26[ebp], xmm0
  000ab	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Backout$26[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000b2	89 7d e4	 mov	 DWORD PTR __Backout$26[ebp], edi
  000b5	89 7d e8	 mov	 DWORD PTR __Backout$26[ebp+4], edi
  000b8	89 5d ec	 mov	 DWORD PTR __Backout$26[ebp+8], ebx
  000bb	8b 5d dc	 mov	 ebx, DWORD PTR __Rightlast$1$[ebp]

; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  000be	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
$LL53@Buynode:

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  000c2	56		 push	 esi
  000c3	8b cf		 mov	 ecx, edi
  000c5	e8 00 00 00 00	 call	 ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z

; 1499 :         ++_Last;

  000ca	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000cd	83 c6 0c	 add	 esi, 12			; 0000000cH

; 1499 :         ++_Last;

  000d0	89 7d e8	 mov	 DWORD PTR __Backout$26[ebp+4], edi

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000d3	3b f3		 cmp	 esi, ebx
  000d5	75 eb		 jne	 SHORT $LL53@Buynode

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000d7	51		 push	 ecx
  000d8	8b d7		 mov	 edx, edi
  000da	8b cf		 mov	 ecx, edi
  000dc	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000e1	8b 45 e0	 mov	 eax, DWORD PTR __My_data$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000e4	83 c4 04	 add	 esp, 4
  000e7	8b 5d d4	 mov	 ebx, DWORD PTR __Newnode$25[ebp+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000ea	89 78 04	 mov	 DWORD PTR [eax+4], edi
$LN69@Buynode:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 359  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);

  000ed	8b 45 d8	 mov	 eax, DWORD PTR __Myhead$1$[ebp]
  000f0	89 03		 mov	 DWORD PTR [ebx], eax

; 360  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);

  000f2	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 361  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);

  000f5	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 2030 :         return _Node::_Buynode(_Getal(), _Get_scary()->_Myhead, _STD forward<_Valty>(_Val)...);

  000f8	8b c3		 mov	 eax, ebx

; 362  :         _Newnode._Ptr->_Color = _Red;

  000fa	66 c7 43 0c 00
	00		 mov	 WORD PTR [ebx+12], 0

; 2031 :     }

  00100	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00103	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010a	59		 pop	 ecx
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00111	33 cd		 xor	 ecx, ebp
  00113	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Newnode$25[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
__unwindfunclet$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$2:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR __Guard$24[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
__unwindfunclet$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$3:
  00010	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$26[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@U?$less@PBD@2@V?$allocator@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@1@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<char const *,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >,std::less<char const *>,std::allocator<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > >,0> >::_Buynode<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 940  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b da		 mov	 ebx, edx

; 941  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 942  :     using _Ty = typename _Alloc::value_type;
; 943  :     if
; 944  :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 945  :             (void) _First;
; 946  :             (void) _Last;
; 947  :             (void) _Al;
; 948  :         }
; 949  :     else {
; 950  :         for (; _First != _Last; ++_First) {

  00006	3b cb		 cmp	 ecx, ebx
  00008	74 4f		 je	 SHORT $LN3@Destroy_ra

; 940  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  0000f	90		 npad	 1
$LL4@Destroy_ra:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00010	8b 07		 mov	 eax, DWORD PTR [edi]
  00012	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00015	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00019	75 27		 jne	 SHORT $LN23@Destroy_ra
  0001b	0f 1f 44 00 00	 npad	 5
$LL22@Destroy_ra:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00020	ff 76 08	 push	 DWORD PTR [esi+8]
  00023	8b cf		 mov	 ecx, edi
  00025	57		 push	 edi
  00026	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b c6		 mov	 eax, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  0002d	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0002f	6a 18		 push	 24			; 00000018H
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00037	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0003a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0003e	74 e0		 je	 SHORT $LL22@Destroy_ra
  00040	8b 07		 mov	 eax, DWORD PTR [edi]
$LN23@Destroy_ra:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00042	6a 18		 push	 24			; 00000018H
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete

; 941  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 942  :     using _Ty = typename _Alloc::value_type;
; 943  :     if
; 944  :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 945  :             (void) _First;
; 946  :             (void) _Last;
; 947  :             (void) _Al;
; 948  :         }
; 949  :     else {
; 950  :         for (; _First != _Last; ++_First) {

  0004a	83 c7 0c	 add	 edi, 12			; 0000000cH

; 195  :     ::operator delete(_Ptr, _Bytes);

  0004d	83 c4 08	 add	 esp, 8

; 941  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 942  :     using _Ty = typename _Alloc::value_type;
; 943  :     if
; 944  :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 945  :             (void) _First;
; 946  :             (void) _Last;
; 947  :             (void) _Al;
; 948  :         }
; 949  :     else {
; 950  :         for (; _First != _Last; ++_First) {

  00050	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00053	3b c3		 cmp	 eax, ebx
  00055	75 b9		 jne	 SHORT $LL4@Destroy_ra
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
$LN3@Destroy_ra:
  00059	5b		 pop	 ebx

; 951  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 952  :         }
; 953  :     }
; 954  : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@YAAAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@YAAAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@0@AAU10@@Z PROC ; std::forward<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@@std@@YAAAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Guard$21 = -52					; size = 4
__Newnode$ = -48					; size = 8
__Myhead$1$ = -40					; size = 4
__Rightlast$1$ = -36					; size = 4
__My_data$1$ = -32					; size = 4
__Backout$22 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_<_Val_0>$ = 8						; size = 4
??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z PROC ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Buynode<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>, COMDAT
; __Al$ = ecx
; __Myhead$ = edx

; 353  :     static _Nodeptr _Buynode(_Alloc& _Al, _Nodeptr _Myhead, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 55 d8	 mov	 DWORD PTR __Myhead$1$[ebp], edx
  0002e	8b 7d 08	 mov	 edi, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00031	89 4d d0	 mov	 DWORD PTR __Newnode$[ebp], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 356  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0003b	6a 20		 push	 32			; 00000020H

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0003d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR __Newnode$[ebp+4], 0

; 51   :         return ::operator new(_Bytes);

  00044	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  00049	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1044 :         _Ptr = _Al.allocate(1);

  0004b	8b d8		 mov	 ebx, eax
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  0004d	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1044 :         _Ptr = _Al.allocate(1);

  00050	89 5d d4	 mov	 DWORD PTR __Newnode$[ebp+4], ebx
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  00053	89 45 e0	 mov	 DWORD PTR __My_data$1$[ebp], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00056	83 c4 04	 add	 esp, 4
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  00059	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00069	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  00070	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00073	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00076	89 45 dc	 mov	 DWORD PTR __Rightlast$1$[ebp], eax

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  00079	3b f0		 cmp	 esi, eax
  0007b	74 6e		 je	 SHORT $LN67@Buynode

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  0007d	8b 5d e0	 mov	 ebx, DWORD PTR __My_data$1$[ebp]
  00080	8b c8		 mov	 ecx, eax
  00082	2b ce		 sub	 ecx, esi
  00084	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00089	f7 e9		 imul	 ecx
  0008b	8b cb		 mov	 ecx, ebx
  0008d	d1 fa		 sar	 edx, 1
  0008f	8b c2		 mov	 eax, edx
  00091	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00094	03 c2		 add	 eax, edx
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXI@Z ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Buy_raw

; 529  :             _Tidy_guard<vector> _Guard{this};

  0009c	89 5d cc	 mov	 DWORD PTR __Guard$21[ebp], ebx

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  0009f	8b 3b		 mov	 edi, DWORD PTR [ebx]
  000a1	0f 57 c0	 xorps	 xmm0, xmm0
  000a4	66 0f d6 45 e4	 movq	 QWORD PTR __Backout$22[ebp], xmm0
  000a9	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Backout$22[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000b0	89 7d e4	 mov	 DWORD PTR __Backout$22[ebp], edi
  000b3	89 7d e8	 mov	 DWORD PTR __Backout$22[ebp+4], edi
  000b6	89 5d ec	 mov	 DWORD PTR __Backout$22[ebp+8], ebx
  000b9	8b 5d dc	 mov	 ebx, DWORD PTR __Rightlast$1$[ebp]

; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  000bc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
$LL51@Buynode:

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  000c0	56		 push	 esi
  000c1	8b cf		 mov	 ecx, edi
  000c3	e8 00 00 00 00	 call	 ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z

; 1499 :         ++_Last;

  000c8	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000cb	83 c6 0c	 add	 esi, 12			; 0000000cH

; 1499 :         ++_Last;

  000ce	89 7d e8	 mov	 DWORD PTR __Backout$22[ebp+4], edi

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000d1	3b f3		 cmp	 esi, ebx
  000d3	75 eb		 jne	 SHORT $LL51@Buynode

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000d5	51		 push	 ecx
  000d6	8b d7		 mov	 edx, edi
  000d8	8b cf		 mov	 ecx, edi
  000da	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000df	8b 45 e0	 mov	 eax, DWORD PTR __My_data$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000e2	83 c4 04	 add	 esp, 4
  000e5	8b 5d d4	 mov	 ebx, DWORD PTR __Newnode$[ebp+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000e8	89 78 04	 mov	 DWORD PTR [eax+4], edi
$LN67@Buynode:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 359  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);

  000eb	8b 45 d8	 mov	 eax, DWORD PTR __Myhead$1$[ebp]
  000ee	89 03		 mov	 DWORD PTR [ebx], eax

; 360  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);

  000f0	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 361  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);

  000f3	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 362  :         _Newnode._Ptr->_Color = _Red;
; 363  :         _Newnode._Ptr->_Isnil = false;
; 364  :         return _Newnode._Release();

  000f6	8b c3		 mov	 eax, ebx
  000f8	66 c7 43 0c 00
	00		 mov	 WORD PTR [ebx+12], 0

; 365  :     }

  000fe	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00101	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00108	59		 pop	 ecx
  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	5b		 pop	 ebx
  0010c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010f	33 cd		 xor	 ecx, ebp
  00111	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Newnode$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
__unwindfunclet$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$2:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR __Guard$21[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
__unwindfunclet$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z$3:
  00010	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$22[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@2@@?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@PAU01@AAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *>::_Buynode<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >,std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$_Unfancy@UImportInfo@SegmentHeader@@@std@@YAPAUImportInfo@SegmentHeader@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@UImportInfo@SegmentHeader@@@std@@YAPAUImportInfo@SegmentHeader@@PAU12@@Z PROC ; std::_Unfancy<SegmentHeader::ImportInfo>, COMDAT
; __Ptr$ = ecx

; 289  :     return _Ptr;

  00000	8b c1		 mov	 eax, ecx

; 290  : }

  00002	c3		 ret	 0
??$_Unfancy@UImportInfo@SegmentHeader@@@std@@YAPAUImportInfo@SegmentHeader@@PAU12@@Z ENDP ; std::_Unfancy<SegmentHeader::ImportInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$destroy@UImportInfo@SegmentHeader@@@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SAXAAV?$allocator@UImportInfo@SegmentHeader@@@1@QAUImportInfo@SegmentHeader@@@Z
_TEXT	SEGMENT
??$destroy@UImportInfo@SegmentHeader@@@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SAXAAV?$allocator@UImportInfo@SegmentHeader@@@1@QAUImportInfo@SegmentHeader@@@Z PROC ; std::_Default_allocator_traits<std::allocator<SegmentHeader::ImportInfo> >::destroy<SegmentHeader::ImportInfo>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 675  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00008	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0000b	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0000f	75 22		 jne	 SHORT $LN18@destroy
$LL17@destroy:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00011	ff 76 08	 push	 DWORD PTR [esi+8]
  00014	8b cf		 mov	 ecx, edi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0001c	8b c6		 mov	 eax, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00020	6a 18		 push	 24			; 00000018H
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00028	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0002b	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002f	74 e0		 je	 SHORT $LL17@destroy
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00031	8b 07		 mov	 eax, DWORD PTR [edi]
$LN18@destroy:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00033	6a 18		 push	 24			; 00000018H
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 676  :         _Ptr->~_Uty();
; 677  :     }

  00040	c3		 ret	 0
??$destroy@UImportInfo@SegmentHeader@@@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SAXAAV?$allocator@UImportInfo@SegmentHeader@@@1@QAUImportInfo@SegmentHeader@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SegmentHeader::ImportInfo> >::destroy<SegmentHeader::ImportInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??_GImportInfo@SegmentHeader@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GImportInfo@SegmentHeader@@QAEPAXI@Z PROC		; SegmentHeader::ImportInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx
  00006	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
  0000e	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00011	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00015	75 22		 jne	 SHORT $LN16@scalar
$LL15@scalar:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00017	ff 76 08	 push	 DWORD PTR [esi+8]
  0001a	8b cf		 mov	 ecx, edi
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00022	8b c6		 mov	 eax, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00024	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00026	6a 18		 push	 24			; 00000018H
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002e	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00031	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00035	74 e0		 je	 SHORT $LL15@scalar
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00037	8b 07		 mov	 eax, DWORD PTR [edi]
$LN16@scalar:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00039	6a 18		 push	 24			; 00000018H
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00041	83 c4 08	 add	 esp, 8
  00044	8b c3		 mov	 eax, ebx
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??_GImportInfo@SegmentHeader@@QAEPAXI@Z ENDP		; SegmentHeader::ImportInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1ImportInfo@SegmentHeader@@QAE@XZ
_TEXT	SEGMENT
??1ImportInfo@SegmentHeader@@QAE@XZ PROC		; SegmentHeader::ImportInfo::~ImportInfo, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  00008	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0000b	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0000f	75 22		 jne	 SHORT $LN12@ImportInfo
$LL11@ImportInfo:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00011	ff 76 08	 push	 DWORD PTR [esi+8]
  00014	8b cf		 mov	 ecx, edi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0001c	8b c6		 mov	 eax, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00020	6a 18		 push	 24			; 00000018H
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00028	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0002b	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002f	74 e0		 je	 SHORT $LL11@ImportInfo
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00031	8b 07		 mov	 eax, DWORD PTR [edi]
$LN12@ImportInfo:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00033	6a 18		 push	 24			; 00000018H
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	c3		 ret	 0
??1ImportInfo@SegmentHeader@@QAE@XZ ENDP		; SegmentHeader::ImportInfo::~ImportInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@XZ PROC ; std::multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::~multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8b 07		 mov	 eax, DWORD PTR [edi]
  00006	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0000d	75 23		 jne	 SHORT $LN9@multimap
  0000f	90		 npad	 1
$LL8@multimap:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00010	ff 76 08	 push	 DWORD PTR [esi+8]
  00013	8b cf		 mov	 ecx, edi
  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0001b	8b c6		 mov	 eax, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0001f	6a 18		 push	 24			; 00000018H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0002a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002e	74 e0		 je	 SHORT $LL8@multimap
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b 07		 mov	 eax, DWORD PTR [edi]
$LN9@multimap:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00032	6a 18		 push	 24			; 00000018H
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003a	83 c4 08	 add	 esp, 8
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	c3		 ret	 0
??1?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@XZ ENDP ; std::multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::~multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; _this$ = ecx

; 1048 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 195  :     ::operator delete(_Ptr, _Bytes);

  00007	6a 20		 push	 32			; 00000020H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 1049 :             _Al.deallocate(_Ptr, 1);
; 1050 :         }
; 1051 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1042 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 51   :         return ::operator new(_Bytes);

  00003	6a 20		 push	 32			; 00000020H

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00005	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 51   :         return ::operator new(_Bytes);

  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 1044 :         _Ptr = _Al.allocate(1);

  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	5e		 pop	 esi

; 1045 :     }

  00018	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::_Release, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00003	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1040 :     }

  0000a	c3		 ret	 0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >, COMDAT
; _this$ = ecx

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::~_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >, COMDAT
; _this$ = ecx

; 1187 :     ~_Tree() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00004	8b 07		 mov	 eax, DWORD PTR [edi]
  00006	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0000d	75 23		 jne	 SHORT $LN7@Tree
  0000f	90		 npad	 1
$LL6@Tree:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00010	ff 76 08	 push	 DWORD PTR [esi+8]
  00013	8b cf		 mov	 ecx, edi
  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0001b	8b c6		 mov	 eax, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  0001f	6a 18		 push	 24			; 00000018H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0002a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002e	74 e0		 je	 SHORT $LL6@Tree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b 07		 mov	 eax, DWORD PTR [edi]
$LN7@Tree:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00032	6a 18		 push	 24			; 00000018H
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003a	83 c4 08	 add	 esp, 8
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 1194 :     }

  0003f	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::~_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 195  :     ::operator delete(_Ptr, _Bytes);

  00006	6a 20		 push	 32			; 00000020H
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 781  :     }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Get_scary, COMDAT
; _this$ = ecx

; 2050 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00000	8b c1		 mov	 eax, ecx

; 2051 :     }

  00002	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Getal, COMDAT
; _this$ = ecx

; 2042 :         return _Mypair._Myval2._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2043 :     }

  00002	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1336 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1337 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z
_TEXT	SEGMENT
__Guard$13 = -36					; size = 4
__My_data$1$ = -32					; size = 4
__Backout$14 = -28					; size = 12
__$ArrayPad$15 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_<_Args_0>$ = 8						; size = 4
??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::construct<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$15[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  0002e	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00031	89 7d e0	 mov	 DWORD PTR __My_data$1$[ebp], edi
  00034	8b 01		 mov	 eax, DWORD PTR [ecx]
  00036	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00038	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0003e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00045	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  0004c	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  0004f	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  00052	3b f3		 cmp	 esi, ebx
  00054	74 72		 je	 SHORT $LN35@construct

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00056	8b cb		 mov	 ecx, ebx
  00058	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0005d	2b ce		 sub	 ecx, esi
  0005f	f7 e9		 imul	 ecx
  00061	8b cf		 mov	 ecx, edi
  00063	d1 fa		 sar	 edx, 1
  00065	8b c2		 mov	 eax, edx
  00067	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0006a	03 c2		 add	 eax, edx
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXI@Z ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Buy_raw

; 529  :             _Tidy_guard<vector> _Guard{this};

  00072	89 7d dc	 mov	 DWORD PTR __Guard$13[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00075	8b 45 e0	 mov	 eax, DWORD PTR __My_data$1$[ebp]
  00078	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 529  :             _Tidy_guard<vector> _Guard{this};

  0007b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00082	8b 3f		 mov	 edi, DWORD PTR [edi]
  00084	66 0f d6 45 e4	 movq	 QWORD PTR __Backout$14[ebp], xmm0
  00089	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Backout$14[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00090	89 7d e4	 mov	 DWORD PTR __Backout$14[ebp], edi
  00093	89 7d e8	 mov	 DWORD PTR __Backout$14[ebp+4], edi
  00096	89 45 ec	 mov	 DWORD PTR __Backout$14[ebp+8], eax

; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00099	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0009d	0f 1f 00	 npad	 3
$LL19@construct:

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  000a0	56		 push	 esi
  000a1	8b cf		 mov	 ecx, edi
  000a3	e8 00 00 00 00	 call	 ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z

; 1499 :         ++_Last;

  000a8	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000ab	83 c6 0c	 add	 esi, 12			; 0000000cH

; 1499 :         ++_Last;

  000ae	89 7d e8	 mov	 DWORD PTR __Backout$14[ebp+4], edi

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000b1	3b f3		 cmp	 esi, ebx
  000b3	75 eb		 jne	 SHORT $LL19@construct

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000b5	51		 push	 ecx
  000b6	8b d7		 mov	 edx, edi
  000b8	8b cf		 mov	 ecx, edi
  000ba	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000bf	8b 45 e0	 mov	 eax, DWORD PTR __My_data$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000c2	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000c5	89 78 04	 mov	 DWORD PTR [eax+4], edi
$LN35@construct:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 672  :     }

  000c8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d2	59		 pop	 ecx
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$15[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z$1:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Guard$13[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
__unwindfunclet$??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z$2:
  00008	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$14[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@1@QAU?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@1@AAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> > >::construct<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > > &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@0@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

  00004	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::nullptr_t>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 572  :     // assign _New_val to _Val, return previous _Val
; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	8b 12		 mov	 edx, DWORD PTR [edx]
  00004	89 11		 mov	 DWORD PTR [ecx], edx

; 575  :     return _Old_val;
; 576  : }

  00006	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 750  :     void _Erase_head(_Alnode& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 751  :         this->_Orphan_all();
; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  0000b	8b 07		 mov	 eax, DWORD PTR [edi]
  0000d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00010	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00014	75 22		 jne	 SHORT $LN5@Erase_head
$LL4@Erase_head:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00016	ff 76 08	 push	 DWORD PTR [esi+8]
  00019	8b cf		 mov	 ecx, edi
  0001b	53		 push	 ebx
  0001c	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00021	8b c6		 mov	 eax, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00023	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00025	6a 18		 push	 24			; 00000018H
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002d	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00030	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00034	74 e0		 je	 SHORT $LL4@Erase_head
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00036	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@Erase_head:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00038	6a 18		 push	 24			; 00000018H
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00040	83 c4 08	 add	 esp, 8
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 754  :     }

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp
;	COMDAT ??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
__Guard$11 = -40					; size = 4
_this$GSCopy$1$ = -36					; size = 4
__My_data$1$ = -32					; size = 4
_this$GSCopy$ = -32					; size = 4
_this$ = -32						; size = 4
__Backout$12 = -28					; size = 12
__$ArrayPad$13 = -16					; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z PROC ; std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >, COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$13[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d1		 mov	 edx, ecx
  0002d	89 55 dc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], edx
  00030	89 55 e0	 mov	 DWORD PTR _this$[ebp], edx
  00033	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00036	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00039	89 55 e0	 mov	 DWORD PTR _this$GSCopy$[ebp], edx
  0003c	89 7d e0	 mov	 DWORD PTR __My_data$1$[ebp], edi
  0003f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00041	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00043	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00049	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00050	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00057	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  0005a	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]

; 527  :         if (_Rightfirst != _Rightlast) {

  0005d	3b f3		 cmp	 esi, ebx
  0005f	74 74		 je	 SHORT $LN39@pair

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00061	8b cb		 mov	 ecx, ebx
  00063	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00068	2b ce		 sub	 ecx, esi
  0006a	f7 e9		 imul	 ecx
  0006c	8b cf		 mov	 ecx, edi
  0006e	d1 fa		 sar	 edx, 1
  00070	8b c2		 mov	 eax, edx
  00072	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00075	03 c2		 add	 eax, edx
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXI@Z ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Buy_raw

; 529  :             _Tidy_guard<vector> _Guard{this};

  0007d	89 7d d8	 mov	 DWORD PTR __Guard$11[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00080	8b 45 e0	 mov	 eax, DWORD PTR __My_data$1$[ebp]
  00083	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 529  :             _Tidy_guard<vector> _Guard{this};

  00086	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  0008d	8b 3f		 mov	 edi, DWORD PTR [edi]
  0008f	66 0f d6 45 e4	 movq	 QWORD PTR __Backout$12[ebp], xmm0
  00094	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Backout$12[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0009b	89 7d e4	 mov	 DWORD PTR __Backout$12[ebp], edi
  0009e	89 7d e8	 mov	 DWORD PTR __Backout$12[ebp+4], edi
  000a1	89 45 ec	 mov	 DWORD PTR __Backout$12[ebp+8], eax

; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  000a4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
$LL17@pair:

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  000a8	56		 push	 esi
  000a9	8b cf		 mov	 ecx, edi
  000ab	e8 00 00 00 00	 call	 ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z

; 1499 :         ++_Last;

  000b0	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000b3	83 c6 0c	 add	 esi, 12			; 0000000cH

; 1499 :         ++_Last;

  000b6	89 7d e8	 mov	 DWORD PTR __Backout$12[ebp+4], edi

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000b9	3b f3		 cmp	 esi, ebx
  000bb	75 eb		 jne	 SHORT $LL17@pair

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000bd	51		 push	 ecx
  000be	8b d7		 mov	 edx, edi
  000c0	8b cf		 mov	 ecx, edi
  000c2	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000c7	8b 45 e0	 mov	 eax, DWORD PTR __My_data$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000ca	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000cd	89 78 04	 mov	 DWORD PTR [eax+4], edi
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  000d0	8b 45 dc	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 527  :         if (_Rightfirst != _Rightlast) {

  000d3	eb 02		 jmp	 SHORT $LN33@pair
$LN39@pair:
; File C:\Users\Neonik\Desktop\CSGO Cheat Sources\OTC-Source\otc\cpp\runtime\RuntimeHandler.cpp

  000d5	8b c2		 mov	 eax, edx
$LN33@pair:
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e1	59		 pop	 ecx
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$13[ebp]
  000e8	33 cd		 xor	 ecx, ebp
  000ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z$1:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Guard$11[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
__unwindfunclet$??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z$2:
  00008	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$12[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@ABU01@@Z ENDP ; std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Guard$10 = -40					; size = 4
_this$GSCopy$1$ = -36					; size = 4
__Rightlast$1$ = -32					; size = 4
__Backout$11 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >, COMDAT
; _this$ = ecx

; 519  :     vector(const vector& _Right)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d dc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  00030	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00033	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00039	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00040	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 520  :         : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 521  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 522  :         auto& _My_data            = _Mypair._Myval2;
; 523  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 524  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00047	8b 30		 mov	 esi, DWORD PTR [eax]

; 525  :         const pointer _Rightlast  = _Right_data._Mylast;

  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	89 45 e0	 mov	 DWORD PTR __Rightlast$1$[ebp], eax

; 526  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 527  :         if (_Rightfirst != _Rightlast) {

  0004f	3b f0		 cmp	 esi, eax
  00051	74 75		 je	 SHORT $LN36@vector

; 528  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00053	8b c8		 mov	 ecx, eax
  00055	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0005a	2b ce		 sub	 ecx, esi
  0005c	f7 e9		 imul	 ecx
  0005e	8b cb		 mov	 ecx, ebx
  00060	d1 fa		 sar	 edx, 1
  00062	8b c2		 mov	 eax, edx
  00064	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00067	03 c2		 add	 eax, edx
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXI@Z ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Buy_raw

; 529  :             _Tidy_guard<vector> _Guard{this};

  0006f	89 5d d8	 mov	 DWORD PTR __Guard$10[ebp], ebx
  00072	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00079	0f 57 c0	 xorps	 xmm0, xmm0

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  0007c	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0007e	66 0f d6 45 e4	 movq	 QWORD PTR __Backout$11[ebp], xmm0
  00083	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Backout$11[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0008a	89 7d e4	 mov	 DWORD PTR __Backout$11[ebp], edi
  0008d	89 7d e8	 mov	 DWORD PTR __Backout$11[ebp+4], edi
  00090	89 5d ec	 mov	 DWORD PTR __Backout$11[ebp+8], ebx
  00093	8b 5d e0	 mov	 ebx, DWORD PTR __Rightlast$1$[ebp]

; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00096	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL14@vector:

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  000a0	56		 push	 esi
  000a1	8b cf		 mov	 ecx, edi
  000a3	e8 00 00 00 00	 call	 ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z

; 1499 :         ++_Last;

  000a8	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000ab	83 c6 0c	 add	 esi, 12			; 0000000cH

; 1499 :         ++_Last;

  000ae	89 7d e8	 mov	 DWORD PTR __Backout$11[ebp+4], edi

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  000b1	3b f3		 cmp	 esi, ebx
  000b3	75 eb		 jne	 SHORT $LL14@vector

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000b5	51		 push	 ecx
  000b6	8b d7		 mov	 edx, edi
  000b8	8b cf		 mov	 ecx, edi
  000ba	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000bf	8b 5d dc	 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1493 :         _Destroy_range(_First, _Last, _Al);

  000c2	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 530  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000c5	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
$LN36@vector:

; 531  :             _Guard._Target   = nullptr;
; 532  :         }
; 533  : 
; 534  :         _Proxy._Release();
; 535  :     }

  000c8	8b c3		 mov	 eax, ebx
  000ca	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d4	59		 pop	 ecx
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Guard$10[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
__unwindfunclet$??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z$1:
  00008	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$11[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??1?$_Tidy_guard@V?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >, COMDAT
; _this$ = ecx

; 5693 :         if (_Target) {

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	0f 85 00 00 00
	00		 jne	 ?_Tidy@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXXZ ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Tidy

; 5694 :             _Target->_Tidy();
; 5695 :         }
; 5696 :     }

  0000a	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >::~_Tidy_guard<std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Getal@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@ABEABV?$allocator@UImportInfo@SegmentHeader@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@ABEABV?$allocator@UImportInfo@SegmentHeader@@@2@XZ PROC ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Getal, COMDAT
; _this$ = ecx

; 1736 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1737 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@ABEABV?$allocator@UImportInfo@SegmentHeader@@@2@XZ ENDP ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ?_Buy_raw@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXI@Z PROC ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1632 :     void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 34   :             if (_Count > _Max_possible) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1632 :     void _Buy_raw(const size_type _Newcapacity) {

  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 34   :             if (_Count > _Max_possible) {

  0000a	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0000f	77 72		 ja	 SHORT $LN30@Buy_raw

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  00011	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  00014	c1 e6 02	 shl	 esi, 2

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00017	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  0001d	72 35		 jb	 SHORT $LN10@Buy_raw

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001f	8d 46 23	 lea	 eax, DWORD PTR [esi+35]

; 90   :     if (_Block_size <= _Bytes) {

  00022	3b c6		 cmp	 eax, esi
  00024	76 5d		 jbe	 SHORT $LN30@Buy_raw

; 51   :         return ::operator new(_Bytes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0002c	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  0002e	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00031	85 c9		 test	 ecx, ecx
  00033	74 19		 je	 SHORT $LN19@Buy_raw

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  0003e	89 07		 mov	 DWORD PTR [edi], eax

; 1644 :         _Mylast            = _Newvec;

  00040	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00043	03 c6		 add	 eax, esi
  00045	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi

; 1646 :     }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
$LN19@Buy_raw:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN10@Buy_raw:

; 179  :     if (_Bytes != 0) {

  00054	85 f6		 test	 esi, esi
  00056	74 19		 je	 SHORT $LN11@Buy_raw

; 51   :         return ::operator new(_Bytes);

  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  0005e	89 07		 mov	 DWORD PTR [edi], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00060	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1644 :         _Mylast            = _Newvec;

  00063	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00066	03 c6		 add	 eax, esi
  00068	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi

; 1646 :     }

  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
$LN11@Buy_raw:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 183  :     return nullptr;

  00071	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1643 :         _Myfirst           = _Newvec;

  00073	89 07		 mov	 DWORD PTR [edi], eax

; 1644 :         _Mylast            = _Newvec;

  00075	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1645 :         _Myend             = _Newvec + _Newcapacity;

  00078	8b c6		 mov	 eax, esi
  0007a	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi

; 1646 :     }

  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
$LN30@Buy_raw:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

  00083	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN31@Buy_raw:
  00088	cc		 int	 3
?_Buy_raw@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEXI@Z ENDP ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SA?AV?$allocator@UImportInfo@SegmentHeader@@@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SA?AV?$allocator@UImportInfo@SegmentHeader@@@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<SegmentHeader::ImportInfo> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 684  :         return _Al;

  00000	8b c1		 mov	 eax, ecx

; 685  :     }

  00002	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SA?AV?$allocator@UImportInfo@SegmentHeader@@@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SegmentHeader::ImportInfo> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QBEABV?$allocator@UImportInfo@SegmentHeader@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QBEABV?$allocator@UImportInfo@SegmentHeader@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QBEABV?$allocator@UImportInfo@SegmentHeader@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?allocate@?$allocator@UImportInfo@SegmentHeader@@@std@@QAEPAUImportInfo@SegmentHeader@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UImportInfo@SegmentHeader@@@std@@QAEPAUImportInfo@SegmentHeader@@I@Z PROC ; std::allocator<SegmentHeader::ImportInfo>::allocate, COMDAT
; _this$dead$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   :             if (_Count > _Max_possible) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0000b	77 4d		 ja	 SHORT $LN27@allocate

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  0000d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00010	c1 e0 02	 shl	 eax, 2

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 29		 jb	 SHORT $LN8@allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

  0001a	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 90   :     if (_Block_size <= _Bytes) {

  0001d	3b c8		 cmp	 ecx, eax
  0001f	76 39		 jbe	 SHORT $LN27@allocate

; 51   :         return ::operator new(_Bytes);

  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00027	8b c8		 mov	 ecx, eax

; 51   :         return ::operator new(_Bytes);

  00029	83 c4 04	 add	 esp, 4

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002c	85 c9		 test	 ecx, ecx
  0002e	74 0d		 je	 SHORT $LN17@allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00033	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00036	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN17@allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN8@allocate:

; 179  :     if (_Bytes != 0) {

  00043	85 c0		 test	 eax, eax
  00045	74 0d		 je	 SHORT $LN9@allocate

; 51   :         return ::operator new(_Bytes);

  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004d	83 c4 04	 add	 esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
$LN9@allocate:

; 183  :     return nullptr;

  00054	33 c0		 xor	 eax, eax

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
$LN27@allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

  0005a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN28@allocate:
  0005f	cc		 int	 3
?allocate@?$allocator@UImportInfo@SegmentHeader@@@std@@QAEPAUImportInfo@SegmentHeader@@I@Z ENDP ; std::allocator<SegmentHeader::ImportInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QBDV?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<char const * const,std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00007	56		 push	 esi
  00008	8b 75 0c	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0000e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00012	75 20		 jne	 SHORT $LN3@Erase_tree
$LL2@Erase_tree:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	ff 76 08	 push	 DWORD PTR [esi+8]
  00017	8b cf		 mov	 ecx, edi
  00019	53		 push	 ebx
  0001a	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0001f	8b c6		 mov	 eax, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00021	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00023	6a 18		 push	 24			; 00000018H
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0002e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00032	74 e0		 je	 SHORT $LL2@Erase_tree
$LN3@Erase_tree:
  00034	5f		 pop	 edi

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 746  :         }
; 747  :     }

  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00000	6a 18		 push	 24			; 00000018H
  00002	52		 push	 edx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00008	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 374  :     }

  0000b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0V?$allocator@UImportInfo@SegmentHeader@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@UImportInfo@SegmentHeader@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@UImportInfo@SegmentHeader@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@UImportInfo@SegmentHeader@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1>::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1><std::allocator<SegmentHeader::ImportInfo> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 08 00	 ret	 8
??$?0V?$allocator@UImportInfo@SegmentHeader@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImportInfo@SegmentHeader@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@UImportInfo@SegmentHeader@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1>::_Compressed_pair<std::allocator<SegmentHeader::ImportInfo>,std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >,1><std::allocator<SegmentHeader::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z
_TEXT	SEGMENT
__Backout$5 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z PROC ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Ucopy<SegmentHeader::ImportInfo *>, COMDAT
; _this$ = ecx

; 1587 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0002b	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0002e	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1587 :     pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator

  00031	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00034	66 0f d6 45 e4	 movq	 QWORD PTR __Backout$5[ebp], xmm0
  00039	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Backout$5[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00040	89 7d e4	 mov	 DWORD PTR __Backout$5[ebp], edi
  00043	89 7d e8	 mov	 DWORD PTR __Backout$5[ebp+4], edi
  00046	89 4d ec	 mov	 DWORD PTR __Backout$5[ebp+8], ecx

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  00049	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00053	3b f3		 cmp	 esi, ebx
  00055	74 15		 je	 SHORT $LN5@Ucopy
$LL6@Ucopy:

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00057	56		 push	 esi
  00058	8b cf		 mov	 ecx, edi
  0005a	e8 00 00 00 00	 call	 ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z

; 1499 :         ++_Last;

  0005f	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  00062	83 c6 0c	 add	 esi, 12			; 0000000cH

; 1499 :         ++_Last;

  00065	89 7d e8	 mov	 DWORD PTR __Backout$5[ebp+4], edi

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  00068	3b f3		 cmp	 esi, ebx
  0006a	75 eb		 jne	 SHORT $LL6@Ucopy
$LN5@Ucopy:

; 1493 :         _Destroy_range(_First, _Last, _Al);

  0006c	51		 push	 ecx
  0006d	8b d7		 mov	 edx, edi
  0006f	8b cf		 mov	 ecx, edi
  00071	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
  00076	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector

; 1588 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00079	8b c7		 mov	 eax, edi

; 1589 :     }

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008c	33 cd		 xor	 ecx, ebp
  0008e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Ucopy@PAUImportInfo@SegmentHeader@@@?$vector@UImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@AAEPAUImportInfo@SegmentHeader@@PAU23@00@Z ENDP ; std::vector<SegmentHeader::ImportInfo,std::allocator<SegmentHeader::ImportInfo> >::_Ucopy<SegmentHeader::ImportInfo *>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0M@@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$0M@@std@@YAII@Z PROC			; std::_Get_size_of_n<12>, COMDAT
; __Count$ = ecx

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {

  00000	81 f9 55 55 55
	15		 cmp	 ecx, 357913941		; 15555555H
  00006	0f 87 00 00 00
	00		 ja	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  0000c	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0000f	c1 e0 02	 shl	 eax, 2

; 40   : }

  00012	c3		 ret	 0
??$_Get_size_of_n@$0M@@std@@YAII@Z ENDP			; std::_Get_size_of_n<12>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >::_Vector_val<std::_Simple_types<SegmentHeader::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::deallocate, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 664  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 195  :     ::operator delete(_Ptr, _Bytes);

  00003	6a 18		 push	 24			; 00000018H
  00005	52		 push	 edx
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8

; 665  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 666  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
; 667  :     }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@0@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@0@Z PROC ; std::exchange<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * &>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 572  :     // assign _New_val to _Val, return previous _Val
; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	8b 12		 mov	 edx, DWORD PTR [edx]
  00004	89 11		 mov	 DWORD PTR [ecx], edx

; 575  :     return _Old_val;
; 576  : }

  00006	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@0@Z ENDP ; std::exchange<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00000	6a 18		 push	 24			; 00000018H
  00002	52		 push	 edx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00008	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 381  :     }

  0000b	c3		 ret	 0
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *>, COMDAT
; __Obj$dead$ = ecx

; 242  :     _Obj.~_Ty();
; 243  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YA$$QAV?$allocator@UImportInfo@SegmentHeader@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YA$$QAV?$allocator@UImportInfo@SegmentHeader@@@0@AAV10@@Z PROC ; std::forward<std::allocator<SegmentHeader::ImportInfo> >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YA$$QAV?$allocator@UImportInfo@SegmentHeader@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<SegmentHeader::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z
_TEXT	SEGMENT
__Backout$5 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Dest$ = 8						; size = 4
__Al$ = 12						; size = 4
??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z PROC ; std::_Uninitialized_copy<SegmentHeader::ImportInfo *,std::allocator<SegmentHeader::ImportInfo> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1517 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b da		 mov	 ebx, edx
  0002d	8b f1		 mov	 esi, ecx

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0002f	8b 7d 08	 mov	 edi, DWORD PTR __Dest$[ebp]
  00032	0f 57 c0	 xorps	 xmm0, xmm0
  00035	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00038	66 0f d6 45 e4	 movq	 QWORD PTR __Backout$5[ebp], xmm0
  0003d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Backout$5[ebp+8], 0
  00044	89 7d e4	 mov	 DWORD PTR __Backout$5[ebp], edi
  00047	89 7d e8	 mov	 DWORD PTR __Backout$5[ebp+4], edi
  0004a	89 45 ec	 mov	 DWORD PTR __Backout$5[ebp+8], eax

; 1518 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1519 :     // note: only called internally from elsewhere in the STL
; 1520 :     using _Ptrval = typename _Alloc::value_type*;
; 1521 : 
; 1522 :     auto _UFirst      = _Get_unwrapped(_First);
; 1523 :     const auto _ULast = _Get_unwrapped(_Last);
; 1524 : 
; 1525 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1526 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1527 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1528 :         _Dest += _ULast - _UFirst;
; 1529 :         (void) _Al;
; 1530 :     } else {
; 1531 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  00054	3b f3		 cmp	 esi, ebx
  00056	74 15		 je	 SHORT $LN3@Uninitiali
$LL4@Uninitiali:

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00058	56		 push	 esi
  00059	8b cf		 mov	 ecx, edi
  0005b	e8 00 00 00 00	 call	 ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z

; 1499 :         ++_Last;

  00060	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  00063	83 c6 0c	 add	 esi, 12			; 0000000cH

; 1499 :         ++_Last;

  00066	89 7d e8	 mov	 DWORD PTR __Backout$5[ebp+4], edi

; 1532 :         for (; _UFirst != _ULast; ++_UFirst) {

  00069	3b f3		 cmp	 esi, ebx
  0006b	75 eb		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1493 :         _Destroy_range(_First, _Last, _Al);

  0006d	51		 push	 ecx
  0006e	8b d7		 mov	 edx, edi
  00070	8b cf		 mov	 ecx, edi
  00072	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
  00077	83 c4 04	 add	 esp, 4

; 1533 :             _Backout._Emplace_back(*_UFirst);
; 1534 :         }
; 1535 : 
; 1536 :         _Dest = _Backout._Release();
; 1537 :     }
; 1538 : 
; 1539 :     return _Dest;

  0007a	8b c7		 mov	 eax, edi

; 1540 : }

  0007c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00086	59		 pop	 ecx
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008d	33 cd		 xor	 ecx, ebp
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PAUImportInfo@SegmentHeader@@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAPAUImportInfo@SegmentHeader@@QAU12@0PAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ENDP ; std::_Uninitialized_copy<SegmentHeader::ImportInfo *,std::allocator<SegmentHeader::ImportInfo> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUImportInfo@SegmentHeader@@@std@@YAPAUImportInfo@SegmentHeader@@ABQAU12@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUImportInfo@SegmentHeader@@@std@@YAPAUImportInfo@SegmentHeader@@ABQAU12@@Z PROC ; std::_Get_unwrapped<SegmentHeader::ImportInfo * const &>, COMDAT
; __It$ = ecx

; 1197 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1198 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1199 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1200 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1201 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1202 :     } else {
; 1203 :         return static_cast<_Iter&&>(_It);
; 1204 :     }
; 1205 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQAUImportInfo@SegmentHeader@@@std@@YAPAUImportInfo@SegmentHeader@@ABQAU12@@Z ENDP ; std::_Get_unwrapped<SegmentHeader::ImportInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00007	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0000e	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEPAUImportInfo@SegmentHeader@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEPAUImportInfo@SegmentHeader@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::_Release, COMDAT
; _this$ = ecx

; 1503 :         _First = _Last;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	89 01		 mov	 DWORD PTR [ecx], eax

; 1504 :         return _Last;
; 1505 :     }

  00005	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEPAUImportInfo@SegmentHeader@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >, COMDAT
; _this$ = ecx

; 1493 :         _Destroy_range(_First, _Last, _Al);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	51		 push	 ecx
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@YAXPAUImportInfo@SegmentHeader@@QAU12@AAV?$allocator@UImportInfo@SegmentHeader@@@0@@Z ; std::_Destroy_range<std::allocator<SegmentHeader::ImportInfo> >
  0000b	59		 pop	 ecx

; 1494 :     }

  0000c	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@PAUImportInfo@SegmentHeader@@AAV?$allocator@UImportInfo@SegmentHeader@@@1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@PAUImportInfo@SegmentHeader@@AAV?$allocator@UImportInfo@SegmentHeader@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >, COMDAT
; _this$ = ecx

; 1487 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Al_$[ebp]
  0000e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00011	8b c1		 mov	 eax, ecx
  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAE@PAUImportInfo@SegmentHeader@@AAV?$allocator@UImportInfo@SegmentHeader@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@YAPAU?$pair@$$CBW4ImportType@SegmentHeader@@K@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@YAPAU?$pair@$$CBW4ImportType@SegmentHeader@@K@0@AAU10@@Z PROC ; std::addressof<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@YAPAU?$pair@$$CBW4ImportType@SegmentHeader@@K@0@AAU10@@Z ENDP ; std::addressof<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@QAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@QAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::destroy<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >, COMDAT
; ___formal$dead$ = ecx
; __Ptr$dead$ = edx

; 676  :         _Ptr->~_Uty();
; 677  :     }

  00000	c2 00 00	 ret	 0
??$destroy@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@QAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::destroy<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Emplace_back@AAUImportInfo@SegmentHeader@@@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEXAAUImportInfo@SegmentHeader@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAUImportInfo@SegmentHeader@@@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEXAAUImportInfo@SegmentHeader@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::_Emplace_back<SegmentHeader::ImportInfo &>, COMDAT
; _this$ = ecx

; 1497 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00004	ff 75 08	 push	 DWORD PTR _<_Vals_0>$[ebp]

; 1497 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00007	8b f1		 mov	 esi, ecx

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00009	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000c	e8 00 00 00 00	 call	 ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z

; 1498 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1499 :         ++_Last;

  00011	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
  00015	5e		 pop	 esi

; 1500 :     }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$_Emplace_back@AAUImportInfo@SegmentHeader@@@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@QAEXAAUImportInfo@SegmentHeader@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SegmentHeader::ImportInfo> >::_Emplace_back<SegmentHeader::ImportInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@AAUImportInfo@SegmentHeader@@@std@@YAAAUImportInfo@SegmentHeader@@AAU12@@Z
_TEXT	SEGMENT
??$forward@AAUImportInfo@SegmentHeader@@@std@@YAAAUImportInfo@SegmentHeader@@AAU12@@Z PROC ; std::forward<SegmentHeader::ImportInfo &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@AAUImportInfo@SegmentHeader@@@std@@YAAAUImportInfo@SegmentHeader@@AAU12@@Z ENDP ; std::forward<SegmentHeader::ImportInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$construct@UImportInfo@SegmentHeader@@AAU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SAXAAV?$allocator@UImportInfo@SegmentHeader@@@1@QAUImportInfo@SegmentHeader@@AAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@UImportInfo@SegmentHeader@@AAU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SAXAAV?$allocator@UImportInfo@SegmentHeader@@@1@QAUImportInfo@SegmentHeader@@AAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<SegmentHeader::ImportInfo> >::construct<SegmentHeader::ImportInfo,SegmentHeader::ImportInfo &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _<_Args_0>$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	e8 00 00 00 00	 call	 ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z

; 671  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 672  :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$construct@UImportInfo@SegmentHeader@@AAU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@SegmentHeader@@@std@@@std@@SAXAAV?$allocator@UImportInfo@SegmentHeader@@@1@QAUImportInfo@SegmentHeader@@AAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SegmentHeader::ImportInfo> >::construct<SegmentHeader::ImportInfo,SegmentHeader::ImportInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z
_TEXT	SEGMENT
__Sentinel$24 = -20					; size = 8
$T18 = -16						; size = 1
_this$GSCopy$ = -16					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z PROC		; SegmentHeader::ImportInfo::ImportInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx

; 891  :         : _Mypair(_One_then_variadic_args_t(), _Right.key_comp(), _One_then_variadic_args_t(),

  0002d	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00030	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
  00033	89 5d f0	 mov	 DWORD PTR _this$GSCopy$[ebp], ebx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00036	6a 18		 push	 24			; 00000018H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 766  :     _Tree_head_scoped_ptr(_Alnode& _Al_, _Scary_val& _Mycont_) : _Al(_Al_), _Mycont(_STD addressof(_Mycont_)) {

  00038	89 7d ec	 mov	 DWORD PTR __Sentinel$24[ebp], edi
  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	89 03		 mov	 DWORD PTR [ebx], eax

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0003f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00045	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 766  :     _Tree_head_scoped_ptr(_Alnode& _Al_, _Scary_val& _Mycont_) : _Al(_Al_), _Mycont(_STD addressof(_Mycont_)) {

  0004c	89 7d f0	 mov	 DWORD PTR __Sentinel$24[ebp+4], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0004f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00054	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00057	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00059	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  0005f	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 767  :         _Mycont->_Myhead = _Alnode::value_type::_Buyheadnode(_Al);

  00065	89 07		 mov	 DWORD PTR [edi], eax

; 896  :         _Tree_head_scoped_ptr<_Alnode, _Scary_val> _Sentinel(_Getal(), *_Scary);

  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1731 :         _Scary->_Myhead->_Parent = _Copy_nodes(_Right_scary->_Myhead->_Parent, _Scary->_Myhead, _Movefl);

  0006e	8b cf		 mov	 ecx, edi
  00070	ff 75 f0	 push	 DWORD PTR $T18[ebp]
  00073	50		 push	 eax
  00074	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00077	ff 70 04	 push	 DWORD PTR [eax+4]
  0007a	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>
  0007f	8b c8		 mov	 ecx, eax
  00081	8b 07		 mov	 eax, DWORD PTR [edi]
  00083	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1732 :         _Scary->_Mysize          = _Right_scary->_Mysize;

  00086	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1733 :         if (!_Scary->_Myhead->_Parent->_Isnil) { // nonempty tree, look for new smallest and largest

  00089	8b 37		 mov	 esi, DWORD PTR [edi]
  0008b	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0008e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00091	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00095	75 39		 jne	 SHORT $LN50@ImportInfo

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00097	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00099	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0009d	75 0d		 jne	 SHORT $LN55@ImportInfo
  0009f	90		 npad	 1
$LL54@ImportInfo:
  000a0	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  000a2	8b d1		 mov	 edx, ecx
  000a4	8b c8		 mov	 ecx, eax
  000a6	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000aa	74 f4		 je	 SHORT $LL54@ImportInfo
$LN55@ImportInfo:

; 1734 :             _Scary->_Myhead->_Left  = _Scary_val::_Min(_Scary->_Myhead->_Parent);

  000ac	89 16		 mov	 DWORD PTR [esi], edx

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  000ae	8b 17		 mov	 edx, DWORD PTR [edi]
  000b0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 443  :         while (!_Pnode->_Right->_Isnil) {

  000b3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b6	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000ba	75 0f		 jne	 SHORT $LN59@ImportInfo
  000bc	0f 1f 40 00	 npad	 4
$LL58@ImportInfo:

; 444  :             _Pnode = _Pnode->_Right;

  000c0	8b c1		 mov	 eax, ecx
  000c2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c5	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000c9	74 f5		 je	 SHORT $LL58@ImportInfo
$LN59@ImportInfo:

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  000cb	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1736 :         } else { // empty tree, just tidy head pointers

  000ce	eb 07		 jmp	 SHORT $LN134@ImportInfo
$LN50@ImportInfo:

; 1737 :             _Scary->_Myhead->_Left  = _Scary->_Myhead;

  000d0	89 36		 mov	 DWORD PTR [esi], esi

; 1738 :             _Scary->_Myhead->_Right = _Scary->_Myhead;

  000d2	8b 07		 mov	 eax, DWORD PTR [edi]
  000d4	89 40 08	 mov	 DWORD PTR [eax+8], eax
$LN134@ImportInfo:
  000d7	8b c3		 mov	 eax, ebx
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e3	59		 pop	 ecx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z$2:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Sentinel$24[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAE@XZ ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::~_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ImportInfo@SegmentHeader@@QAE@ABU01@@Z ENDP		; SegmentHeader::ImportInfo::ImportInfo
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map
;	COMDAT ??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Sentinel$23 = -20					; size = 8
$T17 = -16						; size = 1
_this$GSCopy$ = -16					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z PROC ; std::multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >, COMDAT
; _this$ = ecx

; 412  :     multimap(const multimap& _Right)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  0002f	89 7d f0	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00032	6a 18		 push	 24			; 00000018H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00034	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0003a	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 766  :     _Tree_head_scoped_ptr(_Alnode& _Al_, _Scary_val& _Mycont_) : _Al(_Al_), _Mycont(_STD addressof(_Mycont_)) {

  00041	89 7d ec	 mov	 DWORD PTR __Sentinel$23[ebp], edi
  00044	89 7d f0	 mov	 DWORD PTR __Sentinel$23[ebp+4], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00047	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004c	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0004f	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00051	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00054	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00057	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 767  :         _Mycont->_Myhead = _Alnode::value_type::_Buyheadnode(_Al);

  0005d	89 07		 mov	 DWORD PTR [edi], eax

; 896  :         _Tree_head_scoped_ptr<_Alnode, _Scary_val> _Sentinel(_Getal(), *_Scary);

  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1731 :         _Scary->_Myhead->_Parent = _Copy_nodes(_Right_scary->_Myhead->_Parent, _Scary->_Myhead, _Movefl);

  00066	8b cf		 mov	 ecx, edi
  00068	ff 75 f0	 push	 DWORD PTR $T17[ebp]
  0006b	50		 push	 eax
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	ff 70 04	 push	 DWORD PTR [eax+4]
  00071	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>
  00076	8b c8		 mov	 ecx, eax
  00078	8b 07		 mov	 eax, DWORD PTR [edi]
  0007a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1732 :         _Scary->_Mysize          = _Right_scary->_Mysize;

  0007d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1733 :         if (!_Scary->_Myhead->_Parent->_Isnil) { // nonempty tree, look for new smallest and largest

  00080	8b 37		 mov	 esi, DWORD PTR [edi]
  00082	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00085	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00088	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0008c	75 34		 jne	 SHORT $LN47@multimap

; 451  :         while (!_Pnode->_Left->_Isnil) {

  0008e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00090	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00094	75 0c		 jne	 SHORT $LN52@multimap
$LL51@multimap:
  00096	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00098	8b d1		 mov	 edx, ecx
  0009a	8b c8		 mov	 ecx, eax
  0009c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000a0	74 f4		 je	 SHORT $LL51@multimap
$LN52@multimap:

; 1734 :             _Scary->_Myhead->_Left  = _Scary_val::_Min(_Scary->_Myhead->_Parent);

  000a2	89 16		 mov	 DWORD PTR [esi], edx

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  000a4	8b 17		 mov	 edx, DWORD PTR [edi]
  000a6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 443  :         while (!_Pnode->_Right->_Isnil) {

  000a9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ac	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000b0	75 0b		 jne	 SHORT $LN56@multimap
$LL55@multimap:

; 444  :             _Pnode = _Pnode->_Right;

  000b2	8b c1		 mov	 eax, ecx
  000b4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b7	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000bb	74 f5		 je	 SHORT $LL55@multimap
$LN56@multimap:

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  000bd	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1736 :         } else { // empty tree, just tidy head pointers

  000c0	eb 07		 jmp	 SHORT $LN130@multimap
$LN47@multimap:

; 1737 :             _Scary->_Myhead->_Left  = _Scary->_Myhead;

  000c2	89 36		 mov	 DWORD PTR [esi], esi

; 1738 :             _Scary->_Myhead->_Right = _Scary->_Myhead;

  000c4	8b 07		 mov	 eax, DWORD PTR [edi]
  000c6	89 40 08	 mov	 DWORD PTR [eax+8], eax
$LN130@multimap:
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\map

; 413  :         : _Mybase(_Right, _Alnode_traits::select_on_container_copy_construction(_Right._Getal())) {}

  000c9	8b c7		 mov	 eax, edi
  000cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d5	59		 pop	 ecx
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z$1:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Sentinel$23[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAE@XZ ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::~_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$multimap@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@@std@@QAE@ABV01@@Z ENDP ; std::multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::multimap<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Getal, COMDAT
; _this$ = ecx

; 2046 :         return _Mypair._Myval2._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2047 :     }

  00002	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 684  :         return _Al;

  00000	8b c1		 mov	 eax, ecx

; 685  :     }

  00002	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Sentinel$ = -20					; size = 8
$T16 = -16						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> ><std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 892  :             _STD forward<_Any_alloc>(_Al)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0002c	6a 18		 push	 24			; 00000018H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0002e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00034	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 766  :     _Tree_head_scoped_ptr(_Alnode& _Al_, _Scary_val& _Mycont_) : _Al(_Al_), _Mycont(_STD addressof(_Mycont_)) {

  0003b	89 7d ec	 mov	 DWORD PTR __Sentinel$[ebp], edi
  0003e	89 7d f0	 mov	 DWORD PTR __Sentinel$[ebp+4], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00041	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00046	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00049	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0004b	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0004e	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00051	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 767  :         _Mycont->_Myhead = _Alnode::value_type::_Buyheadnode(_Al);

  00057	89 07		 mov	 DWORD PTR [edi], eax

; 893  :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 894  :         const auto _Scary = _Get_scary();
; 895  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, *_Scary);
; 896  :         _Tree_head_scoped_ptr<_Alnode, _Scary_val> _Sentinel(_Getal(), *_Scary);

  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1731 :         _Scary->_Myhead->_Parent = _Copy_nodes(_Right_scary->_Myhead->_Parent, _Scary->_Myhead, _Movefl);

  00060	8b cf		 mov	 ecx, edi
  00062	ff 75 f0	 push	 DWORD PTR $T16[ebp]
  00065	50		 push	 eax
  00066	8b 06		 mov	 eax, DWORD PTR [esi]
  00068	ff 70 04	 push	 DWORD PTR [eax+4]
  0006b	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>
  00070	8b c8		 mov	 ecx, eax
  00072	8b 07		 mov	 eax, DWORD PTR [edi]
  00074	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1732 :         _Scary->_Mysize          = _Right_scary->_Mysize;

  00077	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1733 :         if (!_Scary->_Myhead->_Parent->_Isnil) { // nonempty tree, look for new smallest and largest

  0007a	8b 37		 mov	 esi, DWORD PTR [edi]
  0007c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0007f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00082	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00086	75 38		 jne	 SHORT $LN44@ImportType

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00088	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0008a	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0008e	75 0c		 jne	 SHORT $LN49@ImportType
$LL48@ImportType:
  00090	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00092	8b d1		 mov	 edx, ecx
  00094	8b c8		 mov	 ecx, eax
  00096	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0009a	74 f4		 je	 SHORT $LL48@ImportType
$LN49@ImportType:

; 1734 :             _Scary->_Myhead->_Left  = _Scary_val::_Min(_Scary->_Myhead->_Parent);

  0009c	89 16		 mov	 DWORD PTR [esi], edx

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  0009e	8b 17		 mov	 edx, DWORD PTR [edi]
  000a0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 443  :         while (!_Pnode->_Right->_Isnil) {

  000a3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a6	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000aa	75 0f		 jne	 SHORT $LN53@ImportType
  000ac	0f 1f 40 00	 npad	 4
$LL52@ImportType:

; 444  :             _Pnode = _Pnode->_Right;

  000b0	8b c1		 mov	 eax, ecx
  000b2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b5	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000b9	74 f5		 je	 SHORT $LL52@ImportType
$LN53@ImportType:

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  000bb	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1736 :         } else { // empty tree, just tidy head pointers

  000be	eb 07		 jmp	 SHORT $LN126@ImportType
$LN44@ImportType:

; 1737 :             _Scary->_Myhead->_Left  = _Scary->_Myhead;

  000c0	89 36		 mov	 DWORD PTR [esi], esi

; 1738 :             _Scary->_Myhead->_Right = _Scary->_Myhead;

  000c2	8b 07		 mov	 eax, DWORD PTR [edi]
  000c4	89 40 08	 mov	 DWORD PTR [eax+8], eax
$LN126@ImportType:

; 897  :         _Copy(_Right, _Copy_tag());
; 898  :         _Sentinel._Release();
; 899  :         _Proxy._Release();
; 900  :     }

  000c7	8b c7		 mov	 eax, edi
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Sentinel$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAE@XZ ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::~_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QAE@ABV01@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> ><std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAE@XZ PROC ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::~_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >, COMDAT
; _this$ = ecx

; 774  :     ~_Tree_head_scoped_ptr() {

  00000	57		 push	 edi

; 775  :         if (_Mycont) {

  00001	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00004	85 ff		 test	 edi, edi
  00006	74 3e		 je	 SHORT $LN43@Tree_head_

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00008	8b 07		 mov	 eax, DWORD PTR [edi]

; 776  :             _Mycont->_Erase_head(_Al);

  0000a	53		 push	 ebx
  0000b	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0000d	56		 push	 esi

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  0000e	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00011	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00015	75 22		 jne	 SHORT $LN8@Tree_head_
$LL7@Tree_head_:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00017	ff 76 08	 push	 DWORD PTR [esi+8]
  0001a	8b cf		 mov	 ecx, edi
  0001c	53		 push	 ebx
  0001d	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00022	8b c6		 mov	 eax, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00024	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00026	6a 18		 push	 24			; 00000018H
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002e	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00031	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00035	74 e0		 je	 SHORT $LL7@Tree_head_
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00037	8b 07		 mov	 eax, DWORD PTR [edi]
$LN8@Tree_head_:

; 195  :     ::operator delete(_Ptr, _Bytes);

  00039	6a 18		 push	 24			; 00000018H
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00041	83 c4 08	 add	 esp, 8
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
$LN43@Tree_head_:
  00046	5f		 pop	 edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 778  :     }

  00047	c3		 ret	 0
??1?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::~_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Release@?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Release@?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAEXXZ PROC ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::_Release, COMDAT
; _this$ = ecx

; 771  :         _Mycont = nullptr;

  00000	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 772  :     }

  00007	c3		 ret	 0
?_Release@?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAEXXZ ENDP ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@AAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
__Mycont_$ = 12						; size = 4
??0?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@AAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@1@@Z PROC ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >, COMDAT
; _this$ = ecx

; 766  :     _Tree_head_scoped_ptr(_Alnode& _Al_, _Scary_val& _Mycont_) : _Al(_Al_), _Mycont(_STD addressof(_Mycont_)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00009	6a 18		 push	 24			; 00000018H
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 766  :     _Tree_head_scoped_ptr(_Alnode& _Al_, _Scary_val& _Mycont_) : _Al(_Al_), _Mycont(_STD addressof(_Mycont_)) {

  0000b	89 06		 mov	 DWORD PTR [esi], eax
  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Mycont_$[ebp]
  00010	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00018	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0001b	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0001d	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00020	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00023	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 767  :         _Mycont->_Myhead = _Alnode::value_type::_Buyheadnode(_Al);

  00029	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002c	89 01		 mov	 DWORD PTR [ecx], eax

; 768  :     }

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
??0?$_Tree_head_scoped_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@AAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@1@@Z ENDP ; std::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >::_Tree_head_scoped_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AU?$less@W4ImportType@SegmentHeader@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AU?$less@W4ImportType@SegmentHeader@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::key_comp, COMDAT
; _this$dead$ = ecx

; 1321 :     _NODISCARD key_compare key_comp() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1322 :         return _Getcomp();

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1323 :     }

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?key_comp@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@QBE?AU?$less@W4ImportType@SegmentHeader@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::key_comp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEABU?$less@W4ImportType@SegmentHeader@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEABU?$less@W4ImportType@SegmentHeader@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Getcomp, COMDAT
; _this$ = ecx

; 2038 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2039 :     }

  00002	c3		 ret	 0
?_Getcomp@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IBEABU?$less@W4ImportType@SegmentHeader@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@W4ImportType@SegmentHeader@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@W4ImportType@SegmentHeader@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@W4ImportType@SegmentHeader@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@W4ImportType@SegmentHeader@@@2@XZ PROC ; std::_Compressed_pair<std::less<enum SegmentHeader::ImportType>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1340 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1341 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@W4ImportType@SegmentHeader@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@W4ImportType@SegmentHeader@@@2@XZ ENDP ; std::_Compressed_pair<std::less<enum SegmentHeader::ImportType>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@0@AAV10@@Z PROC ; std::forward<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0U?$less@W4ImportType@SegmentHeader@@@std@@U_One_then_variadic_args_t@1@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@?$_Compressed_pair@U?$less@W4ImportType@SegmentHeader@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$less@W4ImportType@SegmentHeader@@@1@$$QAU21@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
_<_Val2_1>$dead$ = 20					; size = 4
??$?0U?$less@W4ImportType@SegmentHeader@@@std@@U_One_then_variadic_args_t@1@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@?$_Compressed_pair@U?$less@W4ImportType@SegmentHeader@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$less@W4ImportType@SegmentHeader@@@1@$$QAU21@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z PROC ; std::_Compressed_pair<std::less<enum SegmentHeader::ImportType>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>,1>::_Compressed_pair<std::less<enum SegmentHeader::ImportType>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>,1><std::less<enum SegmentHeader::ImportType>,std::_One_then_variadic_args_t,std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 10 00	 ret	 16			; 00000010H
??$?0U?$less@W4ImportType@SegmentHeader@@@std@@U_One_then_variadic_args_t@1@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@?$_Compressed_pair@U?$less@W4ImportType@SegmentHeader@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$less@W4ImportType@SegmentHeader@@@1@$$QAU21@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ENDP ; std::_Compressed_pair<std::less<enum SegmentHeader::ImportType>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>,1>::_Compressed_pair<std::less<enum SegmentHeader::ImportType>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>,1><std::less<enum SegmentHeader::ImportType>,std::_One_then_variadic_args_t,std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Movefl$ = 12						; size = 1
??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>, COMDAT
; _this$ = ecx

; 1728 :     void _Copy(const _Tree& _Right, _Moveit _Movefl) { // copy or move entire tree from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1729 :         const auto _Scary        = _Get_scary();
; 1730 :         const auto _Right_scary  = _Right._Get_scary();
; 1731 :         _Scary->_Myhead->_Parent = _Copy_nodes(_Right_scary->_Myhead->_Parent, _Scary->_Myhead, _Movefl);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	ff 75 0c	 push	 DWORD PTR __Movefl$[ebp]
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 06		 mov	 eax, DWORD PTR [esi]
  0000f	ff 37		 push	 DWORD PTR [edi]
  00011	ff 70 04	 push	 DWORD PTR [eax+4]
  00014	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>
  00019	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0001b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1732 :         _Scary->_Mysize          = _Right_scary->_Mysize;

  0001e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1733 :         if (!_Scary->_Myhead->_Parent->_Isnil) { // nonempty tree, look for new smallest and largest

  00021	8b 37		 mov	 esi, DWORD PTR [edi]
  00023	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00026	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00029	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0002d	75 38		 jne	 SHORT $LN2@Copy

; 451  :         while (!_Pnode->_Left->_Isnil) {

  0002f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00031	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00035	75 0c		 jne	 SHORT $LN7@Copy
$LL6@Copy:
  00037	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00039	8b d1		 mov	 edx, ecx
  0003b	8b c8		 mov	 ecx, eax
  0003d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00041	74 f4		 je	 SHORT $LL6@Copy
$LN7@Copy:

; 1734 :             _Scary->_Myhead->_Left  = _Scary_val::_Min(_Scary->_Myhead->_Parent);

  00043	89 16		 mov	 DWORD PTR [esi], edx

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  00045	8b 17		 mov	 edx, DWORD PTR [edi]
  00047	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 443  :         while (!_Pnode->_Right->_Isnil) {

  0004a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0004d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00051	75 0b		 jne	 SHORT $LN11@Copy
$LL10@Copy:

; 444  :             _Pnode = _Pnode->_Right;

  00053	8b c8		 mov	 ecx, eax
  00055	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00058	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0005c	74 f5		 je	 SHORT $LL10@Copy
$LN11@Copy:
  0005e	5f		 pop	 edi

; 1735 :             _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);

  0005f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1739 :         }
; 1740 :     }

  00062	5e		 pop	 esi
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
$LN2@Copy:

; 1736 :         } else { // empty tree, just tidy head pointers
; 1737 :             _Scary->_Myhead->_Left  = _Scary->_Myhead;

  00067	89 36		 mov	 DWORD PTR [esi], esi

; 1738 :             _Scary->_Myhead->_Right = _Scary->_Myhead;

  00069	8b 07		 mov	 eax, DWORD PTR [edi]
  0006b	5f		 pop	 edi

; 1739 :         }
; 1740 :     }

  0006c	5e		 pop	 esi
  0006d	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; __Al$dead$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0000a	89 00		 mov	 DWORD PTR [eax], eax

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0000c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0000f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 347  :         _Pnode->_Color = _Black;

  00012	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 348  :         _Pnode->_Isnil = true;
; 349  :         return _Pnode;
; 350  :     }

  00018	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Max, COMDAT
; __Pnode$ = ecx

; 443  :         while (!_Pnode->_Right->_Isnil) {

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00007	75 12		 jne	 SHORT $LN9@Max
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Max:

; 444  :             _Pnode = _Pnode->_Right;

  00010	8b c8		 mov	 ecx, eax
  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN9@Max:

; 445  :         }
; 446  : 
; 447  :         return _Pnode;
; 448  :     }

  0001b	8b c1		 mov	 eax, ecx
  0001d	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 51   :         return ::operator new(_Bytes);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

  0000a	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1><std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 08 00	 ret	 8
??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >,1><std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@U?$less@W4ImportType@SegmentHeader@@@std@@@std@@YA$$QAU?$less@W4ImportType@SegmentHeader@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$less@W4ImportType@SegmentHeader@@@std@@@std@@YA$$QAU?$less@W4ImportType@SegmentHeader@@@0@AAU10@@Z PROC ; std::forward<std::less<enum SegmentHeader::ImportType> >, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@U?$less@W4ImportType@SegmentHeader@@@std@@@std@@YA$$QAU?$less@W4ImportType@SegmentHeader@@@0@AAU10@@Z ENDP ; std::forward<std::less<enum SegmentHeader::ImportType> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -36					; size = 4
__Newnode$13 = -32					; size = 8
__Newroot$ = -28					; size = 4
__Movefl$GSCopy$ = -24					; size = 1
__Myhead$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
__Movefl$ = 16						; size = 1
??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>, COMDAT
; _this$ = ecx

; 1758 :     _Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode, _Moveit _Movefl) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	8b 5d 08	 mov	 ebx, DWORD PTR __Rootnode$[ebp]
  00030	8a 45 10	 mov	 al, BYTE PTR __Movefl$[ebp]
  00033	88 45 e8	 mov	 BYTE PTR __Movefl$GSCopy$[ebp], al

; 1759 :         // copy entire subtree, recursively
; 1760 :         const auto _Scary = _Get_scary();

  00036	8b 07		 mov	 eax, DWORD PTR [edi]

; 1761 :         _Nodeptr _Newroot = _Scary->_Myhead; // point at nil node
; 1762 : 
; 1763 :         if (!_Rootnode->_Isnil) { // copy or move a node, then any subtrees

  00038	80 7b 0d 00	 cmp	 BYTE PTR [ebx+13], 0
  0003c	89 7d dc	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  0003f	89 45 ec	 mov	 DWORD PTR __Myhead$1$[ebp], eax
  00042	75 7a		 jne	 SHORT $LN5@Copy_nodes
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00044	89 7d e0	 mov	 DWORD PTR __Newnode$13[ebp], edi
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 356  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);

  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  0004e	6a 18		 push	 24			; 00000018H

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00050	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Newnode$13[ebp+4], 0

; 51   :         return ::operator new(_Bytes);

  00057	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 359  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);

  0005c	8b 4d ec	 mov	 ecx, DWORD PTR __Myhead$1$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 180  :         return _Traits::_Allocate(_Bytes);

  0005f	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 358  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

  00061	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00064	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 358  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

  00067	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0006a	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0006d	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1764 :             typename is_same<key_type, value_type>::type _Is_set;
; 1765 :             _Nodeptr _Pnode = _Copy_or_move(_Rootnode->_Myval, _Movefl, _Is_set);
; 1766 :             _Pnode->_Parent = _Wherenode;

  00070	8b 45 0c	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 359  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);

  00073	89 0e		 mov	 DWORD PTR [esi], ecx

; 360  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);
; 361  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);

  00075	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 362  :         _Newnode._Ptr->_Color = _Red;

  00078	66 c7 46 0c 00
	00		 mov	 WORD PTR [esi+12], 0

; 1764 :             typename is_same<key_type, value_type>::type _Is_set;
; 1765 :             _Nodeptr _Pnode = _Copy_or_move(_Rootnode->_Myval, _Movefl, _Is_set);
; 1766 :             _Pnode->_Parent = _Wherenode;

  0007e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1767 :             _Pnode->_Color  = _Rootnode->_Color;

  00081	8a 43 0c	 mov	 al, BYTE PTR [ebx+12]
  00084	88 46 0c	 mov	 BYTE PTR [esi+12], al

; 1768 :             if (_Newroot->_Isnil) {

  00087	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0

; 1769 :                 _Newroot = _Pnode; // memorize new root
; 1770 :             }
; 1771 : 
; 1772 :             _TRY_BEGIN

  0008b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 1773 :             _Pnode->_Left  = _Copy_nodes(_Rootnode->_Left, _Pnode, _Movefl);

  00092	ff 75 e8	 push	 DWORD PTR __Movefl$GSCopy$[ebp]
  00095	0f 45 ce	 cmovne	 ecx, esi
  00098	56		 push	 esi
  00099	ff 33		 push	 DWORD PTR [ebx]
  0009b	89 4d ec	 mov	 DWORD PTR __Myhead$1$[ebp], ecx
  0009e	89 4d e4	 mov	 DWORD PTR __Newroot$[ebp], ecx
  000a1	8b cf		 mov	 ecx, edi
  000a3	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>

; 1774 :             _Pnode->_Right = _Copy_nodes(_Rootnode->_Right, _Pnode, _Movefl);

  000a8	ff 75 e8	 push	 DWORD PTR __Movefl$GSCopy$[ebp]
  000ab	89 06		 mov	 DWORD PTR [esi], eax
  000ad	8b cf		 mov	 ecx, edi
  000af	56		 push	 esi
  000b0	ff 73 08	 push	 DWORD PTR [ebx+8]
  000b3	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>
  000b8	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000bb	8b 45 ec	 mov	 eax, DWORD PTR __Myhead$1$[ebp]
$LN5@Copy_nodes:

; 1778 :             _CATCH_END
; 1779 :         }
; 1780 : 
; 1781 :         return _Newroot; // return newly constructed tree
; 1782 :     }

  000be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c8	59		 pop	 ecx
  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 0c 00	 ret	 12			; 0000000cH
__catch$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$0:

; 1775 :             _CATCH_ALL
; 1776 :             _Scary->_Erase_tree_and_orphan(_Getal(), _Newroot); // subtree copy failed, bail out

  000d2	ff 75 e4	 push	 DWORD PTR __Newroot$[ebp]
  000d5	8b 4d dc	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Getal
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree_and_orphan<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >

; 1777 :             _RERAISE;

  000e3	6a 00		 push	 0
  000e5	6a 00		 push	 0
  000e7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN79@Copy_nodes:
  000ec	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$2:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Newnode$13[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_tag>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

  00004	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BI@@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$0BI@@std@@YAII@Z PROC		; std::_Get_size_of_n<24>, COMDAT
; __Count$ = ecx

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {

  00000	81 f9 aa aa aa
	0a		 cmp	 ecx, 178956970		; 0aaaaaaaH
  00006	0f 87 00 00 00
	00		 ja	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

  0000c	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0000f	c1 e0 03	 shl	 eax, 3

; 40   : }

  00012	c3		 ret	 0
??$_Get_size_of_n@$0BI@@std@@YAII@Z ENDP		; std::_Get_size_of_n<24>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >, COMDAT
; _this$ = ecx

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
__Newnode$13 = -20					; size = 8
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_or_move<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,std::integral_constant<bool,0> >, COMDAT
; _this$ = ecx

; 1743 :     _Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set) { // copy to new node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2030 :         return _Node::_Buynode(_Getal(), _Get_scary()->_Myhead, _STD forward<_Valty>(_Val)...);

  00026	8b 31		 mov	 esi, DWORD PTR [ecx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	89 4d ec	 mov	 DWORD PTR __Newnode$13[ebp], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 356  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00032	6a 18		 push	 24			; 00000018H

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00034	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Newnode$13[ebp+4], 0

; 51   :         return ::operator new(_Bytes);

  0003b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 358  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

  00040	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00043	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 358  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

  00046	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00048	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0004b	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0004e	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 359  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);

  00051	89 30		 mov	 DWORD PTR [eax], esi

; 360  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);

  00053	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 361  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);

  00056	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 362  :         _Newnode._Ptr->_Color = _Red;

  00059	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0

; 1744 :         return _Buynode(_Val);
; 1745 :     }

  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5e		 pop	 esi
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Newnode$13[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Copy_or_move@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Copy_or_move<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,std::integral_constant<bool,0> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree_and_orphan<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 732  :     void _Erase_tree_and_orphan(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00007	56		 push	 esi
  00008	8b 75 0c	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 733  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0000e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00012	75 20		 jne	 SHORT $LN3@Erase_tree
$LL2@Erase_tree:

; 734  :             _Erase_tree_and_orphan(_Al, _Rootnode->_Right);

  00014	ff 76 08	 push	 DWORD PTR [esi+8]
  00017	8b cf		 mov	 ecx, edi
  00019	53		 push	 ebx
  0001a	e8 00 00 00 00	 call	 ??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree_and_orphan<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0001f	8b c6		 mov	 eax, esi

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00021	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 195  :     ::operator delete(_Ptr, _Bytes);

  00023	6a 18		 push	 24			; 00000018H
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 733  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0002e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00032	74 e0		 je	 SHORT $LL2@Erase_tree
$LN3@Erase_tree:
  00034	5f		 pop	 edi

; 735  :             auto _To_delete = _STD exchange(_Rootnode, _Rootnode->_Left);
; 736  :             _Orphan_ptr(_To_delete);
; 737  :             _Alnode::value_type::_Freenode(_Al, _To_delete);
; 738  :         }
; 739  :     }

  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$_Erase_tree_and_orphan@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Erase_tree_and_orphan<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *>, COMDAT
; __Val$ = ecx

; 275  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 276  : }

  00002	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@ABQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$forward@ABQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * const &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@ABQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Orphan_ptr, COMDAT
; _this$dead$ = ecx

; 714  : #if _ITERATOR_DEBUG_LEVEL == 2
; 715  :         _Lockit _Lock(_LOCK_DEBUG);
; 716  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 717  :         while (*_Pnext) {
; 718  :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 719  :             if (_Pnextptr == _Myhead || (_Ptr != nullptr && _Pnextptr != _Ptr)) {
; 720  :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 721  :             } else { // orphan the iterator
; 722  :                 (*_Pnext)->_Myproxy = nullptr;
; 723  :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 724  :             }
; 725  :         }
; 726  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 727  :         (void) _Ptr;
; 728  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 729  :     }

  00000	c2 04 00	 ret	 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<enum SegmentHeader::ImportType const ,unsigned long> > >::_Orphan_ptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z
_TEXT	SEGMENT
__Newnode$12 = -20					; size = 8
__$EHRec$ = -12						; size = 12
_<_Val_0>$ = 8						; size = 4
??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z PROC ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Buynode<std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>, COMDAT
; _this$ = ecx

; 2029 :     _Nodeptr _Buynode(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2030 :         return _Node::_Buynode(_Getal(), _Get_scary()->_Myhead, _STD forward<_Valty>(_Val)...);

  00026	8b 31		 mov	 esi, DWORD PTR [ecx]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	89 4d ec	 mov	 DWORD PTR __Newnode$12[ebp], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 356  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00032	6a 18		 push	 24			; 00000018H

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00034	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Newnode$12[ebp+4], 0

; 51   :         return ::operator new(_Bytes);

  0003b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 358  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

  00040	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00043	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 358  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

  00046	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00048	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0004b	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0004e	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 359  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);

  00051	89 30		 mov	 DWORD PTR [eax], esi

; 360  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);

  00053	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 361  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);

  00056	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 362  :         _Newnode._Ptr->_Color = _Red;

  00059	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0

; 2031 :     }

  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5e		 pop	 esi
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Newnode$12[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@?$_Tree@V?$_Tmap_traits@W4ImportType@SegmentHeader@@KU?$less@W4ImportType@SegmentHeader@@@std@@V?$allocator@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@4@$00@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@1@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<enum SegmentHeader::ImportType,unsigned long,std::less<enum SegmentHeader::ImportType>,std::allocator<std::pair<enum SegmentHeader::ImportType const ,unsigned long> >,1> >::_Buynode<std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@YAAAU?$pair@$$CBW4ImportType@SegmentHeader@@K@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@YAAAU?$pair@$$CBW4ImportType@SegmentHeader@@K@0@AAU10@@Z PROC ; std::forward<std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@@std@@YAAAU?$pair@$$CBW4ImportType@SegmentHeader@@K@0@AAU10@@Z ENDP ; std::forward<std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree
;	COMDAT ??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z
_TEXT	SEGMENT
__Newnode$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_<_Val_0>$ = 8						; size = 4
??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z PROC ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Buynode<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>, COMDAT
; __Al$ = ecx
; __Myhead$ = edx

; 353  :     static _Nodeptr _Buynode(_Alloc& _Al, _Nodeptr _Myhead, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f2		 mov	 esi, edx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	89 4d ec	 mov	 DWORD PTR __Newnode$[ebp], ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 356  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00032	6a 18		 push	 24			; 00000018H

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00034	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Newnode$[ebp+4], 0

; 51   :         return ::operator new(_Bytes);

  0003b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 358  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

  00040	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 51   :         return ::operator new(_Bytes);

  00043	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xtree

; 358  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

  00046	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00048	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0004b	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0004e	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 359  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);

  00051	89 30		 mov	 DWORD PTR [eax], esi

; 360  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);

  00053	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 361  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);

  00056	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 362  :         _Newnode._Ptr->_Color = _Red;

  00059	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0

; 363  :         _Newnode._Ptr->_Isnil = false;
; 364  :         return _Newnode._Release();
; 365  :     }

  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5e		 pop	 esi
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Newnode$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@2@@?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@PAU01@AAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@@Z ENDP ; std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *>::_Buynode<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >,std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 1048 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 195  :     ::operator delete(_Ptr, _Bytes);

  00007	6a 18		 push	 24			; 00000018H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 1049 :             _Al.deallocate(_Ptr, 1);
; 1050 :         }
; 1051 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1042 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 51   :         return ::operator new(_Bytes);

  00003	6a 18		 push	 24			; 00000018H

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00005	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 51   :         return ::operator new(_Bytes);

  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 1044 :         _Ptr = _Al.allocate(1);

  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	5e		 pop	 esi

; 1045 :     }

  00018	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::_Release, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility

; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00003	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory

; 1040 :     }

  0000a	c3		 ret	 0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 195  :     ::operator delete(_Ptr, _Bytes);

  00006	6a 18		 push	 24			; 00000018H
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 781  :     }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@QAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@AAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@QAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@AAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::construct<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	89 02		 mov	 DWORD PTR [edx], eax
  0000a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000d	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 671  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 672  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$construct@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@AAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@1@QAU?$pair@$$CBW4ImportType@SegmentHeader@@K@1@AAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> > >::construct<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,std::pair<enum SegmentHeader::ImportType const ,unsigned long> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@0@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

  00004	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::nullptr_t>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 572  :     // assign _New_val to _Val, return previous _Val
; 573  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 574  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	8b 12		 mov	 edx, DWORD PTR [edx]
  00004	89 11		 mov	 DWORD PTR [ecx], edx

; 575  :     return _Old_val;
; 576  : }

  00006	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Visual Studio IDE\VC\Tools\MSVC\14.26.28801\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * &>, COMDAT
; __Arg$ = ecx

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1456 : }

  00002	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBW4ImportType@SegmentHeader@@K@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<enum SegmentHeader::ImportType const ,unsigned long>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
END
